{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AggregatedLogsBlock.java",
  "functionName": "render",
  "functionId": "render___html-Block",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
  "functionStartLine": 52,
  "functionEndLine": 120,
  "numCommitsSeen": 21,
  "timeTaken": 5031,
  "changeHistory": [
    "b91099efd6e1fdcb31ec4ca7142439443c9ae536",
    "28c4957fccebe2d7e63ec9fe9af58313b4f21d4f",
    "91cc070d67533ebb3325b982eba2135e0d175a82",
    "38c6fa5c7a61c7f6d4d2db5f12f9c60d477fb397",
    "c4d4df8de09ee0c89ea8176bd8149900becd3c0c",
    "6dd6ca442aba8612c3780399a42bb473e4483021",
    "58e9f24e0f06efede21085b7ffe36af042fa7b38",
    "e90718fa5a0e7c18592af61534668acebb9db51b",
    "5a1b33507b935f91d6dee6056fe840e778fb198e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "8e576570a99270f2db4bd722f451cde0a5c3e4a4",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449"
  ],
  "changeHistoryShort": {
    "b91099efd6e1fdcb31ec4ca7142439443c9ae536": "Ybodychange",
    "28c4957fccebe2d7e63ec9fe9af58313b4f21d4f": "Ybodychange",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Ybodychange",
    "38c6fa5c7a61c7f6d4d2db5f12f9c60d477fb397": "Ybodychange",
    "c4d4df8de09ee0c89ea8176bd8149900becd3c0c": "Ybodychange",
    "6dd6ca442aba8612c3780399a42bb473e4483021": "Ybodychange",
    "58e9f24e0f06efede21085b7ffe36af042fa7b38": "Ybodychange",
    "e90718fa5a0e7c18592af61534668acebb9db51b": "Ybodychange",
    "5a1b33507b935f91d6dee6056fe840e778fb198e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "8e576570a99270f2db4bd722f451cde0a5c3e4a4": "Ybodychange",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": "Ybodychange",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": "Ymultichange(Ymovefromfile,Ybodychange)",
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b91099efd6e1fdcb31ec4ca7142439443c9ae536": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9451. AggregatedLogsBlock shows wrong NM http port. Contributed by Prabhu Joseph\n",
      "commitDate": "12/08/19 6:05 AM",
      "commitName": "b91099efd6e1fdcb31ec4ca7142439443c9ae536",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "27/09/17 3:46 PM",
      "commitNameOld": "28c4957fccebe2d7e63ec9fe9af58313b4f21d4f",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 683.6,
      "commitsBetweenForRepo": 5658,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d LogAggregationWebUtils\n         .verifyAndGetContainerId(html, $(CONTAINER_ID));\n     NodeId nodeId \u003d LogAggregationWebUtils\n         .verifyAndGetNodeId(html, $(NM_NODENAME));\n     String appOwner \u003d LogAggregationWebUtils\n         .verifyAndGetAppOwner(html, $(APP_OWNER));\n     boolean isValid \u003d true;\n     try {\n       LogAggregationWebUtils.getLogStartIndex(\n           html, $(\"start\"));\n     } catch (NumberFormatException ne) {\n       html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n       isValid \u003d false;\n     }\n     try {\n       LogAggregationWebUtils.getLogEndIndex(\n           html, $(\"end\"));\n     } catch (NumberFormatException ne) {\n       html.h1().__(\"Invalid log end value: \" + $(\"end\")).__();\n       isValid \u003d false;\n     }\n \n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || !isValid) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           .__();\n       if(nmApplicationLogUrl !\u003d null) {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n     }\n \n     LogAggregationFileController fileController;\n     try {\n       fileController \u003d this.factory.getFileControllerForRead(\n           applicationId, appOwner);\n     } catch (Exception fnf) {\n       html.h1()\n           .__(\"Logs not available for \" + logEntity\n-              + \". Aggregation may not be complete, \"\n-              + \"Check back later or try the nodemanager at \" + nodeId).__();\n+              + \". Aggregation may not be complete, Check back later or \"\n+              + \"try to find the container logs in the local directory of \"\n+              + \"nodemanager \" + nodeId).__();\n       if(nmApplicationLogUrl !\u003d null)  {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n     }\n \n     fileController.renderAggregatedLogsBlock(html, this.context());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d LogAggregationWebUtils\n        .verifyAndGetContainerId(html, $(CONTAINER_ID));\n    NodeId nodeId \u003d LogAggregationWebUtils\n        .verifyAndGetNodeId(html, $(NM_NODENAME));\n    String appOwner \u003d LogAggregationWebUtils\n        .verifyAndGetAppOwner(html, $(APP_OWNER));\n    boolean isValid \u003d true;\n    try {\n      LogAggregationWebUtils.getLogStartIndex(\n          html, $(\"start\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n      isValid \u003d false;\n    }\n    try {\n      LogAggregationWebUtils.getLogEndIndex(\n          html, $(\"end\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log end value: \" + $(\"end\")).__();\n      isValid \u003d false;\n    }\n\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || !isValid) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          .__();\n      if(nmApplicationLogUrl !\u003d null) {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    LogAggregationFileController fileController;\n    try {\n      fileController \u003d this.factory.getFileControllerForRead(\n          applicationId, appOwner);\n    } catch (Exception fnf) {\n      html.h1()\n          .__(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, Check back later or \"\n              + \"try to find the container logs in the local directory of \"\n              + \"nodemanager \" + nodeId).__();\n      if(nmApplicationLogUrl !\u003d null)  {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    fileController.renderAggregatedLogsBlock(html, this.context());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "28c4957fccebe2d7e63ec9fe9af58313b4f21d4f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7257. AggregatedLogsBlock reports a bad \u0027end\u0027 value as a bad\n\u0027start\u0027 value. Contributed by Jason Lowe\n",
      "commitDate": "27/09/17 3:46 PM",
      "commitName": "28c4957fccebe2d7e63ec9fe9af58313b4f21d4f",
      "commitAuthor": "Xuan",
      "commitDateOld": "31/08/17 4:41 PM",
      "commitNameOld": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 26.96,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d LogAggregationWebUtils\n         .verifyAndGetContainerId(html, $(CONTAINER_ID));\n     NodeId nodeId \u003d LogAggregationWebUtils\n         .verifyAndGetNodeId(html, $(NM_NODENAME));\n     String appOwner \u003d LogAggregationWebUtils\n         .verifyAndGetAppOwner(html, $(APP_OWNER));\n     boolean isValid \u003d true;\n     try {\n       LogAggregationWebUtils.getLogStartIndex(\n           html, $(\"start\"));\n     } catch (NumberFormatException ne) {\n       html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n       isValid \u003d false;\n     }\n     try {\n       LogAggregationWebUtils.getLogEndIndex(\n           html, $(\"end\"));\n     } catch (NumberFormatException ne) {\n-      html.h1().__(\"Invalid log start value: \" + $(\"end\")).__();\n+      html.h1().__(\"Invalid log end value: \" + $(\"end\")).__();\n       isValid \u003d false;\n     }\n \n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || !isValid) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           .__();\n       if(nmApplicationLogUrl !\u003d null) {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n     }\n \n     LogAggregationFileController fileController;\n     try {\n       fileController \u003d this.factory.getFileControllerForRead(\n           applicationId, appOwner);\n     } catch (Exception fnf) {\n       html.h1()\n           .__(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \" + nodeId).__();\n       if(nmApplicationLogUrl !\u003d null)  {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n     }\n \n     fileController.renderAggregatedLogsBlock(html, this.context());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d LogAggregationWebUtils\n        .verifyAndGetContainerId(html, $(CONTAINER_ID));\n    NodeId nodeId \u003d LogAggregationWebUtils\n        .verifyAndGetNodeId(html, $(NM_NODENAME));\n    String appOwner \u003d LogAggregationWebUtils\n        .verifyAndGetAppOwner(html, $(APP_OWNER));\n    boolean isValid \u003d true;\n    try {\n      LogAggregationWebUtils.getLogStartIndex(\n          html, $(\"start\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n      isValid \u003d false;\n    }\n    try {\n      LogAggregationWebUtils.getLogEndIndex(\n          html, $(\"end\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log end value: \" + $(\"end\")).__();\n      isValid \u003d false;\n    }\n\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || !isValid) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          .__();\n      if(nmApplicationLogUrl !\u003d null) {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    LogAggregationFileController fileController;\n    try {\n      fileController \u003d this.factory.getFileControllerForRead(\n          applicationId, appOwner);\n    } catch (Exception fnf) {\n      html.h1()\n          .__(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId).__();\n      if(nmApplicationLogUrl !\u003d null)  {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    fileController.renderAggregatedLogsBlock(html, this.context());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "commitDateOld": "27/07/17 5:10 PM",
      "commitNameOld": "38c6fa5c7a61c7f6d4d2db5f12f9c60d477fb397",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 34.98,
      "commitsBetweenForRepo": 330,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,68 @@\n   protected void render(Block html) {\n-    ContainerId containerId \u003d verifyAndGetContainerId(html);\n-    NodeId nodeId \u003d verifyAndGetNodeId(html);\n-    String appOwner \u003d verifyAndGetAppOwner(html);\n-    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n+    ContainerId containerId \u003d LogAggregationWebUtils\n+        .verifyAndGetContainerId(html, $(CONTAINER_ID));\n+    NodeId nodeId \u003d LogAggregationWebUtils\n+        .verifyAndGetNodeId(html, $(NM_NODENAME));\n+    String appOwner \u003d LogAggregationWebUtils\n+        .verifyAndGetAppOwner(html, $(APP_OWNER));\n+    boolean isValid \u003d true;\n+    try {\n+      LogAggregationWebUtils.getLogStartIndex(\n+          html, $(\"start\"));\n+    } catch (NumberFormatException ne) {\n+      html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n+      isValid \u003d false;\n+    }\n+    try {\n+      LogAggregationWebUtils.getLogEndIndex(\n+          html, $(\"end\"));\n+    } catch (NumberFormatException ne) {\n+      html.h1().__(\"Invalid log start value: \" + $(\"end\")).__();\n+      isValid \u003d false;\n+    }\n+\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n-        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n+        || appOwner.isEmpty() || !isValid) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           .__();\n       if(nmApplicationLogUrl !\u003d null) {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n     }\n \n-    Path remoteRootLogDir \u003d new Path(conf.get(\n-        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n-        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n-    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n-        remoteRootLogDir, applicationId, appOwner,\n-        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n-    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n+    LogAggregationFileController fileController;\n     try {\n-      Path qualifiedLogDir \u003d\n-          FileContext.getFileContext(conf).makeQualified(\n-            remoteAppDir);\n-      nodeFiles \u003d\n-          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n-            .listStatus(remoteAppDir);\n-    } catch (FileNotFoundException fnf) {\n+      fileController \u003d this.factory.getFileControllerForRead(\n+          applicationId, appOwner);\n+    } catch (Exception fnf) {\n       html.h1()\n           .__(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \" + nodeId).__();\n       if(nmApplicationLogUrl !\u003d null)  {\n         html.h1()\n             .__(\"Or see application log at \" + nmApplicationLogUrl)\n             .__();\n       }\n       return;\n-    } catch (Exception ex) {\n-      html.h1()\n-          .__(\"Error getting logs at \" + nodeId).__();\n-      return;\n     }\n \n-    boolean foundLog \u003d false;\n-    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n-    try {\n-      while (nodeFiles.hasNext()) {\n-        AggregatedLogFormat.LogReader reader \u003d null;\n-        try {\n-          FileStatus thisNodeFile \u003d nodeFiles.next();\n-          if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n-            Path p \u003d new Path(\"har:///\"\n-                + thisNodeFile.getPath().toUri().getRawPath());\n-            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n-            continue;\n-          }\n-          if (!thisNodeFile.getPath().getName()\n-            .contains(LogAggregationUtils.getNodeString(nodeId))\n-              || thisNodeFile.getPath().getName()\n-                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n-            continue;\n-          }\n-          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n-          reader \u003d\n-              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n-\n-          String owner \u003d null;\n-          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n-          try {\n-            owner \u003d reader.getApplicationOwner();\n-            appAcls \u003d reader.getApplicationAcls();\n-          } catch (IOException e) {\n-            LOG.error(\"Error getting logs for \" + logEntity, e);\n-            continue;\n-          }\n-          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n-          aclsManager.addApplication(applicationId, appAcls);\n-\n-          String remoteUser \u003d request().getRemoteUser();\n-          UserGroupInformation callerUGI \u003d null;\n-          if (remoteUser !\u003d null) {\n-            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n-          }\n-          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n-              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n-            html.h1()\n-                .__(\"User [\" + remoteUser\n-                    + \"] is not authorized to view the logs for \" + logEntity\n-                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\").__();\n-            LOG.error(\"User [\" + remoteUser\n-              + \"] is not authorized to view the logs for \" + logEntity);\n-            continue;\n-          }\n-\n-          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n-            .getContainerLogsReader(containerId);\n-          if (logReader \u003d\u003d null) {\n-            continue;\n-          }\n-\n-          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n-              desiredLogType, logUploadedTime);\n-        } catch (IOException ex) {\n-          LOG.error(\"Error getting logs for \" + logEntity, ex);\n-          continue;\n-        } finally {\n-          if (reader !\u003d null) {\n-            reader.close();\n-          }\n-        }\n-      }\n-      if (!foundLog) {\n-        if (desiredLogType.isEmpty()) {\n-          html.h1(\"No logs available for container \" + containerId.toString());\n-        } else {\n-          html.h1(\"Unable to locate \u0027\" + desiredLogType\n-              + \"\u0027 log for container \" + containerId.toString());\n-        }\n-      }\n-    } catch (IOException e) {\n-      html.h1().__(\"Error getting logs for \" + logEntity).__();\n-      LOG.error(\"Error getting logs for \" + logEntity, e);\n-    }\n+    fileController.renderAggregatedLogsBlock(html, this.context());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d LogAggregationWebUtils\n        .verifyAndGetContainerId(html, $(CONTAINER_ID));\n    NodeId nodeId \u003d LogAggregationWebUtils\n        .verifyAndGetNodeId(html, $(NM_NODENAME));\n    String appOwner \u003d LogAggregationWebUtils\n        .verifyAndGetAppOwner(html, $(APP_OWNER));\n    boolean isValid \u003d true;\n    try {\n      LogAggregationWebUtils.getLogStartIndex(\n          html, $(\"start\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log start value: \" + $(\"start\")).__();\n      isValid \u003d false;\n    }\n    try {\n      LogAggregationWebUtils.getLogEndIndex(\n          html, $(\"end\"));\n    } catch (NumberFormatException ne) {\n      html.h1().__(\"Invalid log start value: \" + $(\"end\")).__();\n      isValid \u003d false;\n    }\n\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || !isValid) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          .__();\n      if(nmApplicationLogUrl !\u003d null) {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    LogAggregationFileController fileController;\n    try {\n      fileController \u003d this.factory.getFileControllerForRead(\n          applicationId, appOwner);\n    } catch (Exception fnf) {\n      html.h1()\n          .__(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId).__();\n      if(nmApplicationLogUrl !\u003d null)  {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    fileController.renderAggregatedLogsBlock(html, this.context());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "38c6fa5c7a61c7f6d4d2db5f12f9c60d477fb397": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11875. [JDK9] Adding a second copy of Hamlet without _ as a one-character identifier.\n",
      "commitDate": "27/07/17 5:10 PM",
      "commitName": "38c6fa5c7a61c7f6d4d2db5f12f9c60d477fb397",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 408.09,
      "commitsBetweenForRepo": 2572,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,143 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n-          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n-          ._();\n+          .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n+          .__();\n       if(nmApplicationLogUrl !\u003d null) {\n         html.h1()\n-            ._(\"Or see application log at \" + nmApplicationLogUrl)\n-            ._();\n+            .__(\"Or see application log at \" + nmApplicationLogUrl)\n+            .__();\n       }\n       return;\n     }\n \n     Path remoteRootLogDir \u003d new Path(conf.get(\n         YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n         YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n         remoteRootLogDir, applicationId, appOwner,\n         LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       Path qualifiedLogDir \u003d\n           FileContext.getFileContext(conf).makeQualified(\n             remoteAppDir);\n       nodeFiles \u003d\n           FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n             .listStatus(remoteAppDir);\n     } catch (FileNotFoundException fnf) {\n       html.h1()\n-          ._(\"Logs not available for \" + logEntity\n+          .__(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n-              + \"Check back later or try the nodemanager at \" + nodeId)._();\n+              + \"Check back later or try the nodemanager at \" + nodeId).__();\n       if(nmApplicationLogUrl !\u003d null)  {\n         html.h1()\n-            ._(\"Or see application log at \" + nmApplicationLogUrl)\n-            ._();\n+            .__(\"Or see application log at \" + nmApplicationLogUrl)\n+            .__();\n       }\n       return;\n     } catch (Exception ex) {\n       html.h1()\n-          ._(\"Error getting logs at \" + nodeId)._();\n+          .__(\"Error getting logs at \" + nodeId).__();\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n           if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n             Path p \u003d new Path(\"har:///\"\n                 + thisNodeFile.getPath().toUri().getRawPath());\n             nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n             continue;\n           }\n           if (!thisNodeFile.getPath().getName()\n             .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                 .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n           long logUploadedTime \u003d thisNodeFile.getModificationTime();\n           reader \u003d\n               new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n           aclsManager.addApplication(applicationId, appAcls);\n \n           String remoteUser \u003d request().getRemoteUser();\n           UserGroupInformation callerUGI \u003d null;\n           if (remoteUser !\u003d null) {\n             callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n           }\n           if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n               ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n             html.h1()\n-                ._(\"User [\" + remoteUser\n+                .__(\"User [\" + remoteUser\n                     + \"] is not authorized to view the logs for \" + logEntity\n-                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n+                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\").__();\n             LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n             .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, logLimits,\n               desiredLogType, logUploadedTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n-          if (reader !\u003d null)\n+          if (reader !\u003d null) {\n             reader.close();\n+          }\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n-      html.h1()._(\"Error getting logs for \" + logEntity)._();\n+      html.h1().__(\"Error getting logs for \" + logEntity).__();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          .__(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          .__();\n      if(nmApplicationLogUrl !\u003d null) {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    }\n\n    Path remoteRootLogDir \u003d new Path(conf.get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, appOwner,\n        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(conf).makeQualified(\n            remoteAppDir);\n      nodeFiles \u003d\n          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n            .listStatus(remoteAppDir);\n    } catch (FileNotFoundException fnf) {\n      html.h1()\n          .__(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId).__();\n      if(nmApplicationLogUrl !\u003d null)  {\n        html.h1()\n            .__(\"Or see application log at \" + nmApplicationLogUrl)\n            .__();\n      }\n      return;\n    } catch (Exception ex) {\n      html.h1()\n          .__(\"Error getting logs at \" + nodeId).__();\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n            .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          reader \u003d\n              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n          aclsManager.addApplication(applicationId, appAcls);\n\n          String remoteUser \u003d request().getRemoteUser();\n          UserGroupInformation callerUGI \u003d null;\n          if (remoteUser !\u003d null) {\n            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n          }\n          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n            html.h1()\n                .__(\"User [\" + remoteUser\n                    + \"] is not authorized to view the logs for \" + logEntity\n                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\").__();\n            LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n              desiredLogType, logUploadedTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null) {\n            reader.close();\n          }\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1().__(\"Error getting logs for \" + logEntity).__();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "c4d4df8de09ee0c89ea8176bd8149900becd3c0c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4701. When task logs are not available, port 8041 is referenced instead of port 8042 (haibochen via rkanter)\n",
      "commitDate": "25/02/16 12:48 PM",
      "commitName": "c4d4df8de09ee0c89ea8176bd8149900becd3c0c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "09/09/15 6:03 PM",
      "commitNameOld": "6dd6ca442aba8612c3780399a42bb473e4483021",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 168.82,
      "commitsBetweenForRepo": 1184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,142 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n+    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n+      if(nmApplicationLogUrl !\u003d null) {\n+        html.h1()\n+            ._(\"Or see application log at \" + nmApplicationLogUrl)\n+            ._();\n+      }\n       return;\n     }\n \n     Path remoteRootLogDir \u003d new Path(conf.get(\n         YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n         YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n         remoteRootLogDir, applicationId, appOwner,\n         LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       Path qualifiedLogDir \u003d\n           FileContext.getFileContext(conf).makeQualified(\n             remoteAppDir);\n       nodeFiles \u003d\n           FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n             .listStatus(remoteAppDir);\n     } catch (FileNotFoundException fnf) {\n       html.h1()\n           ._(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \" + nodeId)._();\n+      if(nmApplicationLogUrl !\u003d null)  {\n+        html.h1()\n+            ._(\"Or see application log at \" + nmApplicationLogUrl)\n+            ._();\n+      }\n       return;\n     } catch (Exception ex) {\n       html.h1()\n           ._(\"Error getting logs at \" + nodeId)._();\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n           if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n             Path p \u003d new Path(\"har:///\"\n                 + thisNodeFile.getPath().toUri().getRawPath());\n             nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n             continue;\n           }\n           if (!thisNodeFile.getPath().getName()\n             .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                 .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n           long logUploadedTime \u003d thisNodeFile.getModificationTime();\n           reader \u003d\n               new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n           aclsManager.addApplication(applicationId, appAcls);\n \n           String remoteUser \u003d request().getRemoteUser();\n           UserGroupInformation callerUGI \u003d null;\n           if (remoteUser !\u003d null) {\n             callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n           }\n           if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n               ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n             html.h1()\n                 ._(\"User [\" + remoteUser\n                     + \"] is not authorized to view the logs for \" + logEntity\n                     + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n             LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n             .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, logLimits,\n               desiredLogType, logUploadedTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n           if (reader !\u003d null)\n             reader.close();\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    String nmApplicationLogUrl \u003d getApplicationLogURL(applicationId);\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      if(nmApplicationLogUrl !\u003d null) {\n        html.h1()\n            ._(\"Or see application log at \" + nmApplicationLogUrl)\n            ._();\n      }\n      return;\n    }\n\n    Path remoteRootLogDir \u003d new Path(conf.get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, appOwner,\n        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(conf).makeQualified(\n            remoteAppDir);\n      nodeFiles \u003d\n          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n            .listStatus(remoteAppDir);\n    } catch (FileNotFoundException fnf) {\n      html.h1()\n          ._(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId)._();\n      if(nmApplicationLogUrl !\u003d null)  {\n        html.h1()\n            ._(\"Or see application log at \" + nmApplicationLogUrl)\n            ._();\n      }\n      return;\n    } catch (Exception ex) {\n      html.h1()\n          ._(\"Error getting logs at \" + nodeId)._();\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n            .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          reader \u003d\n              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n          aclsManager.addApplication(applicationId, appAcls);\n\n          String remoteUser \u003d request().getRemoteUser();\n          UserGroupInformation callerUGI \u003d null;\n          if (remoteUser !\u003d null) {\n            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n          }\n          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n            html.h1()\n                ._(\"User [\" + remoteUser\n                    + \"] is not authorized to view the logs for \" + logEntity\n                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n            LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n              desiredLogType, logUploadedTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null)\n            reader.close();\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "6dd6ca442aba8612c3780399a42bb473e4483021": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4086. Allow Aggregated Log readers to handle HAR files (rkanter)\n",
      "commitDate": "09/09/15 6:03 PM",
      "commitName": "6dd6ca442aba8612c3780399a42bb473e4483021",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "01/12/14 2:29 PM",
      "commitNameOld": "0f9528b99addbb0fd9a19d84db22a8c8e934b05f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 282.11,
      "commitsBetweenForRepo": 2156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,131 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n \n     Path remoteRootLogDir \u003d new Path(conf.get(\n         YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n         YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n         remoteRootLogDir, applicationId, appOwner,\n         LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       Path qualifiedLogDir \u003d\n           FileContext.getFileContext(conf).makeQualified(\n             remoteAppDir);\n       nodeFiles \u003d\n           FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n             .listStatus(remoteAppDir);\n     } catch (FileNotFoundException fnf) {\n       html.h1()\n           ._(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \" + nodeId)._();\n       return;\n     } catch (Exception ex) {\n       html.h1()\n           ._(\"Error getting logs at \" + nodeId)._();\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n+          if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n+            Path p \u003d new Path(\"har:///\"\n+                + thisNodeFile.getPath().toUri().getRawPath());\n+            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n+            continue;\n+          }\n           if (!thisNodeFile.getPath().getName()\n             .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                 .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n           long logUploadedTime \u003d thisNodeFile.getModificationTime();\n           reader \u003d\n               new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n           aclsManager.addApplication(applicationId, appAcls);\n \n           String remoteUser \u003d request().getRemoteUser();\n           UserGroupInformation callerUGI \u003d null;\n           if (remoteUser !\u003d null) {\n             callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n           }\n           if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n               ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n             html.h1()\n                 ._(\"User [\" + remoteUser\n                     + \"] is not authorized to view the logs for \" + logEntity\n                     + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n             LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n             .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, logLimits,\n               desiredLogType, logUploadedTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n           if (reader !\u003d null)\n             reader.close();\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n\n    Path remoteRootLogDir \u003d new Path(conf.get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, appOwner,\n        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(conf).makeQualified(\n            remoteAppDir);\n      nodeFiles \u003d\n          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n            .listStatus(remoteAppDir);\n    } catch (FileNotFoundException fnf) {\n      html.h1()\n          ._(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId)._();\n      return;\n    } catch (Exception ex) {\n      html.h1()\n          ._(\"Error getting logs at \" + nodeId)._();\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (thisNodeFile.getPath().getName().equals(applicationId + \".har\")) {\n            Path p \u003d new Path(\"har:///\"\n                + thisNodeFile.getPath().toUri().getRawPath());\n            nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n            continue;\n          }\n          if (!thisNodeFile.getPath().getName()\n            .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          reader \u003d\n              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n          aclsManager.addApplication(applicationId, appAcls);\n\n          String remoteUser \u003d request().getRemoteUser();\n          UserGroupInformation callerUGI \u003d null;\n          if (remoteUser !\u003d null) {\n            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n          }\n          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n            html.h1()\n                ._(\"User [\" + remoteUser\n                    + \"] is not authorized to view the logs for \" + logEntity\n                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n            LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n              desiredLogType, logUploadedTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null)\n            reader.close();\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "58e9f24e0f06efede21085b7ffe36af042fa7b38": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2788. Fixed backwards compatiblity issues with log-aggregation feature that were caused when adding log-upload-time via YARN-2703. Contributed by Xuan Gong.\n",
      "commitDate": "03/11/14 1:16 PM",
      "commitName": "58e9f24e0f06efede21085b7ffe36af042fa7b38",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/14 2:10 PM",
      "commitNameOld": "f81dc3f995579c1b94b11d60e9fc6da56c8a9496",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.0,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,125 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n       return;\n     }\n \n     ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n         .getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n \n     Path remoteRootLogDir \u003d new Path(conf.get(\n         YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n         YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n         remoteRootLogDir, applicationId, appOwner,\n         LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n     RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n       Path qualifiedLogDir \u003d\n           FileContext.getFileContext(conf).makeQualified(\n             remoteAppDir);\n       nodeFiles \u003d\n           FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n             .listStatus(remoteAppDir);\n     } catch (FileNotFoundException fnf) {\n       html.h1()\n           ._(\"Logs not available for \" + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \" + nodeId)._();\n       return;\n     } catch (Exception ex) {\n       html.h1()\n           ._(\"Error getting logs at \" + nodeId)._();\n       return;\n     }\n \n     boolean foundLog \u003d false;\n     String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n       while (nodeFiles.hasNext()) {\n         AggregatedLogFormat.LogReader reader \u003d null;\n         try {\n           FileStatus thisNodeFile \u003d nodeFiles.next();\n           if (!thisNodeFile.getPath().getName()\n             .contains(LogAggregationUtils.getNodeString(nodeId))\n               || thisNodeFile.getPath().getName()\n                 .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n             continue;\n           }\n+          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n           reader \u003d\n               new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n \n           String owner \u003d null;\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n           try {\n             owner \u003d reader.getApplicationOwner();\n             appAcls \u003d reader.getApplicationAcls();\n           } catch (IOException e) {\n             LOG.error(\"Error getting logs for \" + logEntity, e);\n             continue;\n           }\n           ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n           aclsManager.addApplication(applicationId, appAcls);\n \n           String remoteUser \u003d request().getRemoteUser();\n           UserGroupInformation callerUGI \u003d null;\n           if (remoteUser !\u003d null) {\n             callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n           }\n           if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n               ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n             html.h1()\n                 ._(\"User [\" + remoteUser\n                     + \"] is not authorized to view the logs for \" + logEntity\n                     + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n             LOG.error(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity);\n             continue;\n           }\n \n           AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n             .getContainerLogsReader(containerId);\n           if (logReader \u003d\u003d null) {\n             continue;\n           }\n \n           foundLog \u003d readContainerLogs(html, logReader, logLimits,\n-              desiredLogType);\n+              desiredLogType, logUploadedTime);\n         } catch (IOException ex) {\n           LOG.error(\"Error getting logs for \" + logEntity, ex);\n           continue;\n         } finally {\n           if (reader !\u003d null)\n             reader.close();\n         }\n       }\n       if (!foundLog) {\n         if (desiredLogType.isEmpty()) {\n           html.h1(\"No logs available for container \" + containerId.toString());\n         } else {\n           html.h1(\"Unable to locate \u0027\" + desiredLogType\n               + \"\u0027 log for container \" + containerId.toString());\n         }\n       }\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n\n    Path remoteRootLogDir \u003d new Path(conf.get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, appOwner,\n        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(conf).makeQualified(\n            remoteAppDir);\n      nodeFiles \u003d\n          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n            .listStatus(remoteAppDir);\n    } catch (FileNotFoundException fnf) {\n      html.h1()\n          ._(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId)._();\n      return;\n    } catch (Exception ex) {\n      html.h1()\n          ._(\"Error getting logs at \" + nodeId)._();\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (!thisNodeFile.getPath().getName()\n            .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          long logUploadedTime \u003d thisNodeFile.getModificationTime();\n          reader \u003d\n              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n          aclsManager.addApplication(applicationId, appAcls);\n\n          String remoteUser \u003d request().getRemoteUser();\n          UserGroupInformation callerUGI \u003d null;\n          if (remoteUser !\u003d null) {\n            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n          }\n          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n            html.h1()\n                ._(\"User [\" + remoteUser\n                    + \"] is not authorized to view the logs for \" + logEntity\n                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n            LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n              desiredLogType, logUploadedTime);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null)\n            reader.close();\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "e90718fa5a0e7c18592af61534668acebb9db51b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2582. Fixed Log CLI and Web UI for showing aggregated logs of LRS. Contributed Xuan Gong.\n",
      "commitDate": "20/10/14 1:38 PM",
      "commitName": "e90718fa5a0e7c18592af61534668acebb9db51b",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "16/12/13 11:27 AM",
      "commitNameOld": "5a1b33507b935f91d6dee6056fe840e778fb198e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 308.05,
      "commitsBetweenForRepo": 2397,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,124 @@\n   protected void render(Block html) {\n-    AggregatedLogFormat.LogReader reader \u003d null;\n+    ContainerId containerId \u003d verifyAndGetContainerId(html);\n+    NodeId nodeId \u003d verifyAndGetNodeId(html);\n+    String appOwner \u003d verifyAndGetAppOwner(html);\n+    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n+    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n+        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n+      return;\n+    }\n+\n+    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n+        .getApplicationId();\n+    String logEntity \u003d $(ENTITY_STRING);\n+    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n+      logEntity \u003d containerId.toString();\n+    }\n+\n+    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n+        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n+      html.h1()\n+          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n+          ._();\n+      return;\n+    }\n+\n+    Path remoteRootLogDir \u003d new Path(conf.get(\n+        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n+        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n+    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n+        remoteRootLogDir, applicationId, appOwner,\n+        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n     try {\n-      ContainerId containerId \u003d verifyAndGetContainerId(html);\n-      NodeId nodeId \u003d verifyAndGetNodeId(html);\n-      String appOwner \u003d verifyAndGetAppOwner(html);\n-      LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n-      if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n-          || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n-        return;\n-      }\n+      Path qualifiedLogDir \u003d\n+          FileContext.getFileContext(conf).makeQualified(\n+            remoteAppDir);\n+      nodeFiles \u003d\n+          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n+            .listStatus(remoteAppDir);\n+    } catch (FileNotFoundException fnf) {\n+      html.h1()\n+          ._(\"Logs not available for \" + logEntity\n+              + \". Aggregation may not be complete, \"\n+              + \"Check back later or try the nodemanager at \" + nodeId)._();\n+      return;\n+    } catch (Exception ex) {\n+      html.h1()\n+          ._(\"Error getting logs at \" + nodeId)._();\n+      return;\n+    }\n \n-      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n-          .getApplicationId();\n-      String logEntity \u003d $(ENTITY_STRING);\n-      if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n-        logEntity \u003d containerId.toString();\n-      }\n-\n-      if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n-          YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n-        html.h1()\n-            ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n-            ._();\n-        return;\n-      }\n-\n-      Path remoteRootLogDir \u003d new Path(conf.get(\n-          YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n-          YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n-\n-      try {\n-        reader \u003d new AggregatedLogFormat.LogReader(conf,\n-            LogAggregationUtils.getRemoteNodeLogFileForApp(remoteRootLogDir,\n-                applicationId, appOwner, nodeId,\n-                LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n-      } catch (FileNotFoundException e) {\n-        // ACLs not available till the log file is opened.\n-        html.h1()\n-            ._(\"Logs not available for \" + logEntity\n-                + \". Aggregation may not be complete, \"\n-                + \"Check back later or try the nodemanager at \" + nodeId)._();\n-        return;\n-      } catch (IOException e) {\n-        html.h1()._(\"Error getting logs for \" + logEntity)._();\n-        LOG.error(\"Error getting logs for \" + logEntity, e);\n-        return;\n-      }\n-\n-      String owner \u003d null;\n-      Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n-      try {\n-        owner \u003d reader.getApplicationOwner();\n-        appAcls \u003d reader.getApplicationAcls();\n-      } catch (IOException e) {\n-        html.h1()._(\"Error getting logs for \" + logEntity)._();\n-        LOG.error(\"Error getting logs for \" + logEntity, e);\n-        return;\n-      }\n-      ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n-      aclsManager.addApplication(applicationId, appAcls);\n-\n-      String remoteUser \u003d request().getRemoteUser();\n-      UserGroupInformation callerUGI \u003d null;\n-      if (remoteUser !\u003d null) {\n-        callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n-      }\n-      if (callerUGI !\u003d null\n-          \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n-              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n-        html.h1()\n-            ._(\"User [\" + remoteUser\n-                + \"] is not authorized to view the logs for \" + logEntity)._();\n-        return;\n-      }\n-\n-      String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n-      try {\n-        AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n-            .getContainerLogsReader(containerId);\n-        if (logReader \u003d\u003d null) {\n-          html.h1()\n-              ._(\"Logs not available for \" + logEntity\n-                  + \". Could be caused by the rentention policy\")._();\n-          return;\n-        }\n-\n-        boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n-            desiredLogType);\n-\n-        if (!foundLog) {\n-          if (desiredLogType.isEmpty()) {\n-            html.h1(\"No logs available for container \" + containerId.toString());\n-          } else {\n-            html.h1(\"Unable to locate \u0027\" + desiredLogType\n-                + \"\u0027 log for container \" + containerId.toString());\n+    boolean foundLog \u003d false;\n+    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n+    try {\n+      while (nodeFiles.hasNext()) {\n+        AggregatedLogFormat.LogReader reader \u003d null;\n+        try {\n+          FileStatus thisNodeFile \u003d nodeFiles.next();\n+          if (!thisNodeFile.getPath().getName()\n+            .contains(LogAggregationUtils.getNodeString(nodeId))\n+              || thisNodeFile.getPath().getName()\n+                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n+            continue;\n           }\n-          return;\n+          reader \u003d\n+              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n+\n+          String owner \u003d null;\n+          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n+          try {\n+            owner \u003d reader.getApplicationOwner();\n+            appAcls \u003d reader.getApplicationAcls();\n+          } catch (IOException e) {\n+            LOG.error(\"Error getting logs for \" + logEntity, e);\n+            continue;\n+          }\n+          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n+          aclsManager.addApplication(applicationId, appAcls);\n+\n+          String remoteUser \u003d request().getRemoteUser();\n+          UserGroupInformation callerUGI \u003d null;\n+          if (remoteUser !\u003d null) {\n+            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n+          }\n+          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n+              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n+            html.h1()\n+                ._(\"User [\" + remoteUser\n+                    + \"] is not authorized to view the logs for \" + logEntity\n+                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n+            LOG.error(\"User [\" + remoteUser\n+              + \"] is not authorized to view the logs for \" + logEntity);\n+            continue;\n+          }\n+\n+          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n+            .getContainerLogsReader(containerId);\n+          if (logReader \u003d\u003d null) {\n+            continue;\n+          }\n+\n+          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n+              desiredLogType);\n+        } catch (IOException ex) {\n+          LOG.error(\"Error getting logs for \" + logEntity, ex);\n+          continue;\n+        } finally {\n+          if (reader !\u003d null)\n+            reader.close();\n         }\n-      } catch (IOException e) {\n-        html.h1()._(\"Error getting logs for \" + logEntity)._();\n-        LOG.error(\"Error getting logs for \" + logEntity, e);\n-        return;\n       }\n-    } finally {\n-      if (reader !\u003d null) {\n-        reader.close();\n+      if (!foundLog) {\n+        if (desiredLogType.isEmpty()) {\n+          html.h1(\"No logs available for container \" + containerId.toString());\n+        } else {\n+          html.h1(\"Unable to locate \u0027\" + desiredLogType\n+              + \"\u0027 log for container \" + containerId.toString());\n+        }\n       }\n+    } catch (IOException e) {\n+      html.h1()._(\"Error getting logs for \" + logEntity)._();\n+      LOG.error(\"Error getting logs for \" + logEntity, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n        .getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n\n    Path remoteRootLogDir \u003d new Path(conf.get(\n        YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n        YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    Path remoteAppDir \u003d LogAggregationUtils.getRemoteAppLogDir(\n        remoteRootLogDir, applicationId, appOwner,\n        LogAggregationUtils.getRemoteNodeLogDirSuffix(conf));\n    RemoteIterator\u003cFileStatus\u003e nodeFiles;\n    try {\n      Path qualifiedLogDir \u003d\n          FileContext.getFileContext(conf).makeQualified(\n            remoteAppDir);\n      nodeFiles \u003d\n          FileContext.getFileContext(qualifiedLogDir.toUri(), conf)\n            .listStatus(remoteAppDir);\n    } catch (FileNotFoundException fnf) {\n      html.h1()\n          ._(\"Logs not available for \" + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \" + nodeId)._();\n      return;\n    } catch (Exception ex) {\n      html.h1()\n          ._(\"Error getting logs at \" + nodeId)._();\n      return;\n    }\n\n    boolean foundLog \u003d false;\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      while (nodeFiles.hasNext()) {\n        AggregatedLogFormat.LogReader reader \u003d null;\n        try {\n          FileStatus thisNodeFile \u003d nodeFiles.next();\n          if (!thisNodeFile.getPath().getName()\n            .contains(LogAggregationUtils.getNodeString(nodeId))\n              || thisNodeFile.getPath().getName()\n                .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n            continue;\n          }\n          reader \u003d\n              new AggregatedLogFormat.LogReader(conf, thisNodeFile.getPath());\n\n          String owner \u003d null;\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n          try {\n            owner \u003d reader.getApplicationOwner();\n            appAcls \u003d reader.getApplicationAcls();\n          } catch (IOException e) {\n            LOG.error(\"Error getting logs for \" + logEntity, e);\n            continue;\n          }\n          ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n          aclsManager.addApplication(applicationId, appAcls);\n\n          String remoteUser \u003d request().getRemoteUser();\n          UserGroupInformation callerUGI \u003d null;\n          if (remoteUser !\u003d null) {\n            callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n          }\n          if (callerUGI !\u003d null \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n            html.h1()\n                ._(\"User [\" + remoteUser\n                    + \"] is not authorized to view the logs for \" + logEntity\n                    + \" in log file [\" + thisNodeFile.getPath().getName() + \"]\")._();\n            LOG.error(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity);\n            continue;\n          }\n\n          AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n          if (logReader \u003d\u003d null) {\n            continue;\n          }\n\n          foundLog \u003d readContainerLogs(html, logReader, logLimits,\n              desiredLogType);\n        } catch (IOException ex) {\n          LOG.error(\"Error getting logs for \" + logEntity, ex);\n          continue;\n        } finally {\n          if (reader !\u003d null)\n            reader.close();\n        }\n      }\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "5a1b33507b935f91d6dee6056fe840e778fb198e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1145. Fixed a potential file-handle leak in the web interface for displaying aggregated logs. Contributed by Rohith Sharma.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/13 11:27 AM",
      "commitName": "5a1b33507b935f91d6dee6056fe840e778fb198e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 8:32 PM",
      "commitNameOld": "f5f8f3bca4eeaedeff8181812452ec363c4db744",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 182.66,
      "commitsBetweenForRepo": 1153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,110 @@\n   protected void render(Block html) {\n-    ContainerId containerId \u003d verifyAndGetContainerId(html);\n-    NodeId nodeId \u003d verifyAndGetNodeId(html);\n-    String appOwner \u003d verifyAndGetAppOwner(html);\n-    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n-    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n-        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n-      return;\n-    }\n-    \n-    ApplicationId applicationId \u003d\n-        containerId.getApplicationAttemptId().getApplicationId();\n-    String logEntity \u003d $(ENTITY_STRING);\n-    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n-      logEntity \u003d containerId.toString();\n-    }\n-\n-    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n-        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n-      html.h1()\n-          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n-          ._();\n-      return;\n-    }\n-    \n-    Path remoteRootLogDir \u003d\n-        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n-            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n-      reader \u003d\n-          new AggregatedLogFormat.LogReader(conf,\n-              LogAggregationUtils.getRemoteNodeLogFileForApp(\n-                  remoteRootLogDir, applicationId, appOwner, nodeId,\n-                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n-    } catch (FileNotFoundException e) {\n-      // ACLs not available till the log file is opened.\n-      html.h1()\n-          ._(\"Logs not available for \"\n-              + logEntity\n-              + \". Aggregation may not be complete, \"\n-              + \"Check back later or try the nodemanager at \"\n-              + nodeId)._();\n-      return;\n-    } catch (IOException e) {\n-      html.h1()._(\"Error getting logs for \" + logEntity)._();\n-      LOG.error(\"Error getting logs for \" + logEntity, e);\n-      return;\n-    }\n-\n-    String owner \u003d null;\n-    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n-    try {\n-      owner \u003d reader.getApplicationOwner();\n-      appAcls \u003d reader.getApplicationAcls();\n-    } catch (IOException e) {\n-      html.h1()._(\"Error getting logs for \" + logEntity)._();\n-      LOG.error(\"Error getting logs for \" + logEntity, e);\n-      return;\n-    }\n-    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n-    aclsManager.addApplication(applicationId, appAcls);\n-\n-    String remoteUser \u003d request().getRemoteUser();\n-    UserGroupInformation callerUGI \u003d null;\n-    if (remoteUser !\u003d null) {\n-      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n-    }\n-    if (callerUGI !\u003d null\n-        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n-            owner, applicationId)) {\n-      html.h1()\n-          ._(\"User [\" + remoteUser\n-              + \"] is not authorized to view the logs for \" + logEntity)._();\n-      return;\n-    }\n-\n-    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n-    try {\n-      AggregatedLogFormat.ContainerLogsReader logReader \u003d\n-          reader.getContainerLogsReader(containerId);\n-      if (logReader \u003d\u003d null) {\n-        html.h1()._(\n-            \"Logs not available for \" + logEntity\n-                + \". Could be caused by the rentention policy\")._();\n+      ContainerId containerId \u003d verifyAndGetContainerId(html);\n+      NodeId nodeId \u003d verifyAndGetNodeId(html);\n+      String appOwner \u003d verifyAndGetAppOwner(html);\n+      LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n+      if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n+          || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n         return;\n       }\n \n-      boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n-          desiredLogType);\n+      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n+          .getApplicationId();\n+      String logEntity \u003d $(ENTITY_STRING);\n+      if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n+        logEntity \u003d containerId.toString();\n+      }\n \n-      if (!foundLog) {\n-        if (desiredLogType.isEmpty()) {\n-          html.h1(\"No logs available for container \" + containerId.toString());\n-        } else {\n-          html.h1(\"Unable to locate \u0027\" + desiredLogType\n-              + \"\u0027 log for container \" + containerId.toString());\n+      if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n+          YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n+        html.h1()\n+            ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n+            ._();\n+        return;\n+      }\n+\n+      Path remoteRootLogDir \u003d new Path(conf.get(\n+          YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n+          YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n+\n+      try {\n+        reader \u003d new AggregatedLogFormat.LogReader(conf,\n+            LogAggregationUtils.getRemoteNodeLogFileForApp(remoteRootLogDir,\n+                applicationId, appOwner, nodeId,\n+                LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n+      } catch (FileNotFoundException e) {\n+        // ACLs not available till the log file is opened.\n+        html.h1()\n+            ._(\"Logs not available for \" + logEntity\n+                + \". Aggregation may not be complete, \"\n+                + \"Check back later or try the nodemanager at \" + nodeId)._();\n+        return;\n+      } catch (IOException e) {\n+        html.h1()._(\"Error getting logs for \" + logEntity)._();\n+        LOG.error(\"Error getting logs for \" + logEntity, e);\n+        return;\n+      }\n+\n+      String owner \u003d null;\n+      Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n+      try {\n+        owner \u003d reader.getApplicationOwner();\n+        appAcls \u003d reader.getApplicationAcls();\n+      } catch (IOException e) {\n+        html.h1()._(\"Error getting logs for \" + logEntity)._();\n+        LOG.error(\"Error getting logs for \" + logEntity, e);\n+        return;\n+      }\n+      ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n+      aclsManager.addApplication(applicationId, appAcls);\n+\n+      String remoteUser \u003d request().getRemoteUser();\n+      UserGroupInformation callerUGI \u003d null;\n+      if (remoteUser !\u003d null) {\n+        callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n+      }\n+      if (callerUGI !\u003d null\n+          \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n+              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n+        html.h1()\n+            ._(\"User [\" + remoteUser\n+                + \"] is not authorized to view the logs for \" + logEntity)._();\n+        return;\n+      }\n+\n+      String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n+      try {\n+        AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n+            .getContainerLogsReader(containerId);\n+        if (logReader \u003d\u003d null) {\n+          html.h1()\n+              ._(\"Logs not available for \" + logEntity\n+                  + \". Could be caused by the rentention policy\")._();\n+          return;\n         }\n+\n+        boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n+            desiredLogType);\n+\n+        if (!foundLog) {\n+          if (desiredLogType.isEmpty()) {\n+            html.h1(\"No logs available for container \" + containerId.toString());\n+          } else {\n+            html.h1(\"Unable to locate \u0027\" + desiredLogType\n+                + \"\u0027 log for container \" + containerId.toString());\n+          }\n+          return;\n+        }\n+      } catch (IOException e) {\n+        html.h1()._(\"Error getting logs for \" + logEntity)._();\n+        LOG.error(\"Error getting logs for \" + logEntity, e);\n         return;\n       }\n-    } catch (IOException e) {\n-      html.h1()._(\"Error getting logs for \" + logEntity)._();\n-      LOG.error(\"Error getting logs for \" + logEntity, e);\n-      return;\n+    } finally {\n+      if (reader !\u003d null) {\n+        reader.close();\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      ContainerId containerId \u003d verifyAndGetContainerId(html);\n      NodeId nodeId \u003d verifyAndGetNodeId(html);\n      String appOwner \u003d verifyAndGetAppOwner(html);\n      LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n      if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n          || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n        return;\n      }\n\n      ApplicationId applicationId \u003d containerId.getApplicationAttemptId()\n          .getApplicationId();\n      String logEntity \u003d $(ENTITY_STRING);\n      if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n        logEntity \u003d containerId.toString();\n      }\n\n      if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n          YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n        html.h1()\n            ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n            ._();\n        return;\n      }\n\n      Path remoteRootLogDir \u003d new Path(conf.get(\n          YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n          YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n\n      try {\n        reader \u003d new AggregatedLogFormat.LogReader(conf,\n            LogAggregationUtils.getRemoteNodeLogFileForApp(remoteRootLogDir,\n                applicationId, appOwner, nodeId,\n                LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n      } catch (FileNotFoundException e) {\n        // ACLs not available till the log file is opened.\n        html.h1()\n            ._(\"Logs not available for \" + logEntity\n                + \". Aggregation may not be complete, \"\n                + \"Check back later or try the nodemanager at \" + nodeId)._();\n        return;\n      } catch (IOException e) {\n        html.h1()._(\"Error getting logs for \" + logEntity)._();\n        LOG.error(\"Error getting logs for \" + logEntity, e);\n        return;\n      }\n\n      String owner \u003d null;\n      Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n      try {\n        owner \u003d reader.getApplicationOwner();\n        appAcls \u003d reader.getApplicationAcls();\n      } catch (IOException e) {\n        html.h1()._(\"Error getting logs for \" + logEntity)._();\n        LOG.error(\"Error getting logs for \" + logEntity, e);\n        return;\n      }\n      ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n      aclsManager.addApplication(applicationId, appAcls);\n\n      String remoteUser \u003d request().getRemoteUser();\n      UserGroupInformation callerUGI \u003d null;\n      if (remoteUser !\u003d null) {\n        callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n      }\n      if (callerUGI !\u003d null\n          \u0026\u0026 !aclsManager.checkAccess(callerUGI,\n              ApplicationAccessType.VIEW_APP, owner, applicationId)) {\n        html.h1()\n            ._(\"User [\" + remoteUser\n                + \"] is not authorized to view the logs for \" + logEntity)._();\n        return;\n      }\n\n      String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n      try {\n        AggregatedLogFormat.ContainerLogsReader logReader \u003d reader\n            .getContainerLogsReader(containerId);\n        if (logReader \u003d\u003d null) {\n          html.h1()\n              ._(\"Logs not available for \" + logEntity\n                  + \". Could be caused by the rentention policy\")._();\n          return;\n        }\n\n        boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n            desiredLogType);\n\n        if (!foundLog) {\n          if (desiredLogType.isEmpty()) {\n            html.h1(\"No logs available for container \" + containerId.toString());\n          } else {\n            html.h1(\"Unable to locate \u0027\" + desiredLogType\n                + \"\u0027 log for container \" + containerId.toString());\n          }\n          return;\n        }\n      } catch (IOException e) {\n        html.h1()._(\"Error getting logs for \" + logEntity)._();\n        LOG.error(\"Error getting logs for \" + logEntity, e);\n        return;\n      }\n    } finally {\n      if (reader !\u003d null) {\n        reader.close();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      AggregatedLogFormat.ContainerLogsReader logReader \u003d\n          reader.getContainerLogsReader(containerId);\n      if (logReader \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n\n      boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n          desiredLogType);\n\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n        return;\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java"
      }
    },
    "8e576570a99270f2db4bd722f451cde0a5c3e4a4": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4283. Display tail of aggregated logs by default (Jason Lowe via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362608 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/12 12:01 PM",
      "commitName": "8e576570a99270f2db4bd722f451cde0a5c3e4a4",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "14/12/11 11:55 AM",
      "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 215.96,
      "commitsBetweenForRepo": 1421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,106 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n+    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n-        || appOwner.isEmpty()) {\n+        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n       return;\n     }\n     \n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n     \n     Path remoteRootLogDir \u003d\n         new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n       reader \u003d\n           new AggregatedLogFormat.LogReader(conf,\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, applicationId, appOwner, nodeId,\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n     } catch (FileNotFoundException e) {\n       // ACLs not available till the log file is opened.\n       html.h1()\n           ._(\"Logs not available for \"\n               + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \"\n               + nodeId)._();\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n \n     String owner \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n     try {\n       owner \u003d reader.getApplicationOwner();\n       appAcls \u003d reader.getApplicationAcls();\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n     ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n     aclsManager.addApplication(applicationId, appAcls);\n \n     String remoteUser \u003d request().getRemoteUser();\n     UserGroupInformation callerUGI \u003d null;\n     if (remoteUser !\u003d null) {\n       callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n     }\n     if (callerUGI !\u003d null\n         \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n             owner, applicationId)) {\n       html.h1()\n           ._(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity)._();\n       return;\n     }\n \n-    DataInputStream valueStream;\n-    LogKey key \u003d new LogKey();\n+    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n     try {\n-      valueStream \u003d reader.next(key);\n-      while (valueStream !\u003d null\n-          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n-        valueStream \u003d reader.next(key);\n-      }\n-      if (valueStream \u003d\u003d null) {\n+      AggregatedLogFormat.ContainerLogsReader logReader \u003d\n+          reader.getContainerLogsReader(containerId);\n+      if (logReader \u003d\u003d null) {\n         html.h1()._(\n             \"Logs not available for \" + logEntity\n                 + \". Could be caused by the rentention policy\")._();\n         return;\n       }\n-      writer().write(\"\u003cpre\u003e\");\n-      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n-      writer().write(\"\u003c/pre\u003e\");\n-      return;\n+\n+      boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n+          desiredLogType);\n+\n+      if (!foundLog) {\n+        if (desiredLogType.isEmpty()) {\n+          html.h1(\"No logs available for container \" + containerId.toString());\n+        } else {\n+          html.h1(\"Unable to locate \u0027\" + desiredLogType\n+              + \"\u0027 log for container \" + containerId.toString());\n+        }\n+        return;\n+      }\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    LogLimits logLimits \u003d verifyAndGetLogLimits(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty() || logLimits \u003d\u003d null) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    String desiredLogType \u003d $(CONTAINER_LOG_TYPE);\n    try {\n      AggregatedLogFormat.ContainerLogsReader logReader \u003d\n          reader.getContainerLogsReader(containerId);\n      if (logReader \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n\n      boolean foundLog \u003d readContainerLogs(html, logReader, logLimits,\n          desiredLogType);\n\n      if (!foundLog) {\n        if (desiredLogType.isEmpty()) {\n          html.h1(\"No logs available for container \" + containerId.toString());\n        } else {\n          html.h1(\"Unable to locate \u0027\" + desiredLogType\n              + \"\u0027 log for container \" + containerId.toString());\n        }\n        return;\n      }\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3398. Fixed log aggregation to work correctly in secure mode. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1214429 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/11 11:55 AM",
      "commitName": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/11/11 1:02 AM",
      "commitNameOld": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 41.5,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty()) {\n       return;\n     }\n     \n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n-    if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n-        YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n+    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n+        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n     \n     Path remoteRootLogDir \u003d\n         new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n       reader \u003d\n           new AggregatedLogFormat.LogReader(conf,\n               LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, applicationId, appOwner, nodeId,\n                   LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n     } catch (FileNotFoundException e) {\n       // ACLs not available till the log file is opened.\n       html.h1()\n           ._(\"Logs not available for \"\n               + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \"\n               + nodeId)._();\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n \n     String owner \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n     try {\n       owner \u003d reader.getApplicationOwner();\n       appAcls \u003d reader.getApplicationAcls();\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n     ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n     aclsManager.addApplication(applicationId, appAcls);\n \n     String remoteUser \u003d request().getRemoteUser();\n     UserGroupInformation callerUGI \u003d null;\n     if (remoteUser !\u003d null) {\n       callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n     }\n     if (callerUGI !\u003d null\n         \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n             owner, applicationId)) {\n       html.h1()\n           ._(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity)._();\n       return;\n     }\n \n     DataInputStream valueStream;\n     LogKey key \u003d new LogKey();\n     try {\n       valueStream \u003d reader.next(key);\n       while (valueStream !\u003d null\n           \u0026\u0026 !key.toString().equals(containerId.toString())) {\n         valueStream \u003d reader.next(key);\n       }\n       if (valueStream \u003d\u003d null) {\n         html.h1()._(\n             \"Logs not available for \" + logEntity\n                 + \". Could be caused by the rentention policy\")._();\n         return;\n       }\n       writer().write(\"\u003cpre\u003e\");\n       AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n       writer().write(\"\u003c/pre\u003e\");\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty()) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    DataInputStream valueStream;\n    LogKey key \u003d new LogKey();\n    try {\n      valueStream \u003d reader.next(key);\n      while (valueStream !\u003d null\n          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n        valueStream \u003d reader.next(key);\n      }\n      if (valueStream \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n      writer().write(\"\u003cpre\u003e\");\n      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n      writer().write(\"\u003c/pre\u003e\");\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/11/11 1:02 AM",
      "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/11/11 1:02 AM",
          "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/11/11 12:06 AM",
          "commitNameOld": "0df4878033b797b9313c887ca9d75f8ea104d029",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,100 +1,100 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty()) {\n       return;\n     }\n     \n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n     \n     Path remoteRootLogDir \u003d\n         new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n       reader \u003d\n           new AggregatedLogFormat.LogReader(conf,\n-              LogAggregationService.getRemoteNodeLogFileForApp(\n+              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, applicationId, appOwner, nodeId,\n-                  LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n+                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n     } catch (FileNotFoundException e) {\n       // ACLs not available till the log file is opened.\n       html.h1()\n           ._(\"Logs not available for \"\n               + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \"\n               + nodeId)._();\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n \n     String owner \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n     try {\n       owner \u003d reader.getApplicationOwner();\n       appAcls \u003d reader.getApplicationAcls();\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n     ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n     aclsManager.addApplication(applicationId, appAcls);\n \n     String remoteUser \u003d request().getRemoteUser();\n     UserGroupInformation callerUGI \u003d null;\n     if (remoteUser !\u003d null) {\n       callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n     }\n     if (callerUGI !\u003d null\n         \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n             owner, applicationId)) {\n       html.h1()\n           ._(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity)._();\n       return;\n     }\n \n     DataInputStream valueStream;\n     LogKey key \u003d new LogKey();\n     try {\n       valueStream \u003d reader.next(key);\n       while (valueStream !\u003d null\n           \u0026\u0026 !key.toString().equals(containerId.toString())) {\n         valueStream \u003d reader.next(key);\n       }\n       if (valueStream \u003d\u003d null) {\n         html.h1()._(\n             \"Logs not available for \" + logEntity\n                 + \". Could be caused by the rentention policy\")._();\n         return;\n       }\n       writer().write(\"\u003cpre\u003e\");\n       AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n       writer().write(\"\u003c/pre\u003e\");\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty()) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    DataInputStream valueStream;\n    LogKey key \u003d new LogKey();\n    try {\n      valueStream \u003d reader.next(key);\n      while (valueStream !\u003d null\n          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n        valueStream \u003d reader.next(key);\n      }\n      if (valueStream \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n      writer().write(\"\u003cpre\u003e\");\n      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n      writer().write(\"\u003c/pre\u003e\");\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
          "extendedDetails": {
            "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/AggregatedLogsBlock.java",
            "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
            "oldMethodName": "render",
            "newMethodName": "render"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/11/11 1:02 AM",
          "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/11/11 12:06 AM",
          "commitNameOld": "0df4878033b797b9313c887ca9d75f8ea104d029",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,100 +1,100 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty()) {\n       return;\n     }\n     \n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n     if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n         YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n       html.h1()\n           ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n           ._();\n       return;\n     }\n     \n     Path remoteRootLogDir \u003d\n         new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n       reader \u003d\n           new AggregatedLogFormat.LogReader(conf,\n-              LogAggregationService.getRemoteNodeLogFileForApp(\n+              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, applicationId, appOwner, nodeId,\n-                  LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n+                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n     } catch (FileNotFoundException e) {\n       // ACLs not available till the log file is opened.\n       html.h1()\n           ._(\"Logs not available for \"\n               + logEntity\n               + \". Aggregation may not be complete, \"\n               + \"Check back later or try the nodemanager at \"\n               + nodeId)._();\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n \n     String owner \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n     try {\n       owner \u003d reader.getApplicationOwner();\n       appAcls \u003d reader.getApplicationAcls();\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n     ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n     aclsManager.addApplication(applicationId, appAcls);\n \n     String remoteUser \u003d request().getRemoteUser();\n     UserGroupInformation callerUGI \u003d null;\n     if (remoteUser !\u003d null) {\n       callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n     }\n     if (callerUGI !\u003d null\n         \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n             owner, applicationId)) {\n       html.h1()\n           ._(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity)._();\n       return;\n     }\n \n     DataInputStream valueStream;\n     LogKey key \u003d new LogKey();\n     try {\n       valueStream \u003d reader.next(key);\n       while (valueStream !\u003d null\n           \u0026\u0026 !key.toString().equals(containerId.toString())) {\n         valueStream \u003d reader.next(key);\n       }\n       if (valueStream \u003d\u003d null) {\n         html.h1()._(\n             \"Logs not available for \" + logEntity\n                 + \". Could be caused by the rentention policy\")._();\n         return;\n       }\n       writer().write(\"\u003cpre\u003e\");\n       AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n       writer().write(\"\u003c/pre\u003e\");\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty()) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationUtils.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationUtils.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    DataInputStream valueStream;\n    LogKey key \u003d new LogKey();\n    try {\n      valueStream \u003d reader.next(key);\n      while (valueStream !\u003d null\n          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n        valueStream \u003d reader.next(key);\n      }\n      if (valueStream \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n      writer().write(\"\u003cpre\u003e\");\n      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n      writer().write(\"\u003c/pre\u003e\");\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/webapp/log/AggregatedLogsBlock.java",
          "extendedDetails": {}
        }
      ]
    },
    "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2696. Fixed NodeManager to cleanup logs in a thread when logs\u0027 aggregation is not enabled. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195383 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 2:55 AM",
      "commitName": "a75c4cf4e4400a2dcb3edc88df7f35a763f93c4e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.13,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,100 @@\n   protected void render(Block html) {\n     ContainerId containerId \u003d verifyAndGetContainerId(html);\n     NodeId nodeId \u003d verifyAndGetNodeId(html);\n     String appOwner \u003d verifyAndGetAppOwner(html);\n     if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n         || appOwner.isEmpty()) {\n       return;\n     }\n     \n     ApplicationId applicationId \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     String logEntity \u003d $(ENTITY_STRING);\n     if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n       logEntity \u003d containerId.toString();\n     }\n \n+    if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n+        YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n+      html.h1()\n+          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n+          ._();\n+      return;\n+    }\n+    \n     Path remoteRootLogDir \u003d\n         new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n             YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n     AggregatedLogFormat.LogReader reader \u003d null;\n     try {\n       reader \u003d\n           new AggregatedLogFormat.LogReader(conf,\n               LogAggregationService.getRemoteNodeLogFileForApp(\n                   remoteRootLogDir, applicationId, appOwner, nodeId,\n                   LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n     } catch (FileNotFoundException e) {\n       // ACLs not available till the log file is opened.\n       html.h1()\n           ._(\"Logs not available for \"\n               + logEntity\n               + \". Aggregation may not be complete, \"\n-              + \"Check back later or try the nodemanager on \"\n+              + \"Check back later or try the nodemanager at \"\n               + nodeId)._();\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n \n     String owner \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n     try {\n       owner \u003d reader.getApplicationOwner();\n       appAcls \u003d reader.getApplicationAcls();\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n     ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n     aclsManager.addApplication(applicationId, appAcls);\n \n     String remoteUser \u003d request().getRemoteUser();\n     UserGroupInformation callerUGI \u003d null;\n     if (remoteUser !\u003d null) {\n       callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n     }\n     if (callerUGI !\u003d null\n         \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n             owner, applicationId)) {\n       html.h1()\n           ._(\"User [\" + remoteUser\n               + \"] is not authorized to view the logs for \" + logEntity)._();\n       return;\n     }\n \n     DataInputStream valueStream;\n     LogKey key \u003d new LogKey();\n     try {\n       valueStream \u003d reader.next(key);\n       while (valueStream !\u003d null\n           \u0026\u0026 !key.toString().equals(containerId.toString())) {\n         valueStream \u003d reader.next(key);\n       }\n       if (valueStream \u003d\u003d null) {\n         html.h1()._(\n             \"Logs not available for \" + logEntity\n                 + \". Could be caused by the rentention policy\")._();\n         return;\n       }\n       writer().write(\"\u003cpre\u003e\");\n       AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n       writer().write(\"\u003c/pre\u003e\");\n       return;\n     } catch (IOException e) {\n       html.h1()._(\"Error getting logs for \" + logEntity)._();\n       LOG.error(\"Error getting logs for \" + logEntity, e);\n       return;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty()) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    if (!conf.getBoolean(YarnConfiguration.NM_LOG_AGGREGATION_ENABLED,\n        YarnConfiguration.DEFAULT_NM_LOG_AGGREGATION_ENABLED)) {\n      html.h1()\n          ._(\"Aggregation is not enabled. Try the nodemanager at \" + nodeId)\n          ._();\n      return;\n    }\n    \n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager at \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    DataInputStream valueStream;\n    LogKey key \u003d new LogKey();\n    try {\n      valueStream \u003d reader.next(key);\n      while (valueStream !\u003d null\n          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n        valueStream \u003d reader.next(key);\n      }\n      if (valueStream \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n      writer().write(\"\u003cpre\u003e\");\n      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n      writer().write(\"\u003c/pre\u003e\");\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/AggregatedLogsBlock.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,92 @@\n+  protected void render(Block html) {\n+    ContainerId containerId \u003d verifyAndGetContainerId(html);\n+    NodeId nodeId \u003d verifyAndGetNodeId(html);\n+    String appOwner \u003d verifyAndGetAppOwner(html);\n+    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n+        || appOwner.isEmpty()) {\n+      return;\n+    }\n+    \n+    ApplicationId applicationId \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n+    String logEntity \u003d $(ENTITY_STRING);\n+    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n+      logEntity \u003d containerId.toString();\n+    }\n+\n+    Path remoteRootLogDir \u003d\n+        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n+            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n+    AggregatedLogFormat.LogReader reader \u003d null;\n+    try {\n+      reader \u003d\n+          new AggregatedLogFormat.LogReader(conf,\n+              LogAggregationService.getRemoteNodeLogFileForApp(\n+                  remoteRootLogDir, applicationId, appOwner, nodeId,\n+                  LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n+    } catch (FileNotFoundException e) {\n+      // ACLs not available till the log file is opened.\n+      html.h1()\n+          ._(\"Logs not available for \"\n+              + logEntity\n+              + \". Aggregation may not be complete, \"\n+              + \"Check back later or try the nodemanager on \"\n+              + nodeId)._();\n+      return;\n+    } catch (IOException e) {\n+      html.h1()._(\"Error getting logs for \" + logEntity)._();\n+      LOG.error(\"Error getting logs for \" + logEntity, e);\n+      return;\n+    }\n+\n+    String owner \u003d null;\n+    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n+    try {\n+      owner \u003d reader.getApplicationOwner();\n+      appAcls \u003d reader.getApplicationAcls();\n+    } catch (IOException e) {\n+      html.h1()._(\"Error getting logs for \" + logEntity)._();\n+      LOG.error(\"Error getting logs for \" + logEntity, e);\n+      return;\n+    }\n+    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n+    aclsManager.addApplication(applicationId, appAcls);\n+\n+    String remoteUser \u003d request().getRemoteUser();\n+    UserGroupInformation callerUGI \u003d null;\n+    if (remoteUser !\u003d null) {\n+      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n+    }\n+    if (callerUGI !\u003d null\n+        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n+            owner, applicationId)) {\n+      html.h1()\n+          ._(\"User [\" + remoteUser\n+              + \"] is not authorized to view the logs for \" + logEntity)._();\n+      return;\n+    }\n+\n+    DataInputStream valueStream;\n+    LogKey key \u003d new LogKey();\n+    try {\n+      valueStream \u003d reader.next(key);\n+      while (valueStream !\u003d null\n+          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n+        valueStream \u003d reader.next(key);\n+      }\n+      if (valueStream \u003d\u003d null) {\n+        html.h1()._(\n+            \"Logs not available for \" + logEntity\n+                + \". Could be caused by the rentention policy\")._();\n+        return;\n+      }\n+      writer().write(\"\u003cpre\u003e\");\n+      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n+      writer().write(\"\u003c/pre\u003e\");\n+      return;\n+    } catch (IOException e) {\n+      html.h1()._(\"Error getting logs for \" + logEntity)._();\n+      LOG.error(\"Error getting logs for \" + logEntity, e);\n+      return;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void render(Block html) {\n    ContainerId containerId \u003d verifyAndGetContainerId(html);\n    NodeId nodeId \u003d verifyAndGetNodeId(html);\n    String appOwner \u003d verifyAndGetAppOwner(html);\n    if (containerId \u003d\u003d null || nodeId \u003d\u003d null || appOwner \u003d\u003d null\n        || appOwner.isEmpty()) {\n      return;\n    }\n    \n    ApplicationId applicationId \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    String logEntity \u003d $(ENTITY_STRING);\n    if (logEntity \u003d\u003d null || logEntity.isEmpty()) {\n      logEntity \u003d containerId.toString();\n    }\n\n    Path remoteRootLogDir \u003d\n        new Path(conf.get(YarnConfiguration.NM_REMOTE_APP_LOG_DIR,\n            YarnConfiguration.DEFAULT_NM_REMOTE_APP_LOG_DIR));\n    AggregatedLogFormat.LogReader reader \u003d null;\n    try {\n      reader \u003d\n          new AggregatedLogFormat.LogReader(conf,\n              LogAggregationService.getRemoteNodeLogFileForApp(\n                  remoteRootLogDir, applicationId, appOwner, nodeId,\n                  LogAggregationService.getRemoteNodeLogDirSuffix(conf)));\n    } catch (FileNotFoundException e) {\n      // ACLs not available till the log file is opened.\n      html.h1()\n          ._(\"Logs not available for \"\n              + logEntity\n              + \". Aggregation may not be complete, \"\n              + \"Check back later or try the nodemanager on \"\n              + nodeId)._();\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n\n    String owner \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appAcls \u003d null;\n    try {\n      owner \u003d reader.getApplicationOwner();\n      appAcls \u003d reader.getApplicationAcls();\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n    ApplicationACLsManager aclsManager \u003d new ApplicationACLsManager(conf);\n    aclsManager.addApplication(applicationId, appAcls);\n\n    String remoteUser \u003d request().getRemoteUser();\n    UserGroupInformation callerUGI \u003d null;\n    if (remoteUser !\u003d null) {\n      callerUGI \u003d UserGroupInformation.createRemoteUser(remoteUser);\n    }\n    if (callerUGI !\u003d null\n        \u0026\u0026 !aclsManager.checkAccess(callerUGI, ApplicationAccessType.VIEW_APP,\n            owner, applicationId)) {\n      html.h1()\n          ._(\"User [\" + remoteUser\n              + \"] is not authorized to view the logs for \" + logEntity)._();\n      return;\n    }\n\n    DataInputStream valueStream;\n    LogKey key \u003d new LogKey();\n    try {\n      valueStream \u003d reader.next(key);\n      while (valueStream !\u003d null\n          \u0026\u0026 !key.toString().equals(containerId.toString())) {\n        valueStream \u003d reader.next(key);\n      }\n      if (valueStream \u003d\u003d null) {\n        html.h1()._(\n            \"Logs not available for \" + logEntity\n                + \". Could be caused by the rentention policy\")._();\n        return;\n      }\n      writer().write(\"\u003cpre\u003e\");\n      AggregatedLogFormat.LogReader.readAcontainerLogs(valueStream, writer());\n      writer().write(\"\u003c/pre\u003e\");\n      return;\n    } catch (IOException e) {\n      html.h1()._(\"Error getting logs for \" + logEntity)._();\n      LOG.error(\"Error getting logs for \" + logEntity, e);\n      return;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/AggregatedLogsBlock.java"
    }
  }
}