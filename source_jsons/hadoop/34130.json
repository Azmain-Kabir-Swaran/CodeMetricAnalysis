{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CGroupElasticMemoryController.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/CGroupElasticMemoryController.java",
  "functionStartLine": 241,
  "functionEndLine": 327,
  "numCommitsSeen": 2,
  "timeTaken": 956,
  "changeHistory": [
    "d9964799544eefcf424fcc178d987525f5356cdf"
  ],
  "changeHistoryShort": {
    "d9964799544eefcf424fcc178d987525f5356cdf": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d9964799544eefcf424fcc178d987525f5356cdf": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4599. Set OOM control for memory cgroups. (Miklos Szegedi via Haibo Chen)\n",
      "commitDate": "23/05/18 4:35 PM",
      "commitName": "d9964799544eefcf424fcc178d987525f5356cdf",
      "commitAuthor": "Haibo Chen",
      "diff": "@@ -0,0 +1,87 @@\n+  public void run() {\n+    ExecutorService executor \u003d null;\n+    try {\n+      // Disable OOM killer and set a limit.\n+      // This has to be set first, so that we get notified about valid events.\n+      // We will be notified about events even, if they happened before\n+      // oom-listener started\n+      setCGroupParameters();\n+\n+      // Start a listener process\n+      ProcessBuilder oomListener \u003d new ProcessBuilder();\n+      oomListener.command(oomListenerPath, yarnCGroupPath);\n+      synchronized (this) {\n+        if (!stopped) {\n+          process \u003d oomListener.start();\n+        } else {\n+          resetCGroupParameters();\n+          LOG.info(\"Listener stopped before starting\");\n+          return;\n+        }\n+      }\n+      LOG.info(String.format(\"Listening on %s with %s\",\n+          yarnCGroupPath,\n+          oomListenerPath));\n+\n+      // We need 1 thread for the error stream and a few others\n+      // as a watchdog for the OOM killer\n+      executor \u003d Executors.newFixedThreadPool(2);\n+\n+      // Listen to any errors in the background. We do not expect this to\n+      // be large in size, so it will fit into a string.\n+      Future\u003cString\u003e errorListener \u003d executor.submit(\n+          () -\u003e IOUtils.toString(process.getErrorStream(),\n+              Charset.defaultCharset()));\n+\n+      // We get Linux event increments (8 bytes) forwarded from the event stream\n+      // The events cannot be split, so it is safe to read them as a whole\n+      // There is no race condition with the cgroup\n+      // running out of memory. If oom is 1 at startup\n+      // oom_listener will send an initial notification\n+      InputStream events \u003d process.getInputStream();\n+      byte[] event \u003d new byte[8];\n+      int read;\n+      // This loop can be exited by terminating the process\n+      // with stopListening()\n+      while ((read \u003d events.read(event)) \u003d\u003d event.length) {\n+        // An OOM event has occurred\n+        resolveOOM(executor);\n+      }\n+\n+      if (read !\u003d -1) {\n+        LOG.warn(String.format(\"Characters returned from event hander: %d\",\n+            read));\n+      }\n+\n+      // If the input stream is closed, we wait for exit or process terminated.\n+      int exitCode \u003d process.waitFor();\n+      String error \u003d errorListener.get();\n+      process \u003d null;\n+      LOG.info(String.format(\"OOM listener exited %d %s\", exitCode, error));\n+    } catch (OOMNotResolvedException ex) {\n+      // We could mark the node unhealthy but it shuts down the node anyways.\n+      // Let\u0027s just bring down the node manager all containers are frozen.\n+      throw new YarnRuntimeException(\"Could not resolve OOM\", ex);\n+    } catch (Exception ex) {\n+      synchronized (this) {\n+        if (!stopped) {\n+          LOG.warn(\"OOM Listener exiting.\", ex);\n+        }\n+      }\n+    } finally {\n+      // Make sure we do not leak the child process,\n+      // especially if process.waitFor() did not finish.\n+      if (process !\u003d null \u0026\u0026 process.isAlive()) {\n+        process.destroyForcibly();\n+      }\n+      if (executor !\u003d null) {\n+        try {\n+          executor.awaitTermination(6, TimeUnit.SECONDS);\n+        } catch (InterruptedException e) {\n+          LOG.warn(\"Exiting without processing all OOM events.\");\n+        }\n+        executor.shutdown();\n+      }\n+      resetCGroupParameters();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ExecutorService executor \u003d null;\n    try {\n      // Disable OOM killer and set a limit.\n      // This has to be set first, so that we get notified about valid events.\n      // We will be notified about events even, if they happened before\n      // oom-listener started\n      setCGroupParameters();\n\n      // Start a listener process\n      ProcessBuilder oomListener \u003d new ProcessBuilder();\n      oomListener.command(oomListenerPath, yarnCGroupPath);\n      synchronized (this) {\n        if (!stopped) {\n          process \u003d oomListener.start();\n        } else {\n          resetCGroupParameters();\n          LOG.info(\"Listener stopped before starting\");\n          return;\n        }\n      }\n      LOG.info(String.format(\"Listening on %s with %s\",\n          yarnCGroupPath,\n          oomListenerPath));\n\n      // We need 1 thread for the error stream and a few others\n      // as a watchdog for the OOM killer\n      executor \u003d Executors.newFixedThreadPool(2);\n\n      // Listen to any errors in the background. We do not expect this to\n      // be large in size, so it will fit into a string.\n      Future\u003cString\u003e errorListener \u003d executor.submit(\n          () -\u003e IOUtils.toString(process.getErrorStream(),\n              Charset.defaultCharset()));\n\n      // We get Linux event increments (8 bytes) forwarded from the event stream\n      // The events cannot be split, so it is safe to read them as a whole\n      // There is no race condition with the cgroup\n      // running out of memory. If oom is 1 at startup\n      // oom_listener will send an initial notification\n      InputStream events \u003d process.getInputStream();\n      byte[] event \u003d new byte[8];\n      int read;\n      // This loop can be exited by terminating the process\n      // with stopListening()\n      while ((read \u003d events.read(event)) \u003d\u003d event.length) {\n        // An OOM event has occurred\n        resolveOOM(executor);\n      }\n\n      if (read !\u003d -1) {\n        LOG.warn(String.format(\"Characters returned from event hander: %d\",\n            read));\n      }\n\n      // If the input stream is closed, we wait for exit or process terminated.\n      int exitCode \u003d process.waitFor();\n      String error \u003d errorListener.get();\n      process \u003d null;\n      LOG.info(String.format(\"OOM listener exited %d %s\", exitCode, error));\n    } catch (OOMNotResolvedException ex) {\n      // We could mark the node unhealthy but it shuts down the node anyways.\n      // Let\u0027s just bring down the node manager all containers are frozen.\n      throw new YarnRuntimeException(\"Could not resolve OOM\", ex);\n    } catch (Exception ex) {\n      synchronized (this) {\n        if (!stopped) {\n          LOG.warn(\"OOM Listener exiting.\", ex);\n        }\n      }\n    } finally {\n      // Make sure we do not leak the child process,\n      // especially if process.waitFor() did not finish.\n      if (process !\u003d null \u0026\u0026 process.isAlive()) {\n        process.destroyForcibly();\n      }\n      if (executor !\u003d null) {\n        try {\n          executor.awaitTermination(6, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n          LOG.warn(\"Exiting without processing all OOM events.\");\n        }\n        executor.shutdown();\n      }\n      resetCGroupParameters();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/CGroupElasticMemoryController.java"
    }
  }
}