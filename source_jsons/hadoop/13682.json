{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "chooseLocalStorage",
  "functionId": "chooseLocalStorage___localMachine-Node__excludedNodes-Set__Node____blocksize-long__maxNodesPerRack-int__results-List__DatanodeStorageInfo____avoidStaleNodes-boolean__storageTypes-EnumMap__StorageType,Integer__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 566,
  "functionEndLine": 574,
  "numCommitsSeen": 99,
  "timeTaken": 2669,
  "changeHistory": [
    "7d7acb004af5095983e99c86deedfc60a0355ff7",
    "8fa41d9dd4b923bf4141f019414a1a8b079124c6",
    "80a29906bcd718bbba223fa099e523281d9f3369"
  ],
  "changeHistoryShort": {
    "7d7acb004af5095983e99c86deedfc60a0355ff7": "Ybodychange",
    "8fa41d9dd4b923bf4141f019414a1a8b079124c6": "Ybodychange",
    "80a29906bcd718bbba223fa099e523281d9f3369": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7d7acb004af5095983e99c86deedfc60a0355ff7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13736. BlockPlacementPolicyDefault can not choose favored nodes when \u0027dfs.namenode.block-placement-policy.default.prefer-local-node\u0027 set to false. Contributed by hu xiaodong.\n",
      "commitDate": "01/11/19 10:20 AM",
      "commitName": "7d7acb004af5095983e99c86deedfc60a0355ff7",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "19/06/19 10:06 AM",
      "commitNameOld": "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e",
      "commitAuthorOld": "David Mollitor",
      "daysBetweenCommits": 135.01,
      "commitsBetweenForRepo": 1074,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,9 @@\n   protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n       Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n       List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n       EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n-    // if no local machine, randomly choose one node\n-    if (localMachine \u003d\u003d null) {\n-      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n-    }\n-    if (preferLocalNode \u0026\u0026 localMachine instanceof DatanodeDescriptor\n-        \u0026\u0026 clusterMap.contains(localMachine)) {\n-      DatanodeDescriptor localDatanode \u003d (DatanodeDescriptor) localMachine;\n-      // otherwise try local machine first\n-      if (excludedNodes.add(localMachine) // was not in the excluded list\n-          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n-              results, avoidStaleNodes)) {\n-        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n-            .entrySet().iterator(); iter.hasNext(); ) {\n-          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n-          DatanodeStorageInfo localStorage \u003d chooseStorage4Block(\n-              localDatanode, blocksize, results, entry.getKey());\n-          if (localStorage !\u003d null) {\n-            // add node and related nodes to excludedNode\n-            addToExcludedNodes(localDatanode, excludedNodes);\n-            int num \u003d entry.getValue();\n-            if (num \u003d\u003d 1) {\n-              iter.remove();\n-            } else {\n-              entry.setValue(num - 1);\n-            }\n-            return localStorage;\n-          }\n-        }\n-      } \n-    }\n-    return null;\n+    return chooseLocalOrFavoredStorage(localMachine, false,\n+        excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes,\n+        storageTypes);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n      Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n      List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n      EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    return chooseLocalOrFavoredStorage(localMachine, false,\n        excludedNodes, blocksize, maxNodesPerRack, results, avoidStaleNodes,\n        storageTypes);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "8fa41d9dd4b923bf4141f019414a1a8b079124c6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8946. Improve choosing datanode storage for block placement. (yliu)\n",
      "commitDate": "31/08/15 5:52 PM",
      "commitName": "8fa41d9dd4b923bf4141f019414a1a8b079124c6",
      "commitAuthor": "yliu",
      "commitDateOld": "20/08/15 5:15 AM",
      "commitNameOld": "5e8fe8943718309b5e39a794360aebccae28b331",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 11.53,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n       Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n       List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n       EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // if no local machine, randomly choose one node\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n     if (preferLocalNode \u0026\u0026 localMachine instanceof DatanodeDescriptor\n         \u0026\u0026 clusterMap.contains(localMachine)) {\n       DatanodeDescriptor localDatanode \u003d (DatanodeDescriptor) localMachine;\n       // otherwise try local machine first\n       if (excludedNodes.add(localMachine) // was not in the excluded list\n           \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n               results, avoidStaleNodes)) {\n         for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n             .entrySet().iterator(); iter.hasNext(); ) {\n           Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n-          for (DatanodeStorageInfo localStorage : DFSUtil.shuffle(\n-              localDatanode.getStorageInfos())) {\n-            StorageType type \u003d entry.getKey();\n-            if (addIfIsGoodTarget(localStorage, excludedNodes, blocksize,\n-                results, type) \u003e\u003d 0) {\n-              int num \u003d entry.getValue();\n-              if (num \u003d\u003d 1) {\n-                iter.remove();\n-              } else {\n-                entry.setValue(num - 1);\n-              }\n-              return localStorage;\n+          DatanodeStorageInfo localStorage \u003d chooseStorage4Block(\n+              localDatanode, blocksize, results, entry.getKey());\n+          if (localStorage !\u003d null) {\n+            // add node and related nodes to excludedNode\n+            addToExcludedNodes(localDatanode, excludedNodes);\n+            int num \u003d entry.getValue();\n+            if (num \u003d\u003d 1) {\n+              iter.remove();\n+            } else {\n+              entry.setValue(num - 1);\n             }\n+            return localStorage;\n           }\n         }\n       } \n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n      Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n      List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n      EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // if no local machine, randomly choose one node\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    if (preferLocalNode \u0026\u0026 localMachine instanceof DatanodeDescriptor\n        \u0026\u0026 clusterMap.contains(localMachine)) {\n      DatanodeDescriptor localDatanode \u003d (DatanodeDescriptor) localMachine;\n      // otherwise try local machine first\n      if (excludedNodes.add(localMachine) // was not in the excluded list\n          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n              results, avoidStaleNodes)) {\n        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n            .entrySet().iterator(); iter.hasNext(); ) {\n          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n          DatanodeStorageInfo localStorage \u003d chooseStorage4Block(\n              localDatanode, blocksize, results, entry.getKey());\n          if (localStorage !\u003d null) {\n            // add node and related nodes to excludedNode\n            addToExcludedNodes(localDatanode, excludedNodes);\n            int num \u003d entry.getValue();\n            if (num \u003d\u003d 1) {\n              iter.remove();\n            } else {\n              entry.setValue(num - 1);\n            }\n            return localStorage;\n          }\n        }\n      } \n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "80a29906bcd718bbba223fa099e523281d9f3369": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
      "commitDate": "20/08/15 5:07 AM",
      "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
      "commitAuthor": "yliu",
      "diff": "@@ -0,0 +1,39 @@\n+  protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n+      Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n+      List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n+      EnumMap\u003cStorageType, Integer\u003e storageTypes)\n+      throws NotEnoughReplicasException {\n+    // if no local machine, randomly choose one node\n+    if (localMachine \u003d\u003d null) {\n+      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n+    }\n+    if (preferLocalNode \u0026\u0026 localMachine instanceof DatanodeDescriptor\n+        \u0026\u0026 clusterMap.contains(localMachine)) {\n+      DatanodeDescriptor localDatanode \u003d (DatanodeDescriptor) localMachine;\n+      // otherwise try local machine first\n+      if (excludedNodes.add(localMachine) // was not in the excluded list\n+          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n+              results, avoidStaleNodes)) {\n+        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n+            .entrySet().iterator(); iter.hasNext(); ) {\n+          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n+          for (DatanodeStorageInfo localStorage : DFSUtil.shuffle(\n+              localDatanode.getStorageInfos())) {\n+            StorageType type \u003d entry.getKey();\n+            if (addIfIsGoodTarget(localStorage, excludedNodes, blocksize,\n+                results, type) \u003e\u003d 0) {\n+              int num \u003d entry.getValue();\n+              if (num \u003d\u003d 1) {\n+                iter.remove();\n+              } else {\n+                entry.setValue(num - 1);\n+              }\n+              return localStorage;\n+            }\n+          }\n+        }\n+      } \n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalStorage(Node localMachine,\n      Set\u003cNode\u003e excludedNodes, long blocksize, int maxNodesPerRack,\n      List\u003cDatanodeStorageInfo\u003e results, boolean avoidStaleNodes,\n      EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // if no local machine, randomly choose one node\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    if (preferLocalNode \u0026\u0026 localMachine instanceof DatanodeDescriptor\n        \u0026\u0026 clusterMap.contains(localMachine)) {\n      DatanodeDescriptor localDatanode \u003d (DatanodeDescriptor) localMachine;\n      // otherwise try local machine first\n      if (excludedNodes.add(localMachine) // was not in the excluded list\n          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n              results, avoidStaleNodes)) {\n        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n            .entrySet().iterator(); iter.hasNext(); ) {\n          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n          for (DatanodeStorageInfo localStorage : DFSUtil.shuffle(\n              localDatanode.getStorageInfos())) {\n            StorageType type \u003d entry.getKey();\n            if (addIfIsGoodTarget(localStorage, excludedNodes, blocksize,\n                results, type) \u003e\u003d 0) {\n              int num \u003d entry.getValue();\n              if (num \u003d\u003d 1) {\n                iter.remove();\n              } else {\n                entry.setValue(num - 1);\n              }\n              return localStorage;\n            }\n          }\n        }\n      } \n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java"
    }
  }
}