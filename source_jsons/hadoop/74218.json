{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LdapGroupsMapping.java",
  "functionName": "doGetGroups",
  "functionId": "doGetGroups___user-String__goUpHierarchy-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
  "functionStartLine": 510,
  "functionEndLine": 556,
  "numCommitsSeen": 46,
  "timeTaken": 3698,
  "changeHistory": [
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
    "a2121cb0d907be439d19cd1165a0371b37a5fe68",
    "6f0aa75121224589fe1e20630c597f851ef3bed2",
    "182fc1986a984ed0be6bed297390a830c2305af1",
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
    "722aa1db1f2ac3db0e70063022436a90f90643f3",
    "82128774156c30a535b62d764bb6cf9c8d2f3a3b",
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9"
  ],
  "changeHistoryShort": {
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": "Ybodychange",
    "a2121cb0d907be439d19cd1165a0371b37a5fe68": "Ybodychange",
    "6f0aa75121224589fe1e20630c597f851ef3bed2": "Ymultichange(Yparameterchange,Ybodychange)",
    "182fc1986a984ed0be6bed297390a830c2305af1": "Ybodychange",
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197": "Ybodychange",
    "722aa1db1f2ac3db0e70063022436a90f90643f3": "Ybodychange",
    "82128774156c30a535b62d764bb6cf9c8d2f3a3b": "Ybodychange",
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15950. Failover for LdapGroupsMapping. Contributed by Lukas Majercak.\n",
      "commitDate": "03/12/18 12:10 PM",
      "commitName": "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "29/03/18 5:16 PM",
      "commitNameOld": "2216bde322961c0fe33b5822510880a65d5c45fd",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 248.83,
      "commitsBetweenForRepo": 2455,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,47 @@\n   List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n       throws NamingException {\n     DirContext c \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(userbaseDN,\n         userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n     // return empty list if the user can not be found.\n     if (!results.hasMoreElements()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n-            \"user is not found.\");\n-      }\n-      return new ArrayList\u003cString\u003e();\n+      LOG.debug(\"doGetGroups({}) returned no groups because the \" +\n+          \"user is not found.\", user);\n+      return new ArrayList\u003c\u003e();\n     }\n     SearchResult result \u003d results.nextElement();\n \n     List\u003cString\u003e groups \u003d null;\n     if (useOneQuery) {\n       try {\n         /**\n          * For Active Directory servers, the user object has an attribute\n          * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n          * user belongs. So the second query may be skipped.\n          */\n         Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n         if (groupDNAttr \u003d\u003d null) {\n           throw new NamingException(\"The user object does not have \u0027\" +\n               memberOfAttr + \"\u0027 attribute.\" +\n               \"Returned user object: \" + result.toString());\n         }\n-        groups \u003d new ArrayList\u003cString\u003e();\n+        groups \u003d new ArrayList\u003c\u003e();\n         NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n         while (groupEnumeration.hasMore()) {\n           String groupDN \u003d groupEnumeration.next().toString();\n           groups.add(getRelativeDistinguishedName(groupDN));\n         }\n       } catch (NamingException e) {\n         // If the first lookup failed, fall back to the typical scenario.\n         LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                 \"the second LDAP query using the user\u0027s DN.\", e);\n       }\n     }\n     if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n       groups \u003d lookupGroup(result, c, goUpHierarchy);\n     }\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n-    }\n+    LOG.debug(\"doGetGroups({}) returned {}\", user, groups);\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n      throws NamingException {\n    DirContext c \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(userbaseDN,\n        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n    // return empty list if the user can not be found.\n    if (!results.hasMoreElements()) {\n      LOG.debug(\"doGetGroups({}) returned no groups because the \" +\n          \"user is not found.\", user);\n      return new ArrayList\u003c\u003e();\n    }\n    SearchResult result \u003d results.nextElement();\n\n    List\u003cString\u003e groups \u003d null;\n    if (useOneQuery) {\n      try {\n        /**\n         * For Active Directory servers, the user object has an attribute\n         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n         * user belongs. So the second query may be skipped.\n         */\n        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n        if (groupDNAttr \u003d\u003d null) {\n          throw new NamingException(\"The user object does not have \u0027\" +\n              memberOfAttr + \"\u0027 attribute.\" +\n              \"Returned user object: \" + result.toString());\n        }\n        groups \u003d new ArrayList\u003c\u003e();\n        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n        while (groupEnumeration.hasMore()) {\n          String groupDN \u003d groupEnumeration.next().toString();\n          groups.add(getRelativeDistinguishedName(groupDN));\n        }\n      } catch (NamingException e) {\n        // If the first lookup failed, fall back to the typical scenario.\n        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                \"the second LDAP query using the user\u0027s DN.\", e);\n      }\n    }\n    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n      groups \u003d lookupGroup(result, c, goUpHierarchy);\n    }\n    LOG.debug(\"doGetGroups({}) returned {}\", user, groups);\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "a2121cb0d907be439d19cd1165a0371b37a5fe68": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14465. LdapGroupsMapping - support user and group search base. Contributed by Shwetha G S and Mingliang Liu\n",
      "commitDate": "09/06/17 2:55 PM",
      "commitName": "a2121cb0d907be439d19cd1165a0371b37a5fe68",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "05/08/16 4:32 PM",
      "commitNameOld": "49ba09a9221ad1e25e89800f6c455bbaad41483b",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 307.93,
      "commitsBetweenForRepo": 1866,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n       throws NamingException {\n     DirContext c \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n-    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n+    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(userbaseDN,\n         userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n     // return empty list if the user can not be found.\n     if (!results.hasMoreElements()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n             \"user is not found.\");\n       }\n       return new ArrayList\u003cString\u003e();\n     }\n     SearchResult result \u003d results.nextElement();\n \n     List\u003cString\u003e groups \u003d null;\n     if (useOneQuery) {\n       try {\n         /**\n          * For Active Directory servers, the user object has an attribute\n          * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n          * user belongs. So the second query may be skipped.\n          */\n         Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n         if (groupDNAttr \u003d\u003d null) {\n           throw new NamingException(\"The user object does not have \u0027\" +\n               memberOfAttr + \"\u0027 attribute.\" +\n               \"Returned user object: \" + result.toString());\n         }\n         groups \u003d new ArrayList\u003cString\u003e();\n         NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n         while (groupEnumeration.hasMore()) {\n           String groupDN \u003d groupEnumeration.next().toString();\n           groups.add(getRelativeDistinguishedName(groupDN));\n         }\n       } catch (NamingException e) {\n         // If the first lookup failed, fall back to the typical scenario.\n         LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                 \"the second LDAP query using the user\u0027s DN.\", e);\n       }\n     }\n     if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n       groups \u003d lookupGroup(result, c, goUpHierarchy);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n      throws NamingException {\n    DirContext c \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(userbaseDN,\n        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n    // return empty list if the user can not be found.\n    if (!results.hasMoreElements()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n            \"user is not found.\");\n      }\n      return new ArrayList\u003cString\u003e();\n    }\n    SearchResult result \u003d results.nextElement();\n\n    List\u003cString\u003e groups \u003d null;\n    if (useOneQuery) {\n      try {\n        /**\n         * For Active Directory servers, the user object has an attribute\n         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n         * user belongs. So the second query may be skipped.\n         */\n        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n        if (groupDNAttr \u003d\u003d null) {\n          throw new NamingException(\"The user object does not have \u0027\" +\n              memberOfAttr + \"\u0027 attribute.\" +\n              \"Returned user object: \" + result.toString());\n        }\n        groups \u003d new ArrayList\u003cString\u003e();\n        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n        while (groupEnumeration.hasMore()) {\n          String groupDN \u003d groupEnumeration.next().toString();\n          groups.add(getRelativeDistinguishedName(groupDN));\n        }\n      } catch (NamingException e) {\n        // If the first lookup failed, fall back to the typical scenario.\n        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                \"the second LDAP query using the user\u0027s DN.\", e);\n      }\n    }\n    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n      groups \u003d lookupGroup(result, c, goUpHierarchy);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "6f0aa75121224589fe1e20630c597f851ef3bed2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
      "commitDate": "15/06/16 11:41 AM",
      "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
          "commitDate": "15/06/16 11:41 AM",
          "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "03/06/16 4:38 PM",
          "commitNameOld": "d82bc8501869be78780fc09752dbf7af918c14af",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 11.79,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n-  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n+  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n+      throws NamingException {\n     DirContext c \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n         userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n     // return empty list if the user can not be found.\n     if (!results.hasMoreElements()) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"doGetGroups(\" + user + \") return no groups because the \" +\n+        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n             \"user is not found.\");\n       }\n       return new ArrayList\u003cString\u003e();\n     }\n     SearchResult result \u003d results.nextElement();\n \n     List\u003cString\u003e groups \u003d null;\n     if (useOneQuery) {\n       try {\n         /**\n          * For Active Directory servers, the user object has an attribute\n          * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n          * user belongs. So the second query may be skipped.\n          */\n         Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n         if (groupDNAttr \u003d\u003d null) {\n           throw new NamingException(\"The user object does not have \u0027\" +\n               memberOfAttr + \"\u0027 attribute.\" +\n               \"Returned user object: \" + result.toString());\n         }\n         groups \u003d new ArrayList\u003cString\u003e();\n         NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n         while (groupEnumeration.hasMore()) {\n           String groupDN \u003d groupEnumeration.next().toString();\n           groups.add(getRelativeDistinguishedName(groupDN));\n         }\n       } catch (NamingException e) {\n         // If the first lookup failed, fall back to the typical scenario.\n         LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                 \"the second LDAP query using the user\u0027s DN.\", e);\n       }\n     }\n-    if (groups \u003d\u003d null || groups.isEmpty()) {\n-      groups \u003d lookupGroup(result, c);\n+    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n+      groups \u003d lookupGroup(result, c, goUpHierarchy);\n     }\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n+      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n      throws NamingException {\n    DirContext c \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n    // return empty list if the user can not be found.\n    if (!results.hasMoreElements()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n            \"user is not found.\");\n      }\n      return new ArrayList\u003cString\u003e();\n    }\n    SearchResult result \u003d results.nextElement();\n\n    List\u003cString\u003e groups \u003d null;\n    if (useOneQuery) {\n      try {\n        /**\n         * For Active Directory servers, the user object has an attribute\n         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n         * user belongs. So the second query may be skipped.\n         */\n        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n        if (groupDNAttr \u003d\u003d null) {\n          throw new NamingException(\"The user object does not have \u0027\" +\n              memberOfAttr + \"\u0027 attribute.\" +\n              \"Returned user object: \" + result.toString());\n        }\n        groups \u003d new ArrayList\u003cString\u003e();\n        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n        while (groupEnumeration.hasMore()) {\n          String groupDN \u003d groupEnumeration.next().toString();\n          groups.add(getRelativeDistinguishedName(groupDN));\n        }\n      } catch (NamingException e) {\n        // If the first lookup failed, fall back to the typical scenario.\n        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                \"the second LDAP query using the user\u0027s DN.\", e);\n      }\n    }\n    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n      groups \u003d lookupGroup(result, c, goUpHierarchy);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n    }\n    return groups;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {
            "oldValue": "[user-String]",
            "newValue": "[user-String, goUpHierarchy-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
          "commitDate": "15/06/16 11:41 AM",
          "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "03/06/16 4:38 PM",
          "commitNameOld": "d82bc8501869be78780fc09752dbf7af918c14af",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 11.79,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n-  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n+  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n+      throws NamingException {\n     DirContext c \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n         userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n     // return empty list if the user can not be found.\n     if (!results.hasMoreElements()) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"doGetGroups(\" + user + \") return no groups because the \" +\n+        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n             \"user is not found.\");\n       }\n       return new ArrayList\u003cString\u003e();\n     }\n     SearchResult result \u003d results.nextElement();\n \n     List\u003cString\u003e groups \u003d null;\n     if (useOneQuery) {\n       try {\n         /**\n          * For Active Directory servers, the user object has an attribute\n          * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n          * user belongs. So the second query may be skipped.\n          */\n         Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n         if (groupDNAttr \u003d\u003d null) {\n           throw new NamingException(\"The user object does not have \u0027\" +\n               memberOfAttr + \"\u0027 attribute.\" +\n               \"Returned user object: \" + result.toString());\n         }\n         groups \u003d new ArrayList\u003cString\u003e();\n         NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n         while (groupEnumeration.hasMore()) {\n           String groupDN \u003d groupEnumeration.next().toString();\n           groups.add(getRelativeDistinguishedName(groupDN));\n         }\n       } catch (NamingException e) {\n         // If the first lookup failed, fall back to the typical scenario.\n         LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                 \"the second LDAP query using the user\u0027s DN.\", e);\n       }\n     }\n-    if (groups \u003d\u003d null || groups.isEmpty()) {\n-      groups \u003d lookupGroup(result, c);\n+    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n+      groups \u003d lookupGroup(result, c, goUpHierarchy);\n     }\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n+      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  List\u003cString\u003e doGetGroups(String user, int goUpHierarchy)\n      throws NamingException {\n    DirContext c \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n    // return empty list if the user can not be found.\n    if (!results.hasMoreElements()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"doGetGroups(\" + user + \") returned no groups because the \" +\n            \"user is not found.\");\n      }\n      return new ArrayList\u003cString\u003e();\n    }\n    SearchResult result \u003d results.nextElement();\n\n    List\u003cString\u003e groups \u003d null;\n    if (useOneQuery) {\n      try {\n        /**\n         * For Active Directory servers, the user object has an attribute\n         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n         * user belongs. So the second query may be skipped.\n         */\n        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n        if (groupDNAttr \u003d\u003d null) {\n          throw new NamingException(\"The user object does not have \u0027\" +\n              memberOfAttr + \"\u0027 attribute.\" +\n              \"Returned user object: \" + result.toString());\n        }\n        groups \u003d new ArrayList\u003cString\u003e();\n        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n        while (groupEnumeration.hasMore()) {\n          String groupDN \u003d groupEnumeration.next().toString();\n          groups.add(getRelativeDistinguishedName(groupDN));\n        }\n      } catch (NamingException e) {\n        // If the first lookup failed, fall back to the typical scenario.\n        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                \"the second LDAP query using the user\u0027s DN.\", e);\n      }\n    }\n    if (groups \u003d\u003d null || groups.isEmpty() || goUpHierarchy \u003e 0) {\n      groups \u003d lookupGroup(result, c, goUpHierarchy);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"doGetGroups(\" + user + \") returned \" + groups);\n    }\n    return groups;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {}
        }
      ]
    },
    "182fc1986a984ed0be6bed297390a830c2305af1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12782. Faster LDAP group name resolution with ActiveDirectory. Contributed by Wei-Chiu Chuang\n",
      "commitDate": "19/05/16 7:15 AM",
      "commitName": "182fc1986a984ed0be6bed297390a830c2305af1",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "05/05/16 3:53 PM",
      "commitNameOld": "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 13.64,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,50 @@\n   List\u003cString\u003e doGetGroups(String user) throws NamingException {\n-    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n-\n-    DirContext ctx \u003d getDirContext();\n+    DirContext c \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n-    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n-        userSearchFilter,\n-        new Object[]{user},\n-        SEARCH_CONTROLS);\n-    if (results.hasMoreElements()) {\n-      SearchResult result \u003d results.nextElement();\n-      String userDn \u003d result.getNameInNamespace();\n-\n-      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n-\n-      if (isPosix) {\n-        String gidNumber \u003d null;\n-        String uidNumber \u003d null;\n-        Attribute gidAttribute \u003d result.getAttributes().get(posixGidAttr);\n-        Attribute uidAttribute \u003d result.getAttributes().get(posixUidAttr);\n-        if (gidAttribute !\u003d null) {\n-          gidNumber \u003d gidAttribute.get().toString();\n-        }\n-        if (uidAttribute !\u003d null) {\n-          uidNumber \u003d uidAttribute.get().toString();\n-        }\n-        if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n-          groupResults \u003d\n-              ctx.search(baseDN,\n-                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + posixGidAttr + \"\u003d{0})\" +\n-                      \"(\" + groupMemberAttr + \"\u003d{1})))\",\n-                  new Object[] { gidNumber, uidNumber },\n-                  SEARCH_CONTROLS);\n-        }\n-      } else {\n-        groupResults \u003d\n-            ctx.search(baseDN,\n-                \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n-                new Object[]{userDn},\n-                SEARCH_CONTROLS);\n+    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n+        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n+    // return empty list if the user can not be found.\n+    if (!results.hasMoreElements()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"doGetGroups(\" + user + \") return no groups because the \" +\n+            \"user is not found.\");\n       }\n-      if (groupResults !\u003d null) {\n-        while (groupResults.hasMoreElements()) {\n-          SearchResult groupResult \u003d groupResults.nextElement();\n-          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n-          groups.add(groupName.get().toString());\n+      return new ArrayList\u003cString\u003e();\n+    }\n+    SearchResult result \u003d results.nextElement();\n+\n+    List\u003cString\u003e groups \u003d null;\n+    if (useOneQuery) {\n+      try {\n+        /**\n+         * For Active Directory servers, the user object has an attribute\n+         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n+         * user belongs. So the second query may be skipped.\n+         */\n+        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n+        if (groupDNAttr \u003d\u003d null) {\n+          throw new NamingException(\"The user object does not have \u0027\" +\n+              memberOfAttr + \"\u0027 attribute.\" +\n+              \"Returned user object: \" + result.toString());\n         }\n+        groups \u003d new ArrayList\u003cString\u003e();\n+        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n+        while (groupEnumeration.hasMore()) {\n+          String groupDN \u003d groupEnumeration.next().toString();\n+          groups.add(getRelativeDistinguishedName(groupDN));\n+        }\n+      } catch (NamingException e) {\n+        // If the first lookup failed, fall back to the typical scenario.\n+        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n+                \"the second LDAP query using the user\u0027s DN.\", e);\n       }\n     }\n-\n+    if (groups \u003d\u003d null || groups.isEmpty()) {\n+      groups \u003d lookupGroup(result, c);\n+    }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n    DirContext c \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d c.search(baseDN,\n        userSearchFilter, new Object[]{user}, SEARCH_CONTROLS);\n    // return empty list if the user can not be found.\n    if (!results.hasMoreElements()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"doGetGroups(\" + user + \") return no groups because the \" +\n            \"user is not found.\");\n      }\n      return new ArrayList\u003cString\u003e();\n    }\n    SearchResult result \u003d results.nextElement();\n\n    List\u003cString\u003e groups \u003d null;\n    if (useOneQuery) {\n      try {\n        /**\n         * For Active Directory servers, the user object has an attribute\n         * \u0027memberOf\u0027 that represents the DNs of group objects to which the\n         * user belongs. So the second query may be skipped.\n         */\n        Attribute groupDNAttr \u003d result.getAttributes().get(memberOfAttr);\n        if (groupDNAttr \u003d\u003d null) {\n          throw new NamingException(\"The user object does not have \u0027\" +\n              memberOfAttr + \"\u0027 attribute.\" +\n              \"Returned user object: \" + result.toString());\n        }\n        groups \u003d new ArrayList\u003cString\u003e();\n        NamingEnumeration groupEnumeration \u003d groupDNAttr.getAll();\n        while (groupEnumeration.hasMore()) {\n          String groupDN \u003d groupEnumeration.next().toString();\n          groups.add(getRelativeDistinguishedName(groupDN));\n        }\n      } catch (NamingException e) {\n        // If the first lookup failed, fall back to the typical scenario.\n        LOG.info(\"Failed to get groups from the first lookup. Initiating \" +\n                \"the second LDAP query using the user\u0027s DN.\", e);\n      }\n    }\n    if (groups \u003d\u003d null || groups.isEmpty()) {\n      groups \u003d lookupGroup(result, c);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13103 Group resolution from LDAP may fail on javax.naming.ServiceUnavailableException\n",
      "commitDate": "05/05/16 3:53 PM",
      "commitName": "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "15/06/15 2:22 PM",
      "commitNameOld": "722aa1db1f2ac3db0e70063022436a90f90643f3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 325.06,
      "commitsBetweenForRepo": 2157,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,56 @@\n   List\u003cString\u003e doGetGroups(String user) throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n \n     DirContext ctx \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n         userSearchFilter,\n         new Object[]{user},\n         SEARCH_CONTROLS);\n     if (results.hasMoreElements()) {\n       SearchResult result \u003d results.nextElement();\n       String userDn \u003d result.getNameInNamespace();\n \n       NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n \n       if (isPosix) {\n         String gidNumber \u003d null;\n         String uidNumber \u003d null;\n         Attribute gidAttribute \u003d result.getAttributes().get(posixGidAttr);\n         Attribute uidAttribute \u003d result.getAttributes().get(posixUidAttr);\n         if (gidAttribute !\u003d null) {\n           gidNumber \u003d gidAttribute.get().toString();\n         }\n         if (uidAttribute !\u003d null) {\n           uidNumber \u003d uidAttribute.get().toString();\n         }\n         if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n           groupResults \u003d\n               ctx.search(baseDN,\n                   \"(\u0026\"+ groupSearchFilter + \"(|(\" + posixGidAttr + \"\u003d{0})\" +\n                       \"(\" + groupMemberAttr + \"\u003d{1})))\",\n                   new Object[] { gidNumber, uidNumber },\n                   SEARCH_CONTROLS);\n         }\n       } else {\n         groupResults \u003d\n             ctx.search(baseDN,\n                 \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                 new Object[]{userDn},\n                 SEARCH_CONTROLS);\n       }\n       if (groupResults !\u003d null) {\n         while (groupResults.hasMoreElements()) {\n           SearchResult groupResult \u003d groupResults.nextElement();\n           Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n           groups.add(groupName.get().toString());\n         }\n       }\n     }\n \n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n+    }\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    DirContext ctx \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n        userSearchFilter,\n        new Object[]{user},\n        SEARCH_CONTROLS);\n    if (results.hasMoreElements()) {\n      SearchResult result \u003d results.nextElement();\n      String userDn \u003d result.getNameInNamespace();\n\n      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n\n      if (isPosix) {\n        String gidNumber \u003d null;\n        String uidNumber \u003d null;\n        Attribute gidAttribute \u003d result.getAttributes().get(posixGidAttr);\n        Attribute uidAttribute \u003d result.getAttributes().get(posixUidAttr);\n        if (gidAttribute !\u003d null) {\n          gidNumber \u003d gidAttribute.get().toString();\n        }\n        if (uidAttribute !\u003d null) {\n          uidNumber \u003d uidAttribute.get().toString();\n        }\n        if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n          groupResults \u003d\n              ctx.search(baseDN,\n                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + posixGidAttr + \"\u003d{0})\" +\n                      \"(\" + groupMemberAttr + \"\u003d{1})))\",\n                  new Object[] { gidNumber, uidNumber },\n                  SEARCH_CONTROLS);\n        }\n      } else {\n        groupResults \u003d\n            ctx.search(baseDN,\n                \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                new Object[]{userDn},\n                SEARCH_CONTROLS);\n      }\n      if (groupResults !\u003d null) {\n        while (groupResults.hasMoreElements()) {\n          SearchResult groupResult \u003d groupResults.nextElement();\n          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n          groups.add(groupName.get().toString());\n        }\n      }\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"doGetGroups(\" + user + \") return \" + groups);\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "722aa1db1f2ac3db0e70063022436a90f90643f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12001. Fixed LdapGroupsMapping to include configurable Posix UID and GID attributes during the search. Contributed by Patrick White.\n",
      "commitDate": "15/06/15 2:22 PM",
      "commitName": "722aa1db1f2ac3db0e70063022436a90f90643f3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/03/15 2:52 PM",
      "commitNameOld": "82128774156c30a535b62d764bb6cf9c8d2f3a3b",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 94.98,
      "commitsBetweenForRepo": 859,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   List\u003cString\u003e doGetGroups(String user) throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n \n     DirContext ctx \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n         userSearchFilter,\n         new Object[]{user},\n         SEARCH_CONTROLS);\n     if (results.hasMoreElements()) {\n       SearchResult result \u003d results.nextElement();\n       String userDn \u003d result.getNameInNamespace();\n \n       NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n \n       if (isPosix) {\n         String gidNumber \u003d null;\n         String uidNumber \u003d null;\n-        Attribute gidAttribute \u003d result.getAttributes().get(POSIX_GIDNUMBER);\n-        Attribute uidAttribute \u003d result.getAttributes().get(POSIX_UIDNUMBER);\n+        Attribute gidAttribute \u003d result.getAttributes().get(posixGidAttr);\n+        Attribute uidAttribute \u003d result.getAttributes().get(posixUidAttr);\n         if (gidAttribute !\u003d null) {\n           gidNumber \u003d gidAttribute.get().toString();\n         }\n         if (uidAttribute !\u003d null) {\n           uidNumber \u003d uidAttribute.get().toString();\n         }\n         if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n           groupResults \u003d\n               ctx.search(baseDN,\n-                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + POSIX_GIDNUMBER + \"\u003d{0})\" +\n+                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + posixGidAttr + \"\u003d{0})\" +\n                       \"(\" + groupMemberAttr + \"\u003d{1})))\",\n                   new Object[] { gidNumber, uidNumber },\n                   SEARCH_CONTROLS);\n         }\n       } else {\n         groupResults \u003d\n             ctx.search(baseDN,\n                 \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                 new Object[]{userDn},\n                 SEARCH_CONTROLS);\n       }\n       if (groupResults !\u003d null) {\n         while (groupResults.hasMoreElements()) {\n           SearchResult groupResult \u003d groupResults.nextElement();\n           Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n           groups.add(groupName.get().toString());\n         }\n       }\n     }\n \n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    DirContext ctx \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n        userSearchFilter,\n        new Object[]{user},\n        SEARCH_CONTROLS);\n    if (results.hasMoreElements()) {\n      SearchResult result \u003d results.nextElement();\n      String userDn \u003d result.getNameInNamespace();\n\n      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n\n      if (isPosix) {\n        String gidNumber \u003d null;\n        String uidNumber \u003d null;\n        Attribute gidAttribute \u003d result.getAttributes().get(posixGidAttr);\n        Attribute uidAttribute \u003d result.getAttributes().get(posixUidAttr);\n        if (gidAttribute !\u003d null) {\n          gidNumber \u003d gidAttribute.get().toString();\n        }\n        if (uidAttribute !\u003d null) {\n          uidNumber \u003d uidAttribute.get().toString();\n        }\n        if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n          groupResults \u003d\n              ctx.search(baseDN,\n                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + posixGidAttr + \"\u003d{0})\" +\n                      \"(\" + groupMemberAttr + \"\u003d{1})))\",\n                  new Object[] { gidNumber, uidNumber },\n                  SEARCH_CONTROLS);\n        }\n      } else {\n        groupResults \u003d\n            ctx.search(baseDN,\n                \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                new Object[]{userDn},\n                SEARCH_CONTROLS);\n      }\n      if (groupResults !\u003d null) {\n        while (groupResults.hasMoreElements()) {\n          SearchResult groupResult \u003d groupResults.nextElement();\n          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n          groups.add(groupName.get().toString());\n        }\n      }\n    }\n\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "82128774156c30a535b62d764bb6cf9c8d2f3a3b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9477. Add posixGroups support for LDAP groups mapping service. (Dapeng Sun via Yongjun Zhang)\n",
      "commitDate": "12/03/15 2:52 PM",
      "commitName": "82128774156c30a535b62d764bb6cf9c8d2f3a3b",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "27/01/15 1:53 PM",
      "commitNameOld": "8bf6f0b70396e8f2d3b37e6da194b19f357e846a",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 44.0,
      "commitsBetweenForRepo": 417,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,53 @@\n   List\u003cString\u003e doGetGroups(String user) throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n \n     DirContext ctx \u003d getDirContext();\n \n     // Search for the user. We\u0027ll only ever need to look at the first result\n     NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n         userSearchFilter,\n         new Object[]{user},\n         SEARCH_CONTROLS);\n     if (results.hasMoreElements()) {\n       SearchResult result \u003d results.nextElement();\n       String userDn \u003d result.getNameInNamespace();\n \n-      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n-          ctx.search(baseDN,\n-              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n-              new Object[]{userDn},\n-              SEARCH_CONTROLS);\n-      while (groupResults.hasMoreElements()) {\n-        SearchResult groupResult \u003d groupResults.nextElement();\n-        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n-        groups.add(groupName.get().toString());\n+      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n+\n+      if (isPosix) {\n+        String gidNumber \u003d null;\n+        String uidNumber \u003d null;\n+        Attribute gidAttribute \u003d result.getAttributes().get(POSIX_GIDNUMBER);\n+        Attribute uidAttribute \u003d result.getAttributes().get(POSIX_UIDNUMBER);\n+        if (gidAttribute !\u003d null) {\n+          gidNumber \u003d gidAttribute.get().toString();\n+        }\n+        if (uidAttribute !\u003d null) {\n+          uidNumber \u003d uidAttribute.get().toString();\n+        }\n+        if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n+          groupResults \u003d\n+              ctx.search(baseDN,\n+                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + POSIX_GIDNUMBER + \"\u003d{0})\" +\n+                      \"(\" + groupMemberAttr + \"\u003d{1})))\",\n+                  new Object[] { gidNumber, uidNumber },\n+                  SEARCH_CONTROLS);\n+        }\n+      } else {\n+        groupResults \u003d\n+            ctx.search(baseDN,\n+                \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n+                new Object[]{userDn},\n+                SEARCH_CONTROLS);\n+      }\n+      if (groupResults !\u003d null) {\n+        while (groupResults.hasMoreElements()) {\n+          SearchResult groupResult \u003d groupResults.nextElement();\n+          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n+          groups.add(groupName.get().toString());\n+        }\n       }\n     }\n \n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    DirContext ctx \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n        userSearchFilter,\n        new Object[]{user},\n        SEARCH_CONTROLS);\n    if (results.hasMoreElements()) {\n      SearchResult result \u003d results.nextElement();\n      String userDn \u003d result.getNameInNamespace();\n\n      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n\n      if (isPosix) {\n        String gidNumber \u003d null;\n        String uidNumber \u003d null;\n        Attribute gidAttribute \u003d result.getAttributes().get(POSIX_GIDNUMBER);\n        Attribute uidAttribute \u003d result.getAttributes().get(POSIX_UIDNUMBER);\n        if (gidAttribute !\u003d null) {\n          gidNumber \u003d gidAttribute.get().toString();\n        }\n        if (uidAttribute !\u003d null) {\n          uidNumber \u003d uidAttribute.get().toString();\n        }\n        if (uidNumber !\u003d null \u0026\u0026 gidNumber !\u003d null) {\n          groupResults \u003d\n              ctx.search(baseDN,\n                  \"(\u0026\"+ groupSearchFilter + \"(|(\" + POSIX_GIDNUMBER + \"\u003d{0})\" +\n                      \"(\" + groupMemberAttr + \"\u003d{1})))\",\n                  new Object[] { gidNumber, uidNumber },\n                  SEARCH_CONTROLS);\n        }\n      } else {\n        groupResults \u003d\n            ctx.search(baseDN,\n                \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                new Object[]{userDn},\n                SEARCH_CONTROLS);\n      }\n      if (groupResults !\u003d null) {\n        while (groupResults.hasMoreElements()) {\n          SearchResult groupResult \u003d groupResults.nextElement();\n          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n          groups.add(groupName.get().toString());\n        }\n      }\n    }\n\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9125. LdapGroupsMapping threw CommunicationException after some idle time. Contributed by Kai Zheng.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461863 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 2:49 PM",
      "commitName": "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,28 @@\n+  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n+    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n+\n+    DirContext ctx \u003d getDirContext();\n+\n+    // Search for the user. We\u0027ll only ever need to look at the first result\n+    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n+        userSearchFilter,\n+        new Object[]{user},\n+        SEARCH_CONTROLS);\n+    if (results.hasMoreElements()) {\n+      SearchResult result \u003d results.nextElement();\n+      String userDn \u003d result.getNameInNamespace();\n+\n+      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n+          ctx.search(baseDN,\n+              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n+              new Object[]{userDn},\n+              SEARCH_CONTROLS);\n+      while (groupResults.hasMoreElements()) {\n+        SearchResult groupResult \u003d groupResults.nextElement();\n+        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n+        groups.add(groupName.get().toString());\n+      }\n+    }\n+\n+    return groups;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e doGetGroups(String user) throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    DirContext ctx \u003d getDirContext();\n\n    // Search for the user. We\u0027ll only ever need to look at the first result\n    NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n        userSearchFilter,\n        new Object[]{user},\n        SEARCH_CONTROLS);\n    if (results.hasMoreElements()) {\n      SearchResult result \u003d results.nextElement();\n      String userDn \u003d result.getNameInNamespace();\n\n      NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n          ctx.search(baseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n        groups.add(groupName.get().toString());\n      }\n    }\n\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java"
    }
  }
}