{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CBZip2InputStream.java",
  "functionName": "getAndMoveToFrontDecode",
  "functionId": "getAndMoveToFrontDecode",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
  "functionStartLine": 807,
  "functionEndLine": 990,
  "numCommitsSeen": 10,
  "timeTaken": 991,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "86724941c5144a06113090d40c50c289e7ebd290",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "86724941c5144a06113090d40c50c289e7ebd290": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void getAndMoveToFrontDecode() throws IOException {\n    this.origPtr \u003d (int) bsR(24);\n    recvDecodingTables();\n\n    final InputStream inShadow \u003d this.in;\n    final Data dataShadow \u003d this.data;\n    final byte[] ll8 \u003d dataShadow.ll8;\n    final int[] unzftab \u003d dataShadow.unzftab;\n    final byte[] selector \u003d dataShadow.selector;\n    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n    final int[] minLens \u003d dataShadow.minLens;\n    final int[][] limit \u003d dataShadow.limit;\n    final int[][] base \u003d dataShadow.base;\n    final int[][] perm \u003d dataShadow.perm;\n    final int limitLast \u003d this.blockSize100k * 100000;\n\n    /*\n    * Setting up the unzftab entries here is not strictly necessary, but it\n    * does save having to do it later in a separate pass, and so saves a\n    * block\u0027s worth of cache misses.\n    */\n    for (int i \u003d 256; --i \u003e\u003d 0;) {\n      yy[i] \u003d (char) i;\n      unzftab[i] \u003d 0;\n    }\n\n    int groupNo \u003d 0;\n    int groupPos \u003d G_SIZE - 1;\n    final int eob \u003d this.nInUse + 1;\n    int nextSym \u003d getAndMoveToFrontDecode0(0);\n    int bsBuffShadow \u003d (int) this.bsBuff;\n    int bsLiveShadow \u003d (int) this.bsLive;\n    int lastShadow \u003d -1;\n    int zt \u003d selector[groupNo] \u0026 0xff;\n    int[] base_zt \u003d base[zt];\n    int[] limit_zt \u003d limit[zt];\n    int[] perm_zt \u003d perm[zt];\n    int minLens_zt \u003d minLens[zt];\n\n    while (nextSym !\u003d eob) {\n      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n        int s \u003d -1;\n\n        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n          if (nextSym \u003d\u003d RUNA) {\n            s +\u003d n;\n          } else if (nextSym \u003d\u003d RUNB) {\n            s +\u003d n \u003c\u003c 1;\n          } else {\n            break;\n          }\n\n          if (groupPos \u003d\u003d 0) {\n            groupPos \u003d G_SIZE - 1;\n            zt \u003d selector[++groupNo] \u0026 0xff;\n            base_zt \u003d base[zt];\n            limit_zt \u003d limit[zt];\n            perm_zt \u003d perm[zt];\n            minLens_zt \u003d minLens[zt];\n          } else {\n            groupPos--;\n          }\n\n          int zn \u003d minLens_zt;\n\n          while (bsLiveShadow \u003c zn) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          long zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n              \u0026 ((1 \u003c\u003c zn) - 1);\n          bsLiveShadow -\u003d zn;\n\n          while (zvec \u003e limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow \u003c 1) {\n              final int thech \u003d readAByte(inShadow);\n              if (thech \u003e\u003d 0) {\n                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                bsLiveShadow +\u003d 8;\n                continue;\n              } else {\n                throw new IOException(\n                    \"unexpected end of stream\");\n              }\n            }\n            bsLiveShadow--;\n            zvec \u003d (zvec \u003c\u003c 1)\n                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n          }\n          nextSym \u003d perm_zt[(int) (zvec - base_zt[zn])];\n        }\n\n        final byte ch \u003d seqToUnseq[yy[0]];\n        unzftab[ch \u0026 0xff] +\u003d s + 1;\n\n        while (s-- \u003e\u003d 0) {\n          ll8[++lastShadow] \u003d ch;\n        }\n\n        if (lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n      } else {\n        if (++lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n\n        final char tmp \u003d yy[nextSym - 1];\n        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n        ll8[lastShadow] \u003d seqToUnseq[tmp];\n\n        /*\n        * This loop is hammered during decompression, hence avoid\n        * native method call overhead of System.arraycopy for very\n        * small ranges to copy.\n        */\n        if (nextSym \u003c\u003d 16) {\n          for (int j \u003d nextSym - 1; j \u003e 0;) {\n            yy[j] \u003d yy[--j];\n          }\n        } else {\n          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n        }\n\n        yy[0] \u003d tmp;\n\n        if (groupPos \u003d\u003d 0) {\n          groupPos \u003d G_SIZE - 1;\n          zt \u003d selector[++groupNo] \u0026 0xff;\n          base_zt \u003d base[zt];\n          limit_zt \u003d limit[zt];\n          perm_zt \u003d perm[zt];\n          minLens_zt \u003d minLens[zt];\n        } else {\n          groupPos--;\n        }\n\n        int zn \u003d minLens_zt;\n\n        while (bsLiveShadow \u003c zn) {\n          final int thech \u003d readAByte(inShadow);\n          if (thech \u003e\u003d 0) {\n            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n            bsLiveShadow +\u003d 8;\n            continue;\n          } else {\n            throw new IOException(\"unexpected end of stream\");\n          }\n        }\n        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n            \u0026 ((1 \u003c\u003c zn) - 1);\n        bsLiveShadow -\u003d zn;\n\n        while (zvec \u003e limit_zt[zn]) {\n          zn++;\n          while (bsLiveShadow \u003c 1) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          bsLiveShadow--;\n          zvec \u003d ((zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1));\n        }\n        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n      }\n    }\n\n    this.last \u003d lastShadow;\n    this.bsLive \u003d bsLiveShadow;\n    this.bsBuff \u003d bsBuffShadow;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void getAndMoveToFrontDecode() throws IOException {\n    this.origPtr \u003d (int) bsR(24);\n    recvDecodingTables();\n\n    final InputStream inShadow \u003d this.in;\n    final Data dataShadow \u003d this.data;\n    final byte[] ll8 \u003d dataShadow.ll8;\n    final int[] unzftab \u003d dataShadow.unzftab;\n    final byte[] selector \u003d dataShadow.selector;\n    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n    final int[] minLens \u003d dataShadow.minLens;\n    final int[][] limit \u003d dataShadow.limit;\n    final int[][] base \u003d dataShadow.base;\n    final int[][] perm \u003d dataShadow.perm;\n    final int limitLast \u003d this.blockSize100k * 100000;\n\n    /*\n    * Setting up the unzftab entries here is not strictly necessary, but it\n    * does save having to do it later in a separate pass, and so saves a\n    * block\u0027s worth of cache misses.\n    */\n    for (int i \u003d 256; --i \u003e\u003d 0;) {\n      yy[i] \u003d (char) i;\n      unzftab[i] \u003d 0;\n    }\n\n    int groupNo \u003d 0;\n    int groupPos \u003d G_SIZE - 1;\n    final int eob \u003d this.nInUse + 1;\n    int nextSym \u003d getAndMoveToFrontDecode0(0);\n    int bsBuffShadow \u003d (int) this.bsBuff;\n    int bsLiveShadow \u003d (int) this.bsLive;\n    int lastShadow \u003d -1;\n    int zt \u003d selector[groupNo] \u0026 0xff;\n    int[] base_zt \u003d base[zt];\n    int[] limit_zt \u003d limit[zt];\n    int[] perm_zt \u003d perm[zt];\n    int minLens_zt \u003d minLens[zt];\n\n    while (nextSym !\u003d eob) {\n      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n        int s \u003d -1;\n\n        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n          if (nextSym \u003d\u003d RUNA) {\n            s +\u003d n;\n          } else if (nextSym \u003d\u003d RUNB) {\n            s +\u003d n \u003c\u003c 1;\n          } else {\n            break;\n          }\n\n          if (groupPos \u003d\u003d 0) {\n            groupPos \u003d G_SIZE - 1;\n            zt \u003d selector[++groupNo] \u0026 0xff;\n            base_zt \u003d base[zt];\n            limit_zt \u003d limit[zt];\n            perm_zt \u003d perm[zt];\n            minLens_zt \u003d minLens[zt];\n          } else {\n            groupPos--;\n          }\n\n          int zn \u003d minLens_zt;\n\n          while (bsLiveShadow \u003c zn) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          long zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n              \u0026 ((1 \u003c\u003c zn) - 1);\n          bsLiveShadow -\u003d zn;\n\n          while (zvec \u003e limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow \u003c 1) {\n              final int thech \u003d readAByte(inShadow);\n              if (thech \u003e\u003d 0) {\n                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                bsLiveShadow +\u003d 8;\n                continue;\n              } else {\n                throw new IOException(\n                    \"unexpected end of stream\");\n              }\n            }\n            bsLiveShadow--;\n            zvec \u003d (zvec \u003c\u003c 1)\n                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n          }\n          nextSym \u003d perm_zt[(int) (zvec - base_zt[zn])];\n        }\n\n        final byte ch \u003d seqToUnseq[yy[0]];\n        unzftab[ch \u0026 0xff] +\u003d s + 1;\n\n        while (s-- \u003e\u003d 0) {\n          ll8[++lastShadow] \u003d ch;\n        }\n\n        if (lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n      } else {\n        if (++lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n\n        final char tmp \u003d yy[nextSym - 1];\n        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n        ll8[lastShadow] \u003d seqToUnseq[tmp];\n\n        /*\n        * This loop is hammered during decompression, hence avoid\n        * native method call overhead of System.arraycopy for very\n        * small ranges to copy.\n        */\n        if (nextSym \u003c\u003d 16) {\n          for (int j \u003d nextSym - 1; j \u003e 0;) {\n            yy[j] \u003d yy[--j];\n          }\n        } else {\n          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n        }\n\n        yy[0] \u003d tmp;\n\n        if (groupPos \u003d\u003d 0) {\n          groupPos \u003d G_SIZE - 1;\n          zt \u003d selector[++groupNo] \u0026 0xff;\n          base_zt \u003d base[zt];\n          limit_zt \u003d limit[zt];\n          perm_zt \u003d perm[zt];\n          minLens_zt \u003d minLens[zt];\n        } else {\n          groupPos--;\n        }\n\n        int zn \u003d minLens_zt;\n\n        while (bsLiveShadow \u003c zn) {\n          final int thech \u003d readAByte(inShadow);\n          if (thech \u003e\u003d 0) {\n            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n            bsLiveShadow +\u003d 8;\n            continue;\n          } else {\n            throw new IOException(\"unexpected end of stream\");\n          }\n        }\n        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n            \u0026 ((1 \u003c\u003c zn) - 1);\n        bsLiveShadow -\u003d zn;\n\n        while (zvec \u003e limit_zt[zn]) {\n          zn++;\n          while (bsLiveShadow \u003c 1) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          bsLiveShadow--;\n          zvec \u003d ((zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1));\n        }\n        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n      }\n    }\n\n    this.last \u003d lastShadow;\n    this.bsLive \u003d bsLiveShadow;\n    this.bsBuff \u003d bsBuffShadow;\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void getAndMoveToFrontDecode() throws IOException {\n    this.origPtr \u003d (int) bsR(24);\n    recvDecodingTables();\n\n    final InputStream inShadow \u003d this.in;\n    final Data dataShadow \u003d this.data;\n    final byte[] ll8 \u003d dataShadow.ll8;\n    final int[] unzftab \u003d dataShadow.unzftab;\n    final byte[] selector \u003d dataShadow.selector;\n    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n    final int[] minLens \u003d dataShadow.minLens;\n    final int[][] limit \u003d dataShadow.limit;\n    final int[][] base \u003d dataShadow.base;\n    final int[][] perm \u003d dataShadow.perm;\n    final int limitLast \u003d this.blockSize100k * 100000;\n\n    /*\n    * Setting up the unzftab entries here is not strictly necessary, but it\n    * does save having to do it later in a separate pass, and so saves a\n    * block\u0027s worth of cache misses.\n    */\n    for (int i \u003d 256; --i \u003e\u003d 0;) {\n      yy[i] \u003d (char) i;\n      unzftab[i] \u003d 0;\n    }\n\n    int groupNo \u003d 0;\n    int groupPos \u003d G_SIZE - 1;\n    final int eob \u003d this.nInUse + 1;\n    int nextSym \u003d getAndMoveToFrontDecode0(0);\n    int bsBuffShadow \u003d (int) this.bsBuff;\n    int bsLiveShadow \u003d (int) this.bsLive;\n    int lastShadow \u003d -1;\n    int zt \u003d selector[groupNo] \u0026 0xff;\n    int[] base_zt \u003d base[zt];\n    int[] limit_zt \u003d limit[zt];\n    int[] perm_zt \u003d perm[zt];\n    int minLens_zt \u003d minLens[zt];\n\n    while (nextSym !\u003d eob) {\n      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n        int s \u003d -1;\n\n        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n          if (nextSym \u003d\u003d RUNA) {\n            s +\u003d n;\n          } else if (nextSym \u003d\u003d RUNB) {\n            s +\u003d n \u003c\u003c 1;\n          } else {\n            break;\n          }\n\n          if (groupPos \u003d\u003d 0) {\n            groupPos \u003d G_SIZE - 1;\n            zt \u003d selector[++groupNo] \u0026 0xff;\n            base_zt \u003d base[zt];\n            limit_zt \u003d limit[zt];\n            perm_zt \u003d perm[zt];\n            minLens_zt \u003d minLens[zt];\n          } else {\n            groupPos--;\n          }\n\n          int zn \u003d minLens_zt;\n\n          while (bsLiveShadow \u003c zn) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          long zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n              \u0026 ((1 \u003c\u003c zn) - 1);\n          bsLiveShadow -\u003d zn;\n\n          while (zvec \u003e limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow \u003c 1) {\n              final int thech \u003d readAByte(inShadow);\n              if (thech \u003e\u003d 0) {\n                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                bsLiveShadow +\u003d 8;\n                continue;\n              } else {\n                throw new IOException(\n                    \"unexpected end of stream\");\n              }\n            }\n            bsLiveShadow--;\n            zvec \u003d (zvec \u003c\u003c 1)\n                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n          }\n          nextSym \u003d perm_zt[(int) (zvec - base_zt[zn])];\n        }\n\n        final byte ch \u003d seqToUnseq[yy[0]];\n        unzftab[ch \u0026 0xff] +\u003d s + 1;\n\n        while (s-- \u003e\u003d 0) {\n          ll8[++lastShadow] \u003d ch;\n        }\n\n        if (lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n      } else {\n        if (++lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n\n        final char tmp \u003d yy[nextSym - 1];\n        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n        ll8[lastShadow] \u003d seqToUnseq[tmp];\n\n        /*\n        * This loop is hammered during decompression, hence avoid\n        * native method call overhead of System.arraycopy for very\n        * small ranges to copy.\n        */\n        if (nextSym \u003c\u003d 16) {\n          for (int j \u003d nextSym - 1; j \u003e 0;) {\n            yy[j] \u003d yy[--j];\n          }\n        } else {\n          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n        }\n\n        yy[0] \u003d tmp;\n\n        if (groupPos \u003d\u003d 0) {\n          groupPos \u003d G_SIZE - 1;\n          zt \u003d selector[++groupNo] \u0026 0xff;\n          base_zt \u003d base[zt];\n          limit_zt \u003d limit[zt];\n          perm_zt \u003d perm[zt];\n          minLens_zt \u003d minLens[zt];\n        } else {\n          groupPos--;\n        }\n\n        int zn \u003d minLens_zt;\n\n        while (bsLiveShadow \u003c zn) {\n          final int thech \u003d readAByte(inShadow);\n          if (thech \u003e\u003d 0) {\n            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n            bsLiveShadow +\u003d 8;\n            continue;\n          } else {\n            throw new IOException(\"unexpected end of stream\");\n          }\n        }\n        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n            \u0026 ((1 \u003c\u003c zn) - 1);\n        bsLiveShadow -\u003d zn;\n\n        while (zvec \u003e limit_zt[zn]) {\n          zn++;\n          while (bsLiveShadow \u003c 1) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          bsLiveShadow--;\n          zvec \u003d ((zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1));\n        }\n        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n      }\n    }\n\n    this.last \u003d lastShadow;\n    this.bsLive \u003d bsLiveShadow;\n    this.bsBuff \u003d bsBuffShadow;\n  }",
      "path": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
        "newPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java"
      }
    },
    "86724941c5144a06113090d40c50c289e7ebd290": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-4012. Provide splitting support for bzip2 compressed files. Contributed by Abdul Qadeer\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@813581 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/09 1:51 PM",
      "commitName": "86724941c5144a06113090d40c50c289e7ebd290",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "18/05/09 9:20 PM",
      "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 114.69,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,184 @@\n   private void getAndMoveToFrontDecode() throws IOException {\n-    this.origPtr \u003d bsR(24);\n+    this.origPtr \u003d (int) bsR(24);\n     recvDecodingTables();\n \n     final InputStream inShadow \u003d this.in;\n     final Data dataShadow \u003d this.data;\n     final byte[] ll8 \u003d dataShadow.ll8;\n     final int[] unzftab \u003d dataShadow.unzftab;\n     final byte[] selector \u003d dataShadow.selector;\n     final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n     final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n     final int[] minLens \u003d dataShadow.minLens;\n     final int[][] limit \u003d dataShadow.limit;\n     final int[][] base \u003d dataShadow.base;\n     final int[][] perm \u003d dataShadow.perm;\n     final int limitLast \u003d this.blockSize100k * 100000;\n \n     /*\n     * Setting up the unzftab entries here is not strictly necessary, but it\n     * does save having to do it later in a separate pass, and so saves a\n     * block\u0027s worth of cache misses.\n     */\n     for (int i \u003d 256; --i \u003e\u003d 0;) {\n       yy[i] \u003d (char) i;\n       unzftab[i] \u003d 0;\n     }\n \n     int groupNo \u003d 0;\n     int groupPos \u003d G_SIZE - 1;\n     final int eob \u003d this.nInUse + 1;\n     int nextSym \u003d getAndMoveToFrontDecode0(0);\n-    int bsBuffShadow \u003d this.bsBuff;\n-    int bsLiveShadow \u003d this.bsLive;\n+    int bsBuffShadow \u003d (int) this.bsBuff;\n+    int bsLiveShadow \u003d (int) this.bsLive;\n     int lastShadow \u003d -1;\n     int zt \u003d selector[groupNo] \u0026 0xff;\n     int[] base_zt \u003d base[zt];\n     int[] limit_zt \u003d limit[zt];\n     int[] perm_zt \u003d perm[zt];\n     int minLens_zt \u003d minLens[zt];\n \n     while (nextSym !\u003d eob) {\n       if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n         int s \u003d -1;\n \n         for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n           if (nextSym \u003d\u003d RUNA) {\n             s +\u003d n;\n           } else if (nextSym \u003d\u003d RUNB) {\n             s +\u003d n \u003c\u003c 1;\n           } else {\n             break;\n           }\n \n           if (groupPos \u003d\u003d 0) {\n             groupPos \u003d G_SIZE - 1;\n             zt \u003d selector[++groupNo] \u0026 0xff;\n             base_zt \u003d base[zt];\n             limit_zt \u003d limit[zt];\n             perm_zt \u003d perm[zt];\n             minLens_zt \u003d minLens[zt];\n           } else {\n             groupPos--;\n           }\n \n           int zn \u003d minLens_zt;\n \n-          // Inlined:\n-          // int zvec \u003d bsR(zn);\n           while (bsLiveShadow \u003c zn) {\n-            final int thech \u003d inShadow.read();\n+            final int thech \u003d readAByte(inShadow);\n             if (thech \u003e\u003d 0) {\n               bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n               bsLiveShadow +\u003d 8;\n               continue;\n             } else {\n               throw new IOException(\"unexpected end of stream\");\n             }\n           }\n-          int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n+          long zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n               \u0026 ((1 \u003c\u003c zn) - 1);\n           bsLiveShadow -\u003d zn;\n \n           while (zvec \u003e limit_zt[zn]) {\n             zn++;\n             while (bsLiveShadow \u003c 1) {\n-              final int thech \u003d inShadow.read();\n+              final int thech \u003d readAByte(inShadow);\n               if (thech \u003e\u003d 0) {\n                 bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                 bsLiveShadow +\u003d 8;\n                 continue;\n               } else {\n                 throw new IOException(\n                     \"unexpected end of stream\");\n               }\n             }\n             bsLiveShadow--;\n             zvec \u003d (zvec \u003c\u003c 1)\n                 | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n           }\n-          nextSym \u003d perm_zt[zvec - base_zt[zn]];\n+          nextSym \u003d perm_zt[(int) (zvec - base_zt[zn])];\n         }\n \n         final byte ch \u003d seqToUnseq[yy[0]];\n         unzftab[ch \u0026 0xff] +\u003d s + 1;\n \n         while (s-- \u003e\u003d 0) {\n           ll8[++lastShadow] \u003d ch;\n         }\n \n         if (lastShadow \u003e\u003d limitLast) {\n           throw new IOException(\"block overrun\");\n         }\n       } else {\n         if (++lastShadow \u003e\u003d limitLast) {\n           throw new IOException(\"block overrun\");\n         }\n \n         final char tmp \u003d yy[nextSym - 1];\n         unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n         ll8[lastShadow] \u003d seqToUnseq[tmp];\n \n         /*\n         * This loop is hammered during decompression, hence avoid\n         * native method call overhead of System.arraycopy for very\n         * small ranges to copy.\n         */\n         if (nextSym \u003c\u003d 16) {\n           for (int j \u003d nextSym - 1; j \u003e 0;) {\n             yy[j] \u003d yy[--j];\n           }\n         } else {\n           System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n         }\n \n         yy[0] \u003d tmp;\n \n         if (groupPos \u003d\u003d 0) {\n           groupPos \u003d G_SIZE - 1;\n           zt \u003d selector[++groupNo] \u0026 0xff;\n           base_zt \u003d base[zt];\n           limit_zt \u003d limit[zt];\n           perm_zt \u003d perm[zt];\n           minLens_zt \u003d minLens[zt];\n         } else {\n           groupPos--;\n         }\n \n         int zn \u003d minLens_zt;\n \n-        // Inlined:\n-        // int zvec \u003d bsR(zn);\n         while (bsLiveShadow \u003c zn) {\n-          final int thech \u003d inShadow.read();\n+          final int thech \u003d readAByte(inShadow);\n           if (thech \u003e\u003d 0) {\n             bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n             bsLiveShadow +\u003d 8;\n             continue;\n           } else {\n             throw new IOException(\"unexpected end of stream\");\n           }\n         }\n         int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n             \u0026 ((1 \u003c\u003c zn) - 1);\n         bsLiveShadow -\u003d zn;\n \n         while (zvec \u003e limit_zt[zn]) {\n           zn++;\n           while (bsLiveShadow \u003c 1) {\n-            final int thech \u003d inShadow.read();\n+            final int thech \u003d readAByte(inShadow);\n             if (thech \u003e\u003d 0) {\n               bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n               bsLiveShadow +\u003d 8;\n               continue;\n             } else {\n               throw new IOException(\"unexpected end of stream\");\n             }\n           }\n           bsLiveShadow--;\n-          zvec \u003d (zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n+          zvec \u003d ((zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1));\n         }\n         nextSym \u003d perm_zt[zvec - base_zt[zn]];\n       }\n     }\n \n     this.last \u003d lastShadow;\n     this.bsLive \u003d bsLiveShadow;\n     this.bsBuff \u003d bsBuffShadow;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void getAndMoveToFrontDecode() throws IOException {\n    this.origPtr \u003d (int) bsR(24);\n    recvDecodingTables();\n\n    final InputStream inShadow \u003d this.in;\n    final Data dataShadow \u003d this.data;\n    final byte[] ll8 \u003d dataShadow.ll8;\n    final int[] unzftab \u003d dataShadow.unzftab;\n    final byte[] selector \u003d dataShadow.selector;\n    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n    final int[] minLens \u003d dataShadow.minLens;\n    final int[][] limit \u003d dataShadow.limit;\n    final int[][] base \u003d dataShadow.base;\n    final int[][] perm \u003d dataShadow.perm;\n    final int limitLast \u003d this.blockSize100k * 100000;\n\n    /*\n    * Setting up the unzftab entries here is not strictly necessary, but it\n    * does save having to do it later in a separate pass, and so saves a\n    * block\u0027s worth of cache misses.\n    */\n    for (int i \u003d 256; --i \u003e\u003d 0;) {\n      yy[i] \u003d (char) i;\n      unzftab[i] \u003d 0;\n    }\n\n    int groupNo \u003d 0;\n    int groupPos \u003d G_SIZE - 1;\n    final int eob \u003d this.nInUse + 1;\n    int nextSym \u003d getAndMoveToFrontDecode0(0);\n    int bsBuffShadow \u003d (int) this.bsBuff;\n    int bsLiveShadow \u003d (int) this.bsLive;\n    int lastShadow \u003d -1;\n    int zt \u003d selector[groupNo] \u0026 0xff;\n    int[] base_zt \u003d base[zt];\n    int[] limit_zt \u003d limit[zt];\n    int[] perm_zt \u003d perm[zt];\n    int minLens_zt \u003d minLens[zt];\n\n    while (nextSym !\u003d eob) {\n      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n        int s \u003d -1;\n\n        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n          if (nextSym \u003d\u003d RUNA) {\n            s +\u003d n;\n          } else if (nextSym \u003d\u003d RUNB) {\n            s +\u003d n \u003c\u003c 1;\n          } else {\n            break;\n          }\n\n          if (groupPos \u003d\u003d 0) {\n            groupPos \u003d G_SIZE - 1;\n            zt \u003d selector[++groupNo] \u0026 0xff;\n            base_zt \u003d base[zt];\n            limit_zt \u003d limit[zt];\n            perm_zt \u003d perm[zt];\n            minLens_zt \u003d minLens[zt];\n          } else {\n            groupPos--;\n          }\n\n          int zn \u003d minLens_zt;\n\n          while (bsLiveShadow \u003c zn) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          long zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n              \u0026 ((1 \u003c\u003c zn) - 1);\n          bsLiveShadow -\u003d zn;\n\n          while (zvec \u003e limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow \u003c 1) {\n              final int thech \u003d readAByte(inShadow);\n              if (thech \u003e\u003d 0) {\n                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                bsLiveShadow +\u003d 8;\n                continue;\n              } else {\n                throw new IOException(\n                    \"unexpected end of stream\");\n              }\n            }\n            bsLiveShadow--;\n            zvec \u003d (zvec \u003c\u003c 1)\n                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n          }\n          nextSym \u003d perm_zt[(int) (zvec - base_zt[zn])];\n        }\n\n        final byte ch \u003d seqToUnseq[yy[0]];\n        unzftab[ch \u0026 0xff] +\u003d s + 1;\n\n        while (s-- \u003e\u003d 0) {\n          ll8[++lastShadow] \u003d ch;\n        }\n\n        if (lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n      } else {\n        if (++lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n\n        final char tmp \u003d yy[nextSym - 1];\n        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n        ll8[lastShadow] \u003d seqToUnseq[tmp];\n\n        /*\n        * This loop is hammered during decompression, hence avoid\n        * native method call overhead of System.arraycopy for very\n        * small ranges to copy.\n        */\n        if (nextSym \u003c\u003d 16) {\n          for (int j \u003d nextSym - 1; j \u003e 0;) {\n            yy[j] \u003d yy[--j];\n          }\n        } else {\n          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n        }\n\n        yy[0] \u003d tmp;\n\n        if (groupPos \u003d\u003d 0) {\n          groupPos \u003d G_SIZE - 1;\n          zt \u003d selector[++groupNo] \u0026 0xff;\n          base_zt \u003d base[zt];\n          limit_zt \u003d limit[zt];\n          perm_zt \u003d perm[zt];\n          minLens_zt \u003d minLens[zt];\n        } else {\n          groupPos--;\n        }\n\n        int zn \u003d minLens_zt;\n\n        while (bsLiveShadow \u003c zn) {\n          final int thech \u003d readAByte(inShadow);\n          if (thech \u003e\u003d 0) {\n            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n            bsLiveShadow +\u003d 8;\n            continue;\n          } else {\n            throw new IOException(\"unexpected end of stream\");\n          }\n        }\n        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n            \u0026 ((1 \u003c\u003c zn) - 1);\n        bsLiveShadow -\u003d zn;\n\n        while (zvec \u003e limit_zt[zn]) {\n          zn++;\n          while (bsLiveShadow \u003c 1) {\n            final int thech \u003d readAByte(inShadow);\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          bsLiveShadow--;\n          zvec \u003d ((zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1));\n        }\n        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n      }\n    }\n\n    this.last \u003d lastShadow;\n    this.bsLive \u003d bsLiveShadow;\n    this.bsBuff \u003d bsBuffShadow;\n  }",
      "path": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,188 @@\n+  private void getAndMoveToFrontDecode() throws IOException {\n+    this.origPtr \u003d bsR(24);\n+    recvDecodingTables();\n+\n+    final InputStream inShadow \u003d this.in;\n+    final Data dataShadow \u003d this.data;\n+    final byte[] ll8 \u003d dataShadow.ll8;\n+    final int[] unzftab \u003d dataShadow.unzftab;\n+    final byte[] selector \u003d dataShadow.selector;\n+    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n+    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n+    final int[] minLens \u003d dataShadow.minLens;\n+    final int[][] limit \u003d dataShadow.limit;\n+    final int[][] base \u003d dataShadow.base;\n+    final int[][] perm \u003d dataShadow.perm;\n+    final int limitLast \u003d this.blockSize100k * 100000;\n+\n+    /*\n+    * Setting up the unzftab entries here is not strictly necessary, but it\n+    * does save having to do it later in a separate pass, and so saves a\n+    * block\u0027s worth of cache misses.\n+    */\n+    for (int i \u003d 256; --i \u003e\u003d 0;) {\n+      yy[i] \u003d (char) i;\n+      unzftab[i] \u003d 0;\n+    }\n+\n+    int groupNo \u003d 0;\n+    int groupPos \u003d G_SIZE - 1;\n+    final int eob \u003d this.nInUse + 1;\n+    int nextSym \u003d getAndMoveToFrontDecode0(0);\n+    int bsBuffShadow \u003d this.bsBuff;\n+    int bsLiveShadow \u003d this.bsLive;\n+    int lastShadow \u003d -1;\n+    int zt \u003d selector[groupNo] \u0026 0xff;\n+    int[] base_zt \u003d base[zt];\n+    int[] limit_zt \u003d limit[zt];\n+    int[] perm_zt \u003d perm[zt];\n+    int minLens_zt \u003d minLens[zt];\n+\n+    while (nextSym !\u003d eob) {\n+      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n+        int s \u003d -1;\n+\n+        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n+          if (nextSym \u003d\u003d RUNA) {\n+            s +\u003d n;\n+          } else if (nextSym \u003d\u003d RUNB) {\n+            s +\u003d n \u003c\u003c 1;\n+          } else {\n+            break;\n+          }\n+\n+          if (groupPos \u003d\u003d 0) {\n+            groupPos \u003d G_SIZE - 1;\n+            zt \u003d selector[++groupNo] \u0026 0xff;\n+            base_zt \u003d base[zt];\n+            limit_zt \u003d limit[zt];\n+            perm_zt \u003d perm[zt];\n+            minLens_zt \u003d minLens[zt];\n+          } else {\n+            groupPos--;\n+          }\n+\n+          int zn \u003d minLens_zt;\n+\n+          // Inlined:\n+          // int zvec \u003d bsR(zn);\n+          while (bsLiveShadow \u003c zn) {\n+            final int thech \u003d inShadow.read();\n+            if (thech \u003e\u003d 0) {\n+              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n+              bsLiveShadow +\u003d 8;\n+              continue;\n+            } else {\n+              throw new IOException(\"unexpected end of stream\");\n+            }\n+          }\n+          int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n+              \u0026 ((1 \u003c\u003c zn) - 1);\n+          bsLiveShadow -\u003d zn;\n+\n+          while (zvec \u003e limit_zt[zn]) {\n+            zn++;\n+            while (bsLiveShadow \u003c 1) {\n+              final int thech \u003d inShadow.read();\n+              if (thech \u003e\u003d 0) {\n+                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n+                bsLiveShadow +\u003d 8;\n+                continue;\n+              } else {\n+                throw new IOException(\n+                    \"unexpected end of stream\");\n+              }\n+            }\n+            bsLiveShadow--;\n+            zvec \u003d (zvec \u003c\u003c 1)\n+                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n+          }\n+          nextSym \u003d perm_zt[zvec - base_zt[zn]];\n+        }\n+\n+        final byte ch \u003d seqToUnseq[yy[0]];\n+        unzftab[ch \u0026 0xff] +\u003d s + 1;\n+\n+        while (s-- \u003e\u003d 0) {\n+          ll8[++lastShadow] \u003d ch;\n+        }\n+\n+        if (lastShadow \u003e\u003d limitLast) {\n+          throw new IOException(\"block overrun\");\n+        }\n+      } else {\n+        if (++lastShadow \u003e\u003d limitLast) {\n+          throw new IOException(\"block overrun\");\n+        }\n+\n+        final char tmp \u003d yy[nextSym - 1];\n+        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n+        ll8[lastShadow] \u003d seqToUnseq[tmp];\n+\n+        /*\n+        * This loop is hammered during decompression, hence avoid\n+        * native method call overhead of System.arraycopy for very\n+        * small ranges to copy.\n+        */\n+        if (nextSym \u003c\u003d 16) {\n+          for (int j \u003d nextSym - 1; j \u003e 0;) {\n+            yy[j] \u003d yy[--j];\n+          }\n+        } else {\n+          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n+        }\n+\n+        yy[0] \u003d tmp;\n+\n+        if (groupPos \u003d\u003d 0) {\n+          groupPos \u003d G_SIZE - 1;\n+          zt \u003d selector[++groupNo] \u0026 0xff;\n+          base_zt \u003d base[zt];\n+          limit_zt \u003d limit[zt];\n+          perm_zt \u003d perm[zt];\n+          minLens_zt \u003d minLens[zt];\n+        } else {\n+          groupPos--;\n+        }\n+\n+        int zn \u003d minLens_zt;\n+\n+        // Inlined:\n+        // int zvec \u003d bsR(zn);\n+        while (bsLiveShadow \u003c zn) {\n+          final int thech \u003d inShadow.read();\n+          if (thech \u003e\u003d 0) {\n+            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n+            bsLiveShadow +\u003d 8;\n+            continue;\n+          } else {\n+            throw new IOException(\"unexpected end of stream\");\n+          }\n+        }\n+        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n+            \u0026 ((1 \u003c\u003c zn) - 1);\n+        bsLiveShadow -\u003d zn;\n+\n+        while (zvec \u003e limit_zt[zn]) {\n+          zn++;\n+          while (bsLiveShadow \u003c 1) {\n+            final int thech \u003d inShadow.read();\n+            if (thech \u003e\u003d 0) {\n+              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n+              bsLiveShadow +\u003d 8;\n+              continue;\n+            } else {\n+              throw new IOException(\"unexpected end of stream\");\n+            }\n+          }\n+          bsLiveShadow--;\n+          zvec \u003d (zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n+        }\n+        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n+      }\n+    }\n+\n+    this.last \u003d lastShadow;\n+    this.bsLive \u003d bsLiveShadow;\n+    this.bsBuff \u003d bsBuffShadow;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void getAndMoveToFrontDecode() throws IOException {\n    this.origPtr \u003d bsR(24);\n    recvDecodingTables();\n\n    final InputStream inShadow \u003d this.in;\n    final Data dataShadow \u003d this.data;\n    final byte[] ll8 \u003d dataShadow.ll8;\n    final int[] unzftab \u003d dataShadow.unzftab;\n    final byte[] selector \u003d dataShadow.selector;\n    final byte[] seqToUnseq \u003d dataShadow.seqToUnseq;\n    final char[] yy \u003d dataShadow.getAndMoveToFrontDecode_yy;\n    final int[] minLens \u003d dataShadow.minLens;\n    final int[][] limit \u003d dataShadow.limit;\n    final int[][] base \u003d dataShadow.base;\n    final int[][] perm \u003d dataShadow.perm;\n    final int limitLast \u003d this.blockSize100k * 100000;\n\n    /*\n    * Setting up the unzftab entries here is not strictly necessary, but it\n    * does save having to do it later in a separate pass, and so saves a\n    * block\u0027s worth of cache misses.\n    */\n    for (int i \u003d 256; --i \u003e\u003d 0;) {\n      yy[i] \u003d (char) i;\n      unzftab[i] \u003d 0;\n    }\n\n    int groupNo \u003d 0;\n    int groupPos \u003d G_SIZE - 1;\n    final int eob \u003d this.nInUse + 1;\n    int nextSym \u003d getAndMoveToFrontDecode0(0);\n    int bsBuffShadow \u003d this.bsBuff;\n    int bsLiveShadow \u003d this.bsLive;\n    int lastShadow \u003d -1;\n    int zt \u003d selector[groupNo] \u0026 0xff;\n    int[] base_zt \u003d base[zt];\n    int[] limit_zt \u003d limit[zt];\n    int[] perm_zt \u003d perm[zt];\n    int minLens_zt \u003d minLens[zt];\n\n    while (nextSym !\u003d eob) {\n      if ((nextSym \u003d\u003d RUNA) || (nextSym \u003d\u003d RUNB)) {\n        int s \u003d -1;\n\n        for (int n \u003d 1; true; n \u003c\u003c\u003d 1) {\n          if (nextSym \u003d\u003d RUNA) {\n            s +\u003d n;\n          } else if (nextSym \u003d\u003d RUNB) {\n            s +\u003d n \u003c\u003c 1;\n          } else {\n            break;\n          }\n\n          if (groupPos \u003d\u003d 0) {\n            groupPos \u003d G_SIZE - 1;\n            zt \u003d selector[++groupNo] \u0026 0xff;\n            base_zt \u003d base[zt];\n            limit_zt \u003d limit[zt];\n            perm_zt \u003d perm[zt];\n            minLens_zt \u003d minLens[zt];\n          } else {\n            groupPos--;\n          }\n\n          int zn \u003d minLens_zt;\n\n          // Inlined:\n          // int zvec \u003d bsR(zn);\n          while (bsLiveShadow \u003c zn) {\n            final int thech \u003d inShadow.read();\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n              \u0026 ((1 \u003c\u003c zn) - 1);\n          bsLiveShadow -\u003d zn;\n\n          while (zvec \u003e limit_zt[zn]) {\n            zn++;\n            while (bsLiveShadow \u003c 1) {\n              final int thech \u003d inShadow.read();\n              if (thech \u003e\u003d 0) {\n                bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n                bsLiveShadow +\u003d 8;\n                continue;\n              } else {\n                throw new IOException(\n                    \"unexpected end of stream\");\n              }\n            }\n            bsLiveShadow--;\n            zvec \u003d (zvec \u003c\u003c 1)\n                | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n          }\n          nextSym \u003d perm_zt[zvec - base_zt[zn]];\n        }\n\n        final byte ch \u003d seqToUnseq[yy[0]];\n        unzftab[ch \u0026 0xff] +\u003d s + 1;\n\n        while (s-- \u003e\u003d 0) {\n          ll8[++lastShadow] \u003d ch;\n        }\n\n        if (lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n      } else {\n        if (++lastShadow \u003e\u003d limitLast) {\n          throw new IOException(\"block overrun\");\n        }\n\n        final char tmp \u003d yy[nextSym - 1];\n        unzftab[seqToUnseq[tmp] \u0026 0xff]++;\n        ll8[lastShadow] \u003d seqToUnseq[tmp];\n\n        /*\n        * This loop is hammered during decompression, hence avoid\n        * native method call overhead of System.arraycopy for very\n        * small ranges to copy.\n        */\n        if (nextSym \u003c\u003d 16) {\n          for (int j \u003d nextSym - 1; j \u003e 0;) {\n            yy[j] \u003d yy[--j];\n          }\n        } else {\n          System.arraycopy(yy, 0, yy, 1, nextSym - 1);\n        }\n\n        yy[0] \u003d tmp;\n\n        if (groupPos \u003d\u003d 0) {\n          groupPos \u003d G_SIZE - 1;\n          zt \u003d selector[++groupNo] \u0026 0xff;\n          base_zt \u003d base[zt];\n          limit_zt \u003d limit[zt];\n          perm_zt \u003d perm[zt];\n          minLens_zt \u003d minLens[zt];\n        } else {\n          groupPos--;\n        }\n\n        int zn \u003d minLens_zt;\n\n        // Inlined:\n        // int zvec \u003d bsR(zn);\n        while (bsLiveShadow \u003c zn) {\n          final int thech \u003d inShadow.read();\n          if (thech \u003e\u003d 0) {\n            bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n            bsLiveShadow +\u003d 8;\n            continue;\n          } else {\n            throw new IOException(\"unexpected end of stream\");\n          }\n        }\n        int zvec \u003d (bsBuffShadow \u003e\u003e (bsLiveShadow - zn))\n            \u0026 ((1 \u003c\u003c zn) - 1);\n        bsLiveShadow -\u003d zn;\n\n        while (zvec \u003e limit_zt[zn]) {\n          zn++;\n          while (bsLiveShadow \u003c 1) {\n            final int thech \u003d inShadow.read();\n            if (thech \u003e\u003d 0) {\n              bsBuffShadow \u003d (bsBuffShadow \u003c\u003c 8) | thech;\n              bsLiveShadow +\u003d 8;\n              continue;\n            } else {\n              throw new IOException(\"unexpected end of stream\");\n            }\n          }\n          bsLiveShadow--;\n          zvec \u003d (zvec \u003c\u003c 1) | ((bsBuffShadow \u003e\u003e bsLiveShadow) \u0026 1);\n        }\n        nextSym \u003d perm_zt[zvec - base_zt[zn]];\n      }\n    }\n\n    this.last \u003d lastShadow;\n    this.bsLive \u003d bsLiveShadow;\n    this.bsBuff \u003d bsBuffShadow;\n  }",
      "path": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2InputStream.java"
    }
  }
}