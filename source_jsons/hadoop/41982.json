{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMasterService.java",
  "functionName": "registerApplicationMaster",
  "functionId": "registerApplicationMaster___request-RegisterApplicationMasterRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
  "functionStartLine": 243,
  "functionEndLine": 297,
  "numCommitsSeen": 119,
  "timeTaken": 12034,
  "changeHistory": [
    "d4d2fd1acd2fdddf04f45e67897804eea30d79a1",
    "859aa1f9d621d07693825e610bdc0149f7a2770a",
    "077fcf6a96e420e7f36350931722b8603d010cf1",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
    "22de7c1dca1be63d523de833163ae51bfe638a79",
    "497c86b485b1bb8a2eba52308646d8e1ee76bce3",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "b67d5ba7842cc10695d987f217027848a5a8c3d8",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
    "0f9147c8579a8e8a1600e8c8182662d94296bd51",
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc",
    "163348701ca6b80b6d9dd7816872845d288f0c18",
    "25bc68d15eb005180ab366e3b9470294018bd2b9",
    "8caae1d5a65bf082eef9bd03a50fd5025c290406",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7",
    "15ce82b9c5087ac5e51f7a43eb57873c3c374ced",
    "5d1b453b8591d87ffb564857015c26c99fb7437c",
    "98d97d316cd6be7ea62a1550e2593f94e3214feb",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "40a8293d36cbae0fc20abe046a35f229df149f46",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
    "cdfabf5ae289836968b3d296668593b9500b6f26",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "d4d2fd1acd2fdddf04f45e67897804eea30d79a1": "Ybodychange",
    "859aa1f9d621d07693825e610bdc0149f7a2770a": "Ybodychange",
    "077fcf6a96e420e7f36350931722b8603d010cf1": "Ybodychange",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Ybodychange",
    "22de7c1dca1be63d523de833163ae51bfe638a79": "Ybodychange",
    "497c86b485b1bb8a2eba52308646d8e1ee76bce3": "Ybodychange",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "b67d5ba7842cc10695d987f217027848a5a8c3d8": "Ybodychange",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": "Ybodychange",
    "0f9147c8579a8e8a1600e8c8182662d94296bd51": "Ybodychange",
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc": "Ybodychange",
    "163348701ca6b80b6d9dd7816872845d288f0c18": "Ybodychange",
    "25bc68d15eb005180ab366e3b9470294018bd2b9": "Ybodychange",
    "8caae1d5a65bf082eef9bd03a50fd5025c290406": "Ybodychange",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": "Ybodychange",
    "15ce82b9c5087ac5e51f7a43eb57873c3c374ced": "Ybodychange",
    "5d1b453b8591d87ffb564857015c26c99fb7437c": "Ybodychange",
    "98d97d316cd6be7ea62a1550e2593f94e3214feb": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": "Yexceptionschange",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "40a8293d36cbae0fc20abe046a35f229df149f46": "Ybodychange",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": "Ybodychange",
    "cdfabf5ae289836968b3d296668593b9500b6f26": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d4d2fd1acd2fdddf04f45e67897804eea30d79a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2037. Add work preserving restart support for Unmanaged AMs. (Botong Huang via Subru).\n",
      "commitDate": "02/10/17 6:14 PM",
      "commitName": "d4d2fd1acd2fdddf04f45e67897804eea30d79a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "e490602e9b306d5b8a543b93fb15a7395bb9a03d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 20.37,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,55 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d\n         YarnServerSecurityUtils.authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n-        String message \u003d AMRMClientUtils.APP_ALREADY_REGISTERED_MESSAGE + appID;\n-        LOG.warn(message);\n-        RMAuditLogger.logFailure(\n-          this.rmContext.getRMApps()\n-            .get(appID).getUser(),\n-          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n-          appID, applicationAttemptId);\n-        throw new InvalidApplicationMasterRequestException(message);\n+        // allow UAM re-register if work preservation is enabled\n+        ApplicationSubmissionContext appContext \u003d\n+            rmContext.getRMApps().get(appID).getApplicationSubmissionContext();\n+        if (!(appContext.getUnmanagedAM()\n+            \u0026\u0026 appContext.getKeepContainersAcrossApplicationAttempts())) {\n+          String message \u003d\n+              AMRMClientUtils.APP_ALREADY_REGISTERED_MESSAGE + appID;\n+          LOG.warn(message);\n+          RMAuditLogger.logFailure(\n+              this.rmContext.getRMApps().get(appID).getUser(),\n+              AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\",\n+              message, appID, applicationAttemptId);\n+          throw new InvalidApplicationMasterRequestException(message);\n+        }\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n \n       RegisterApplicationMasterResponse response \u003d\n           recordFactory.newRecordInstance(\n               RegisterApplicationMasterResponse.class);\n       this.amsProcessingChain.registerApplicationMaster(\n           amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n        YarnServerSecurityUtils.authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        // allow UAM re-register if work preservation is enabled\n        ApplicationSubmissionContext appContext \u003d\n            rmContext.getRMApps().get(appID).getApplicationSubmissionContext();\n        if (!(appContext.getUnmanagedAM()\n            \u0026\u0026 appContext.getKeepContainersAcrossApplicationAttempts())) {\n          String message \u003d\n              AMRMClientUtils.APP_ALREADY_REGISTERED_MESSAGE + appID;\n          LOG.warn(message);\n          RMAuditLogger.logFailure(\n              this.rmContext.getRMApps().get(appID).getUser(),\n              AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\",\n              message, appID, applicationAttemptId);\n          throw new InvalidApplicationMasterRequestException(message);\n        }\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n\n      RegisterApplicationMasterResponse response \u003d\n          recordFactory.newRecordInstance(\n              RegisterApplicationMasterResponse.class);\n      this.amsProcessingChain.registerApplicationMaster(\n          amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "859aa1f9d621d07693825e610bdc0149f7a2770a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5531. UnmanagedAM pool manager for federating application across clusters. (Botong Huang via Subru).\n\n(cherry picked from commit 73bb2102ce4b82b3a3bed91319f7c8f067ddc3e8)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "859aa1f9d621d07693825e610bdc0149f7a2770a",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "19/07/17 12:26 PM",
      "commitNameOld": "077fcf6a96e420e7f36350931722b8603d010cf1",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 13.21,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,49 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d\n         YarnServerSecurityUtils.authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n-        String message \u003d\n-            \"Application Master is already registered : \"\n-                + appID;\n+        String message \u003d AMRMClientUtils.APP_ALREADY_REGISTERED_MESSAGE + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n-            this.rmContext.getRMApps()\n-                .get(appID).getUser(),\n-            AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n-            appID, applicationAttemptId);\n+          this.rmContext.getRMApps()\n+            .get(appID).getUser(),\n+          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n+          appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n \n       RegisterApplicationMasterResponse response \u003d\n           recordFactory.newRecordInstance(\n               RegisterApplicationMasterResponse.class);\n       this.amsProcessingChain.registerApplicationMaster(\n           amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n        YarnServerSecurityUtils.authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d AMRMClientUtils.APP_ALREADY_REGISTERED_MESSAGE + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n\n      RegisterApplicationMasterResponse response \u003d\n          recordFactory.newRecordInstance(\n              RegisterApplicationMasterResponse.class);\n      this.amsProcessingChain.registerApplicationMaster(\n          amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "077fcf6a96e420e7f36350931722b8603d010cf1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
      "commitDate": "19/07/17 12:26 PM",
      "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/07/17 2:34 PM",
      "commitNameOld": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,51 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d\n         YarnServerSecurityUtils.authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appID).getUser(),\n             AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n             appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n \n-      return this.amsProcessor.registerApplicationMaster(\n-          amrmTokenIdentifier.getApplicationAttemptId(), request);\n+      RegisterApplicationMasterResponse response \u003d\n+          recordFactory.newRecordInstance(\n+              RegisterApplicationMasterResponse.class);\n+      this.amsProcessingChain.registerApplicationMaster(\n+          amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n+      return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n        YarnServerSecurityUtils.authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appID).getUser(),\n            AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n            appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n\n      RegisterApplicationMasterResponse response \u003d\n          recordFactory.newRecordInstance(\n              RegisterApplicationMasterResponse.class);\n      this.amsProcessingChain.registerApplicationMaster(\n          amrmTokenIdentifier.getApplicationAttemptId(), request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
      "commitDate": "10/07/17 2:34 PM",
      "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "01/05/17 7:45 AM",
      "commitNameOld": "30fc5801966feb7f9bdd7d79db75acc595102913",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 70.28,
      "commitsBetweenForRepo": 344,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,47 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d\n         YarnServerSecurityUtils.authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n-          this.rmContext.getRMApps()\n-            .get(appID).getUser(),\n-          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n-          appID, applicationAttemptId);\n+            this.rmContext.getRMApps()\n+                .get(appID).getUser(),\n+            AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n+            appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n-      \n+\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n-      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n-      \n+\n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n-      LOG.info(\"AM registration \" + applicationAttemptId);\n-      this.rmContext\n-        .getDispatcher()\n-        .getEventHandler()\n-        .handle(\n-          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n-            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n-      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n-        \"ApplicationMasterService\", appID, applicationAttemptId);\n \n-      // Pick up min/max resource from scheduler...\n-      RegisterApplicationMasterResponse response \u003d recordFactory\n-          .newRecordInstance(RegisterApplicationMasterResponse.class);\n-      response.setMaximumResourceCapability(rScheduler\n-          .getMaximumResourceCapability(app.getQueue()));\n-      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n-          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n-      response.setQueue(app.getQueue());\n-      if (UserGroupInformation.isSecurityEnabled()) {\n-        LOG.info(\"Setting client token master key\");\n-        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n-            .getClientToAMTokenSecretManager()\n-            .getMasterKey(applicationAttemptId).getEncoded()));        \n-      }\n-\n-      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n-      // and corresponding NM tokens.\n-      if (app.getApplicationSubmissionContext()\n-          .getKeepContainersAcrossApplicationAttempts()) {\n-        List\u003cContainer\u003e transferredContainers \u003d rScheduler\n-            .getTransferredContainers(applicationAttemptId);\n-        if (!transferredContainers.isEmpty()) {\n-          response.setContainersFromPreviousAttempts(transferredContainers);\n-          List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n-          for (Container container : transferredContainers) {\n-            try {\n-              NMToken token \u003d rmContext.getNMTokenSecretManager()\n-                  .createAndGetNMToken(app.getUser(), applicationAttemptId,\n-                      container);\n-              if (null !\u003d token) {\n-                nmTokens.add(token);\n-              }\n-            } catch (IllegalArgumentException e) {\n-              // if it\u0027s a DNS issue, throw UnknowHostException directly and\n-              // that\n-              // will be automatically retried by RMProxy in RPC layer.\n-              if (e.getCause() instanceof UnknownHostException) {\n-                throw (UnknownHostException) e.getCause();\n-              }\n-            }\n-          }\n-          response.setNMTokensFromPreviousAttempts(nmTokens);\n-          LOG.info(\"Application \" + appID + \" retrieved \"\n-              + transferredContainers.size() + \" containers from previous\"\n-              + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n-        }\n-      }\n-\n-      response.setSchedulerResourceTypes(rScheduler\n-        .getSchedulingResourceTypes());\n-\n-      return response;\n+      return this.amsProcessor.registerApplicationMaster(\n+          amrmTokenIdentifier.getApplicationAttemptId(), request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n        YarnServerSecurityUtils.authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appID).getUser(),\n            AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n            appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n\n      return this.amsProcessor.registerApplicationMaster(\n          amrmTokenIdentifier.getApplicationAttemptId(), request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "commitDateOld": "20/08/15 10:21 PM",
      "commitNameOld": "22de7c1dca1be63d523de833163ae51bfe638a79",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 17.84,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n-    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n+    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n+        YarnServerSecurityUtils.authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability(app.getQueue()));\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       if (app.getApplicationSubmissionContext()\n           .getKeepContainersAcrossApplicationAttempts()) {\n         List\u003cContainer\u003e transferredContainers \u003d rScheduler\n             .getTransferredContainers(applicationAttemptId);\n         if (!transferredContainers.isEmpty()) {\n           response.setContainersFromPreviousAttempts(transferredContainers);\n           List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n           for (Container container : transferredContainers) {\n             try {\n               NMToken token \u003d rmContext.getNMTokenSecretManager()\n                   .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                       container);\n               if (null !\u003d token) {\n                 nmTokens.add(token);\n               }\n             } catch (IllegalArgumentException e) {\n               // if it\u0027s a DNS issue, throw UnknowHostException directly and\n               // that\n               // will be automatically retried by RMProxy in RPC layer.\n               if (e.getCause() instanceof UnknownHostException) {\n                 throw (UnknownHostException) e.getCause();\n               }\n             }\n           }\n           response.setNMTokensFromPreviousAttempts(nmTokens);\n           LOG.info(\"Application \" + appID + \" retrieved \"\n               + transferredContainers.size() + \" containers from previous\"\n               + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n         }\n       }\n \n       response.setSchedulerResourceTypes(rScheduler\n         .getSchedulingResourceTypes());\n \n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d\n        YarnServerSecurityUtils.authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability(app.getQueue()));\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      if (app.getApplicationSubmissionContext()\n          .getKeepContainersAcrossApplicationAttempts()) {\n        List\u003cContainer\u003e transferredContainers \u003d rScheduler\n            .getTransferredContainers(applicationAttemptId);\n        if (!transferredContainers.isEmpty()) {\n          response.setContainersFromPreviousAttempts(transferredContainers);\n          List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n          for (Container container : transferredContainers) {\n            try {\n              NMToken token \u003d rmContext.getNMTokenSecretManager()\n                  .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                      container);\n              if (null !\u003d token) {\n                nmTokens.add(token);\n              }\n            } catch (IllegalArgumentException e) {\n              // if it\u0027s a DNS issue, throw UnknowHostException directly and\n              // that\n              // will be automatically retried by RMProxy in RPC layer.\n              if (e.getCause() instanceof UnknownHostException) {\n                throw (UnknownHostException) e.getCause();\n              }\n            }\n          }\n          response.setNMTokensFromPreviousAttempts(nmTokens);\n          LOG.info(\"Application \" + appID + \" retrieved \"\n              + transferredContainers.size() + \" containers from previous\"\n              + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n        }\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "22de7c1dca1be63d523de833163ae51bfe638a79": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3986. getTransferredContainers in AbstractYarnScheduler should be present in YarnScheduler interface\n",
      "commitDate": "20/08/15 10:21 PM",
      "commitName": "22de7c1dca1be63d523de833163ae51bfe638a79",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "03/06/15 5:20 PM",
      "commitNameOld": "5766a04428f65bb008b5c451f6f09e61e1000300",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 78.21,
      "commitsBetweenForRepo": 479,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability(app.getQueue()));\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       if (app.getApplicationSubmissionContext()\n           .getKeepContainersAcrossApplicationAttempts()) {\n-        List\u003cContainer\u003e transferredContainers \u003d ((AbstractYarnScheduler) rScheduler)\n+        List\u003cContainer\u003e transferredContainers \u003d rScheduler\n             .getTransferredContainers(applicationAttemptId);\n         if (!transferredContainers.isEmpty()) {\n           response.setContainersFromPreviousAttempts(transferredContainers);\n           List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n           for (Container container : transferredContainers) {\n             try {\n               NMToken token \u003d rmContext.getNMTokenSecretManager()\n                   .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                       container);\n               if (null !\u003d token) {\n                 nmTokens.add(token);\n               }\n             } catch (IllegalArgumentException e) {\n               // if it\u0027s a DNS issue, throw UnknowHostException directly and\n               // that\n               // will be automatically retried by RMProxy in RPC layer.\n               if (e.getCause() instanceof UnknownHostException) {\n                 throw (UnknownHostException) e.getCause();\n               }\n             }\n           }\n           response.setNMTokensFromPreviousAttempts(nmTokens);\n           LOG.info(\"Application \" + appID + \" retrieved \"\n               + transferredContainers.size() + \" containers from previous\"\n               + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n         }\n       }\n \n       response.setSchedulerResourceTypes(rScheduler\n         .getSchedulingResourceTypes());\n \n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability(app.getQueue()));\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      if (app.getApplicationSubmissionContext()\n          .getKeepContainersAcrossApplicationAttempts()) {\n        List\u003cContainer\u003e transferredContainers \u003d rScheduler\n            .getTransferredContainers(applicationAttemptId);\n        if (!transferredContainers.isEmpty()) {\n          response.setContainersFromPreviousAttempts(transferredContainers);\n          List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n          for (Container container : transferredContainers) {\n            try {\n              NMToken token \u003d rmContext.getNMTokenSecretManager()\n                  .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                      container);\n              if (null !\u003d token) {\n                nmTokens.add(token);\n              }\n            } catch (IllegalArgumentException e) {\n              // if it\u0027s a DNS issue, throw UnknowHostException directly and\n              // that\n              // will be automatically retried by RMProxy in RPC layer.\n              if (e.getCause() instanceof UnknownHostException) {\n                throw (UnknownHostException) e.getCause();\n              }\n            }\n          }\n          response.setNMTokensFromPreviousAttempts(nmTokens);\n          LOG.info(\"Application \" + appID + \" retrieved \"\n              + transferredContainers.size() + \" containers from previous\"\n              + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n        }\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "497c86b485b1bb8a2eba52308646d8e1ee76bce3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3136. Fixed a synchronization problem of AbstractYarnScheduler#getTransferredContainers. Contributed by Sunil G\n",
      "commitDate": "18/04/15 12:46 PM",
      "commitName": "497c86b485b1bb8a2eba52308646d8e1ee76bce3",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/04/15 5:11 PM",
      "commitNameOld": "f65eeb412d140a3808bcf99344a9f3a965918f70",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,106 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability(app.getQueue()));\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n-      List\u003cContainer\u003e transferredContainers \u003d\n-          ((AbstractYarnScheduler) rScheduler)\n+      if (app.getApplicationSubmissionContext()\n+          .getKeepContainersAcrossApplicationAttempts()) {\n+        List\u003cContainer\u003e transferredContainers \u003d ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n-      if (!transferredContainers.isEmpty()) {\n-        response.setContainersFromPreviousAttempts(transferredContainers);\n-        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n-        for (Container container : transferredContainers) {\n-          try {\n-            NMToken token \u003d rmContext.getNMTokenSecretManager()\n-                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n-                    container);\n-            if (null !\u003d token) {\n-              nmTokens.add(token);\n-            }\n-          } catch (IllegalArgumentException e) {\n-            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n-            // will be automatically retried by RMProxy in RPC layer.\n-            if (e.getCause() instanceof UnknownHostException) {\n-              throw (UnknownHostException) e.getCause();\n+        if (!transferredContainers.isEmpty()) {\n+          response.setContainersFromPreviousAttempts(transferredContainers);\n+          List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n+          for (Container container : transferredContainers) {\n+            try {\n+              NMToken token \u003d rmContext.getNMTokenSecretManager()\n+                  .createAndGetNMToken(app.getUser(), applicationAttemptId,\n+                      container);\n+              if (null !\u003d token) {\n+                nmTokens.add(token);\n+              }\n+            } catch (IllegalArgumentException e) {\n+              // if it\u0027s a DNS issue, throw UnknowHostException directly and\n+              // that\n+              // will be automatically retried by RMProxy in RPC layer.\n+              if (e.getCause() instanceof UnknownHostException) {\n+                throw (UnknownHostException) e.getCause();\n+              }\n             }\n           }\n+          response.setNMTokensFromPreviousAttempts(nmTokens);\n+          LOG.info(\"Application \" + appID + \" retrieved \"\n+              + transferredContainers.size() + \" containers from previous\"\n+              + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n         }\n-        response.setNMTokensFromPreviousAttempts(nmTokens);\n-        LOG.info(\"Application \" + appID + \" retrieved \"\n-            + transferredContainers.size() + \" containers from previous\"\n-            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n \n       response.setSchedulerResourceTypes(rScheduler\n         .getSchedulingResourceTypes());\n \n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability(app.getQueue()));\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      if (app.getApplicationSubmissionContext()\n          .getKeepContainersAcrossApplicationAttempts()) {\n        List\u003cContainer\u003e transferredContainers \u003d ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n        if (!transferredContainers.isEmpty()) {\n          response.setContainersFromPreviousAttempts(transferredContainers);\n          List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n          for (Container container : transferredContainers) {\n            try {\n              NMToken token \u003d rmContext.getNMTokenSecretManager()\n                  .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                      container);\n              if (null !\u003d token) {\n                nmTokens.add(token);\n              }\n            } catch (IllegalArgumentException e) {\n              // if it\u0027s a DNS issue, throw UnknowHostException directly and\n              // that\n              // will be automatically retried by RMProxy in RPC layer.\n              if (e.getCause() instanceof UnknownHostException) {\n                throw (UnknownHostException) e.getCause();\n              }\n            }\n          }\n          response.setNMTokensFromPreviousAttempts(nmTokens);\n          LOG.info(\"Application \" + appID + \" retrieved \"\n              + transferredContainers.size() + \" containers from previous\"\n              + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n        }\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
      "commitDate": "05/02/15 11:28 AM",
      "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "13/11/14 8:13 AM",
      "commitNameOld": "3651fe1b089851b38be351c00a9899817166bf3e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 84.14,
      "commitsBetweenForRepo": 543,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n-          .getMaximumResourceCapability());\n+          .getMaximumResourceCapability(app.getQueue()));\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       if (!transferredContainers.isEmpty()) {\n         response.setContainersFromPreviousAttempts(transferredContainers);\n         List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n         for (Container container : transferredContainers) {\n           try {\n             NMToken token \u003d rmContext.getNMTokenSecretManager()\n                 .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                     container);\n             if (null !\u003d token) {\n               nmTokens.add(token);\n             }\n           } catch (IllegalArgumentException e) {\n             // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n             // will be automatically retried by RMProxy in RPC layer.\n             if (e.getCause() instanceof UnknownHostException) {\n               throw (UnknownHostException) e.getCause();\n             }\n           }\n         }\n         response.setNMTokensFromPreviousAttempts(nmTokens);\n         LOG.info(\"Application \" + appID + \" retrieved \"\n             + transferredContainers.size() + \" containers from previous\"\n             + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n \n       response.setSchedulerResourceTypes(rScheduler\n         .getSchedulingResourceTypes());\n \n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability(app.getQueue()));\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            NMToken token \u003d rmContext.getNMTokenSecretManager()\n                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                    container);\n            if (null !\u003d token) {\n              nmTokens.add(token);\n            }\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/09/14 10:19 PM",
      "commitNameOld": "469ea3dcef6e427d02fd08b859b2789cc25189f9",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 33.84,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n-                + applicationAttemptId.getApplicationId();\n+                + appID;\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n-            .get(applicationAttemptId.getApplicationId()).getUser(),\n+            .get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n-          applicationAttemptId.getApplicationId(), applicationAttemptId);\n+          appID, applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       if (!transferredContainers.isEmpty()) {\n         response.setContainersFromPreviousAttempts(transferredContainers);\n         List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n         for (Container container : transferredContainers) {\n           try {\n             NMToken token \u003d rmContext.getNMTokenSecretManager()\n                 .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                     container);\n             if (null !\u003d token) {\n               nmTokens.add(token);\n             }\n           } catch (IllegalArgumentException e) {\n             // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n             // will be automatically retried by RMProxy in RPC layer.\n             if (e.getCause() instanceof UnknownHostException) {\n               throw (UnknownHostException) e.getCause();\n             }\n           }\n         }\n         response.setNMTokensFromPreviousAttempts(nmTokens);\n         LOG.info(\"Application \" + appID + \" retrieved \"\n             + transferredContainers.size() + \" containers from previous\"\n             + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n \n       response.setSchedulerResourceTypes(rScheduler\n         .getSchedulingResourceTypes());\n \n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + appID;\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          appID, applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            NMToken token \u003d rmContext.getNMTokenSecretManager()\n                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                    container);\n            if (null !\u003d token) {\n              nmTokens.add(token);\n            }\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "b67d5ba7842cc10695d987f217027848a5a8c3d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2448. Changed ApplicationMasterProtocol to expose RM-recognized resource types to the AMs. Contributed by Varun Vasudev.\n",
      "commitDate": "10/09/14 10:15 AM",
      "commitName": "b67d5ba7842cc10695d987f217027848a5a8c3d8",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/08/14 2:38 PM",
      "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthorOld": "Xuan Gong",
      "daysBetweenCommits": 32.82,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,103 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n     ApplicationAttemptId applicationAttemptId \u003d\n         amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       if (!transferredContainers.isEmpty()) {\n         response.setContainersFromPreviousAttempts(transferredContainers);\n         List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n         for (Container container : transferredContainers) {\n           try {\n             NMToken token \u003d rmContext.getNMTokenSecretManager()\n                 .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                     container);\n             if (null !\u003d token) {\n               nmTokens.add(token);\n             }\n           } catch (IllegalArgumentException e) {\n             // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n             // will be automatically retried by RMProxy in RPC layer.\n             if (e.getCause() instanceof UnknownHostException) {\n               throw (UnknownHostException) e.getCause();\n             }\n           }\n         }\n         response.setNMTokensFromPreviousAttempts(nmTokens);\n         LOG.info(\"Application \" + appID + \" retrieved \"\n             + transferredContainers.size() + \" containers from previous\"\n             + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n+\n+      response.setSchedulerResourceTypes(rScheduler\n+        .getSchedulingResourceTypes());\n+\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            NMToken token \u003d rmContext.getNMTokenSecretManager()\n                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                    container);\n            if (null !\u003d token) {\n              nmTokens.add(token);\n            }\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n\n      response.setSchedulerResourceTypes(rScheduler\n        .getSchedulingResourceTypes());\n\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2212: ApplicationMaster needs to find a way to update the AMRMToken periodically. Contributed by Xuan Gong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616892 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:38 PM",
      "commitName": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthor": "Xuan Gong",
      "commitDateOld": "31/07/14 1:06 PM",
      "commitNameOld": "e52f67e3897a67a0b6d29e557a31cfa881738821",
      "commitAuthorOld": "Xuan Gong",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,99 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n-    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n+    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n+    ApplicationAttemptId applicationAttemptId \u003d\n+        amrmTokenIdentifier.getApplicationAttemptId();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       if (!transferredContainers.isEmpty()) {\n         response.setContainersFromPreviousAttempts(transferredContainers);\n         List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n         for (Container container : transferredContainers) {\n           try {\n             NMToken token \u003d rmContext.getNMTokenSecretManager()\n                 .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                     container);\n             if (null !\u003d token) {\n               nmTokens.add(token);\n             }\n           } catch (IllegalArgumentException e) {\n             // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n             // will be automatically retried by RMProxy in RPC layer.\n             if (e.getCause() instanceof UnknownHostException) {\n               throw (UnknownHostException) e.getCause();\n             }\n           }\n         }\n         response.setNMTokensFromPreviousAttempts(nmTokens);\n         LOG.info(\"Application \" + appID + \" retrieved \"\n             + transferredContainers.size() + \" containers from previous\"\n             + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    AMRMTokenIdentifier amrmTokenIdentifier \u003d authorizeRequest();\n    ApplicationAttemptId applicationAttemptId \u003d\n        amrmTokenIdentifier.getApplicationAttemptId();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            NMToken token \u003d rmContext.getNMTokenSecretManager()\n                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                    container);\n            if (null !\u003d token) {\n              nmTokens.add(token);\n            }\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "0f9147c8579a8e8a1600e8c8182662d94296bd51": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2053. Fixed a bug in AMS to not add null NMToken into NMTokens list from previous attempts for work-preserving AM restart. Contributed by Wangda Tan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595116 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/05/14 11:22 PM",
      "commitName": "0f9147c8579a8e8a1600e8c8182662d94296bd51",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/03/14 10:58 AM",
      "commitNameOld": "7da07461ffadb462567c81ad155d3d1473ad89d7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 66.52,
      "commitsBetweenForRepo": 443,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,97 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n       // and corresponding NM tokens.\n       List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       if (!transferredContainers.isEmpty()) {\n         response.setContainersFromPreviousAttempts(transferredContainers);\n         List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n         for (Container container : transferredContainers) {\n           try {\n-            nmTokens.add(rmContext.getNMTokenSecretManager()\n-              .createAndGetNMToken(app.getUser(), applicationAttemptId,\n-                container));\n+            NMToken token \u003d rmContext.getNMTokenSecretManager()\n+                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n+                    container);\n+            if (null !\u003d token) {\n+              nmTokens.add(token);\n+            }\n           } catch (IllegalArgumentException e) {\n             // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n             // will be automatically retried by RMProxy in RPC layer.\n             if (e.getCause() instanceof UnknownHostException) {\n               throw (UnknownHostException) e.getCause();\n             }\n           }\n         }\n         response.setNMTokensFromPreviousAttempts(nmTokens);\n         LOG.info(\"Application \" + appID + \" retrieved \"\n             + transferredContainers.size() + \" containers from previous\"\n             + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            NMToken token \u003d rmContext.getNMTokenSecretManager()\n                .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                    container);\n            if (null !\u003d token) {\n              nmTokens.add(token);\n            }\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1588. Enhanced RM and the scheduling protocol to also send NMTokens of transferred containers from previous app-attempts to new AMs after YARN-1490. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1572230 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/14 12:20 PM",
      "commitName": "0fbc7fe816007b4e330604e9f8bae6b1e4b448bc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/02/14 3:39 PM",
      "commitNameOld": "5fd5c9900cfd299428acbc8dff767273e44647c0",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.86,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,94 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n-      List\u003cContainer\u003e containerList \u003d\n+      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n+      // and corresponding NM tokens.\n+      List\u003cContainer\u003e transferredContainers \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n-      response.setContainersFromPreviousAttempt(containerList);\n+      if (!transferredContainers.isEmpty()) {\n+        response.setContainersFromPreviousAttempts(transferredContainers);\n+        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n+        for (Container container : transferredContainers) {\n+          try {\n+            nmTokens.add(rmContext.getNMTokenSecretManager()\n+              .createAndGetNMToken(app.getUser(), applicationAttemptId,\n+                container));\n+          } catch (IllegalArgumentException e) {\n+            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n+            // will be automatically retried by RMProxy in RPC layer.\n+            if (e.getCause() instanceof UnknownHostException) {\n+              throw (UnknownHostException) e.getCause();\n+            }\n+          }\n+        }\n+        response.setNMTokensFromPreviousAttempts(nmTokens);\n+        LOG.info(\"Application \" + appID + \" retrieved \"\n+            + transferredContainers.size() + \" containers from previous\"\n+            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n+      }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      // For work-preserving AM restart, retrieve previous attempts\u0027 containers\n      // and corresponding NM tokens.\n      List\u003cContainer\u003e transferredContainers \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      if (!transferredContainers.isEmpty()) {\n        response.setContainersFromPreviousAttempts(transferredContainers);\n        List\u003cNMToken\u003e nmTokens \u003d new ArrayList\u003cNMToken\u003e();\n        for (Container container : transferredContainers) {\n          try {\n            nmTokens.add(rmContext.getNMTokenSecretManager()\n              .createAndGetNMToken(app.getUser(), applicationAttemptId,\n                container));\n          } catch (IllegalArgumentException e) {\n            // if it\u0027s a DNS issue, throw UnknowHostException directly and that\n            // will be automatically retried by RMProxy in RPC layer.\n            if (e.getCause() instanceof UnknownHostException) {\n              throw (UnknownHostException) e.getCause();\n            }\n          }\n        }\n        response.setNMTokensFromPreviousAttempts(nmTokens);\n        LOG.info(\"Application \" + appID + \" retrieved \"\n            + transferredContainers.size() + \" containers from previous\"\n            + \" attempts and \" + nmTokens.size() + \" NM tokens.\");\n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "163348701ca6b80b6d9dd7816872845d288f0c18": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1623. Include queue name in RegisterApplicationMasterResponse (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1560545 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/01/14 2:25 PM",
      "commitName": "163348701ca6b80b6d9dd7816872845d288f0c18",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "10/01/14 11:07 PM",
      "commitNameOld": "25bc68d15eb005180ab366e3b9470294018bd2b9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.64,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n+      response.setQueue(app.getQueue());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n \n       List\u003cContainer\u003e containerList \u003d\n           ((AbstractYarnScheduler) rScheduler)\n             .getTransferredContainers(applicationAttemptId);\n       response.setContainersFromPreviousAttempt(containerList);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      response.setQueue(app.getQueue());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      List\u003cContainer\u003e containerList \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      response.setContainersFromPreviousAttempt(containerList);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "25bc68d15eb005180ab366e3b9470294018bd2b9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1041. Added the ApplicationMasterProtocol API for applications to use the ability in ResourceManager to optionally not kill containers when the ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557318 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 11:07 PM",
      "commitName": "25bc68d15eb005180ab366e3b9470294018bd2b9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/01/14 7:04 AM",
      "commitNameOld": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,71 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n               + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lock) {\n       AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n+\n+      List\u003cContainer\u003e containerList \u003d\n+          ((AbstractYarnScheduler) rScheduler)\n+            .getTransferredContainers(applicationAttemptId);\n+      response.setContainersFromPreviousAttempt(containerList);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n\n      List\u003cContainer\u003e containerList \u003d\n          ((AbstractYarnScheduler) rScheduler)\n            .getTransferredContainers(applicationAttemptId);\n      response.setContainersFromPreviousAttempt(containerList);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "8caae1d5a65bf082eef9bd03a50fd5025c290406": {
      "type": "Ybodychange",
      "commitMessage": "YARN-744. Race condition in ApplicationMasterService.allocate .. It might process same allocate request twice resulting in additional containers getting allocated. (Omkar Vinit Joshi via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543707 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/13 9:06 PM",
      "commitName": "8caae1d5a65bf082eef9bd03a50fd5025c290406",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "14/09/13 6:01 PM",
      "commitNameOld": "ec010a29362c6c5572f8681f4e7d0469176345e1",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 66.17,
      "commitsBetweenForRepo": 434,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,66 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n-    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n-    if (lastResponse \u003d\u003d null) {\n-      String message \u003d \"Application doesn\u0027t exist in cache \"\n-          + applicationAttemptId;\n-      LOG.error(message);\n+    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n+    if (lock \u003d\u003d null) {\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n-          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n+          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n+              + applicationAttemptId, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n-      throw RPCUtil.getRemoteException(message);\n+      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n-    synchronized (lastResponse) {\n-\n+    synchronized (lock) {\n+      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n-      responseMap.put(applicationAttemptId, lastResponse);\n+      lock.setAllocateResponse(lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"Application doesn\u0027t exist in cache \"\n              + applicationAttemptId, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lock) {\n      AllocateResponse lastResponse \u003d lock.getAllocateResponse();\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      lock.setAllocateResponse(lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-918. Remove ApplicationAttemptId from RegisterApplicationMasterRequestProto. Contributed by Vinod K V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504735 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 5:57 PM",
      "commitName": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "18/07/13 12:03 PM",
      "commitNameOld": "32bc200d54928d39acdc837c2c77b4c443fb46be",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,68 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n-    ApplicationAttemptId applicationAttemptId \u003d request\n-        .getApplicationAttemptId();\n-    authorizeRequest(applicationAttemptId);\n+    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       if (hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is already registered : \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.warn(message);\n         RMAuditLogger.logFailure(\n           this.rmContext.getRMApps()\n             .get(applicationAttemptId.getApplicationId()).getUser(),\n           AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n           applicationAttemptId.getApplicationId(), applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       \n       // Setting the response id to 0 to identify if the\n       // application master is register for the respective attemptid\n       lastResponse.setResponseId(0);\n       responseMap.put(applicationAttemptId, lastResponse);\n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.rmContext\n         .getDispatcher()\n         .getEventHandler()\n         .handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n             .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n       RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n         \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      responseMap.put(applicationAttemptId, lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "15ce82b9c5087ac5e51f7a43eb57873c3c374ced": {
      "type": "Ybodychange",
      "commitMessage": "YARN-369. Handle ( or throw a proper error when receiving) status updates from application masters that have not registered (Mayank Bansal \u0026 Abhishek Kapoor via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501605 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/13 4:14 PM",
      "commitName": "15ce82b9c5087ac5e51f7a43eb57873c3c374ced",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "18/06/13 4:19 PM",
      "commitNameOld": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 21.0,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,70 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n-      LOG.info(\"AM registration \" + applicationAttemptId);\n+      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n+        String message \u003d\n+            \"Application Master is already registered : \"\n+                + applicationAttemptId.getApplicationId();\n+        LOG.warn(message);\n+        RMAuditLogger.logFailure(\n+          this.rmContext.getRMApps()\n+            .get(applicationAttemptId.getApplicationId()).getUser(),\n+          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n+          applicationAttemptId.getApplicationId(), applicationAttemptId);\n+        throw new InvalidApplicationMasterRequestException(message);\n+      }\n+      \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n-\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n-              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n-\n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n-      RMAuditLogger.logSuccess(app.getUser(),\n-          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n-          applicationAttemptId);\n+      \n+      // Setting the response id to 0 to identify if the\n+      // application master is register for the respective attemptid\n+      lastResponse.setResponseId(0);\n+      responseMap.put(applicationAttemptId, lastResponse);\n+      LOG.info(\"AM registration \" + applicationAttemptId);\n+      this.rmContext\n+        .getDispatcher()\n+        .getEventHandler()\n+        .handle(\n+          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n+            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n+      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n+        \"ApplicationMasterService\", appID, applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       if (UserGroupInformation.isSecurityEnabled()) {\n         LOG.info(\"Setting client token master key\");\n         response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n             .getClientToAMTokenSecretManager()\n             .getMasterKey(applicationAttemptId).getEncoded()));        \n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      if (hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is already registered : \"\n                + applicationAttemptId.getApplicationId();\n        LOG.warn(message);\n        RMAuditLogger.logFailure(\n          this.rmContext.getRMApps()\n            .get(applicationAttemptId.getApplicationId()).getUser(),\n          AuditConstants.REGISTER_AM, \"\", \"ApplicationMasterService\", message,\n          applicationAttemptId.getApplicationId(), applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      \n      // Setting the response id to 0 to identify if the\n      // application master is register for the respective attemptid\n      lastResponse.setResponseId(0);\n      responseMap.put(applicationAttemptId, lastResponse);\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.rmContext\n        .getDispatcher()\n        .getEventHandler()\n        .handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n            .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n      RMAuditLogger.logSuccess(app.getUser(), AuditConstants.REGISTER_AM,\n        \"ApplicationMasterService\", appID, applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "5d1b453b8591d87ffb564857015c26c99fb7437c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 4:13 PM",
      "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 12:11 PM",
      "commitNameOld": "7d0c43d7cff6d250613a04fea9449f139988e901",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,52 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n+      if (UserGroupInformation.isSecurityEnabled()) {\n+        LOG.info(\"Setting client token master key\");\n+        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n+            .getClientToAMTokenSecretManager()\n+            .getMasterKey(applicationAttemptId).getEncoded()));        \n+      }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      if (UserGroupInformation.isSecurityEnabled()) {\n        LOG.info(\"Setting client token master key\");\n        response.setClientToAMTokenMasterKey(java.nio.ByteBuffer.wrap(rmContext\n            .getClientToAMTokenSecretManager()\n            .getMasterKey(applicationAttemptId).getEncoded()));        \n      }\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "98d97d316cd6be7ea62a1550e2593f94e3214feb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-787. Removed minimum resource from RegisterApplicationMasterResponse. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493509 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/06/13 6:59 AM",
      "commitName": "98d97d316cd6be7ea62a1550e2593f94e3214feb",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "15/06/13 8:11 PM",
      "commitNameOld": "769a0bd8314cd7317c083a9b74abf47242acb58c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,46 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n-      response.setMinimumResourceCapability(rScheduler\n-          .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n-      RegisterApplicationMasterRequest request) throws YarnRemoteException,\n+      RegisterApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-630. Changed AMRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5226. Handling YarnRemoteException separately from IOException in MR App\u0027s use of AMRMProtocol after YARN-630. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480529 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 10:32 PM",
      "commitName": "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/04/13 10:45 AM",
      "commitNameOld": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 33.49,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,48 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n-      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n+      RegisterApplicationMasterRequest request) throws YarnRemoteException,\n+      IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-396. Rationalize AllocateResponse in RM Scheduler API. Contributed by Zhijie Shen.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/13 1:44 PM",
      "commitName": "1bd345d6e3855ab330963efd32e0fac102e61d1a",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 70.65,
      "commitsBetweenForRepo": 330,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n-    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n+    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMApp app \u003d this.rmContext.getRMApps().get(appID);\n       RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n           .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
      }
    },
    "40a8293d36cbae0fc20abe046a35f229df149f46": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4034. Unable to view task logs on history server with mapreduce.job.acl-view-job\u003d* (Jason Lowe and Siddarth Seth via bobby)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/12 9:29 AM",
      "commitName": "40a8293d36cbae0fc20abe046a35f229df149f46",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "20/12/11 3:27 PM",
      "commitNameOld": "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 90.71,
      "commitsBetweenForRepo": 622,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,47 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n-      RMAuditLogger.logSuccess(this.rmContext.getRMApps().get(appID).getUser(),\n+      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n+      RMAuditLogger.logSuccess(app.getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n+      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n+          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMApp app \u003d this.rmContext.getRMApps().get(appID);\n      RMAuditLogger.logSuccess(app.getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      response.setApplicationACLs(app.getRMAppAttempt(applicationAttemptId)\n          .getSubmissionContext().getAMContainerSpec().getApplicationACLs());\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3257. Added authorization checks for the protocol between ResourceManager and ApplicatoinMaster. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189630 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 11:24 PM",
      "commitName": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 2.01,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,44 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n+    authorizeRequest(applicationAttemptId);\n+\n     ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n           \"Error in registering application master\", appID,\n           applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n       RMAuditLogger.logSuccess(this.rmContext.getRMApps().get(appID).getUser(),\n           AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n           applicationAttemptId);\n \n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMAuditLogger.logSuccess(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID,\n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "cdfabf5ae289836968b3d296668593b9500b6f26": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 6:24 PM",
      "commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 13.05,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,42 @@\n   public RegisterApplicationMasterResponse registerApplicationMaster(\n       RegisterApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n+    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n     AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n+      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(), \n+          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n+          \"Error in registering application master\", appID,\n+          applicationAttemptId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do registerApp at a time.\n     synchronized (lastResponse) {\n \n       LOG.info(\"AM registration \" + applicationAttemptId);\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n               .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n \n+      RMAuditLogger.logSuccess(this.rmContext.getRMApps().get(appID).getUser(),\n+          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID, \n+          applicationAttemptId);\n+\n       // Pick up min/max resource from scheduler...\n       RegisterApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(RegisterApplicationMasterResponse.class);\n       response.setMinimumResourceCapability(rScheduler\n           .getMinimumResourceCapability());\n       response.setMaximumResourceCapability(rScheduler\n           .getMaximumResourceCapability());\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    ApplicationId appID \u003d applicationAttemptId.getApplicationId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      RMAuditLogger.logFailure(this.rmContext.getRMApps().get(appID).getUser(), \n          AuditConstants.REGISTER_AM, message, \"ApplicationMasterService\",\n          \"Error in registering application master\", appID,\n          applicationAttemptId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      RMAuditLogger.logSuccess(this.rmContext.getRMApps().get(appID).getUser(),\n          AuditConstants.REGISTER_AM, \"ApplicationMasterService\", appID, \n          applicationAttemptId);\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,33 @@\n+  public RegisterApplicationMasterResponse registerApplicationMaster(\n+      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n+\n+    ApplicationAttemptId applicationAttemptId \u003d request\n+        .getApplicationAttemptId();\n+    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n+    if (lastResponse \u003d\u003d null) {\n+      String message \u003d \"Application doesn\u0027t exist in cache \"\n+          + applicationAttemptId;\n+      LOG.error(message);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+\n+    // Allow only one thread in AM to do registerApp at a time.\n+    synchronized (lastResponse) {\n+\n+      LOG.info(\"AM registration \" + applicationAttemptId);\n+      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n+\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n+              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n+\n+      // Pick up min/max resource from scheduler...\n+      RegisterApplicationMasterResponse response \u003d recordFactory\n+          .newRecordInstance(RegisterApplicationMasterResponse.class);\n+      response.setMinimumResourceCapability(rScheduler\n+          .getMinimumResourceCapability());\n+      response.setMaximumResourceCapability(rScheduler\n+          .getMaximumResourceCapability());\n+      return response;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterApplicationMasterResponse registerApplicationMaster(\n      RegisterApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do registerApp at a time.\n    synchronized (lastResponse) {\n\n      LOG.info(\"AM registration \" + applicationAttemptId);\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRegistrationEvent(applicationAttemptId, request\n              .getHost(), request.getRpcPort(), request.getTrackingUrl()));\n\n      // Pick up min/max resource from scheduler...\n      RegisterApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(RegisterApplicationMasterResponse.class);\n      response.setMinimumResourceCapability(rScheduler\n          .getMinimumResourceCapability());\n      response.setMaximumResourceCapability(rScheduler\n          .getMaximumResourceCapability());\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
    }
  }
}