{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PmemMappableBlockLoader.java",
  "functionName": "load",
  "functionId": "load___length-long__blockIn-FileInputStream__metaIn-FileInputStream__blockFileName-String__key-ExtendedBlockId",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemMappableBlockLoader.java",
  "functionStartLine": 82,
  "functionEndLine": 116,
  "numCommitsSeen": 6,
  "timeTaken": 2274,
  "changeHistory": [
    "37900c5639f8ba8d41b9fedc3d41ee0fbda7d5db",
    "9b0aace1e6c54f201784912c0b623707aa82b761",
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a"
  ],
  "changeHistoryShort": {
    "37900c5639f8ba8d41b9fedc3d41ee0fbda7d5db": "Ybodychange",
    "9b0aace1e6c54f201784912c0b623707aa82b761": "Ybodychange",
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "37900c5639f8ba8d41b9fedc3d41ee0fbda7d5db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14402. Use FileChannel.transferTo() method for transferring block to SCM cache. Contributed by Feilong He.\n",
      "commitDate": "26/05/19 2:00 AM",
      "commitName": "37900c5639f8ba8d41b9fedc3d41ee0fbda7d5db",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "08/05/19 4:50 AM",
      "commitNameOld": "9b0aace1e6c54f201784912c0b623707aa82b761",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 17.88,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,36 @@\n   MappableBlock load(long length, FileInputStream blockIn,\n-                            FileInputStream metaIn, String blockFileName,\n-                            ExtendedBlockId key)\n+                     FileInputStream metaIn, String blockFileName,\n+                     ExtendedBlockId key)\n       throws IOException {\n     PmemMappedBlock mappableBlock \u003d null;\n-    String filePath \u003d null;\n+    String cachePath \u003d null;\n \n     FileChannel blockChannel \u003d null;\n-    RandomAccessFile file \u003d null;\n-    MappedByteBuffer out \u003d null;\n+    RandomAccessFile cacheFile \u003d null;\n     try {\n       blockChannel \u003d blockIn.getChannel();\n       if (blockChannel \u003d\u003d null) {\n         throw new IOException(\"Block InputStream has no FileChannel.\");\n       }\n+      cachePath \u003d pmemVolumeManager.getCachePath(key);\n+      cacheFile \u003d new RandomAccessFile(cachePath, \"rw\");\n+      blockChannel.transferTo(0, length, cacheFile.getChannel());\n \n-      filePath \u003d pmemVolumeManager.getCachePath(key);\n-      file \u003d new RandomAccessFile(filePath, \"rw\");\n-      out \u003d file.getChannel().\n-          map(FileChannel.MapMode.READ_WRITE, 0, length);\n-      if (out \u003d\u003d null) {\n-        throw new IOException(\"Failed to map the block \" + blockFileName +\n-            \" to persistent storage.\");\n-      }\n-      verifyChecksumAndMapBlock(out, length, metaIn, blockChannel,\n-          blockFileName);\n+      // Verify checksum for the cached data instead of block file.\n+      // The file channel should be repositioned.\n+      cacheFile.getChannel().position(0);\n+      verifyChecksum(length, metaIn, cacheFile.getChannel(), blockFileName);\n+\n       mappableBlock \u003d new PmemMappedBlock(length, key);\n       LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n-          + \", [cached path\u003d{}, length\u003d{}]\", key, filePath, length);\n+          + \", [cached path\u003d{}, length\u003d{}]\", key, cachePath, length);\n     } finally {\n       IOUtils.closeQuietly(blockChannel);\n-      if (out !\u003d null) {\n-        NativeIO.POSIX.munmap(out);\n-      }\n-      IOUtils.closeQuietly(file);\n+      IOUtils.closeQuietly(cacheFile);\n       if (mappableBlock \u003d\u003d null) {\n-        LOG.debug(\"Delete {} due to unsuccessful mapping.\", filePath);\n-        FsDatasetUtil.deleteMappedFile(filePath);\n+        LOG.debug(\"Delete {} due to unsuccessful mapping.\", cachePath);\n+        FsDatasetUtil.deleteMappedFile(cachePath);\n       }\n     }\n     return mappableBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  MappableBlock load(long length, FileInputStream blockIn,\n                     FileInputStream metaIn, String blockFileName,\n                     ExtendedBlockId key)\n      throws IOException {\n    PmemMappedBlock mappableBlock \u003d null;\n    String cachePath \u003d null;\n\n    FileChannel blockChannel \u003d null;\n    RandomAccessFile cacheFile \u003d null;\n    try {\n      blockChannel \u003d blockIn.getChannel();\n      if (blockChannel \u003d\u003d null) {\n        throw new IOException(\"Block InputStream has no FileChannel.\");\n      }\n      cachePath \u003d pmemVolumeManager.getCachePath(key);\n      cacheFile \u003d new RandomAccessFile(cachePath, \"rw\");\n      blockChannel.transferTo(0, length, cacheFile.getChannel());\n\n      // Verify checksum for the cached data instead of block file.\n      // The file channel should be repositioned.\n      cacheFile.getChannel().position(0);\n      verifyChecksum(length, metaIn, cacheFile.getChannel(), blockFileName);\n\n      mappableBlock \u003d new PmemMappedBlock(length, key);\n      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n          + \", [cached path\u003d{}, length\u003d{}]\", key, cachePath, length);\n    } finally {\n      IOUtils.closeQuietly(blockChannel);\n      IOUtils.closeQuietly(cacheFile);\n      if (mappableBlock \u003d\u003d null) {\n        LOG.debug(\"Delete {} due to unsuccessful mapping.\", cachePath);\n        FsDatasetUtil.deleteMappedFile(cachePath);\n      }\n    }\n    return mappableBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemMappableBlockLoader.java",
      "extendedDetails": {}
    },
    "9b0aace1e6c54f201784912c0b623707aa82b761": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14401. Refine the implementation for HDFS cache on SCM. Contributed by Feilong He.\n",
      "commitDate": "08/05/19 4:50 AM",
      "commitName": "9b0aace1e6c54f201784912c0b623707aa82b761",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "30/03/19 11:33 PM",
      "commitNameOld": "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 38.22,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,42 @@\n   MappableBlock load(long length, FileInputStream blockIn,\n                             FileInputStream metaIn, String blockFileName,\n                             ExtendedBlockId key)\n       throws IOException {\n     PmemMappedBlock mappableBlock \u003d null;\n     String filePath \u003d null;\n \n     FileChannel blockChannel \u003d null;\n     RandomAccessFile file \u003d null;\n     MappedByteBuffer out \u003d null;\n     try {\n       blockChannel \u003d blockIn.getChannel();\n       if (blockChannel \u003d\u003d null) {\n         throw new IOException(\"Block InputStream has no FileChannel.\");\n       }\n \n-      Byte volumeIndex \u003d pmemVolumeManager.getOneVolumeIndex();\n-      filePath \u003d pmemVolumeManager.inferCacheFilePath(volumeIndex, key);\n+      filePath \u003d pmemVolumeManager.getCachePath(key);\n       file \u003d new RandomAccessFile(filePath, \"rw\");\n       out \u003d file.getChannel().\n           map(FileChannel.MapMode.READ_WRITE, 0, length);\n       if (out \u003d\u003d null) {\n         throw new IOException(\"Failed to map the block \" + blockFileName +\n             \" to persistent storage.\");\n       }\n       verifyChecksumAndMapBlock(out, length, metaIn, blockChannel,\n           blockFileName);\n-      mappableBlock \u003d new PmemMappedBlock(\n-          length, volumeIndex, key, pmemVolumeManager);\n-      pmemVolumeManager.afterCache(key, volumeIndex);\n+      mappableBlock \u003d new PmemMappedBlock(length, key);\n       LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n           + \", [cached path\u003d{}, length\u003d{}]\", key, filePath, length);\n     } finally {\n       IOUtils.closeQuietly(blockChannel);\n       if (out !\u003d null) {\n         NativeIO.POSIX.munmap(out);\n       }\n       IOUtils.closeQuietly(file);\n       if (mappableBlock \u003d\u003d null) {\n+        LOG.debug(\"Delete {} due to unsuccessful mapping.\", filePath);\n         FsDatasetUtil.deleteMappedFile(filePath);\n       }\n     }\n     return mappableBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  MappableBlock load(long length, FileInputStream blockIn,\n                            FileInputStream metaIn, String blockFileName,\n                            ExtendedBlockId key)\n      throws IOException {\n    PmemMappedBlock mappableBlock \u003d null;\n    String filePath \u003d null;\n\n    FileChannel blockChannel \u003d null;\n    RandomAccessFile file \u003d null;\n    MappedByteBuffer out \u003d null;\n    try {\n      blockChannel \u003d blockIn.getChannel();\n      if (blockChannel \u003d\u003d null) {\n        throw new IOException(\"Block InputStream has no FileChannel.\");\n      }\n\n      filePath \u003d pmemVolumeManager.getCachePath(key);\n      file \u003d new RandomAccessFile(filePath, \"rw\");\n      out \u003d file.getChannel().\n          map(FileChannel.MapMode.READ_WRITE, 0, length);\n      if (out \u003d\u003d null) {\n        throw new IOException(\"Failed to map the block \" + blockFileName +\n            \" to persistent storage.\");\n      }\n      verifyChecksumAndMapBlock(out, length, metaIn, blockChannel,\n          blockFileName);\n      mappableBlock \u003d new PmemMappedBlock(length, key);\n      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n          + \", [cached path\u003d{}, length\u003d{}]\", key, filePath, length);\n    } finally {\n      IOUtils.closeQuietly(blockChannel);\n      if (out !\u003d null) {\n        NativeIO.POSIX.munmap(out);\n      }\n      IOUtils.closeQuietly(file);\n      if (mappableBlock \u003d\u003d null) {\n        LOG.debug(\"Delete {} due to unsuccessful mapping.\", filePath);\n        FsDatasetUtil.deleteMappedFile(filePath);\n      }\n    }\n    return mappableBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemMappableBlockLoader.java",
      "extendedDetails": {}
    },
    "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14355 : Implement HDFS cache on SCM by using pure java mapped byte buffer. Contributed by Feilong He.\n",
      "commitDate": "30/03/19 11:33 PM",
      "commitName": "35ff31dd9462cf4fb4ebf5556ee8ae6bcd7c5c3a",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,44 @@\n+  MappableBlock load(long length, FileInputStream blockIn,\n+                            FileInputStream metaIn, String blockFileName,\n+                            ExtendedBlockId key)\n+      throws IOException {\n+    PmemMappedBlock mappableBlock \u003d null;\n+    String filePath \u003d null;\n+\n+    FileChannel blockChannel \u003d null;\n+    RandomAccessFile file \u003d null;\n+    MappedByteBuffer out \u003d null;\n+    try {\n+      blockChannel \u003d blockIn.getChannel();\n+      if (blockChannel \u003d\u003d null) {\n+        throw new IOException(\"Block InputStream has no FileChannel.\");\n+      }\n+\n+      Byte volumeIndex \u003d pmemVolumeManager.getOneVolumeIndex();\n+      filePath \u003d pmemVolumeManager.inferCacheFilePath(volumeIndex, key);\n+      file \u003d new RandomAccessFile(filePath, \"rw\");\n+      out \u003d file.getChannel().\n+          map(FileChannel.MapMode.READ_WRITE, 0, length);\n+      if (out \u003d\u003d null) {\n+        throw new IOException(\"Failed to map the block \" + blockFileName +\n+            \" to persistent storage.\");\n+      }\n+      verifyChecksumAndMapBlock(out, length, metaIn, blockChannel,\n+          blockFileName);\n+      mappableBlock \u003d new PmemMappedBlock(\n+          length, volumeIndex, key, pmemVolumeManager);\n+      pmemVolumeManager.afterCache(key, volumeIndex);\n+      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n+          + \", [cached path\u003d{}, length\u003d{}]\", key, filePath, length);\n+    } finally {\n+      IOUtils.closeQuietly(blockChannel);\n+      if (out !\u003d null) {\n+        NativeIO.POSIX.munmap(out);\n+      }\n+      IOUtils.closeQuietly(file);\n+      if (mappableBlock \u003d\u003d null) {\n+        FsDatasetUtil.deleteMappedFile(filePath);\n+      }\n+    }\n+    return mappableBlock;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  MappableBlock load(long length, FileInputStream blockIn,\n                            FileInputStream metaIn, String blockFileName,\n                            ExtendedBlockId key)\n      throws IOException {\n    PmemMappedBlock mappableBlock \u003d null;\n    String filePath \u003d null;\n\n    FileChannel blockChannel \u003d null;\n    RandomAccessFile file \u003d null;\n    MappedByteBuffer out \u003d null;\n    try {\n      blockChannel \u003d blockIn.getChannel();\n      if (blockChannel \u003d\u003d null) {\n        throw new IOException(\"Block InputStream has no FileChannel.\");\n      }\n\n      Byte volumeIndex \u003d pmemVolumeManager.getOneVolumeIndex();\n      filePath \u003d pmemVolumeManager.inferCacheFilePath(volumeIndex, key);\n      file \u003d new RandomAccessFile(filePath, \"rw\");\n      out \u003d file.getChannel().\n          map(FileChannel.MapMode.READ_WRITE, 0, length);\n      if (out \u003d\u003d null) {\n        throw new IOException(\"Failed to map the block \" + blockFileName +\n            \" to persistent storage.\");\n      }\n      verifyChecksumAndMapBlock(out, length, metaIn, blockChannel,\n          blockFileName);\n      mappableBlock \u003d new PmemMappedBlock(\n          length, volumeIndex, key, pmemVolumeManager);\n      pmemVolumeManager.afterCache(key, volumeIndex);\n      LOG.info(\"Successfully cached one replica:{} into persistent memory\"\n          + \", [cached path\u003d{}, length\u003d{}]\", key, filePath, length);\n    } finally {\n      IOUtils.closeQuietly(blockChannel);\n      if (out !\u003d null) {\n        NativeIO.POSIX.munmap(out);\n      }\n      IOUtils.closeQuietly(file);\n      if (mappableBlock \u003d\u003d null) {\n        FsDatasetUtil.deleteMappedFile(filePath);\n      }\n    }\n    return mappableBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/PmemMappableBlockLoader.java"
    }
  }
}