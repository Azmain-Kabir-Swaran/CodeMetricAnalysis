{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSQueueConverter.java",
  "functionName": "getCapacities",
  "functionId": "getCapacities___totalWeight-int__children-List__FSQueue__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/converter/FSQueueConverter.java",
  "functionStartLine": 315,
  "functionEndLine": 367,
  "numCommitsSeen": 9,
  "timeTaken": 2903,
  "changeHistory": [
    "38d87883b6d4fe6a974e99b937b03cab55bc3820",
    "9314ef947f4f4620943be83a73a170d9fcf3b020",
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d"
  ],
  "changeHistoryShort": {
    "38d87883b6d4fe6a974e99b937b03cab55bc3820": "Ybodychange",
    "9314ef947f4f4620943be83a73a170d9fcf3b020": "Ymultichange(Yreturntypechange,Ybodychange)",
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "38d87883b6d4fe6a974e99b937b03cab55bc3820": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10193. FS-CS converter: fix incorrect capacity conversion. Contributed by Peter Bacsko\n",
      "commitDate": "12/03/20 4:18 AM",
      "commitName": "38d87883b6d4fe6a974e99b937b03cab55bc3820",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "10/03/20 8:07 AM",
      "commitNameOld": "9314ef947f4f4620943be83a73a170d9fcf3b020",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n       List\u003cFSQueue\u003e children) {\n     final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n \n     if (children.size() \u003d\u003d 0) {\n       return new HashMap\u003c\u003e();\n     } else if (children.size() \u003d\u003d 1) {\n       Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n       String queueName \u003d children.get(0).getName();\n       capacity.put(queueName, hundred);\n \n       return capacity;\n     } else {\n       Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n \n       children\n           .stream()\n           .forEach(queue -\u003e {\n             BigDecimal total \u003d new BigDecimal(totalWeight);\n             BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n             BigDecimal pct \u003d weight\n                               .setScale(5)\n                               .divide(total, RoundingMode.HALF_UP)\n                               .multiply(hundred)\n                               .setScale(3);\n \n             if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n               ruleHandler.handleMinResources();\n             }\n \n             capacities.put(queue.getName(), pct);\n           });\n \n       BigDecimal totalPct \u003d new BigDecimal(0);\n       for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n         totalPct \u003d totalPct.add(entry.getValue());\n       }\n \n       // fix last value if total !\u003d 100.000\n       if (!totalPct.equals(hundred)) {\n         BigDecimal tmp \u003d new BigDecimal(0);\n-        for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n+        for (int i \u003d 0; i \u003c children.size() - 1; i++) {\n           tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n         }\n \n         String lastQueue \u003d children.get(children.size() - 1).getName();\n         BigDecimal corrected \u003d hundred.subtract(tmp);\n         capacities.put(lastQueue, corrected);\n       }\n \n       return capacities;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n      List\u003cFSQueue\u003e children) {\n    final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n\n    if (children.size() \u003d\u003d 0) {\n      return new HashMap\u003c\u003e();\n    } else if (children.size() \u003d\u003d 1) {\n      Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n      String queueName \u003d children.get(0).getName();\n      capacity.put(queueName, hundred);\n\n      return capacity;\n    } else {\n      Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n\n      children\n          .stream()\n          .forEach(queue -\u003e {\n            BigDecimal total \u003d new BigDecimal(totalWeight);\n            BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n            BigDecimal pct \u003d weight\n                              .setScale(5)\n                              .divide(total, RoundingMode.HALF_UP)\n                              .multiply(hundred)\n                              .setScale(3);\n\n            if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n              ruleHandler.handleMinResources();\n            }\n\n            capacities.put(queue.getName(), pct);\n          });\n\n      BigDecimal totalPct \u003d new BigDecimal(0);\n      for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n        totalPct \u003d totalPct.add(entry.getValue());\n      }\n\n      // fix last value if total !\u003d 100.000\n      if (!totalPct.equals(hundred)) {\n        BigDecimal tmp \u003d new BigDecimal(0);\n        for (int i \u003d 0; i \u003c children.size() - 1; i++) {\n          tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n        }\n\n        String lastQueue \u003d children.get(children.size() - 1).getName();\n        BigDecimal corrected \u003d hundred.subtract(tmp);\n        capacities.put(lastQueue, corrected);\n      }\n\n      return capacities;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/converter/FSQueueConverter.java",
      "extendedDetails": {}
    },
    "9314ef947f4f4620943be83a73a170d9fcf3b020": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-10168. FS-CS Converter: tool doesn\u0027t handle min/max resource conversion correctly. Contributed by Peter Bacsko\n",
      "commitDate": "10/03/20 8:07 AM",
      "commitName": "9314ef947f4f4620943be83a73a170d9fcf3b020",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-10168. FS-CS Converter: tool doesn\u0027t handle min/max resource conversion correctly. Contributed by Peter Bacsko\n",
          "commitDate": "10/03/20 8:07 AM",
          "commitName": "9314ef947f4f4620943be83a73a170d9fcf3b020",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "05/03/20 12:56 AM",
          "commitNameOld": "004e95534817b3966d8e1727469c657cf1d043d7",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 5.26,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,53 @@\n-  private Map\u003cString, Capacity\u003e getCapacities(int totalWeight,\n+  private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n       List\u003cFSQueue\u003e children) {\n     final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n \n     if (children.size() \u003d\u003d 0) {\n       return new HashMap\u003c\u003e();\n     } else if (children.size() \u003d\u003d 1) {\n-      Map\u003cString, Capacity\u003e capacity \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n       String queueName \u003d children.get(0).getName();\n-      capacity.put(queueName, Capacity.newCapacity(hundred));\n+      capacity.put(queueName, hundred);\n \n       return capacity;\n     } else {\n-      Map\u003cString, Capacity\u003e capacities \u003d new HashMap\u003c\u003e();\n-      Map\u003cString, BigDecimal\u003e bdCapacities \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n \n-      MutableBoolean needVerifySum \u003d new MutableBoolean(true);\n       children\n           .stream()\n           .forEach(queue -\u003e {\n             BigDecimal total \u003d new BigDecimal(totalWeight);\n             BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n             BigDecimal pct \u003d weight\n                               .setScale(5)\n                               .divide(total, RoundingMode.HALF_UP)\n                               .multiply(hundred)\n                               .setScale(3);\n \n-            // \u003cminResources\u003e defined?\n             if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n-              needVerifySum.setFalse();\n-\n-              /* TODO: Needs discussion.\n-               *\n-               * Probably it\u0027s not entirely correct this way!\n-               * Eg. root.queue1 in FS translates to 33%\n-               * capacity, but minResources is defined as 1vcore,8GB\n-               * which is less than 33%.\n-               *\n-               * Therefore max(calculatedCapacity, minResource) is\n-               * more sound.\n-               */\n-              Resource minShare \u003d queue.getMinShare();\n-              // TODO: in Phase-2, we have to deal with other resources as well\n-              String capacity \u003d String.format(\"[memory\u003d%d,vcores\u003d%d]\",\n-                  minShare.getMemorySize(), minShare.getVirtualCores());\n-              capacities.put(queue.getName(), Capacity.newCapacity(capacity));\n-            } else {\n-              capacities.put(queue.getName(), Capacity.newCapacity(pct));\n-              bdCapacities.put(queue.getName(), pct);\n+              ruleHandler.handleMinResources();\n             }\n+\n+            capacities.put(queue.getName(), pct);\n           });\n \n-      if (needVerifySum.isTrue()) {\n-        BigDecimal totalPct \u003d new BigDecimal(0);\n-        for (Map.Entry\u003cString, BigDecimal\u003e entry : bdCapacities.entrySet()) {\n-          totalPct \u003d totalPct.add(entry.getValue());\n+      BigDecimal totalPct \u003d new BigDecimal(0);\n+      for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n+        totalPct \u003d totalPct.add(entry.getValue());\n+      }\n+\n+      // fix last value if total !\u003d 100.000\n+      if (!totalPct.equals(hundred)) {\n+        BigDecimal tmp \u003d new BigDecimal(0);\n+        for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n+          tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n         }\n \n-        // fix last value if total !\u003d 100.000\n-        if (!totalPct.equals(hundred)) {\n-          BigDecimal tmp \u003d new BigDecimal(0);\n-          for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n-            tmp \u003d tmp.add(bdCapacities.get(children.get(i).getQueueName()));\n-          }\n-\n-          String lastQueue \u003d children.get(children.size() - 1).getName();\n-          BigDecimal corrected \u003d hundred.subtract(tmp);\n-          capacities.put(lastQueue, Capacity.newCapacity(corrected));\n-        }\n+        String lastQueue \u003d children.get(children.size() - 1).getName();\n+        BigDecimal corrected \u003d hundred.subtract(tmp);\n+        capacities.put(lastQueue, corrected);\n       }\n \n       return capacities;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n      List\u003cFSQueue\u003e children) {\n    final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n\n    if (children.size() \u003d\u003d 0) {\n      return new HashMap\u003c\u003e();\n    } else if (children.size() \u003d\u003d 1) {\n      Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n      String queueName \u003d children.get(0).getName();\n      capacity.put(queueName, hundred);\n\n      return capacity;\n    } else {\n      Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n\n      children\n          .stream()\n          .forEach(queue -\u003e {\n            BigDecimal total \u003d new BigDecimal(totalWeight);\n            BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n            BigDecimal pct \u003d weight\n                              .setScale(5)\n                              .divide(total, RoundingMode.HALF_UP)\n                              .multiply(hundred)\n                              .setScale(3);\n\n            if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n              ruleHandler.handleMinResources();\n            }\n\n            capacities.put(queue.getName(), pct);\n          });\n\n      BigDecimal totalPct \u003d new BigDecimal(0);\n      for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n        totalPct \u003d totalPct.add(entry.getValue());\n      }\n\n      // fix last value if total !\u003d 100.000\n      if (!totalPct.equals(hundred)) {\n        BigDecimal tmp \u003d new BigDecimal(0);\n        for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n          tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n        }\n\n        String lastQueue \u003d children.get(children.size() - 1).getName();\n        BigDecimal corrected \u003d hundred.subtract(tmp);\n        capacities.put(lastQueue, corrected);\n      }\n\n      return capacities;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/converter/FSQueueConverter.java",
          "extendedDetails": {
            "oldValue": "Map\u003cString,Capacity\u003e",
            "newValue": "Map\u003cString,BigDecimal\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10168. FS-CS Converter: tool doesn\u0027t handle min/max resource conversion correctly. Contributed by Peter Bacsko\n",
          "commitDate": "10/03/20 8:07 AM",
          "commitName": "9314ef947f4f4620943be83a73a170d9fcf3b020",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "05/03/20 12:56 AM",
          "commitNameOld": "004e95534817b3966d8e1727469c657cf1d043d7",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 5.26,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,75 +1,53 @@\n-  private Map\u003cString, Capacity\u003e getCapacities(int totalWeight,\n+  private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n       List\u003cFSQueue\u003e children) {\n     final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n \n     if (children.size() \u003d\u003d 0) {\n       return new HashMap\u003c\u003e();\n     } else if (children.size() \u003d\u003d 1) {\n-      Map\u003cString, Capacity\u003e capacity \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n       String queueName \u003d children.get(0).getName();\n-      capacity.put(queueName, Capacity.newCapacity(hundred));\n+      capacity.put(queueName, hundred);\n \n       return capacity;\n     } else {\n-      Map\u003cString, Capacity\u003e capacities \u003d new HashMap\u003c\u003e();\n-      Map\u003cString, BigDecimal\u003e bdCapacities \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n \n-      MutableBoolean needVerifySum \u003d new MutableBoolean(true);\n       children\n           .stream()\n           .forEach(queue -\u003e {\n             BigDecimal total \u003d new BigDecimal(totalWeight);\n             BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n             BigDecimal pct \u003d weight\n                               .setScale(5)\n                               .divide(total, RoundingMode.HALF_UP)\n                               .multiply(hundred)\n                               .setScale(3);\n \n-            // \u003cminResources\u003e defined?\n             if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n-              needVerifySum.setFalse();\n-\n-              /* TODO: Needs discussion.\n-               *\n-               * Probably it\u0027s not entirely correct this way!\n-               * Eg. root.queue1 in FS translates to 33%\n-               * capacity, but minResources is defined as 1vcore,8GB\n-               * which is less than 33%.\n-               *\n-               * Therefore max(calculatedCapacity, minResource) is\n-               * more sound.\n-               */\n-              Resource minShare \u003d queue.getMinShare();\n-              // TODO: in Phase-2, we have to deal with other resources as well\n-              String capacity \u003d String.format(\"[memory\u003d%d,vcores\u003d%d]\",\n-                  minShare.getMemorySize(), minShare.getVirtualCores());\n-              capacities.put(queue.getName(), Capacity.newCapacity(capacity));\n-            } else {\n-              capacities.put(queue.getName(), Capacity.newCapacity(pct));\n-              bdCapacities.put(queue.getName(), pct);\n+              ruleHandler.handleMinResources();\n             }\n+\n+            capacities.put(queue.getName(), pct);\n           });\n \n-      if (needVerifySum.isTrue()) {\n-        BigDecimal totalPct \u003d new BigDecimal(0);\n-        for (Map.Entry\u003cString, BigDecimal\u003e entry : bdCapacities.entrySet()) {\n-          totalPct \u003d totalPct.add(entry.getValue());\n+      BigDecimal totalPct \u003d new BigDecimal(0);\n+      for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n+        totalPct \u003d totalPct.add(entry.getValue());\n+      }\n+\n+      // fix last value if total !\u003d 100.000\n+      if (!totalPct.equals(hundred)) {\n+        BigDecimal tmp \u003d new BigDecimal(0);\n+        for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n+          tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n         }\n \n-        // fix last value if total !\u003d 100.000\n-        if (!totalPct.equals(hundred)) {\n-          BigDecimal tmp \u003d new BigDecimal(0);\n-          for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n-            tmp \u003d tmp.add(bdCapacities.get(children.get(i).getQueueName()));\n-          }\n-\n-          String lastQueue \u003d children.get(children.size() - 1).getName();\n-          BigDecimal corrected \u003d hundred.subtract(tmp);\n-          capacities.put(lastQueue, Capacity.newCapacity(corrected));\n-        }\n+        String lastQueue \u003d children.get(children.size() - 1).getName();\n+        BigDecimal corrected \u003d hundred.subtract(tmp);\n+        capacities.put(lastQueue, corrected);\n       }\n \n       return capacities;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Map\u003cString, BigDecimal\u003e getCapacities(int totalWeight,\n      List\u003cFSQueue\u003e children) {\n    final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n\n    if (children.size() \u003d\u003d 0) {\n      return new HashMap\u003c\u003e();\n    } else if (children.size() \u003d\u003d 1) {\n      Map\u003cString, BigDecimal\u003e capacity \u003d new HashMap\u003c\u003e();\n      String queueName \u003d children.get(0).getName();\n      capacity.put(queueName, hundred);\n\n      return capacity;\n    } else {\n      Map\u003cString, BigDecimal\u003e capacities \u003d new HashMap\u003c\u003e();\n\n      children\n          .stream()\n          .forEach(queue -\u003e {\n            BigDecimal total \u003d new BigDecimal(totalWeight);\n            BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n            BigDecimal pct \u003d weight\n                              .setScale(5)\n                              .divide(total, RoundingMode.HALF_UP)\n                              .multiply(hundred)\n                              .setScale(3);\n\n            if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n              ruleHandler.handleMinResources();\n            }\n\n            capacities.put(queue.getName(), pct);\n          });\n\n      BigDecimal totalPct \u003d new BigDecimal(0);\n      for (Map.Entry\u003cString, BigDecimal\u003e entry : capacities.entrySet()) {\n        totalPct \u003d totalPct.add(entry.getValue());\n      }\n\n      // fix last value if total !\u003d 100.000\n      if (!totalPct.equals(hundred)) {\n        BigDecimal tmp \u003d new BigDecimal(0);\n        for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n          tmp \u003d tmp.add(capacities.get(children.get(i).getQueueName()));\n        }\n\n        String lastQueue \u003d children.get(children.size() - 1).getName();\n        BigDecimal corrected \u003d hundred.subtract(tmp);\n        capacities.put(lastQueue, corrected);\n      }\n\n      return capacities;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/converter/FSQueueConverter.java",
          "extendedDetails": {}
        }
      ]
    },
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d": {
      "type": "Yintroduced",
      "commitMessage": "YARN-9699. Migration tool that help to generate CS config based on FS config [Phase 1]. Contributed by Peter Bacsko\n",
      "commitDate": "14/10/19 8:19 AM",
      "commitName": "5cc7873a4723a6c8e8e001d008fcd522eec0433d",
      "commitAuthor": "Szilard Nemeth",
      "diff": "@@ -0,0 +1,75 @@\n+  private Map\u003cString, Capacity\u003e getCapacities(int totalWeight,\n+      List\u003cFSQueue\u003e children) {\n+    final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n+\n+    if (children.size() \u003d\u003d 0) {\n+      return new HashMap\u003c\u003e();\n+    } else if (children.size() \u003d\u003d 1) {\n+      Map\u003cString, Capacity\u003e capacity \u003d new HashMap\u003c\u003e();\n+      String queueName \u003d children.get(0).getName();\n+      capacity.put(queueName, Capacity.newCapacity(hundred));\n+\n+      return capacity;\n+    } else {\n+      Map\u003cString, Capacity\u003e capacities \u003d new HashMap\u003c\u003e();\n+      Map\u003cString, BigDecimal\u003e bdCapacities \u003d new HashMap\u003c\u003e();\n+\n+      MutableBoolean needVerifySum \u003d new MutableBoolean(true);\n+      children\n+          .stream()\n+          .forEach(queue -\u003e {\n+            BigDecimal total \u003d new BigDecimal(totalWeight);\n+            BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n+            BigDecimal pct \u003d weight\n+                              .setScale(5)\n+                              .divide(total, RoundingMode.HALF_UP)\n+                              .multiply(hundred)\n+                              .setScale(3);\n+\n+            // \u003cminResources\u003e defined?\n+            if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n+              needVerifySum.setFalse();\n+\n+              /* TODO: Needs discussion.\n+               *\n+               * Probably it\u0027s not entirely correct this way!\n+               * Eg. root.queue1 in FS translates to 33%\n+               * capacity, but minResources is defined as 1vcore,8GB\n+               * which is less than 33%.\n+               *\n+               * Therefore max(calculatedCapacity, minResource) is\n+               * more sound.\n+               */\n+              Resource minShare \u003d queue.getMinShare();\n+              // TODO: in Phase-2, we have to deal with other resources as well\n+              String capacity \u003d String.format(\"[memory\u003d%d,vcores\u003d%d]\",\n+                  minShare.getMemorySize(), minShare.getVirtualCores());\n+              capacities.put(queue.getName(), Capacity.newCapacity(capacity));\n+            } else {\n+              capacities.put(queue.getName(), Capacity.newCapacity(pct));\n+              bdCapacities.put(queue.getName(), pct);\n+            }\n+          });\n+\n+      if (needVerifySum.isTrue()) {\n+        BigDecimal totalPct \u003d new BigDecimal(0);\n+        for (Map.Entry\u003cString, BigDecimal\u003e entry : bdCapacities.entrySet()) {\n+          totalPct \u003d totalPct.add(entry.getValue());\n+        }\n+\n+        // fix last value if total !\u003d 100.000\n+        if (!totalPct.equals(hundred)) {\n+          BigDecimal tmp \u003d new BigDecimal(0);\n+          for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n+            tmp \u003d tmp.add(bdCapacities.get(children.get(i).getQueueName()));\n+          }\n+\n+          String lastQueue \u003d children.get(children.size() - 1).getName();\n+          BigDecimal corrected \u003d hundred.subtract(tmp);\n+          capacities.put(lastQueue, Capacity.newCapacity(corrected));\n+        }\n+      }\n+\n+      return capacities;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cString, Capacity\u003e getCapacities(int totalWeight,\n      List\u003cFSQueue\u003e children) {\n    final BigDecimal hundred \u003d new BigDecimal(100).setScale(3);\n\n    if (children.size() \u003d\u003d 0) {\n      return new HashMap\u003c\u003e();\n    } else if (children.size() \u003d\u003d 1) {\n      Map\u003cString, Capacity\u003e capacity \u003d new HashMap\u003c\u003e();\n      String queueName \u003d children.get(0).getName();\n      capacity.put(queueName, Capacity.newCapacity(hundred));\n\n      return capacity;\n    } else {\n      Map\u003cString, Capacity\u003e capacities \u003d new HashMap\u003c\u003e();\n      Map\u003cString, BigDecimal\u003e bdCapacities \u003d new HashMap\u003c\u003e();\n\n      MutableBoolean needVerifySum \u003d new MutableBoolean(true);\n      children\n          .stream()\n          .forEach(queue -\u003e {\n            BigDecimal total \u003d new BigDecimal(totalWeight);\n            BigDecimal weight \u003d new BigDecimal(queue.getWeight());\n            BigDecimal pct \u003d weight\n                              .setScale(5)\n                              .divide(total, RoundingMode.HALF_UP)\n                              .multiply(hundred)\n                              .setScale(3);\n\n            // \u003cminResources\u003e defined?\n            if (Resources.none().compareTo(queue.getMinShare()) !\u003d 0) {\n              needVerifySum.setFalse();\n\n              /* TODO: Needs discussion.\n               *\n               * Probably it\u0027s not entirely correct this way!\n               * Eg. root.queue1 in FS translates to 33%\n               * capacity, but minResources is defined as 1vcore,8GB\n               * which is less than 33%.\n               *\n               * Therefore max(calculatedCapacity, minResource) is\n               * more sound.\n               */\n              Resource minShare \u003d queue.getMinShare();\n              // TODO: in Phase-2, we have to deal with other resources as well\n              String capacity \u003d String.format(\"[memory\u003d%d,vcores\u003d%d]\",\n                  minShare.getMemorySize(), minShare.getVirtualCores());\n              capacities.put(queue.getName(), Capacity.newCapacity(capacity));\n            } else {\n              capacities.put(queue.getName(), Capacity.newCapacity(pct));\n              bdCapacities.put(queue.getName(), pct);\n            }\n          });\n\n      if (needVerifySum.isTrue()) {\n        BigDecimal totalPct \u003d new BigDecimal(0);\n        for (Map.Entry\u003cString, BigDecimal\u003e entry : bdCapacities.entrySet()) {\n          totalPct \u003d totalPct.add(entry.getValue());\n        }\n\n        // fix last value if total !\u003d 100.000\n        if (!totalPct.equals(hundred)) {\n          BigDecimal tmp \u003d new BigDecimal(0);\n          for (int i \u003d 0; i \u003c children.size() - 2; i++) {\n            tmp \u003d tmp.add(bdCapacities.get(children.get(i).getQueueName()));\n          }\n\n          String lastQueue \u003d children.get(children.size() - 1).getName();\n          BigDecimal corrected \u003d hundred.subtract(tmp);\n          capacities.put(lastQueue, Capacity.newCapacity(corrected));\n        }\n      }\n\n      return capacities;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/converter/FSQueueConverter.java"
    }
  }
}