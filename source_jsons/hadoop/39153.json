{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SchedulerApplicationAttempt.java",
  "functionName": "pullNewlyUpdatedContainers",
  "functionId": "pullNewlyUpdatedContainers___newlyUpdatedContainers-Map__ContainerId,RMContainer____updateTpe-ContainerUpdateType",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
  "functionStartLine": 922,
  "functionEndLine": 977,
  "numCommitsSeen": 178,
  "timeTaken": 6686,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "a957f1c60e1308d1d70a1803381994f59949c5f8",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "a957f1c60e1308d1d70a1803381994f59949c5f8": "Ybodychange",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ymultichange(Yparameterchange,Ybodychange)",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Ybodychange",
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df": "Ymultichange(Ymodifierchange,Ybodychange)",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n       ContainerUpdateType updateTpe) {\n     List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n     if (oppContainerContext \u003d\u003d null \u0026\u0026\n         (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n             || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n       return updatedContainers;\n     }\n+\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n           newlyUpdatedContainers.entrySet().iterator();\n       while (i.hasNext()) {\n         Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n         ContainerId matchedContainerId \u003d entry.getKey();\n         RMContainer tempRMContainer \u003d entry.getValue();\n \n         RMContainer existingRMContainer \u003d\n             getRMContainer(matchedContainerId);\n         if (existingRMContainer !\u003d null) {\n           // swap containers\n           existingRMContainer \u003d getUpdateContext().swapContainer(\n               tempRMContainer, existingRMContainer, updateTpe);\n           getUpdateContext().removeFromOutstandingUpdate(\n               tempRMContainer.getAllocatedSchedulerKey(),\n               existingRMContainer.getContainer());\n           Container updatedContainer \u003d updateContainerAndNMToken(\n               existingRMContainer, updateTpe);\n           updatedContainers.add(updatedContainer);\n         }\n         tempContainerToKill.add(tempRMContainer);\n         i.remove();\n       }\n       // Release all temporary containers\n       Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n       while (tempIter.hasNext()) {\n         RMContainer c \u003d tempIter.next();\n         // Mark container for release (set RRs to null, so RM does not think\n         // it is a recoverable container)\n         ((RMContainerImpl) c).setContainerRequest(null);\n \n         // Release this container async-ly so as to prevent\n         // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n         // on the app and queue which can contended for in the reverse order\n         // by the Scheduler thread.\n         ((AbstractYarnScheduler)rmContext.getScheduler())\n             .asyncContainerRelease(c);\n         tempIter.remove();\n       }\n       return updatedContainers;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n      ContainerUpdateType updateTpe) {\n    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n    if (oppContainerContext \u003d\u003d null \u0026\u0026\n        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n      return updatedContainers;\n    }\n\n    writeLock.lock();\n    try {\n      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          newlyUpdatedContainers.entrySet().iterator();\n      while (i.hasNext()) {\n        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n        ContainerId matchedContainerId \u003d entry.getKey();\n        RMContainer tempRMContainer \u003d entry.getValue();\n\n        RMContainer existingRMContainer \u003d\n            getRMContainer(matchedContainerId);\n        if (existingRMContainer !\u003d null) {\n          // swap containers\n          existingRMContainer \u003d getUpdateContext().swapContainer(\n              tempRMContainer, existingRMContainer, updateTpe);\n          getUpdateContext().removeFromOutstandingUpdate(\n              tempRMContainer.getAllocatedSchedulerKey(),\n              existingRMContainer.getContainer());\n          Container updatedContainer \u003d updateContainerAndNMToken(\n              existingRMContainer, updateTpe);\n          updatedContainers.add(updatedContainer);\n        }\n        tempContainerToKill.add(tempRMContainer);\n        i.remove();\n      }\n      // Release all temporary containers\n      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n      while (tempIter.hasNext()) {\n        RMContainer c \u003d tempIter.next();\n        // Mark container for release (set RRs to null, so RM does not think\n        // it is a recoverable container)\n        ((RMContainerImpl) c).setContainerRequest(null);\n\n        // Release this container async-ly so as to prevent\n        // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n        // on the app and queue which can contended for in the reverse order\n        // by the Scheduler thread.\n        ((AbstractYarnScheduler)rmContext.getScheduler())\n            .asyncContainerRelease(c);\n        tempIter.remove();\n      }\n      return updatedContainers;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
      "extendedDetails": {}
    },
    "a957f1c60e1308d1d70a1803381994f59949c5f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7438. Additional changes to make SchedulingPlacementSet agnostic to ResourceRequest / placement algorithm. Contributed by Wangda Tan\n",
      "commitDate": "05/12/17 9:20 AM",
      "commitName": "a957f1c60e1308d1d70a1803381994f59949c5f8",
      "commitAuthor": "Sunil G",
      "commitDateOld": "27/11/17 10:19 AM",
      "commitNameOld": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n       ContainerUpdateType updateTpe) {\n     List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n     if (oppContainerContext \u003d\u003d null \u0026\u0026\n         (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n             || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n       return updatedContainers;\n     }\n     try {\n       writeLock.lock();\n       Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n           newlyUpdatedContainers.entrySet().iterator();\n       while (i.hasNext()) {\n         Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n         ContainerId matchedContainerId \u003d entry.getKey();\n         RMContainer tempRMContainer \u003d entry.getValue();\n \n         RMContainer existingRMContainer \u003d\n             getRMContainer(matchedContainerId);\n         if (existingRMContainer !\u003d null) {\n           // swap containers\n           existingRMContainer \u003d getUpdateContext().swapContainer(\n               tempRMContainer, existingRMContainer, updateTpe);\n           getUpdateContext().removeFromOutstandingUpdate(\n               tempRMContainer.getAllocatedSchedulerKey(),\n               existingRMContainer.getContainer());\n           Container updatedContainer \u003d updateContainerAndNMToken(\n               existingRMContainer, updateTpe);\n           updatedContainers.add(updatedContainer);\n         }\n         tempContainerToKill.add(tempRMContainer);\n         i.remove();\n       }\n       // Release all temporary containers\n       Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n       while (tempIter.hasNext()) {\n         RMContainer c \u003d tempIter.next();\n         // Mark container for release (set RRs to null, so RM does not think\n         // it is a recoverable container)\n-        ((RMContainerImpl) c).setResourceRequests(null);\n+        ((RMContainerImpl) c).setContainerRequest(null);\n \n         // Release this container async-ly so as to prevent\n         // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n         // on the app and queue which can contended for in the reverse order\n         // by the Scheduler thread.\n         ((AbstractYarnScheduler)rmContext.getScheduler())\n             .asyncContainerRelease(c);\n         tempIter.remove();\n       }\n       return updatedContainers;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n      ContainerUpdateType updateTpe) {\n    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n    if (oppContainerContext \u003d\u003d null \u0026\u0026\n        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n      return updatedContainers;\n    }\n    try {\n      writeLock.lock();\n      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          newlyUpdatedContainers.entrySet().iterator();\n      while (i.hasNext()) {\n        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n        ContainerId matchedContainerId \u003d entry.getKey();\n        RMContainer tempRMContainer \u003d entry.getValue();\n\n        RMContainer existingRMContainer \u003d\n            getRMContainer(matchedContainerId);\n        if (existingRMContainer !\u003d null) {\n          // swap containers\n          existingRMContainer \u003d getUpdateContext().swapContainer(\n              tempRMContainer, existingRMContainer, updateTpe);\n          getUpdateContext().removeFromOutstandingUpdate(\n              tempRMContainer.getAllocatedSchedulerKey(),\n              existingRMContainer.getContainer());\n          Container updatedContainer \u003d updateContainerAndNMToken(\n              existingRMContainer, updateTpe);\n          updatedContainers.add(updatedContainer);\n        }\n        tempContainerToKill.add(tempRMContainer);\n        i.remove();\n      }\n      // Release all temporary containers\n      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n      while (tempIter.hasNext()) {\n        RMContainer c \u003d tempIter.next();\n        // Mark container for release (set RRs to null, so RM does not think\n        // it is a recoverable container)\n        ((RMContainerImpl) c).setContainerRequest(null);\n\n        // Release this container async-ly so as to prevent\n        // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n        // on the app and queue which can contended for in the reverse order\n        // by the Scheduler thread.\n        ((AbstractYarnScheduler)rmContext.getScheduler())\n            .asyncContainerRelease(c);\n        tempIter.remove();\n      }\n      return updatedContainers;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
      "extendedDetails": {}
    },
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6251. Do async container release to prevent deadlock during container updates. (Arun Suresh via wangda)\n\nChange-Id: I6c67d20c5dd4d22752830ebf0ed2340824976ecb\n",
      "commitDate": "23/08/17 9:56 AM",
      "commitName": "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/08/17 7:54 AM",
      "commitNameOld": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,55 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n       ContainerUpdateType updateTpe) {\n     List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n     if (oppContainerContext \u003d\u003d null \u0026\u0026\n         (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n             || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n       return updatedContainers;\n     }\n     try {\n       writeLock.lock();\n       Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n           newlyUpdatedContainers.entrySet().iterator();\n       while (i.hasNext()) {\n         Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n         ContainerId matchedContainerId \u003d entry.getKey();\n         RMContainer tempRMContainer \u003d entry.getValue();\n \n         RMContainer existingRMContainer \u003d\n             getRMContainer(matchedContainerId);\n         if (existingRMContainer !\u003d null) {\n           // swap containers\n           existingRMContainer \u003d getUpdateContext().swapContainer(\n               tempRMContainer, existingRMContainer, updateTpe);\n           getUpdateContext().removeFromOutstandingUpdate(\n               tempRMContainer.getAllocatedSchedulerKey(),\n               existingRMContainer.getContainer());\n           Container updatedContainer \u003d updateContainerAndNMToken(\n               existingRMContainer, updateTpe);\n           updatedContainers.add(updatedContainer);\n         }\n         tempContainerToKill.add(tempRMContainer);\n         i.remove();\n       }\n       // Release all temporary containers\n       Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n       while (tempIter.hasNext()) {\n         RMContainer c \u003d tempIter.next();\n         // Mark container for release (set RRs to null, so RM does not think\n         // it is a recoverable container)\n         ((RMContainerImpl) c).setResourceRequests(null);\n-        ((AbstractYarnScheduler) rmContext.getScheduler()).completedContainer(c,\n-            SchedulerUtils.createAbnormalContainerStatus(c.getContainerId(),\n-                SchedulerUtils.UPDATED_CONTAINER),\n-            RMContainerEventType.KILL);\n+\n+        // Release this container async-ly so as to prevent\n+        // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n+        // on the app and queue which can contended for in the reverse order\n+        // by the Scheduler thread.\n+        ((AbstractYarnScheduler)rmContext.getScheduler())\n+            .asyncContainerRelease(c);\n         tempIter.remove();\n       }\n       return updatedContainers;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n      ContainerUpdateType updateTpe) {\n    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n    if (oppContainerContext \u003d\u003d null \u0026\u0026\n        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n      return updatedContainers;\n    }\n    try {\n      writeLock.lock();\n      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          newlyUpdatedContainers.entrySet().iterator();\n      while (i.hasNext()) {\n        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n        ContainerId matchedContainerId \u003d entry.getKey();\n        RMContainer tempRMContainer \u003d entry.getValue();\n\n        RMContainer existingRMContainer \u003d\n            getRMContainer(matchedContainerId);\n        if (existingRMContainer !\u003d null) {\n          // swap containers\n          existingRMContainer \u003d getUpdateContext().swapContainer(\n              tempRMContainer, existingRMContainer, updateTpe);\n          getUpdateContext().removeFromOutstandingUpdate(\n              tempRMContainer.getAllocatedSchedulerKey(),\n              existingRMContainer.getContainer());\n          Container updatedContainer \u003d updateContainerAndNMToken(\n              existingRMContainer, updateTpe);\n          updatedContainers.add(updatedContainer);\n        }\n        tempContainerToKill.add(tempRMContainer);\n        i.remove();\n      }\n      // Release all temporary containers\n      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n      while (tempIter.hasNext()) {\n        RMContainer c \u003d tempIter.next();\n        // Mark container for release (set RRs to null, so RM does not think\n        // it is a recoverable container)\n        ((RMContainerImpl) c).setResourceRequests(null);\n\n        // Release this container async-ly so as to prevent\n        // \u0027LeafQueue::completedContainer()\u0027 from trying to acquire a lock\n        // on the app and queue which can contended for in the reverse order\n        // by the Scheduler thread.\n        ((AbstractYarnScheduler)rmContext.getScheduler())\n            .asyncContainerRelease(c);\n        tempIter.remove();\n      }\n      return updatedContainers;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
          "commitDate": "28/02/17 10:35 AM",
          "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 10:23 AM",
          "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 19.01,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,52 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n-      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n+      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n+      ContainerUpdateType updateTpe) {\n+    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n+    if (oppContainerContext \u003d\u003d null \u0026\u0026\n+        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n+            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n+      return updatedContainers;\n+    }\n     try {\n       writeLock.lock();\n-      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n-          updatedContainerMap.size());\n-\n-      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n-          updatedContainerMap.entrySet().iterator();\n+      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n+          newlyUpdatedContainers.entrySet().iterator();\n       while (i.hasNext()) {\n-        RMContainer rmContainer \u003d i.next().getValue();\n-        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n-            increase ? ContainerUpdateType.INCREASE_RESOURCE :\n-                ContainerUpdateType.DECREASE_RESOURCE);\n-        if (updatedContainer !\u003d null) {\n-          returnContainerList.add(updatedContainer);\n-          i.remove();\n+        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n+        ContainerId matchedContainerId \u003d entry.getKey();\n+        RMContainer tempRMContainer \u003d entry.getValue();\n+\n+        RMContainer existingRMContainer \u003d\n+            getRMContainer(matchedContainerId);\n+        if (existingRMContainer !\u003d null) {\n+          // swap containers\n+          existingRMContainer \u003d getUpdateContext().swapContainer(\n+              tempRMContainer, existingRMContainer, updateTpe);\n+          getUpdateContext().removeFromOutstandingUpdate(\n+              tempRMContainer.getAllocatedSchedulerKey(),\n+              existingRMContainer.getContainer());\n+          Container updatedContainer \u003d updateContainerAndNMToken(\n+              existingRMContainer, updateTpe);\n+          updatedContainers.add(updatedContainer);\n         }\n+        tempContainerToKill.add(tempRMContainer);\n+        i.remove();\n       }\n-      return returnContainerList;\n+      // Release all temporary containers\n+      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n+      while (tempIter.hasNext()) {\n+        RMContainer c \u003d tempIter.next();\n+        // Mark container for release (set RRs to null, so RM does not think\n+        // it is a recoverable container)\n+        ((RMContainerImpl) c).setResourceRequests(null);\n+        ((AbstractYarnScheduler) rmContext.getScheduler()).completedContainer(c,\n+            SchedulerUtils.createAbnormalContainerStatus(c.getContainerId(),\n+                SchedulerUtils.UPDATED_CONTAINER),\n+            RMContainerEventType.KILL);\n+        tempIter.remove();\n+      }\n+      return updatedContainers;\n     } finally {\n       writeLock.unlock();\n     }\n-\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n      ContainerUpdateType updateTpe) {\n    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n    if (oppContainerContext \u003d\u003d null \u0026\u0026\n        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n      return updatedContainers;\n    }\n    try {\n      writeLock.lock();\n      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          newlyUpdatedContainers.entrySet().iterator();\n      while (i.hasNext()) {\n        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n        ContainerId matchedContainerId \u003d entry.getKey();\n        RMContainer tempRMContainer \u003d entry.getValue();\n\n        RMContainer existingRMContainer \u003d\n            getRMContainer(matchedContainerId);\n        if (existingRMContainer !\u003d null) {\n          // swap containers\n          existingRMContainer \u003d getUpdateContext().swapContainer(\n              tempRMContainer, existingRMContainer, updateTpe);\n          getUpdateContext().removeFromOutstandingUpdate(\n              tempRMContainer.getAllocatedSchedulerKey(),\n              existingRMContainer.getContainer());\n          Container updatedContainer \u003d updateContainerAndNMToken(\n              existingRMContainer, updateTpe);\n          updatedContainers.add(updatedContainer);\n        }\n        tempContainerToKill.add(tempRMContainer);\n        i.remove();\n      }\n      // Release all temporary containers\n      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n      while (tempIter.hasNext()) {\n        RMContainer c \u003d tempIter.next();\n        // Mark container for release (set RRs to null, so RM does not think\n        // it is a recoverable container)\n        ((RMContainerImpl) c).setResourceRequests(null);\n        ((AbstractYarnScheduler) rmContext.getScheduler()).completedContainer(c,\n            SchedulerUtils.createAbnormalContainerStatus(c.getContainerId(),\n                SchedulerUtils.UPDATED_CONTAINER),\n            RMContainerEventType.KILL);\n        tempIter.remove();\n      }\n      return updatedContainers;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
          "extendedDetails": {
            "oldValue": "[updatedContainerMap-Map\u003cContainerId,RMContainer\u003e, increase-boolean]",
            "newValue": "[newlyUpdatedContainers-Map\u003cContainerId,RMContainer\u003e, updateTpe-ContainerUpdateType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
          "commitDate": "28/02/17 10:35 AM",
          "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "09/02/17 10:23 AM",
          "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 19.01,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,52 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n-      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n+      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n+      ContainerUpdateType updateTpe) {\n+    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n+    if (oppContainerContext \u003d\u003d null \u0026\u0026\n+        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n+            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n+      return updatedContainers;\n+    }\n     try {\n       writeLock.lock();\n-      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n-          updatedContainerMap.size());\n-\n-      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n-          updatedContainerMap.entrySet().iterator();\n+      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n+          newlyUpdatedContainers.entrySet().iterator();\n       while (i.hasNext()) {\n-        RMContainer rmContainer \u003d i.next().getValue();\n-        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n-            increase ? ContainerUpdateType.INCREASE_RESOURCE :\n-                ContainerUpdateType.DECREASE_RESOURCE);\n-        if (updatedContainer !\u003d null) {\n-          returnContainerList.add(updatedContainer);\n-          i.remove();\n+        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n+        ContainerId matchedContainerId \u003d entry.getKey();\n+        RMContainer tempRMContainer \u003d entry.getValue();\n+\n+        RMContainer existingRMContainer \u003d\n+            getRMContainer(matchedContainerId);\n+        if (existingRMContainer !\u003d null) {\n+          // swap containers\n+          existingRMContainer \u003d getUpdateContext().swapContainer(\n+              tempRMContainer, existingRMContainer, updateTpe);\n+          getUpdateContext().removeFromOutstandingUpdate(\n+              tempRMContainer.getAllocatedSchedulerKey(),\n+              existingRMContainer.getContainer());\n+          Container updatedContainer \u003d updateContainerAndNMToken(\n+              existingRMContainer, updateTpe);\n+          updatedContainers.add(updatedContainer);\n         }\n+        tempContainerToKill.add(tempRMContainer);\n+        i.remove();\n       }\n-      return returnContainerList;\n+      // Release all temporary containers\n+      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n+      while (tempIter.hasNext()) {\n+        RMContainer c \u003d tempIter.next();\n+        // Mark container for release (set RRs to null, so RM does not think\n+        // it is a recoverable container)\n+        ((RMContainerImpl) c).setResourceRequests(null);\n+        ((AbstractYarnScheduler) rmContext.getScheduler()).completedContainer(c,\n+            SchedulerUtils.createAbnormalContainerStatus(c.getContainerId(),\n+                SchedulerUtils.UPDATED_CONTAINER),\n+            RMContainerEventType.KILL);\n+        tempIter.remove();\n+      }\n+      return updatedContainers;\n     } finally {\n       writeLock.unlock();\n     }\n-\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e newlyUpdatedContainers,\n      ContainerUpdateType updateTpe) {\n    List\u003cContainer\u003e updatedContainers \u003d new ArrayList\u003c\u003e();\n    if (oppContainerContext \u003d\u003d null \u0026\u0026\n        (ContainerUpdateType.DEMOTE_EXECUTION_TYPE \u003d\u003d updateTpe\n            || ContainerUpdateType.PROMOTE_EXECUTION_TYPE \u003d\u003d updateTpe)) {\n      return updatedContainers;\n    }\n    try {\n      writeLock.lock();\n      Iterator\u003cMap.Entry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          newlyUpdatedContainers.entrySet().iterator();\n      while (i.hasNext()) {\n        Map.Entry\u003cContainerId, RMContainer\u003e entry \u003d i.next();\n        ContainerId matchedContainerId \u003d entry.getKey();\n        RMContainer tempRMContainer \u003d entry.getValue();\n\n        RMContainer existingRMContainer \u003d\n            getRMContainer(matchedContainerId);\n        if (existingRMContainer !\u003d null) {\n          // swap containers\n          existingRMContainer \u003d getUpdateContext().swapContainer(\n              tempRMContainer, existingRMContainer, updateTpe);\n          getUpdateContext().removeFromOutstandingUpdate(\n              tempRMContainer.getAllocatedSchedulerKey(),\n              existingRMContainer.getContainer());\n          Container updatedContainer \u003d updateContainerAndNMToken(\n              existingRMContainer, updateTpe);\n          updatedContainers.add(updatedContainer);\n        }\n        tempContainerToKill.add(tempRMContainer);\n        i.remove();\n      }\n      // Release all temporary containers\n      Iterator\u003cRMContainer\u003e tempIter \u003d tempContainerToKill.iterator();\n      while (tempIter.hasNext()) {\n        RMContainer c \u003d tempIter.next();\n        // Mark container for release (set RRs to null, so RM does not think\n        // it is a recoverable container)\n        ((RMContainerImpl) c).setResourceRequests(null);\n        ((AbstractYarnScheduler) rmContext.getScheduler()).completedContainer(c,\n            SchedulerUtils.createAbnormalContainerStatus(c.getContainerId(),\n                SchedulerUtils.UPDATED_CONTAINER),\n            RMContainerEventType.KILL);\n        tempIter.remove();\n      }\n      return updatedContainers;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
          "extendedDetails": {}
        }
      ]
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n     try {\n       writeLock.lock();\n       List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n           updatedContainerMap.size());\n \n       Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n           updatedContainerMap.entrySet().iterator();\n       while (i.hasNext()) {\n         RMContainer rmContainer \u003d i.next().getValue();\n         Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n-            false, increase);\n+            increase ? ContainerUpdateType.INCREASE_RESOURCE :\n+                ContainerUpdateType.DECREASE_RESOURCE);\n         if (updatedContainer !\u003d null) {\n           returnContainerList.add(updatedContainer);\n           i.remove();\n         }\n       }\n       return returnContainerList;\n     } finally {\n       writeLock.unlock();\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n    try {\n      writeLock.lock();\n      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n          updatedContainerMap.size());\n\n      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          updatedContainerMap.entrySet().iterator();\n      while (i.hasNext()) {\n        RMContainer rmContainer \u003d i.next().getValue();\n        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n            increase ? ContainerUpdateType.INCREASE_RESOURCE :\n                ContainerUpdateType.DECREASE_RESOURCE);\n        if (updatedContainer !\u003d null) {\n          returnContainerList.add(updatedContainer);\n          i.remove();\n        }\n      }\n      return returnContainerList;\n    } finally {\n      writeLock.unlock();\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
      "extendedDetails": {}
    },
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "19/09/16 2:08 AM",
      "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "19/09/16 2:08 AM",
          "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 19.43,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,24 @@\n-  private synchronized List\u003cContainer\u003e pullNewlyUpdatedContainers(\n+  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n-    List\u003cContainer\u003e returnContainerList \u003d\n-        new ArrayList\u003cContainer\u003e(updatedContainerMap.size());\n-    for (Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n-        updatedContainerMap.entrySet().iterator(); i.hasNext();) {\n-      RMContainer rmContainer \u003d i.next().getValue();\n-      Container updatedContainer \u003d\n-          updateContainerAndNMToken(rmContainer, false, increase);\n-      if (updatedContainer !\u003d null) {\n-        returnContainerList.add(updatedContainer);\n-        i.remove();\n+    try {\n+      writeLock.lock();\n+      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n+          updatedContainerMap.size());\n+\n+      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n+          updatedContainerMap.entrySet().iterator();\n+      while (i.hasNext()) {\n+        RMContainer rmContainer \u003d i.next().getValue();\n+        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n+            false, increase);\n+        if (updatedContainer !\u003d null) {\n+          returnContainerList.add(updatedContainer);\n+          i.remove();\n+        }\n       }\n+      return returnContainerList;\n+    } finally {\n+      writeLock.unlock();\n     }\n-    return returnContainerList;\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n    try {\n      writeLock.lock();\n      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n          updatedContainerMap.size());\n\n      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          updatedContainerMap.entrySet().iterator();\n      while (i.hasNext()) {\n        RMContainer rmContainer \u003d i.next().getValue();\n        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n            false, increase);\n        if (updatedContainer !\u003d null) {\n          returnContainerList.add(updatedContainer);\n          i.remove();\n        }\n      }\n      return returnContainerList;\n    } finally {\n      writeLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "19/09/16 2:08 AM",
          "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 19.43,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,24 @@\n-  private synchronized List\u003cContainer\u003e pullNewlyUpdatedContainers(\n+  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n       Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n-    List\u003cContainer\u003e returnContainerList \u003d\n-        new ArrayList\u003cContainer\u003e(updatedContainerMap.size());\n-    for (Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n-        updatedContainerMap.entrySet().iterator(); i.hasNext();) {\n-      RMContainer rmContainer \u003d i.next().getValue();\n-      Container updatedContainer \u003d\n-          updateContainerAndNMToken(rmContainer, false, increase);\n-      if (updatedContainer !\u003d null) {\n-        returnContainerList.add(updatedContainer);\n-        i.remove();\n+    try {\n+      writeLock.lock();\n+      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n+          updatedContainerMap.size());\n+\n+      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n+          updatedContainerMap.entrySet().iterator();\n+      while (i.hasNext()) {\n+        RMContainer rmContainer \u003d i.next().getValue();\n+        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n+            false, increase);\n+        if (updatedContainer !\u003d null) {\n+          returnContainerList.add(updatedContainer);\n+          i.remove();\n+        }\n       }\n+      return returnContainerList;\n+    } finally {\n+      writeLock.unlock();\n     }\n-    return returnContainerList;\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n    try {\n      writeLock.lock();\n      List \u003cContainer\u003e returnContainerList \u003d new ArrayList \u003cContainer\u003e(\n          updatedContainerMap.size());\n\n      Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n          updatedContainerMap.entrySet().iterator();\n      while (i.hasNext()) {\n        RMContainer rmContainer \u003d i.next().getValue();\n        Container updatedContainer \u003d updateContainerAndNMToken(rmContainer,\n            false, increase);\n        if (updatedContainer !\u003d null) {\n          returnContainerList.add(updatedContainer);\n          i.remove();\n        }\n      }\n      return returnContainerList;\n    } finally {\n      writeLock.unlock();\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
          "extendedDetails": {}
        }
      ]
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,16 @@\n+  private synchronized List\u003cContainer\u003e pullNewlyUpdatedContainers(\n+      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n+    List\u003cContainer\u003e returnContainerList \u003d\n+        new ArrayList\u003cContainer\u003e(updatedContainerMap.size());\n+    for (Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n+        updatedContainerMap.entrySet().iterator(); i.hasNext();) {\n+      RMContainer rmContainer \u003d i.next().getValue();\n+      Container updatedContainer \u003d\n+          updateContainerAndNMToken(rmContainer, false, increase);\n+      if (updatedContainer !\u003d null) {\n+        returnContainerList.add(updatedContainer);\n+        i.remove();\n+      }\n+    }\n+    return returnContainerList;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized List\u003cContainer\u003e pullNewlyUpdatedContainers(\n      Map\u003cContainerId, RMContainer\u003e updatedContainerMap, boolean increase) {\n    List\u003cContainer\u003e returnContainerList \u003d\n        new ArrayList\u003cContainer\u003e(updatedContainerMap.size());\n    for (Iterator\u003cEntry\u003cContainerId, RMContainer\u003e\u003e i \u003d\n        updatedContainerMap.entrySet().iterator(); i.hasNext();) {\n      RMContainer rmContainer \u003d i.next().getValue();\n      Container updatedContainer \u003d\n          updateContainerAndNMToken(rmContainer, false, increase);\n      if (updatedContainer !\u003d null) {\n        returnContainerList.add(updatedContainer);\n        i.remove();\n      }\n    }\n    return returnContainerList;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java"
    }
  }
}