{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirDeleteOp.java",
  "functionName": "unprotectedDelete",
  "functionId": "unprotectedDelete___fsd-FSDirectory__iip-INodesInPath__reclaimContext-ReclaimContext__mtime-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
  "functionStartLine": 232,
  "functionEndLine": 268,
  "numCommitsSeen": 260,
  "timeTaken": 10110,
  "changeHistory": [
    "b2c85db86c9a62b0a03ee87547265077f664970a",
    "4536399d47f6c061e149e2504600804a0f1e093d",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
    "d244574d03903b0514b0308da85d2f06c2384524",
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823",
    "d46e1608626c64400d2b6c7693a4c035783c55b4"
  ],
  "changeHistoryShort": {
    "b2c85db86c9a62b0a03ee87547265077f664970a": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "4536399d47f6c061e149e2504600804a0f1e093d": "Ybodychange",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": "Ymultichange(Yparameterchange,Ybodychange)",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e": "Ymultichange(Yexceptionschange,Ybodychange)",
    "d244574d03903b0514b0308da85d2f06c2384524": "Ybodychange",
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Ybodychange",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ybodychange",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Ybodychange",
    "d46e1608626c64400d2b6c7693a4c035783c55b4": "Ybodychange"
  },
  "changeHistoryDetails": {
    "b2c85db86c9a62b0a03ee87547265077f664970a": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
      "commitDate": "13/05/15 9:50 PM",
      "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,37 @@\n-  private static long unprotectedDelete(\n-      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n+  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n+      ReclaimContext reclaimContext, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n-      return -1;\n+      return false;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n-      return -1;\n+      return false;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n-    fsd.updateCountForDelete(targetNode, iip);\n-    if (removed \u003d\u003d 0) {\n-      return 0;\n-    }\n-\n     // collect block and update quota\n-    INode.ReclaimContext reclaimContext \u003d new INode.ReclaimContext(\n-        fsd.getBlockStoragePolicySuite(), collectedBlocks,\n-        removedINodes, removedUCFiles);\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(reclaimContext);\n     } else {\n-      QuotaCounts counts \u003d targetNode.cleanSubtree(reclaimContext,\n-          CURRENT_STATE_ID, latestSnapshot);\n-      removed \u003d counts.getNameSpace();\n-      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n+      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n-    return removed;\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n      ReclaimContext reclaimContext, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return false;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return false;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(reclaimContext);\n    } else {\n      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, iip-INodesInPath, collectedBlocks-BlocksMapUpdateInfo, removedINodes-List\u003cINode\u003e, removedUCFiles-List\u003cLong\u003e, mtime-long]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, reclaimContext-ReclaimContext, mtime-long]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,37 @@\n-  private static long unprotectedDelete(\n-      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n+  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n+      ReclaimContext reclaimContext, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n-      return -1;\n+      return false;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n-      return -1;\n+      return false;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n-    fsd.updateCountForDelete(targetNode, iip);\n-    if (removed \u003d\u003d 0) {\n-      return 0;\n-    }\n-\n     // collect block and update quota\n-    INode.ReclaimContext reclaimContext \u003d new INode.ReclaimContext(\n-        fsd.getBlockStoragePolicySuite(), collectedBlocks,\n-        removedINodes, removedUCFiles);\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(reclaimContext);\n     } else {\n-      QuotaCounts counts \u003d targetNode.cleanSubtree(reclaimContext,\n-          CURRENT_STATE_ID, latestSnapshot);\n-      removed \u003d counts.getNameSpace();\n-      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n+      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n-    return removed;\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n      ReclaimContext reclaimContext, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return false;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return false;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(reclaimContext);\n    } else {\n      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "long",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,37 @@\n-  private static long unprotectedDelete(\n-      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n+  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n+      ReclaimContext reclaimContext, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n-      return -1;\n+      return false;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n-      return -1;\n+      return false;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n-    fsd.updateCountForDelete(targetNode, iip);\n-    if (removed \u003d\u003d 0) {\n-      return 0;\n-    }\n-\n     // collect block and update quota\n-    INode.ReclaimContext reclaimContext \u003d new INode.ReclaimContext(\n-        fsd.getBlockStoragePolicySuite(), collectedBlocks,\n-        removedINodes, removedUCFiles);\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(reclaimContext);\n     } else {\n-      QuotaCounts counts \u003d targetNode.cleanSubtree(reclaimContext,\n-          CURRENT_STATE_ID, latestSnapshot);\n-      removed \u003d counts.getNameSpace();\n-      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n+      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n-    return removed;\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean unprotectedDelete(FSDirectory fsd, INodesInPath iip,\n      ReclaimContext reclaimContext, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return false;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return false;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(reclaimContext);\n    } else {\n      targetNode.cleanSubtree(reclaimContext, CURRENT_STATE_ID, latestSnapshot);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "4536399d47f6c061e149e2504600804a0f1e093d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8357. Consolidate parameters of INode.CleanSubtree() into a parameter objects. Contributed by Li Lu.\n",
      "commitDate": "09/05/15 10:51 PM",
      "commitName": "4536399d47f6c061e149e2504600804a0f1e093d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/05/15 11:04 PM",
      "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,49 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n+    INode.ReclaimContext reclaimContext \u003d new INode.ReclaimContext(\n+        fsd.getBlockStoragePolicySuite(), collectedBlocks,\n+        removedINodes, removedUCFiles);\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n-      targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n-        collectedBlocks, removedINodes, removedUCFiles);\n+      targetNode.destroyAndCollectBlocks(reclaimContext);\n     } else {\n-      QuotaCounts counts \u003d targetNode.cleanSubtree(\n-        fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n-          latestSnapshot, collectedBlocks, removedINodes, removedUCFiles);\n+      QuotaCounts counts \u003d targetNode.cleanSubtree(reclaimContext,\n+          CURRENT_STATE_ID, latestSnapshot);\n       removed \u003d counts.getNameSpace();\n       fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    INode.ReclaimContext reclaimContext \u003d new INode.ReclaimContext(\n        fsd.getBlockStoragePolicySuite(), collectedBlocks,\n        removedINodes, removedUCFiles);\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(reclaimContext);\n    } else {\n      QuotaCounts counts \u003d targetNode.cleanSubtree(reclaimContext,\n          CURRENT_STATE_ID, latestSnapshot);\n      removed \u003d counts.getNameSpace();\n      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
      "extendedDetails": {}
    },
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:04 PM",
      "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:04 PM",
          "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "28/04/15 6:05 PM",
          "commitNameOld": "c79e7f7d997596e0c38ae4cddff2bd0910581c16",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 10.21,
          "commitsBetweenForRepo": 163,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,48 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, long mtime) {\n+      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n-        collectedBlocks, removedINodes);\n+        collectedBlocks, removedINodes, removedUCFiles);\n     } else {\n       QuotaCounts counts \u003d targetNode.cleanSubtree(\n         fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n-          latestSnapshot, collectedBlocks, removedINodes);\n+          latestSnapshot, collectedBlocks, removedINodes, removedUCFiles);\n       removed \u003d counts.getNameSpace();\n       fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n        collectedBlocks, removedINodes, removedUCFiles);\n    } else {\n      QuotaCounts counts \u003d targetNode.cleanSubtree(\n        fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, removedUCFiles);\n      removed \u003d counts.getNameSpace();\n      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, iip-INodesInPath, collectedBlocks-BlocksMapUpdateInfo, removedINodes-List\u003cINode\u003e, mtime-long]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, collectedBlocks-BlocksMapUpdateInfo, removedINodes-List\u003cINode\u003e, removedUCFiles-List\u003cLong\u003e, mtime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:04 PM",
          "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "28/04/15 6:05 PM",
          "commitNameOld": "c79e7f7d997596e0c38ae4cddff2bd0910581c16",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 10.21,
          "commitsBetweenForRepo": 163,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,48 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, long mtime) {\n+      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n-        collectedBlocks, removedINodes);\n+        collectedBlocks, removedINodes, removedUCFiles);\n     } else {\n       QuotaCounts counts \u003d targetNode.cleanSubtree(\n         fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n-          latestSnapshot, collectedBlocks, removedINodes);\n+          latestSnapshot, collectedBlocks, removedINodes, removedUCFiles);\n       removed \u003d counts.getNameSpace();\n       fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n        collectedBlocks, removedINodes, removedUCFiles);\n    } else {\n      QuotaCounts counts \u003d targetNode.cleanSubtree(\n        fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, removedUCFiles);\n      removed \u003d counts.getNameSpace();\n      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "02/02/15 4:32 PM",
      "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 8.76,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,48 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n-      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+      targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n+        collectedBlocks, removedINodes);\n     } else {\n-      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n+      QuotaCounts counts \u003d targetNode.cleanSubtree(\n+        fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes);\n-      removed \u003d counts.get(Quota.NAMESPACE);\n-      fsd.updateCountNoQuotaCheck(iip, iip.length() - 1,\n-          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n+      removed \u003d counts.getNameSpace();\n+      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(fsd.getBlockStoragePolicySuite(),\n        collectedBlocks, removedINodes);\n    } else {\n      QuotaCounts counts \u003d targetNode.cleanSubtree(\n        fsd.getBlockStoragePolicySuite(), CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes);\n      removed \u003d counts.getNameSpace();\n      fsd.updateCountNoQuotaCheck(iip, iip.length() -1, counts.negation());\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
      "extendedDetails": {}
    },
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
      "commitDate": "02/02/15 4:32 PM",
      "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
          "commitDate": "02/02/15 4:32 PM",
          "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "28/01/15 3:25 PM",
          "commitNameOld": "d244574d03903b0514b0308da85d2f06c2384524",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.05,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,47 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n+      List\u003cINode\u003e removedINodes, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n-          latestSnapshot, collectedBlocks, removedINodes, true);\n+          latestSnapshot, collectedBlocks, removedINodes);\n       removed \u003d counts.get(Quota.NAMESPACE);\n-      // TODO: quota verification may fail the deletion here. We should not\n-      // count the snapshot diff into quota usage in the future.\n-      fsd.updateCount(iip, -counts.get(Quota.NAMESPACE),\n-          -counts.get(Quota.DISKSPACE), true);\n+      fsd.updateCountNoQuotaCheck(iip, iip.length() - 1,\n+          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes);\n      removed \u003d counts.get(Quota.NAMESPACE);\n      fsd.updateCountNoQuotaCheck(iip, iip.length() - 1,\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "[QuotaExceededException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
          "commitDate": "02/02/15 4:32 PM",
          "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "28/01/15 3:25 PM",
          "commitNameOld": "d244574d03903b0514b0308da85d2f06c2384524",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.05,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,47 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n-      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n+      List\u003cINode\u003e removedINodes, long mtime) {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n \n     fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n     // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n-          latestSnapshot, collectedBlocks, removedINodes, true);\n+          latestSnapshot, collectedBlocks, removedINodes);\n       removed \u003d counts.get(Quota.NAMESPACE);\n-      // TODO: quota verification may fail the deletion here. We should not\n-      // count the snapshot diff into quota usage in the future.\n-      fsd.updateCount(iip, -counts.get(Quota.NAMESPACE),\n-          -counts.get(Quota.DISKSPACE), true);\n+      fsd.updateCountNoQuotaCheck(iip, iip.length() - 1,\n+          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n \n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes);\n      removed \u003d counts.get(Quota.NAMESPACE);\n      fsd.updateCountNoQuotaCheck(iip, iip.length() - 1,\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "d244574d03903b0514b0308da85d2f06c2384524": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7611. deleteSnapshot and delete of a file can leave orphaned blocks in the blocksMap on NameNode restart. Contributed by Jing Zhao and Byron Wong.\n",
      "commitDate": "28/01/15 3:25 PM",
      "commitName": "d244574d03903b0514b0308da85d2f06c2384524",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/01/15 12:56 PM",
      "commitNameOld": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 11.1,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,49 @@\n   private static long unprotectedDelete(\n       FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n+\n+    fsd.updateCountForDelete(targetNode, iip);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n \n-    // collect block\n+    // collect block and update quota\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n-      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n-          -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n+      // TODO: quota verification may fail the deletion here. We should not\n+      // count the snapshot diff into quota usage in the future.\n+      fsd.updateCount(iip, -counts.get(Quota.NAMESPACE),\n+          -counts.get(Quota.DISKSPACE), true);\n     }\n+\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n\n    fsd.updateCountForDelete(targetNode, iip);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block and update quota\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n      // TODO: quota verification may fail the deletion here. We should not\n      // count the snapshot diff into quota usage in the future.\n      fsd.updateCount(iip, -counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n    }\n\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
      "extendedDetails": {}
    },
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "17/01/15 12:56 PM",
      "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "17/01/15 12:56 PM",
          "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "17/01/15 10:40 AM",
          "commitNameOld": "2908fe4ec52f78d74e4207274a34d88d54cd468f",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n+  private static long unprotectedDelete(\n+      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n-    assert hasWriteLock();\n+    assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n-    long removed \u003d removeLastINode(iip);\n+    long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n-    \n+\n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
            "oldMethodName": "unprotectedDelete",
            "newMethodName": "unprotectedDelete"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "17/01/15 12:56 PM",
          "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "17/01/15 10:40 AM",
          "commitNameOld": "2908fe4ec52f78d74e4207274a34d88d54cd468f",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n+  private static long unprotectedDelete(\n+      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n-    assert hasWriteLock();\n+    assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n-    long removed \u003d removeLastINode(iip);\n+    long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n-    \n+\n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "17/01/15 12:56 PM",
          "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "17/01/15 10:40 AM",
          "commitNameOld": "2908fe4ec52f78d74e4207274a34d88d54cd468f",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n+  private static long unprotectedDelete(\n+      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n-    assert hasWriteLock();\n+    assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n-    long removed \u003d removeLastINode(iip);\n+    long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n-    \n+\n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "17/01/15 12:56 PM",
          "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "17/01/15 10:40 AM",
          "commitNameOld": "2908fe4ec52f78d74e4207274a34d88d54cd468f",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,44 @@\n-  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n+  private static long unprotectedDelete(\n+      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n-    assert hasWriteLock();\n+    assert fsd.hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n-    long removed \u003d removeLastINode(iip);\n+    long removed \u003d fsd.removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n-    \n+\n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static long unprotectedDelete(\n      FSDirectory fsd, INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert fsd.hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d fsd.removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n\n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirDeleteOp.java",
          "extendedDetails": {
            "oldValue": "[iip-INodesInPath, collectedBlocks-BlocksMapUpdateInfo, removedINodes-List\u003cINode\u003e, mtime-long]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, collectedBlocks-BlocksMapUpdateInfo, removedINodes-List\u003cINode\u003e, mtime-long]"
          }
        }
      ]
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n-      Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/12/14 2:09 PM",
      "commitNameOld": "26d8dec756da1d9bd3df3b41a4dd5d8ff03bc5b2",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n-          + targetNode.getFullPathName() + \" is removed\");\n+          + iip.getPath() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + iip.getPath() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6838. Code cleanup for unnecessary INode replacement. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 2:28 PM",
      "commitName": "80691b073fe7c104a8684c0a8900a1657bcdc03f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "04/08/14 8:44 AM",
      "commitNameOld": "431857d09dac2a9554f7ee8a6a92ae05844d0066",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 7.24,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final int latestSnapshot \u003d iip.getLatestSnapshotId();\n-    targetNode \u003d targetNode.recordModification(latestSnapshot);\n-    iip.setLastINode(targetNode);\n+    targetNode.recordModification(latestSnapshot);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n           latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + targetNode.getFullPathName() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode.recordModification(latestSnapshot);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + targetNode.getFullPathName() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n-    final Snapshot latestSnapshot \u003d iip.getLatestSnapshot();\n+    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n     targetNode \u003d targetNode.recordModification(latestSnapshot);\n     iip.setLastINode(targetNode);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n-      Quota.Counts counts \u003d targetNode.cleanSubtree(null, latestSnapshot,\n-          collectedBlocks, removedINodes, true);\n+      Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+          latestSnapshot, collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + targetNode.getFullPathName() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final int latestSnapshot \u003d iip.getLatestSnapshotId();\n    targetNode \u003d targetNode.recordModification(latestSnapshot);\n    iip.setLastINode(targetNode);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n          latestSnapshot, collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + targetNode.getFullPathName() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/12/13 9:41 AM",
      "commitNameOld": "18159be495f96bde4bd4fa2cacb14aafb87e87bc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.69,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final Snapshot latestSnapshot \u003d iip.getLatestSnapshot();\n-    targetNode \u003d targetNode.recordModification(latestSnapshot, inodeMap);\n+    targetNode \u003d targetNode.recordModification(latestSnapshot);\n     iip.setLastINode(targetNode);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n-    parent.updateModificationTime(mtime, latestSnapshot, inodeMap);\n+    parent.updateModificationTime(mtime, latestSnapshot);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(null, latestSnapshot,\n           collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n           -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + targetNode.getFullPathName() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final Snapshot latestSnapshot \u003d iip.getLatestSnapshot();\n    targetNode \u003d targetNode.recordModification(latestSnapshot);\n    iip.setLastINode(targetNode);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(null, latestSnapshot,\n          collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + targetNode.getFullPathName() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d46e1608626c64400d2b6c7693a4c035783c55b4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 1:15 PM",
      "commitName": "d46e1608626c64400d2b6c7693a4c035783c55b4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/05/13 10:26 AM",
      "commitNameOld": "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n       List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n     assert hasWriteLock();\n \n     // check if target node exists\n     INode targetNode \u003d iip.getLastINode();\n     if (targetNode \u003d\u003d null) {\n       return -1;\n     }\n \n     // record modification\n     final Snapshot latestSnapshot \u003d iip.getLatestSnapshot();\n     targetNode \u003d targetNode.recordModification(latestSnapshot, inodeMap);\n     iip.setLastINode(targetNode);\n \n     // Remove the node from the namespace\n     long removed \u003d removeLastINode(iip);\n     if (removed \u003d\u003d -1) {\n       return -1;\n     }\n \n     // set the parent\u0027s modification time\n     final INodeDirectory parent \u003d targetNode.getParent();\n     parent.updateModificationTime(mtime, latestSnapshot, inodeMap);\n     if (removed \u003d\u003d 0) {\n       return 0;\n     }\n     \n     // collect block\n     if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n       targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n     } else {\n       Quota.Counts counts \u003d targetNode.cleanSubtree(null, latestSnapshot,\n-          collectedBlocks, removedINodes);\n+          collectedBlocks, removedINodes, true);\n       parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n-          -counts.get(Quota.DISKSPACE), true, Snapshot.INVALID_ID);\n+          -counts.get(Quota.DISKSPACE), true);\n       removed \u003d counts.get(Quota.NAMESPACE);\n     }\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n           + targetNode.getFullPathName() + \" is removed\");\n     }\n     return removed;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long unprotectedDelete(INodesInPath iip, BlocksMapUpdateInfo collectedBlocks,\n      List\u003cINode\u003e removedINodes, long mtime) throws QuotaExceededException {\n    assert hasWriteLock();\n\n    // check if target node exists\n    INode targetNode \u003d iip.getLastINode();\n    if (targetNode \u003d\u003d null) {\n      return -1;\n    }\n\n    // record modification\n    final Snapshot latestSnapshot \u003d iip.getLatestSnapshot();\n    targetNode \u003d targetNode.recordModification(latestSnapshot, inodeMap);\n    iip.setLastINode(targetNode);\n\n    // Remove the node from the namespace\n    long removed \u003d removeLastINode(iip);\n    if (removed \u003d\u003d -1) {\n      return -1;\n    }\n\n    // set the parent\u0027s modification time\n    final INodeDirectory parent \u003d targetNode.getParent();\n    parent.updateModificationTime(mtime, latestSnapshot, inodeMap);\n    if (removed \u003d\u003d 0) {\n      return 0;\n    }\n    \n    // collect block\n    if (!targetNode.isInLatestSnapshot(latestSnapshot)) {\n      targetNode.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n    } else {\n      Quota.Counts counts \u003d targetNode.cleanSubtree(null, latestSnapshot,\n          collectedBlocks, removedINodes, true);\n      parent.addSpaceConsumed(-counts.get(Quota.NAMESPACE),\n          -counts.get(Quota.DISKSPACE), true);\n      removed \u003d counts.get(Quota.NAMESPACE);\n    }\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* FSDirectory.unprotectedDelete: \"\n          + targetNode.getFullPathName() + \" is removed\");\n    }\n    return removed;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    }
  }
}