{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Util.java",
  "functionName": "receiveFile",
  "functionId": "receiveFile___url-String__localPaths-List__File____dstStorage-Storage__getChecksum-boolean__advertisedSize-long__advertisedDigest-MD5Hash__fsImageName-String__stream-InputStream__throttler-DataTransferThrottler",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
  "functionStartLine": 194,
  "functionEndLine": 330,
  "numCommitsSeen": 53,
  "timeTaken": 5383,
  "changeHistory": [
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c",
    "13d4bcfe3535a2df79c2a56e7578716d15497ff4",
    "7ec609b28989303fe0cc36812f225028b0251b32",
    "fd1c09be3e7c67c188a1dd7e4fccb3d92dcc5b5b",
    "4da8490b512a33a255ed27309860859388d7c168",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "c0d666c74e9ea76564a2458c6c0a78ae7afa9fea",
    "94a1632fcb677fda6f4d812614026417f1d0a360"
  ],
  "changeHistoryShort": {
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c": "Ybodychange",
    "13d4bcfe3535a2df79c2a56e7578716d15497ff4": "Ybodychange",
    "7ec609b28989303fe0cc36812f225028b0251b32": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "fd1c09be3e7c67c188a1dd7e4fccb3d92dcc5b5b": "Ybodychange",
    "4da8490b512a33a255ed27309860859388d7c168": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "c0d666c74e9ea76564a2458c6c0a78ae7afa9fea": "Ybodychange",
    "94a1632fcb677fda6f4d812614026417f1d0a360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6a28a2b914664fbbb5267f13e82d42b3bb49610c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11914. Add more diagnosis info for fsimage transfer failure. Contributed by Yongjun Zhang.\n",
      "commitDate": "05/06/17 4:31 PM",
      "commitName": "6a28a2b914664fbbb5267f13e82d42b3bb49610c",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "03/05/17 4:29 PM",
      "commitNameOld": "81092b1f1193cb0d4208960b51ab4ffaddeafe01",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 33.0,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws\n       IOException {\n     long startTime \u003d Time.monotonicNow();\n     Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n     StringBuilder xferStats \u003d new StringBuilder();\n     double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n+    int num \u003d 1;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             FileOutputStream fos \u003d new FileOutputStream(f);\n             outputStreams.add(fos);\n             streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n \n-      int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n       double xferSec \u003d Math.max(\n           ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n       long xferKb \u003d received / 1024;\n       xferCombined +\u003d xferSec;\n       xferStats.append(\n           String.format(\" The file download took %.2fs at %.2f KB/s.\",\n               xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n         double writeSec \u003d Math.max(((float)\n             (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n         xferCombined +\u003d writeSec;\n         xferStats.append(String\n             .format(\" Synchronous (fsync) write to disk of \" +\n                 streamPathMap.get(fos).getAbsolutePath() +\n                 \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n-            \" is not of the advertised size \" +\n-            advertisedSize);\n+            \" is not of the advertised size \" + advertisedSize +\n+            \". Fsimage name: \" + fsImageName + \" lastReceived: \" + num);\n       }\n     }\n     xferStats.insert(0, String.format(\"Combined time for file download and\" +\n         \" fsync to all disks took %.2fs.\", xferCombined));\n     LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" +\n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws\n      IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n\n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n    int num \u003d 1;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n\n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The file download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n            .format(\" Synchronous (fsync) write to disk of \" +\n                streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n            \" is not of the advertised size \" + advertisedSize +\n            \". Fsimage name: \" + fsImageName + \" lastReceived: \" + num);\n      }\n    }\n    xferStats.insert(0, String.format(\"Combined time for file download and\" +\n        \" fsync to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n\n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" +\n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
      "extendedDetails": {}
    },
    "13d4bcfe3535a2df79c2a56e7578716d15497ff4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4025. QJM: Sychronize past log segments to JNs that missed them. Contributed by Hanisha Koneru.\n",
      "commitDate": "22/02/17 4:33 PM",
      "commitName": "13d4bcfe3535a2df79c2a56e7578716d15497ff4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "09/01/17 6:05 PM",
      "commitNameOld": "7ec609b28989303fe0cc36812f225028b0251b32",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 43.94,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws\n       IOException {\n     long startTime \u003d Time.monotonicNow();\n     Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n     StringBuilder xferStats \u003d new StringBuilder();\n     double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             FileOutputStream fos \u003d new FileOutputStream(f);\n             outputStreams.add(fos);\n             streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n \n       int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n       double xferSec \u003d Math.max(\n           ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n       long xferKb \u003d received / 1024;\n       xferCombined +\u003d xferSec;\n       xferStats.append(\n-          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n+          String.format(\" The file download took %.2fs at %.2f KB/s.\",\n               xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n         double writeSec \u003d Math.max(((float)\n             (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n         xferCombined +\u003d writeSec;\n         xferStats.append(String\n             .format(\" Synchronous (fsync) write to disk of \" +\n                 streamPathMap.get(fos).getAbsolutePath() +\n                 \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n             \" is not of the advertised size \" +\n             advertisedSize);\n       }\n     }\n-    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n+    xferStats.insert(0, String.format(\"Combined time for file download and\" +\n         \" fsync to all disks took %.2fs.\", xferCombined));\n     LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" +\n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws\n      IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n\n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n\n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n\n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The file download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n            .format(\" Synchronous (fsync) write to disk of \" +\n                streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n            \" is not of the advertised size \" +\n            advertisedSize);\n      }\n    }\n    xferStats.insert(0, String.format(\"Combined time for file download and\" +\n        \" fsync to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n\n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" +\n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
      "extendedDetails": {}
    },
    "7ec609b28989303fe0cc36812f225028b0251b32": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-11273. Move TransferFsImage#doGetUrl function to a Util class. Contributed by Hanisha Koneru.\n",
      "commitDate": "09/01/17 6:05 PM",
      "commitName": "7ec609b28989303fe0cc36812f225028b0251b32",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-11273. Move TransferFsImage#doGetUrl function to a Util class. Contributed by Hanisha Koneru.\n",
          "commitDate": "09/01/17 6:05 PM",
          "commitName": "7ec609b28989303fe0cc36812f225028b0251b32",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/01/17 6:01 PM",
          "commitNameOld": "511d39e0740f36bf937e7bcf974e1050f0e7c1e0",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,138 +1,137 @@\n-  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n+  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n-      DataTransferThrottler throttler) throws IOException {\n+      DataTransferThrottler throttler) throws\n+      IOException {\n     long startTime \u003d Time.monotonicNow();\n     Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n     StringBuilder xferStats \u003d new StringBuilder();\n     double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n-      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n+      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n-    \n+\n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             FileOutputStream fos \u003d new FileOutputStream(f);\n             outputStreams.add(fos);\n             streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n-        \n+\n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n-      \n+\n       int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n       double xferSec \u003d Math.max(\n-                 ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n+          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n       long xferKb \u003d received / 1024;\n       xferCombined +\u003d xferSec;\n       xferStats.append(\n           String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n               xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n         double writeSec \u003d Math.max(((float)\n-               (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n+            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n         xferCombined +\u003d writeSec;\n         xferStats.append(String\n-                .format(\" Synchronous (fsync) write to disk of \" +\n-                 streamPathMap.get(fos).getAbsolutePath() +\n+            .format(\" Synchronous (fsync) write to disk of \" +\n+                streamPathMap.get(fos).getAbsolutePath() +\n                 \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n-                              \" is not of the advertised size \" +\n-                              advertisedSize);\n+            \" is not of the advertised size \" +\n+            advertisedSize);\n       }\n     }\n-    xferStats.insert(\n-        0, String.format(\n-            \"Combined time for fsimage download and fsync \" +\n-            \"to all disks took %.2fs.\", xferCombined));\n+    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n+        \" fsync to all disks took %.2fs.\", xferCombined));\n     LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n-      \n+\n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n-            computedDigest + \" does not match advertised digest \" + \n+            computedDigest + \" does not match advertised digest \" +\n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n-    }    \n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws\n      IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n\n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n\n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n\n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n            .format(\" Synchronous (fsync) write to disk of \" +\n                streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n            \" is not of the advertised size \" +\n            advertisedSize);\n      }\n    }\n    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n        \" fsync to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n\n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" +\n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
            "oldMethodName": "receiveFile",
            "newMethodName": "receiveFile"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-11273. Move TransferFsImage#doGetUrl function to a Util class. Contributed by Hanisha Koneru.\n",
          "commitDate": "09/01/17 6:05 PM",
          "commitName": "7ec609b28989303fe0cc36812f225028b0251b32",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/01/17 6:01 PM",
          "commitNameOld": "511d39e0740f36bf937e7bcf974e1050f0e7c1e0",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,138 +1,137 @@\n-  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n+  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n-      DataTransferThrottler throttler) throws IOException {\n+      DataTransferThrottler throttler) throws\n+      IOException {\n     long startTime \u003d Time.monotonicNow();\n     Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n     StringBuilder xferStats \u003d new StringBuilder();\n     double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n-      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n+      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n-    \n+\n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             FileOutputStream fos \u003d new FileOutputStream(f);\n             outputStreams.add(fos);\n             streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n-        \n+\n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n-      \n+\n       int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n       double xferSec \u003d Math.max(\n-                 ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n+          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n       long xferKb \u003d received / 1024;\n       xferCombined +\u003d xferSec;\n       xferStats.append(\n           String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n               xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n         double writeSec \u003d Math.max(((float)\n-               (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n+            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n         xferCombined +\u003d writeSec;\n         xferStats.append(String\n-                .format(\" Synchronous (fsync) write to disk of \" +\n-                 streamPathMap.get(fos).getAbsolutePath() +\n+            .format(\" Synchronous (fsync) write to disk of \" +\n+                streamPathMap.get(fos).getAbsolutePath() +\n                 \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n-                              \" is not of the advertised size \" +\n-                              advertisedSize);\n+            \" is not of the advertised size \" +\n+            advertisedSize);\n       }\n     }\n-    xferStats.insert(\n-        0, String.format(\n-            \"Combined time for fsimage download and fsync \" +\n-            \"to all disks took %.2fs.\", xferCombined));\n+    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n+        \" fsync to all disks took %.2fs.\", xferCombined));\n     LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n-      \n+\n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n-            computedDigest + \" does not match advertised digest \" + \n+            computedDigest + \" does not match advertised digest \" +\n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n-    }    \n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws\n      IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n\n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n\n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n\n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n            .format(\" Synchronous (fsync) write to disk of \" +\n                streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n            \" is not of the advertised size \" +\n            advertisedSize);\n      }\n    }\n    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n        \" fsync to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n\n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" +\n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11273. Move TransferFsImage#doGetUrl function to a Util class. Contributed by Hanisha Koneru.\n",
          "commitDate": "09/01/17 6:05 PM",
          "commitName": "7ec609b28989303fe0cc36812f225028b0251b32",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/01/17 6:01 PM",
          "commitNameOld": "511d39e0740f36bf937e7bcf974e1050f0e7c1e0",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,138 +1,137 @@\n-  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n+  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n-      DataTransferThrottler throttler) throws IOException {\n+      DataTransferThrottler throttler) throws\n+      IOException {\n     long startTime \u003d Time.monotonicNow();\n     Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n     StringBuilder xferStats \u003d new StringBuilder();\n     double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n-      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n+      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n-    \n+\n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             FileOutputStream fos \u003d new FileOutputStream(f);\n             outputStreams.add(fos);\n             streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n-        \n+\n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n-      \n+\n       int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n       double xferSec \u003d Math.max(\n-                 ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n+          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n       long xferKb \u003d received / 1024;\n       xferCombined +\u003d xferSec;\n       xferStats.append(\n           String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n               xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n         double writeSec \u003d Math.max(((float)\n-               (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n+            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n         xferCombined +\u003d writeSec;\n         xferStats.append(String\n-                .format(\" Synchronous (fsync) write to disk of \" +\n-                 streamPathMap.get(fos).getAbsolutePath() +\n+            .format(\" Synchronous (fsync) write to disk of \" +\n+                streamPathMap.get(fos).getAbsolutePath() +\n                 \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n-                              \" is not of the advertised size \" +\n-                              advertisedSize);\n+            \" is not of the advertised size \" +\n+            advertisedSize);\n       }\n     }\n-    xferStats.insert(\n-        0, String.format(\n-            \"Combined time for fsimage download and fsync \" +\n-            \"to all disks took %.2fs.\", xferCombined));\n+    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n+        \" fsync to all disks took %.2fs.\", xferCombined));\n     LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n-      \n+\n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n-            computedDigest + \" does not match advertised digest \" + \n+            computedDigest + \" does not match advertised digest \" +\n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n-    }    \n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws\n      IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003c\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n\n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n\n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n\n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n          ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n            (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n            .format(\" Synchronous (fsync) write to disk of \" +\n                streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n            \" is not of the advertised size \" +\n            advertisedSize);\n      }\n    }\n    xferStats.insert(0, String.format(\"Combined time for fsimage download and\" +\n        \" fsync to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n\n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" +\n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Util.java",
          "extendedDetails": {}
        }
      ]
    },
    "fd1c09be3e7c67c188a1dd7e4fccb3d92dcc5b5b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9521. TransferFsImage.receiveFile should account and log separate times for image download and fsync to disk. Contributed by Wellington Chevreuil\n",
      "commitDate": "07/03/16 3:44 AM",
      "commitName": "fd1c09be3e7c67c188a1dd7e4fccb3d92dcc5b5b",
      "commitAuthor": "Harsh J",
      "commitDateOld": "23/10/15 2:01 PM",
      "commitNameOld": "ab3c4cff4af338caaa23be0ec383fc1fe473714f",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 135.61,
      "commitsBetweenForRepo": 901,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,138 @@\n   private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws IOException {\n     long startTime \u003d Time.monotonicNow();\n+    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n+    StringBuilder xferStats \u003d new StringBuilder();\n+    double xferCombined \u003d 0;\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n     \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n-            outputStreams.add(new FileOutputStream(f));\n+            FileOutputStream fos \u003d new FileOutputStream(f);\n+            outputStreams.add(fos);\n+            streamPathMap.put(fos, f);\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n         \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n       \n       int num \u003d 1;\n       byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n+      double xferSec \u003d Math.max(\n+                 ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n+      long xferKb \u003d received / 1024;\n+      xferCombined +\u003d xferSec;\n+      xferStats.append(\n+          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n+              xferSec, xferKb / xferSec));\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n+        long flushStartTime \u003d Time.monotonicNow();\n         fos.getChannel().force(true);\n         fos.close();\n+        double writeSec \u003d Math.max(((float)\n+               (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n+        xferCombined +\u003d writeSec;\n+        xferStats.append(String\n+                .format(\" Synchronous (fsync) write to disk of \" +\n+                 streamPathMap.get(fos).getAbsolutePath() +\n+                \" took %.2fs.\", writeSec));\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n                               \" is not of the advertised size \" +\n                               advertisedSize);\n       }\n     }\n-    double xferSec \u003d Math.max(\n-        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n-    long xferKb \u003d received / 1024;\n-    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n-        xferSec, xferKb / xferSec));\n+    xferStats.insert(\n+        0, String.format(\n+            \"Combined time for fsimage download and fsync \" +\n+            \"to all disks took %.2fs.\", xferCombined));\n+    LOG.info(xferStats.toString());\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n       \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" + \n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws IOException {\n    long startTime \u003d Time.monotonicNow();\n    Map\u003cFileOutputStream, File\u003e streamPathMap \u003d new HashMap\u003c\u003e();\n    StringBuilder xferStats \u003d new StringBuilder();\n    double xferCombined \u003d 0;\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n    \n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            FileOutputStream fos \u003d new FileOutputStream(f);\n            outputStreams.add(fos);\n            streamPathMap.put(fos, f);\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n        \n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n      \n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n      double xferSec \u003d Math.max(\n                 ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n      long xferKb \u003d received / 1024;\n      xferCombined +\u003d xferSec;\n      xferStats.append(\n          String.format(\" The fsimage download took %.2fs at %.2f KB/s.\",\n              xferSec, xferKb / xferSec));\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        long flushStartTime \u003d Time.monotonicNow();\n        fos.getChannel().force(true);\n        fos.close();\n        double writeSec \u003d Math.max(((float)\n               (flushStartTime - Time.monotonicNow())) / 1000.0, 0.001);\n        xferCombined +\u003d writeSec;\n        xferStats.append(String\n                .format(\" Synchronous (fsync) write to disk of \" +\n                 streamPathMap.get(fos).getAbsolutePath() +\n                \" took %.2fs.\", writeSec));\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n                              \" is not of the advertised size \" +\n                              advertisedSize);\n      }\n    }\n    xferStats.insert(\n        0, String.format(\n            \"Combined time for fsimage download and fsync \" +\n            \"to all disks took %.2fs.\", xferCombined));\n    LOG.info(xferStats.toString());\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n      \n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" + \n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "4da8490b512a33a255ed27309860859388d7c168": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8314. Move HdfsServerConstants#IO_FILE_BUFFER_SIZE and SMALL_BUFFER_SIZE to the users. Contributed by Li Lu.\n",
      "commitDate": "05/05/15 3:41 PM",
      "commitName": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,118 @@\n   private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws IOException {\n     long startTime \u003d Time.monotonicNow();\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n     \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             outputStreams.add(new FileOutputStream(f));\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n         \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n       \n       int num \u003d 1;\n-      byte[] buf \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n+      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         fos.getChannel().force(true);\n         fos.close();\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n                               \" is not of the advertised size \" +\n                               advertisedSize);\n       }\n     }\n     double xferSec \u003d Math.max(\n         ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n     long xferKb \u003d received / 1024;\n     LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n         xferSec, xferKb / xferSec));\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n       \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" + \n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws IOException {\n    long startTime \u003d Time.monotonicNow();\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n    \n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            outputStreams.add(new FileOutputStream(f));\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n        \n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n      \n      int num \u003d 1;\n      byte[] buf \u003d new byte[IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        fos.getChannel().force(true);\n        fos.close();\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n                              \" is not of the advertised size \" +\n                              advertisedSize);\n      }\n    }\n    double xferSec \u003d Math.max(\n        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n    long xferKb \u003d received / 1024;\n    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n        xferSec, xferKb / xferSec));\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n      \n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" + \n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/03/15 3:35 PM",
      "commitNameOld": "c5eac9c6fe937ff32f4efed89d34c06974fac4d6",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 60.73,
      "commitsBetweenForRepo": 538,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,118 @@\n   private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws IOException {\n     long startTime \u003d Time.monotonicNow();\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n     \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             outputStreams.add(new FileOutputStream(f));\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n         \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n       \n       int num \u003d 1;\n-      byte[] buf \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n+      byte[] buf \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         fos.getChannel().force(true);\n         fos.close();\n       }\n \n       // Something went wrong and did not finish reading.\n       // Remove the temporary files.\n       if (!finishedReceiving) {\n         deleteTmpFiles(localPaths);\n       }\n \n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n                               \" is not of the advertised size \" +\n                               advertisedSize);\n       }\n     }\n     double xferSec \u003d Math.max(\n         ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n     long xferKb \u003d received / 1024;\n     LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n         xferSec, xferKb / xferSec));\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n       \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n         deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" + \n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws IOException {\n    long startTime \u003d Time.monotonicNow();\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n    \n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            outputStreams.add(new FileOutputStream(f));\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n        \n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n      \n      int num \u003d 1;\n      byte[] buf \u003d new byte[HdfsServerConstants.IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        fos.getChannel().force(true);\n        fos.close();\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n                              \" is not of the advertised size \" +\n                              advertisedSize);\n      }\n    }\n    double xferSec \u003d Math.max(\n        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n    long xferKb \u003d received / 1024;\n    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n        xferSec, xferKb / xferSec));\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n      \n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" + \n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "c0d666c74e9ea76564a2458c6c0a78ae7afa9fea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7373. Clean up temporary files after fsimage transfer failures. Contributed by Kihwal Lee\n",
      "commitDate": "18/12/14 10:58 AM",
      "commitName": "c0d666c74e9ea76564a2458c6c0a78ae7afa9fea",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "02/09/14 2:02 PM",
      "commitNameOld": "faa4455be512e070fa420084be8d1be5c72f3b08",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 106.91,
      "commitsBetweenForRepo": 993,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,118 @@\n   private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n       Storage dstStorage, boolean getChecksum, long advertisedSize,\n       MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n       DataTransferThrottler throttler) throws IOException {\n     long startTime \u003d Time.monotonicNow();\n     if (localPaths !\u003d null) {\n       // If the local paths refer to directories, use the server-provided header\n       // as the filename within that directory\n       List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n       for (File localPath : localPaths) {\n         if (localPath.isDirectory()) {\n           if (fsImageName \u003d\u003d null) {\n             throw new IOException(\"No filename header provided by server\");\n           }\n           newLocalPaths.add(new File(localPath, fsImageName));\n         } else {\n           newLocalPaths.add(localPath);\n         }\n       }\n       localPaths \u003d newLocalPaths;\n     }\n     \n \n     long received \u003d 0;\n     MessageDigest digester \u003d null;\n     if (getChecksum) {\n       digester \u003d MD5Hash.getDigester();\n       stream \u003d new DigestInputStream(stream, digester);\n     }\n     boolean finishedReceiving \u003d false;\n \n     List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n \n     try {\n       if (localPaths !\u003d null) {\n         for (File f : localPaths) {\n           try {\n             if (f.exists()) {\n               LOG.warn(\"Overwriting existing file \" + f\n                   + \" with file downloaded from \" + url);\n             }\n             outputStreams.add(new FileOutputStream(f));\n           } catch (IOException ioe) {\n             LOG.warn(\"Unable to download file \" + f, ioe);\n             // This will be null if we\u0027re downloading the fsimage to a file\n             // outside of an NNStorage directory.\n             if (dstStorage !\u003d null \u0026\u0026\n                 (dstStorage instanceof StorageErrorReporter)) {\n               ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n             }\n           }\n         }\n         \n         if (outputStreams.isEmpty()) {\n           throw new IOException(\n               \"Unable to download to any storage directory\");\n         }\n       }\n       \n       int num \u003d 1;\n       byte[] buf \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n       while (num \u003e 0) {\n         num \u003d stream.read(buf);\n         if (num \u003e 0) {\n           received +\u003d num;\n           for (FileOutputStream fos : outputStreams) {\n             fos.write(buf, 0, num);\n           }\n           if (throttler !\u003d null) {\n             throttler.throttle(num);\n           }\n         }\n       }\n       finishedReceiving \u003d true;\n     } finally {\n       stream.close();\n       for (FileOutputStream fos : outputStreams) {\n         fos.getChannel().force(true);\n         fos.close();\n       }\n+\n+      // Something went wrong and did not finish reading.\n+      // Remove the temporary files.\n+      if (!finishedReceiving) {\n+        deleteTmpFiles(localPaths);\n+      }\n+\n       if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n         // only throw this exception if we think we read all of it on our end\n         // -- otherwise a client-side IOException would be masked by this\n         // exception that makes it look like a server-side problem!\n+        deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" received length \" + received +\n                               \" is not of the advertised size \" +\n                               advertisedSize);\n       }\n     }\n     double xferSec \u003d Math.max(\n         ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n     long xferKb \u003d received / 1024;\n     LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n         xferSec, xferKb / xferSec));\n \n     if (digester !\u003d null) {\n       MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n       \n       if (advertisedDigest !\u003d null \u0026\u0026\n           !computedDigest.equals(advertisedDigest)) {\n+        deleteTmpFiles(localPaths);\n         throw new IOException(\"File \" + url + \" computed digest \" +\n             computedDigest + \" does not match advertised digest \" + \n             advertisedDigest);\n       }\n       return computedDigest;\n     } else {\n       return null;\n     }    \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws IOException {\n    long startTime \u003d Time.monotonicNow();\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n    \n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            outputStreams.add(new FileOutputStream(f));\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n        \n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n      \n      int num \u003d 1;\n      byte[] buf \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        fos.getChannel().force(true);\n        fos.close();\n      }\n\n      // Something went wrong and did not finish reading.\n      // Remove the temporary files.\n      if (!finishedReceiving) {\n        deleteTmpFiles(localPaths);\n      }\n\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" received length \" + received +\n                              \" is not of the advertised size \" +\n                              advertisedSize);\n      }\n    }\n    double xferSec \u003d Math.max(\n        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n    long xferKb \u003d received / 1024;\n    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n        xferSec, xferKb / xferSec));\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n      \n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        deleteTmpFiles(localPaths);\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" + \n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java",
      "extendedDetails": {}
    },
    "94a1632fcb677fda6f4d812614026417f1d0a360": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:25 PM",
      "commitName": "94a1632fcb677fda6f4d812614026417f1d0a360",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,109 @@\n+  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n+      Storage dstStorage, boolean getChecksum, long advertisedSize,\n+      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n+      DataTransferThrottler throttler) throws IOException {\n+    long startTime \u003d Time.monotonicNow();\n+    if (localPaths !\u003d null) {\n+      // If the local paths refer to directories, use the server-provided header\n+      // as the filename within that directory\n+      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n+      for (File localPath : localPaths) {\n+        if (localPath.isDirectory()) {\n+          if (fsImageName \u003d\u003d null) {\n+            throw new IOException(\"No filename header provided by server\");\n+          }\n+          newLocalPaths.add(new File(localPath, fsImageName));\n+        } else {\n+          newLocalPaths.add(localPath);\n+        }\n+      }\n+      localPaths \u003d newLocalPaths;\n+    }\n+    \n+\n+    long received \u003d 0;\n+    MessageDigest digester \u003d null;\n+    if (getChecksum) {\n+      digester \u003d MD5Hash.getDigester();\n+      stream \u003d new DigestInputStream(stream, digester);\n+    }\n+    boolean finishedReceiving \u003d false;\n+\n+    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n+\n+    try {\n+      if (localPaths !\u003d null) {\n+        for (File f : localPaths) {\n+          try {\n+            if (f.exists()) {\n+              LOG.warn(\"Overwriting existing file \" + f\n+                  + \" with file downloaded from \" + url);\n+            }\n+            outputStreams.add(new FileOutputStream(f));\n+          } catch (IOException ioe) {\n+            LOG.warn(\"Unable to download file \" + f, ioe);\n+            // This will be null if we\u0027re downloading the fsimage to a file\n+            // outside of an NNStorage directory.\n+            if (dstStorage !\u003d null \u0026\u0026\n+                (dstStorage instanceof StorageErrorReporter)) {\n+              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n+            }\n+          }\n+        }\n+        \n+        if (outputStreams.isEmpty()) {\n+          throw new IOException(\n+              \"Unable to download to any storage directory\");\n+        }\n+      }\n+      \n+      int num \u003d 1;\n+      byte[] buf \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n+      while (num \u003e 0) {\n+        num \u003d stream.read(buf);\n+        if (num \u003e 0) {\n+          received +\u003d num;\n+          for (FileOutputStream fos : outputStreams) {\n+            fos.write(buf, 0, num);\n+          }\n+          if (throttler !\u003d null) {\n+            throttler.throttle(num);\n+          }\n+        }\n+      }\n+      finishedReceiving \u003d true;\n+    } finally {\n+      stream.close();\n+      for (FileOutputStream fos : outputStreams) {\n+        fos.getChannel().force(true);\n+        fos.close();\n+      }\n+      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n+        // only throw this exception if we think we read all of it on our end\n+        // -- otherwise a client-side IOException would be masked by this\n+        // exception that makes it look like a server-side problem!\n+        throw new IOException(\"File \" + url + \" received length \" + received +\n+                              \" is not of the advertised size \" +\n+                              advertisedSize);\n+      }\n+    }\n+    double xferSec \u003d Math.max(\n+        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n+    long xferKb \u003d received / 1024;\n+    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n+        xferSec, xferKb / xferSec));\n+\n+    if (digester !\u003d null) {\n+      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n+      \n+      if (advertisedDigest !\u003d null \u0026\u0026\n+          !computedDigest.equals(advertisedDigest)) {\n+        throw new IOException(\"File \" + url + \" computed digest \" +\n+            computedDigest + \" does not match advertised digest \" + \n+            advertisedDigest);\n+      }\n+      return computedDigest;\n+    } else {\n+      return null;\n+    }    \n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static MD5Hash receiveFile(String url, List\u003cFile\u003e localPaths,\n      Storage dstStorage, boolean getChecksum, long advertisedSize,\n      MD5Hash advertisedDigest, String fsImageName, InputStream stream,\n      DataTransferThrottler throttler) throws IOException {\n    long startTime \u003d Time.monotonicNow();\n    if (localPaths !\u003d null) {\n      // If the local paths refer to directories, use the server-provided header\n      // as the filename within that directory\n      List\u003cFile\u003e newLocalPaths \u003d new ArrayList\u003cFile\u003e();\n      for (File localPath : localPaths) {\n        if (localPath.isDirectory()) {\n          if (fsImageName \u003d\u003d null) {\n            throw new IOException(\"No filename header provided by server\");\n          }\n          newLocalPaths.add(new File(localPath, fsImageName));\n        } else {\n          newLocalPaths.add(localPath);\n        }\n      }\n      localPaths \u003d newLocalPaths;\n    }\n    \n\n    long received \u003d 0;\n    MessageDigest digester \u003d null;\n    if (getChecksum) {\n      digester \u003d MD5Hash.getDigester();\n      stream \u003d new DigestInputStream(stream, digester);\n    }\n    boolean finishedReceiving \u003d false;\n\n    List\u003cFileOutputStream\u003e outputStreams \u003d Lists.newArrayList();\n\n    try {\n      if (localPaths !\u003d null) {\n        for (File f : localPaths) {\n          try {\n            if (f.exists()) {\n              LOG.warn(\"Overwriting existing file \" + f\n                  + \" with file downloaded from \" + url);\n            }\n            outputStreams.add(new FileOutputStream(f));\n          } catch (IOException ioe) {\n            LOG.warn(\"Unable to download file \" + f, ioe);\n            // This will be null if we\u0027re downloading the fsimage to a file\n            // outside of an NNStorage directory.\n            if (dstStorage !\u003d null \u0026\u0026\n                (dstStorage instanceof StorageErrorReporter)) {\n              ((StorageErrorReporter)dstStorage).reportErrorOnFile(f);\n            }\n          }\n        }\n        \n        if (outputStreams.isEmpty()) {\n          throw new IOException(\n              \"Unable to download to any storage directory\");\n        }\n      }\n      \n      int num \u003d 1;\n      byte[] buf \u003d new byte[HdfsConstants.IO_FILE_BUFFER_SIZE];\n      while (num \u003e 0) {\n        num \u003d stream.read(buf);\n        if (num \u003e 0) {\n          received +\u003d num;\n          for (FileOutputStream fos : outputStreams) {\n            fos.write(buf, 0, num);\n          }\n          if (throttler !\u003d null) {\n            throttler.throttle(num);\n          }\n        }\n      }\n      finishedReceiving \u003d true;\n    } finally {\n      stream.close();\n      for (FileOutputStream fos : outputStreams) {\n        fos.getChannel().force(true);\n        fos.close();\n      }\n      if (finishedReceiving \u0026\u0026 received !\u003d advertisedSize) {\n        // only throw this exception if we think we read all of it on our end\n        // -- otherwise a client-side IOException would be masked by this\n        // exception that makes it look like a server-side problem!\n        throw new IOException(\"File \" + url + \" received length \" + received +\n                              \" is not of the advertised size \" +\n                              advertisedSize);\n      }\n    }\n    double xferSec \u003d Math.max(\n        ((float)(Time.monotonicNow() - startTime)) / 1000.0, 0.001);\n    long xferKb \u003d received / 1024;\n    LOG.info(String.format(\"Transfer took %.2fs at %.2f KB/s\",\n        xferSec, xferKb / xferSec));\n\n    if (digester !\u003d null) {\n      MD5Hash computedDigest \u003d new MD5Hash(digester.digest());\n      \n      if (advertisedDigest !\u003d null \u0026\u0026\n          !computedDigest.equals(advertisedDigest)) {\n        throw new IOException(\"File \" + url + \" computed digest \" +\n            computedDigest + \" does not match advertised digest \" + \n            advertisedDigest);\n      }\n      return computedDigest;\n    } else {\n      return null;\n    }    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/TransferFsImage.java"
    }
  }
}