{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MapFile.java",
  "functionName": "mergePass",
  "functionId": "mergePass",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/MapFile.java",
  "functionStartLine": 941,
  "functionEndLine": 986,
  "numCommitsSeen": 11,
  "timeTaken": 914,
  "changeHistory": [
    "48c7ee7553af94a57952bca03b49c04b9bbfab45"
  ],
  "changeHistoryShort": {
    "48c7ee7553af94a57952bca03b49c04b9bbfab45": "Yintroduced"
  },
  "changeHistoryDetails": {
    "48c7ee7553af94a57952bca03b49c04b9bbfab45": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-11569. Provide Merge API for MapFile to merge multiple similar MapFiles to one MapFile. Contributed by Vinayakumar B.\n",
      "commitDate": "27/02/15 12:46 AM",
      "commitName": "48c7ee7553af94a57952bca03b49c04b9bbfab45",
      "commitAuthor": "Tsuyoshi Ozawa",
      "diff": "@@ -0,0 +1,46 @@\n+    private void mergePass() throws IOException {\n+      // re-usable array\n+      WritableComparable[] keys \u003d new WritableComparable[inReaders.length];\n+      Writable[] values \u003d new Writable[inReaders.length];\n+      // Read first key/value from all inputs\n+      for (int i \u003d 0; i \u003c inReaders.length; i++) {\n+        keys[i] \u003d ReflectionUtils.newInstance(keyClass, null);\n+        values[i] \u003d ReflectionUtils.newInstance(valueClass, null);\n+        if (!inReaders[i].next(keys[i], values[i])) {\n+          // Handle empty files\n+          keys[i] \u003d null;\n+          values[i] \u003d null;\n+        }\n+      }\n+\n+      do {\n+        int currentEntry \u003d -1;\n+        WritableComparable currentKey \u003d null;\n+        Writable currentValue \u003d null;\n+        for (int i \u003d 0; i \u003c keys.length; i++) {\n+          if (keys[i] \u003d\u003d null) {\n+            // Skip Readers reached EOF\n+            continue;\n+          }\n+          if (currentKey \u003d\u003d null || comparator.compare(currentKey, keys[i]) \u003e 0) {\n+            currentEntry \u003d i;\n+            currentKey \u003d keys[i];\n+            currentValue \u003d values[i];\n+          }\n+        }\n+        if (currentKey \u003d\u003d null) {\n+          // Merge Complete\n+          break;\n+        }\n+        // Write the selected key/value to merge stream\n+        outWriter.append(currentKey, currentValue);\n+        // Replace the already written key/value in keys/values arrays with the\n+        // next key/value from the selected input\n+        if (!inReaders[currentEntry].next(keys[currentEntry],\n+            values[currentEntry])) {\n+          // EOF for this file\n+          keys[currentEntry] \u003d null;\n+          values[currentEntry] \u003d null;\n+        }\n+      } while (true);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void mergePass() throws IOException {\n      // re-usable array\n      WritableComparable[] keys \u003d new WritableComparable[inReaders.length];\n      Writable[] values \u003d new Writable[inReaders.length];\n      // Read first key/value from all inputs\n      for (int i \u003d 0; i \u003c inReaders.length; i++) {\n        keys[i] \u003d ReflectionUtils.newInstance(keyClass, null);\n        values[i] \u003d ReflectionUtils.newInstance(valueClass, null);\n        if (!inReaders[i].next(keys[i], values[i])) {\n          // Handle empty files\n          keys[i] \u003d null;\n          values[i] \u003d null;\n        }\n      }\n\n      do {\n        int currentEntry \u003d -1;\n        WritableComparable currentKey \u003d null;\n        Writable currentValue \u003d null;\n        for (int i \u003d 0; i \u003c keys.length; i++) {\n          if (keys[i] \u003d\u003d null) {\n            // Skip Readers reached EOF\n            continue;\n          }\n          if (currentKey \u003d\u003d null || comparator.compare(currentKey, keys[i]) \u003e 0) {\n            currentEntry \u003d i;\n            currentKey \u003d keys[i];\n            currentValue \u003d values[i];\n          }\n        }\n        if (currentKey \u003d\u003d null) {\n          // Merge Complete\n          break;\n        }\n        // Write the selected key/value to merge stream\n        outWriter.append(currentKey, currentValue);\n        // Replace the already written key/value in keys/values arrays with the\n        // next key/value from the selected input\n        if (!inReaders[currentEntry].next(keys[currentEntry],\n            values[currentEntry])) {\n          // EOF for this file\n          keys[currentEntry] \u003d null;\n          values[currentEntry] \u003d null;\n        }\n      } while (true);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/MapFile.java"
    }
  }
}