{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "INodeFile.java",
  "functionName": "computeQuotaDeltaForTruncate",
  "functionId": "computeQuotaDeltaForTruncate___newLength-long__bsps-BlockStoragePolicy__delta-QuotaCounts",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
  "functionStartLine": 1145,
  "functionEndLine": 1193,
  "numCommitsSeen": 266,
  "timeTaken": 5884,
  "changeHistory": [
    "0faee62a0c8c1b8fd83227babfd00fbc2b26bddf",
    "745d04be59accf80feda0ad38efcc74ba362f2ca",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "6bacaa9a5233cbad7f311ccd9d8f8dc9375c732d",
    "544f75d6512fefd0e36f24a35e6b7472ca7bf301",
    "6d5da9484185ca9f585195d6da069b9cd5be4044",
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
    "d368d3647a858644b9fcd3be33d9fea2a6962f69"
  ],
  "changeHistoryShort": {
    "0faee62a0c8c1b8fd83227babfd00fbc2b26bddf": "Ybodychange",
    "745d04be59accf80feda0ad38efcc74ba362f2ca": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "6bacaa9a5233cbad7f311ccd9d8f8dc9375c732d": "Ybodychange",
    "544f75d6512fefd0e36f24a35e6b7472ca7bf301": "Ybodychange",
    "6d5da9484185ca9f585195d6da069b9cd5be4044": "Ybodychange",
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
    "d368d3647a858644b9fcd3be33d9fea2a6962f69": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0faee62a0c8c1b8fd83227babfd00fbc2b26bddf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10764. Fix INodeFile#getBlocks to not return null. Contributed by Arpit Agarwal.\n",
      "commitDate": "19/08/16 10:13 PM",
      "commitName": "0faee62a0c8c1b8fd83227babfd00fbc2b26bddf",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "22/06/16 11:17 AM",
      "commitNameOld": "17eae9ebb30a3b106c4f6ae0c5374a3ab83abd8a",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 58.46,
      "commitsBetweenForRepo": 541,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n     final BlockInfo[] blocks \u003d getBlocks();\n-    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n+    if (blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n     for (BlockInfo b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n     BlockInfo[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n       BlockInfo bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n       delta.addStorageSpace(-truncatedBytes * bi.getReplication());\n       if (bsps !\u003d null) {\n         List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(bi.getReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfo[] blocks \u003d getBlocks();\n    if (blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfo b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfo[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfo bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * bi.getReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(bi.getReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "745d04be59accf80feda0ad38efcc74ba362f2ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
      "commitDate": "22/08/15 12:09 AM",
      "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/08/15 3:11 PM",
      "commitNameOld": "4e14f7982a6e57bf08deb3b266806c2b779a157d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,49 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n     final BlockInfo[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n     for (BlockInfo b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n     BlockInfo[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n       BlockInfo bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n-      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n+      delta.addStorageSpace(-truncatedBytes * bi.getReplication());\n       if (bsps !\u003d null) {\n-        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n-            getPreferredBlockReplication());\n+        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(bi.getReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfo[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfo b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfo[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfo bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * bi.getReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(bi.getReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "13/05/15 9:50 PM",
      "commitNameOld": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 13.74,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n-    final BlockInfoContiguous[] blocks \u003d getBlocks();\n+    final BlockInfo[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n-    for (BlockInfoContiguous b : blocks) {\n+    for (BlockInfo b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n-    BlockInfoContiguous[] sblocks \u003d null;\n+    BlockInfo[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n-      BlockInfoContiguous bi \u003d blocks[i];\n+      BlockInfo bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n       delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n       if (bsps !\u003d null) {\n         List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n             getPreferredBlockReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfo[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfo b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfo[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfo bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getPreferredBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "6bacaa9a5233cbad7f311ccd9d8f8dc9375c732d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7936. Erasure coding: resolving conflicts in the branch when merging trunk changes (this commit is for HDFS-8327 and HDFS-8357). Contributed by Zhe Zhang.\n",
      "commitDate": "26/05/15 12:01 PM",
      "commitName": "6bacaa9a5233cbad7f311ccd9d8f8dc9375c732d",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:58 AM",
      "commitNameOld": "4d0bc724f29b646e252f53d1c654a23e8526a4bf",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n     final BlockInfo[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n-    for (BlockInfoContiguous b : blocks) {\n+    for (BlockInfo b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n-    BlockInfoContiguous[] sblocks \u003d null;\n+    BlockInfo[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n       BlockInfo bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n       delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n       if (bsps !\u003d null) {\n         List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n             getPreferredBlockReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfo[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfo b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfo[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfo bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getPreferredBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "544f75d6512fefd0e36f24a35e6b7472ca7bf301": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7936. Erasure coding: resolving conflicts when merging with HDFS-7903, HDFS-7435 and HDFS-7930 (this commit is for HDFS-7930 only)\n",
      "commitDate": "26/05/15 11:43 AM",
      "commitName": "544f75d6512fefd0e36f24a35e6b7472ca7bf301",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:43 AM",
      "commitNameOld": "57a84c0d149b693c913416975cafe6de4e23c321",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n-    final BlockInfoContiguous[] blocks \u003d getBlocks();\n+    final BlockInfo[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n     for (BlockInfoContiguous b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n     BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n-      BlockInfoContiguous bi \u003d blocks[i];\n+      BlockInfo bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n       delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n       if (bsps !\u003d null) {\n         List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n             getPreferredBlockReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfo[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfo bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getPreferredBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "6d5da9484185ca9f585195d6da069b9cd5be4044": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8255. Rename getBlockReplication to getPreferredBlockReplication. (Contributed by Zhe Zhang)\n",
      "commitDate": "12/05/15 6:29 AM",
      "commitName": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthor": "yliu",
      "commitDateOld": "09/05/15 10:51 PM",
      "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.32,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   void computeQuotaDeltaForTruncate(\n       long newLength, BlockStoragePolicy bsps,\n       QuotaCounts delta) {\n     final BlockInfoContiguous[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n       return;\n     }\n \n     long size \u003d 0;\n     for (BlockInfoContiguous b : blocks) {\n       size +\u003d b.getNumBytes();\n     }\n \n     BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n       sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n     }\n \n     for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n          size -\u003d blocks[i].getNumBytes(), --i) {\n       BlockInfoContiguous bi \u003d blocks[i];\n       long truncatedBytes;\n       if (size - newLength \u003c bi.getNumBytes()) {\n         // Record a full block as the last block will be copied during\n         // recovery\n         truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n       } else {\n         truncatedBytes \u003d bi.getNumBytes();\n       }\n \n       // The block exist in snapshot, adding back the truncated bytes in the\n       // existing files\n       if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n         truncatedBytes -\u003d bi.getNumBytes();\n       }\n \n-      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n+      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n       if (bsps !\u003d null) {\n         List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n-            getBlockReplication());\n+            getPreferredBlockReplication());\n         for (StorageType t : types) {\n           if (t.supportTypeQuota()) {\n             delta.addTypeSpace(t, -truncatedBytes);\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfoContiguous bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getPreferredBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getPreferredBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
      "extendedDetails": {}
    },
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:09 PM",
      "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:09 PM",
          "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-  long computeQuotaDeltaForTruncate(final long newLength) {\n+  void computeQuotaDeltaForTruncate(\n+      long newLength, BlockStoragePolicy bsps,\n+      QuotaCounts delta) {\n     final BlockInfoContiguous[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n-      return 0;\n+      return;\n     }\n \n-    int n \u003d 0;\n     long size \u003d 0;\n-    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n-      size +\u003d blocks[n].getNumBytes();\n-    }\n-    final boolean onBoundary \u003d size \u003d\u003d newLength;\n-\n-    long truncateSize \u003d 0;\n-    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n-      truncateSize +\u003d blocks[i].getNumBytes();\n+    for (BlockInfoContiguous b : blocks) {\n+      size +\u003d b.getNumBytes();\n     }\n \n+    BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n-      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n-      if (sblocks !\u003d null) {\n-        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n-            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n-          truncateSize -\u003d blocks[i].getNumBytes();\n+      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n+    }\n+\n+    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n+         size -\u003d blocks[i].getNumBytes(), --i) {\n+      BlockInfoContiguous bi \u003d blocks[i];\n+      long truncatedBytes;\n+      if (size - newLength \u003c bi.getNumBytes()) {\n+        // Record a full block as the last block will be copied during\n+        // recovery\n+        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n+      } else {\n+        truncatedBytes \u003d bi.getNumBytes();\n+      }\n+\n+      // The block exist in snapshot, adding back the truncated bytes in the\n+      // existing files\n+      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n+        truncatedBytes -\u003d bi.getNumBytes();\n+      }\n+\n+      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n+      if (bsps !\u003d null) {\n+        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n+            getBlockReplication());\n+        for (StorageType t : types) {\n+          if (t.supportTypeQuota()) {\n+            delta.addTypeSpace(t, -truncatedBytes);\n+          }\n         }\n       }\n     }\n-    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfoContiguous bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
          "extendedDetails": {
            "oldValue": "[newLength-long(modifiers-final)]",
            "newValue": "[newLength-long, bsps-BlockStoragePolicy, delta-QuotaCounts]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:09 PM",
          "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-  long computeQuotaDeltaForTruncate(final long newLength) {\n+  void computeQuotaDeltaForTruncate(\n+      long newLength, BlockStoragePolicy bsps,\n+      QuotaCounts delta) {\n     final BlockInfoContiguous[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n-      return 0;\n+      return;\n     }\n \n-    int n \u003d 0;\n     long size \u003d 0;\n-    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n-      size +\u003d blocks[n].getNumBytes();\n-    }\n-    final boolean onBoundary \u003d size \u003d\u003d newLength;\n-\n-    long truncateSize \u003d 0;\n-    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n-      truncateSize +\u003d blocks[i].getNumBytes();\n+    for (BlockInfoContiguous b : blocks) {\n+      size +\u003d b.getNumBytes();\n     }\n \n+    BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n-      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n-      if (sblocks !\u003d null) {\n-        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n-            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n-          truncateSize -\u003d blocks[i].getNumBytes();\n+      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n+    }\n+\n+    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n+         size -\u003d blocks[i].getNumBytes(), --i) {\n+      BlockInfoContiguous bi \u003d blocks[i];\n+      long truncatedBytes;\n+      if (size - newLength \u003c bi.getNumBytes()) {\n+        // Record a full block as the last block will be copied during\n+        // recovery\n+        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n+      } else {\n+        truncatedBytes \u003d bi.getNumBytes();\n+      }\n+\n+      // The block exist in snapshot, adding back the truncated bytes in the\n+      // existing files\n+      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n+        truncatedBytes -\u003d bi.getNumBytes();\n+      }\n+\n+      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n+      if (bsps !\u003d null) {\n+        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n+            getBlockReplication());\n+        for (StorageType t : types) {\n+          if (t.supportTypeQuota()) {\n+            delta.addTypeSpace(t, -truncatedBytes);\n+          }\n         }\n       }\n     }\n-    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfoContiguous bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
          "extendedDetails": {
            "oldValue": "long",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:09 PM",
          "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-  long computeQuotaDeltaForTruncate(final long newLength) {\n+  void computeQuotaDeltaForTruncate(\n+      long newLength, BlockStoragePolicy bsps,\n+      QuotaCounts delta) {\n     final BlockInfoContiguous[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n-      return 0;\n+      return;\n     }\n \n-    int n \u003d 0;\n     long size \u003d 0;\n-    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n-      size +\u003d blocks[n].getNumBytes();\n-    }\n-    final boolean onBoundary \u003d size \u003d\u003d newLength;\n-\n-    long truncateSize \u003d 0;\n-    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n-      truncateSize +\u003d blocks[i].getNumBytes();\n+    for (BlockInfoContiguous b : blocks) {\n+      size +\u003d b.getNumBytes();\n     }\n \n+    BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n-      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n-      if (sblocks !\u003d null) {\n-        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n-            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n-          truncateSize -\u003d blocks[i].getNumBytes();\n+      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n+    }\n+\n+    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n+         size -\u003d blocks[i].getNumBytes(), --i) {\n+      BlockInfoContiguous bi \u003d blocks[i];\n+      long truncatedBytes;\n+      if (size - newLength \u003c bi.getNumBytes()) {\n+        // Record a full block as the last block will be copied during\n+        // recovery\n+        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n+      } else {\n+        truncatedBytes \u003d bi.getNumBytes();\n+      }\n+\n+      // The block exist in snapshot, adding back the truncated bytes in the\n+      // existing files\n+      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n+        truncatedBytes -\u003d bi.getNumBytes();\n+      }\n+\n+      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n+      if (bsps !\u003d null) {\n+        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n+            getBlockReplication());\n+        for (StorageType t : types) {\n+          if (t.supportTypeQuota()) {\n+            delta.addTypeSpace(t, -truncatedBytes);\n+          }\n         }\n       }\n     }\n-    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfoContiguous bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:09 PM",
          "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-  long computeQuotaDeltaForTruncate(final long newLength) {\n+  void computeQuotaDeltaForTruncate(\n+      long newLength, BlockStoragePolicy bsps,\n+      QuotaCounts delta) {\n     final BlockInfoContiguous[] blocks \u003d getBlocks();\n     if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n-      return 0;\n+      return;\n     }\n \n-    int n \u003d 0;\n     long size \u003d 0;\n-    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n-      size +\u003d blocks[n].getNumBytes();\n-    }\n-    final boolean onBoundary \u003d size \u003d\u003d newLength;\n-\n-    long truncateSize \u003d 0;\n-    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n-      truncateSize +\u003d blocks[i].getNumBytes();\n+    for (BlockInfoContiguous b : blocks) {\n+      size +\u003d b.getNumBytes();\n     }\n \n+    BlockInfoContiguous[] sblocks \u003d null;\n     FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n     if (sf !\u003d null) {\n       FileDiff diff \u003d sf.getDiffs().getLast();\n-      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n-      if (sblocks !\u003d null) {\n-        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n-            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n-          truncateSize -\u003d blocks[i].getNumBytes();\n+      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n+    }\n+\n+    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n+         size -\u003d blocks[i].getNumBytes(), --i) {\n+      BlockInfoContiguous bi \u003d blocks[i];\n+      long truncatedBytes;\n+      if (size - newLength \u003c bi.getNumBytes()) {\n+        // Record a full block as the last block will be copied during\n+        // recovery\n+        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n+      } else {\n+        truncatedBytes \u003d bi.getNumBytes();\n+      }\n+\n+      // The block exist in snapshot, adding back the truncated bytes in the\n+      // existing files\n+      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n+        truncatedBytes -\u003d bi.getNumBytes();\n+      }\n+\n+      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n+      if (bsps !\u003d null) {\n+        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n+            getBlockReplication());\n+        for (StorageType t : types) {\n+          if (t.supportTypeQuota()) {\n+            delta.addTypeSpace(t, -truncatedBytes);\n+          }\n         }\n       }\n     }\n-    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void computeQuotaDeltaForTruncate(\n      long newLength, BlockStoragePolicy bsps,\n      QuotaCounts delta) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return;\n    }\n\n    long size \u003d 0;\n    for (BlockInfoContiguous b : blocks) {\n      size +\u003d b.getNumBytes();\n    }\n\n    BlockInfoContiguous[] sblocks \u003d null;\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n    }\n\n    for (int i \u003d blocks.length - 1; i \u003e\u003d 0 \u0026\u0026 size \u003e newLength;\n         size -\u003d blocks[i].getNumBytes(), --i) {\n      BlockInfoContiguous bi \u003d blocks[i];\n      long truncatedBytes;\n      if (size - newLength \u003c bi.getNumBytes()) {\n        // Record a full block as the last block will be copied during\n        // recovery\n        truncatedBytes \u003d bi.getNumBytes() - getPreferredBlockSize();\n      } else {\n        truncatedBytes \u003d bi.getNumBytes();\n      }\n\n      // The block exist in snapshot, adding back the truncated bytes in the\n      // existing files\n      if (sblocks !\u003d null \u0026\u0026 i \u003c sblocks.length \u0026\u0026 bi.equals(sblocks[i])) {\n        truncatedBytes -\u003d bi.getNumBytes();\n      }\n\n      delta.addStorageSpace(-truncatedBytes * getBlockReplication());\n      if (bsps !\u003d null) {\n        List\u003cStorageType\u003e types \u003d bsps.chooseStorageTypes(\n            getBlockReplication());\n        for (StorageType t : types) {\n          if (t.supportTypeQuota()) {\n            delta.addTypeSpace(t, -truncatedBytes);\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java",
          "extendedDetails": {
            "oldValue": "[newLength-long(modifiers-final)]",
            "newValue": "[newLength-long, bsps-BlockStoragePolicy, delta-QuotaCounts]"
          }
        }
      ]
    },
    "d368d3647a858644b9fcd3be33d9fea2a6962f69": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7957. Truncate should verify quota before making changes. Contributed by Jing Zhao.\n",
      "commitDate": "20/03/15 11:50 AM",
      "commitName": "d368d3647a858644b9fcd3be33d9fea2a6962f69",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,31 @@\n+  long computeQuotaDeltaForTruncate(final long newLength) {\n+    final BlockInfoContiguous[] blocks \u003d getBlocks();\n+    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n+      return 0;\n+    }\n+\n+    int n \u003d 0;\n+    long size \u003d 0;\n+    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n+      size +\u003d blocks[n].getNumBytes();\n+    }\n+    final boolean onBoundary \u003d size \u003d\u003d newLength;\n+\n+    long truncateSize \u003d 0;\n+    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n+      truncateSize +\u003d blocks[i].getNumBytes();\n+    }\n+\n+    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n+    if (sf !\u003d null) {\n+      FileDiff diff \u003d sf.getDiffs().getLast();\n+      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n+      if (sblocks !\u003d null) {\n+        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n+            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n+          truncateSize -\u003d blocks[i].getNumBytes();\n+        }\n+      }\n+    }\n+    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  long computeQuotaDeltaForTruncate(final long newLength) {\n    final BlockInfoContiguous[] blocks \u003d getBlocks();\n    if (blocks \u003d\u003d null || blocks.length \u003d\u003d 0) {\n      return 0;\n    }\n\n    int n \u003d 0;\n    long size \u003d 0;\n    for (; n \u003c blocks.length \u0026\u0026 newLength \u003e size; n++) {\n      size +\u003d blocks[n].getNumBytes();\n    }\n    final boolean onBoundary \u003d size \u003d\u003d newLength;\n\n    long truncateSize \u003d 0;\n    for (int i \u003d (onBoundary ? n : n - 1); i \u003c blocks.length; i++) {\n      truncateSize +\u003d blocks[i].getNumBytes();\n    }\n\n    FileWithSnapshotFeature sf \u003d getFileWithSnapshotFeature();\n    if (sf !\u003d null) {\n      FileDiff diff \u003d sf.getDiffs().getLast();\n      BlockInfoContiguous[] sblocks \u003d diff !\u003d null ? diff.getBlocks() : null;\n      if (sblocks !\u003d null) {\n        for (int i \u003d (onBoundary ? n : n-1); i \u003c blocks.length\n            \u0026\u0026 i \u003c sblocks.length \u0026\u0026 blocks[i].equals(sblocks[i]); i++) {\n          truncateSize -\u003d blocks[i].getNumBytes();\n        }\n      }\n    }\n    return onBoundary ? -truncateSize : (getPreferredBlockSize() - truncateSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeFile.java"
    }
  }
}