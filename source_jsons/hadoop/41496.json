{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "reinitialize",
  "functionId": "reinitialize___conf-Configuration__rmContext-RMContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 1568,
  "functionEndLine": 1582,
  "numCommitsSeen": 229,
  "timeTaken": 7442,
  "changeHistory": [
    "889df6f1949921371d6d55dff93d3818d03be3bb",
    "a63d19d36520fa55bf523483f14329756f6eadd3",
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
    "a4ba451802c6c61a0c804809740d46dd76059f25",
    "a00b2d4f37518cb5e579ab7e49d0c8b33ded9cf4",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "25bc68d15eb005180ab366e3b9470294018bd2b9",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
    "3858b9018e3c2f4b883b02021679852591b706f7",
    "ae05623a75803d4e12a902ac4a24187540f56699",
    "942e2ebaa54306ffc5b0ffb403e552764a40d58c",
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
    "b9753e509ce2487aa71174d2dab440c33c6a17a4",
    "334de8d21189109dcd2423d13fab56477980872b",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f",
    "414458ff9dd1f8f2e3e0b9079eabbc8c391222a2",
    "576f96f0ac79a2afe49948056498f2c06fe317c3",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "889df6f1949921371d6d55dff93d3818d03be3bb": "Ybodychange",
    "a63d19d36520fa55bf523483f14329756f6eadd3": "Ybodychange",
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f": "Ymodifierchange",
    "a4ba451802c6c61a0c804809740d46dd76059f25": "Ybodychange",
    "a00b2d4f37518cb5e579ab7e49d0c8b33ded9cf4": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "25bc68d15eb005180ab366e3b9470294018bd2b9": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Ybodychange",
    "3858b9018e3c2f4b883b02021679852591b706f7": "Ybodychange",
    "ae05623a75803d4e12a902ac4a24187540f56699": "Ybodychange",
    "942e2ebaa54306ffc5b0ffb403e552764a40d58c": "Ybodychange",
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e": "Ybodychange",
    "b9753e509ce2487aa71174d2dab440c33c6a17a4": "Ybodychange",
    "334de8d21189109dcd2423d13fab56477980872b": "Ybodychange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Ybodychange",
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f": "Ybodychange",
    "414458ff9dd1f8f2e3e0b9079eabbc8c391222a2": "Ybodychange",
    "576f96f0ac79a2afe49948056498f2c06fe317c3": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ymultichange(Yparameterchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "889df6f1949921371d6d55dff93d3818d03be3bb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7948. Enable fair scheduler to refresh maximum allocation for multiple resource types. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "02/08/18 10:10 AM",
      "commitName": "889df6f1949921371d6d55dff93d3818d03be3bb",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "31/07/18 3:01 PM",
      "commitNameOld": "c7ebcd76bf3dd14127336951f2be3de772e7826a",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,9 +1,15 @@\n   public void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     try {\n       allocsLoader.reloadAllocations();\n       super.reinitialize(conf, rmContext);\n     } catch (Exception e) {\n       LOG.error(\"Failed to reload allocations file\", e);\n     }\n+    try {\n+      refreshMaximumAllocation(\n+          ResourceUtils.fetchMaximumAllocationFromConfig(conf));\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to refresh maximum allocation\", e);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    try {\n      allocsLoader.reloadAllocations();\n      super.reinitialize(conf, rmContext);\n    } catch (Exception e) {\n      LOG.error(\"Failed to reload allocations file\", e);\n    }\n    try {\n      refreshMaximumAllocation(\n          ResourceUtils.fetchMaximumAllocationFromConfig(conf));\n    } catch (Exception e) {\n      LOG.error(\"Failed to refresh maximum allocation\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a63d19d36520fa55bf523483f14329756f6eadd3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6124. Make SchedulingEditPolicy can be enabled / disabled / updated with RMAdmin -refreshQueues. (Zian Chen via wangda)\n\nChange-Id: Id93656f3af7dcd78cafa94e33663c78d410d43c2\n",
      "commitDate": "30/11/17 3:57 PM",
      "commitName": "a63d19d36520fa55bf523483f14329756f6eadd3",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/11/17 10:19 AM",
      "commitNameOld": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,8 +1,9 @@\n   public void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     try {\n       allocsLoader.reloadAllocations();\n+      super.reinitialize(conf, rmContext);\n     } catch (Exception e) {\n       LOG.error(\"Failed to reload allocations file\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    try {\n      allocsLoader.reloadAllocations();\n      super.reinitialize(conf, rmContext);\n    } catch (Exception e) {\n      LOG.error(\"Failed to reload allocations file\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-2608. FairScheduler: Potential deadlocks in loading alloc files and clock access. (Wei Yan via kasha)\n",
      "commitDate": "25/09/14 5:42 PM",
      "commitName": "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "18/09/14 11:03 AM",
      "commitNameOld": "485c96e3cb9b0b05d6e490b4773506da83ebc61d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.28,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,8 +1,8 @@\n-  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n+  public void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       LOG.error(\"Failed to reload allocations file\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      LOG.error(\"Failed to reload allocations file\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "[public, synchronized]",
        "newValue": "[public]"
      }
    },
    "a4ba451802c6c61a0c804809740d46dd76059f25": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1474. Make schedulers services. (Tsuyoshi Ozawa via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598908 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/14 12:33 PM",
      "commitName": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "28/05/14 9:01 PM",
      "commitNameOld": "342da5b4d3d6f8ae4c9e6c7ece642f7378a6e87c",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 2.65,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,8 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n-    if (!initialized) {\n-      this.conf \u003d new FairSchedulerConfiguration(conf);\n-      validateConf(this.conf);\n-      minimumAllocation \u003d this.conf.getMinimumAllocation();\n-      maximumAllocation \u003d this.conf.getMaximumAllocation();\n-      incrAllocation \u003d this.conf.getIncrementAllocation();\n-      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n-      continuousSchedulingSleepMs \u003d\n-              this.conf.getContinuousSchedulingSleepMs();\n-      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n-      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n-      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-      preemptionUtilizationThreshold \u003d\n-          this.conf.getPreemptionUtilizationThreshold();\n-      assignMultiple \u003d this.conf.getAssignMultiple();\n-      maxAssign \u003d this.conf.getMaxAssign();\n-      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-      preemptionInterval \u003d this.conf.getPreemptionInterval();\n-      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n-      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-      \n-      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n-      this.rmContext \u003d rmContext;\n-      // This stores per-application scheduling information\n-      this.applications \u003d\n-          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n-      this.eventLog \u003d new FairSchedulerEventLog();\n-      eventLog.init(this.conf);\n-\n-      initialized \u003d true;\n-\n-      allocConf \u003d new AllocationConfiguration(conf);\n-      try {\n-        queueMgr.initialize(conf);\n-      } catch (Exception e) {\n-        throw new IOException(\"Failed to start FairScheduler\", e);\n-      }\n-\n-      Thread updateThread \u003d new Thread(new UpdateThread());\n-      updateThread.setName(\"FairSchedulerUpdateThread\");\n-      updateThread.setDaemon(true);\n-      updateThread.start();\n-\n-      if (continuousSchedulingEnabled) {\n-        // start continuous scheduling thread\n-        Thread schedulingThread \u003d new Thread(\n-          new Runnable() {\n-            @Override\n-            public void run() {\n-              continuousScheduling();\n-            }\n-          }\n-        );\n-        schedulingThread.setName(\"ContinuousScheduling\");\n-        schedulingThread.setDaemon(true);\n-        schedulingThread.start();\n-      }\n-      \n-      allocsLoader.init(conf);\n-      allocsLoader.setReloadListener(new AllocationReloadListener());\n-      // If we fail to load allocations file on initialize, we want to fail\n-      // immediately.  After a successful load, exceptions on future reloads\n-      // will just result in leaving things as they are.\n-      try {\n-        allocsLoader.reloadAllocations();\n-      } catch (Exception e) {\n-        throw new IOException(\"Failed to initialize FairScheduler\", e);\n-      }\n-      allocsLoader.start();\n-    } else {\n-      try {\n-        allocsLoader.reloadAllocations();\n-      } catch (Exception e) {\n-        LOG.error(\"Failed to reload allocations file\", e);\n-      }\n+    try {\n+      allocsLoader.reloadAllocations();\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to reload allocations file\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      LOG.error(\"Failed to reload allocations file\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a00b2d4f37518cb5e579ab7e49d0c8b33ded9cf4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2073. Fair Scheduler: Add a utilization threshold to prevent preempting resources when cluster is free (Karthik Kambatla via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597209 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/14 3:52 PM",
      "commitName": "a00b2d4f37518cb5e579ab7e49d0c8b33ded9cf4",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/05/14 10:32 PM",
      "commitNameOld": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,81 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     if (!initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       maximumAllocation \u003d this.conf.getMaximumAllocation();\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n               this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      preemptionUtilizationThreshold \u003d\n+          this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       // This stores per-application scheduling information\n       this.applications \u003d\n           new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         Thread schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               continuousScheduling();\n             }\n           }\n         );\n         schedulingThread.setName(\"ContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n         schedulingThread.start();\n       }\n       \n       allocsLoader.init(conf);\n       allocsLoader.setReloadListener(new AllocationReloadListener());\n       // If we fail to load allocations file on initialize, we want to fail\n       // immediately.  After a successful load, exceptions on future reloads\n       // will just result in leaving things as they are.\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n       allocsLoader.start();\n     } else {\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         LOG.error(\"Failed to reload allocations file\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n              this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      \n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      // This stores per-application scheduling information\n      this.applications \u003d\n          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n      \n      allocsLoader.init(conf);\n      allocsLoader.setReloadListener(new AllocationReloadListener());\n      // If we fail to load allocations file on initialize, we want to fail\n      // immediately.  After a successful load, exceptions on future reloads\n      // will just result in leaving things as they are.\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n      allocsLoader.start();\n    } else {\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        LOG.error(\"Failed to reload allocations file\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     if (!initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       maximumAllocation \u003d this.conf.getMaximumAllocation();\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n               this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       // This stores per-application scheduling information\n       this.applications \u003d\n-          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003e();\n+          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         Thread schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               continuousScheduling();\n             }\n           }\n         );\n         schedulingThread.setName(\"ContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n         schedulingThread.start();\n       }\n       \n       allocsLoader.init(conf);\n       allocsLoader.setReloadListener(new AllocationReloadListener());\n       // If we fail to load allocations file on initialize, we want to fail\n       // immediately.  After a successful load, exceptions on future reloads\n       // will just result in leaving things as they are.\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n       allocsLoader.start();\n     } else {\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         LOG.error(\"Failed to reload allocations file\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n              this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      \n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      // This stores per-application scheduling information\n      this.applications \u003d\n          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n      \n      allocsLoader.init(conf);\n      allocsLoader.setReloadListener(new AllocationReloadListener());\n      // If we fail to load allocations file on initialize, we want to fail\n      // immediately.  After a successful load, exceptions on future reloads\n      // will just result in leaving things as they are.\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n      allocsLoader.start();\n    } else {\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        LOG.error(\"Failed to reload allocations file\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "25bc68d15eb005180ab366e3b9470294018bd2b9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1041. Added the ApplicationMasterProtocol API for applications to use the ability in ResourceManager to optionally not kill containers when the ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557318 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 11:07 PM",
      "commitName": "25bc68d15eb005180ab366e3b9470294018bd2b9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/01/14 5:15 PM",
      "commitNameOld": "f677175f35f68bde9df72e648dffacbd31cfd620",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,79 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     if (!initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       maximumAllocation \u003d this.conf.getMaximumAllocation();\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n               this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n+      // This stores per-application scheduling information\n+      this.applications \u003d\n+          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         Thread schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               continuousScheduling();\n             }\n           }\n         );\n         schedulingThread.setName(\"ContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n         schedulingThread.start();\n       }\n       \n       allocsLoader.init(conf);\n       allocsLoader.setReloadListener(new AllocationReloadListener());\n       // If we fail to load allocations file on initialize, we want to fail\n       // immediately.  After a successful load, exceptions on future reloads\n       // will just result in leaving things as they are.\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n       allocsLoader.start();\n     } else {\n       try {\n         allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         LOG.error(\"Failed to reload allocations file\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n              this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      \n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      // This stores per-application scheduling information\n      this.applications \u003d\n          new ConcurrentHashMap\u003cApplicationId, SchedulerApplication\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n      \n      allocsLoader.init(conf);\n      allocsLoader.setReloadListener(new AllocationReloadListener());\n      // If we fail to load allocations file on initialize, we want to fail\n      // immediately.  After a successful load, exceptions on future reloads\n      // will just result in leaving things as they are.\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n      allocsLoader.start();\n    } else {\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        LOG.error(\"Failed to reload allocations file\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/11/13 11:02 AM",
      "commitNameOld": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,76 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n-    this.conf \u003d new FairSchedulerConfiguration(conf);\n-    validateConf(this.conf);\n-    minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    maximumAllocation \u003d this.conf.getMaximumAllocation();\n-    incrAllocation \u003d this.conf.getIncrementAllocation();\n-    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n-    continuousSchedulingSleepMs \u003d\n-            this.conf.getContinuousSchedulingSleepMs();\n-    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n-    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n-    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-    assignMultiple \u003d this.conf.getAssignMultiple();\n-    maxAssign \u003d this.conf.getMaxAssign();\n-    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-    preemptionInterval \u003d this.conf.getPreemptionInterval();\n-    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n-    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    \n     if (!initialized) {\n+      this.conf \u003d new FairSchedulerConfiguration(conf);\n+      validateConf(this.conf);\n+      minimumAllocation \u003d this.conf.getMinimumAllocation();\n+      maximumAllocation \u003d this.conf.getMaximumAllocation();\n+      incrAllocation \u003d this.conf.getIncrementAllocation();\n+      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n+      continuousSchedulingSleepMs \u003d\n+              this.conf.getContinuousSchedulingSleepMs();\n+      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n+      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n+      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      assignMultiple \u003d this.conf.getAssignMultiple();\n+      maxAssign \u003d this.conf.getMaxAssign();\n+      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+      preemptionInterval \u003d this.conf.getPreemptionInterval();\n+      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n+      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+      \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n+      allocConf \u003d new AllocationConfiguration(conf);\n       try {\n-        queueMgr.initialize();\n+        queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         Thread schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               continuousScheduling();\n             }\n           }\n         );\n         schedulingThread.setName(\"ContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n         schedulingThread.start();\n       }\n-    } else {\n+      \n+      allocsLoader.init(conf);\n+      allocsLoader.setReloadListener(new AllocationReloadListener());\n+      // If we fail to load allocations file on initialize, we want to fail\n+      // immediately.  After a successful load, exceptions on future reloads\n+      // will just result in leaving things as they are.\n       try {\n-        queueMgr.reloadAllocs();\n+        allocsLoader.reloadAllocations();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n+      allocsLoader.start();\n+    } else {\n+      try {\n+        allocsLoader.reloadAllocations();\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to reload allocations file\", e);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n              this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      \n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n      \n      allocsLoader.init(conf);\n      allocsLoader.setReloadListener(new AllocationReloadListener());\n      // If we fail to load allocations file on initialize, we want to fail\n      // immediately.  After a successful load, exceptions on future reloads\n      // will just result in leaving things as they are.\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n      allocsLoader.start();\n    } else {\n      try {\n        allocsLoader.reloadAllocations();\n      } catch (Exception e) {\n        LOG.error(\"Failed to reload allocations file\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3858b9018e3c2f4b883b02021679852591b706f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1392. Allow sophisticated app-to-queue placement policies in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:12 PM",
      "commitName": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "05/11/13 1:23 PM",
      "commitNameOld": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 9.03,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n-    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n             this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     \n     if (!initialized) {\n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         Thread schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               continuousScheduling();\n             }\n           }\n         );\n         schedulingThread.setName(\"ContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n         schedulingThread.start();\n       }\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n            this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    \n    if (!initialized) {\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ae05623a75803d4e12a902ac4a24187540f56699": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1010. FairScheduler: decouple container scheduling from nodemanager heartbeats. (Wei Yan via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/10/13 12:54 PM",
      "commitName": "ae05623a75803d4e12a902ac4a24187540f56699",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/09/13 1:21 AM",
      "commitNameOld": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.48,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,64 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n+    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n+    continuousSchedulingSleepMs \u003d\n+            this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n+    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     \n     if (!initialized) {\n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n+\n+      if (continuousSchedulingEnabled) {\n+        // start continuous scheduling thread\n+        Thread schedulingThread \u003d new Thread(\n+          new Runnable() {\n+            @Override\n+            public void run() {\n+              continuousScheduling();\n+            }\n+          }\n+        );\n+        schedulingThread.setName(\"ContinuousScheduling\");\n+        schedulingThread.setDaemon(true);\n+        schedulingThread.start();\n+      }\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n            this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    \n    if (!initialized) {\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        Thread schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n        );\n        schedulingThread.setName(\"ContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n        schedulingThread.start();\n      }\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "942e2ebaa54306ffc5b0ffb403e552764a40d58c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1008. MiniYARNCluster with multiple nodemanagers, all nodes have same key for allocations. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1517563 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/08/13 8:39 AM",
      "commitName": "942e2ebaa54306ffc5b0ffb403e552764a40d58c",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "21/08/13 4:33 PM",
      "commitNameOld": "42a2846b3b824af808d7fd190f7dd4ea1ee10cbb",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 4.67,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n-\n+    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+    \n     if (!initialized) {\n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    \n    if (!initialized) {\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-883. Expose Fair Scheduler-specific queue metrics. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1497884 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/06/13 11:59 AM",
      "commitName": "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "24/06/13 11:33 AM",
      "commitNameOld": "e60fbbcc2e6a0d27d588b620817d29d1c70893a5",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.02,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n \n     if (!initialized) {\n-      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n+      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n\n    if (!initialized) {\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "b9753e509ce2487aa71174d2dab440c33c6a17a4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-789. Enable zero capabilities resource requests in fair scheduler. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493219 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 12:16 PM",
      "commitName": "b9753e509ce2487aa71174d2dab440c33c6a17a4",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "14/06/13 10:07 AM",
      "commitNameOld": "334de8d21189109dcd2423d13fab56477980872b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n+    incrAllocation \u003d this.conf.getIncrementAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n \n     if (!initialized) {\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n\n    if (!initialized) {\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "334de8d21189109dcd2423d13fab56477980872b": {
      "type": "Ybodychange",
      "commitMessage": " ARN-803. factor out scheduler config validation from the ResourceManager to each scheduler implementation. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493160 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 10:07 AM",
      "commitName": "334de8d21189109dcd2423d13fab56477980872b",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "06/06/13 11:46 AM",
      "commitNameOld": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 7.93,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n+    validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n \n     if (!initialized) {\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n\n    if (!initialized) {\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Ybodychange",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 3:15 PM",
      "commitNameOld": "51ccb87031eda6a2b75be098a88f1d89ea82c610",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 24.8,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n-    minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n-    maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n+    minimumAllocation \u003d this.conf.getMinimumAllocation();\n+    maximumAllocation \u003d this.conf.getMaximumAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n \n     if (!initialized) {\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n\n    if (!initialized) {\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-568. Add support for work preserving preemption to the FairScheduler.\nContributed by Carlo Curino and Sandy Ryza\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480778 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 2:21 PM",
      "commitName": "505fe2653941e4f36f61edd0fc2f8e750ceb5d8f",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "25/04/13 2:15 AM",
      "commitNameOld": "d10428cab26c4c75328ecca118744041f2848251",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 14.5,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,41 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n     maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n     userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-    \n+    preemptionInterval \u003d this.conf.getPreemptionInterval();\n+    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n+\n     if (!initialized) {\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       initialized \u003d true;\n \n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n       try {\n         queueMgr.reloadAllocs();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n    maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n\n    if (!initialized) {\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "414458ff9dd1f8f2e3e0b9079eabbc8c391222a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-496. Fair scheduler configs are refreshed inconsistently in reinitialize. Contributed by Sandy Ryza\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461614 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 7:42 AM",
      "commitName": "414458ff9dd1f8f2e3e0b9079eabbc8c391222a2",
      "commitAuthor": "Thomas White",
      "commitDateOld": "25/03/13 8:25 PM",
      "commitNameOld": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 1.47,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,39 @@\n   public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n       throws IOException {\n+    this.conf \u003d new FairSchedulerConfiguration(conf);\n+    minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n+    maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n+    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n+    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+    assignMultiple \u003d this.conf.getAssignMultiple();\n+    maxAssign \u003d this.conf.getMaxAssign();\n+    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+    \n     if (!initialized) {\n-      this.conf \u003d new FairSchedulerConfiguration(conf);\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n-      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n-      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n-      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n-      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-      assignMultiple \u003d this.conf.getAssignMultiple();\n-      maxAssign \u003d this.conf.getMaxAssign();\n \n       initialized \u003d true;\n \n-      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-\n       try {\n         queueMgr.initialize();\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n       updateThread.start();\n     } else {\n-      this.conf \u003d new FairSchedulerConfiguration(conf);\n-      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n-      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       try {\n         queueMgr.reloadAllocs();\n-\n       } catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf, RMContext rmContext)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n    maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n    userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    \n    if (!initialized) {\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      initialized \u003d true;\n\n      try {\n        queueMgr.initialize();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      try {\n        queueMgr.reloadAllocs();\n      } catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "576f96f0ac79a2afe49948056498f2c06fe317c3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-184. Remove unnecessary locking in fair scheduler, and address findbugs excludes. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1410826 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/11/12 9:00 PM",
      "commitName": "576f96f0ac79a2afe49948056498f2c06fe317c3",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/11/12 4:38 AM",
      "commitNameOld": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 8.68,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,46 @@\n       reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n     if (!initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n-      this.clock \u003d new SystemClock();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n       maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n \n-      Thread updateThread \u003d new Thread(new UpdateThread());\n-      updateThread.start();\n-\n       initialized \u003d true;\n \n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n \n-      queueMgr \u003d new QueueManager(this);\n-\n       try {\n         queueMgr.initialize();\n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n+      \n+      Thread updateThread \u003d new Thread(new UpdateThread());\n+      updateThread.setName(\"FairSchedulerUpdateThread\");\n+      updateThread.setDaemon(true);\n+      updateThread.start();\n     } else {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       try {\n        queueMgr.reloadAllocs();\n \n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n      \n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n      updateThread.start();\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "26/10/12 1:55 PM",
      "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n       reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n-    if (!this.initialized) {\n+    if (!initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n-      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n+      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n       this.rmContext \u003d rmContext;\n       this.clock \u003d new SystemClock();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n       maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.start();\n \n       initialized \u003d true;\n \n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n \n       queueMgr \u003d new QueueManager(this);\n \n       try {\n         queueMgr.initialize();\n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n     } else {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       try {\n        queueMgr.reloadAllocs();\n \n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n    if (!initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.clock \u003d new SystemClock();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.start();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      queueMgr \u003d new QueueManager(this);\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/08/12 7:18 PM",
          "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 16.87,
          "commitsBetweenForRepo": 114,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,47 @@\n-  public synchronized void reinitialize(Configuration conf,\n-      ContainerTokenSecretManager containerTokenSecretManager,\n-      RMContext rmContext)\n-  throws IOException\n-  {\n+      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n     if (!this.initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n-      this.containerTokenSecretManager \u003d containerTokenSecretManager;\n       this.rmContext \u003d rmContext;\n       this.clock \u003d new SystemClock();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n       maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.start();\n \n       initialized \u003d true;\n \n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n \n       queueMgr \u003d new QueueManager(this);\n \n       try {\n         queueMgr.initialize();\n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n     } else {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       try {\n        queueMgr.reloadAllocs();\n \n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n    if (!this.initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.clock \u003d new SystemClock();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.start();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      queueMgr \u003d new QueueManager(this);\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration, containerTokenSecretManager-ContainerTokenSecretManager, rmContext-RMContext]",
            "newValue": "[conf-Configuration, rmContext-RMContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/08/12 7:18 PM",
          "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
          "commitAuthor": "Siddharth Seth",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 16.87,
          "commitsBetweenForRepo": 114,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,47 @@\n-  public synchronized void reinitialize(Configuration conf,\n-      ContainerTokenSecretManager containerTokenSecretManager,\n-      RMContext rmContext)\n-  throws IOException\n-  {\n+      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n     if (!this.initialized) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n-      this.containerTokenSecretManager \u003d containerTokenSecretManager;\n       this.rmContext \u003d rmContext;\n       this.clock \u003d new SystemClock();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n       maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n \n       Thread updateThread \u003d new Thread(new UpdateThread());\n       updateThread.start();\n \n       initialized \u003d true;\n \n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n \n       queueMgr \u003d new QueueManager(this);\n \n       try {\n         queueMgr.initialize();\n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n     } else {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       try {\n        queueMgr.reloadAllocs();\n \n       }\n       catch (Exception e) {\n         throw new IOException(\"Failed to initialize FairScheduler\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "      reinitialize(Configuration conf, RMContext rmContext) throws IOException {\n    if (!this.initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.rmContext \u003d rmContext;\n      this.clock \u003d new SystemClock();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.start();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      queueMgr \u003d new QueueManager(this);\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized void reinitialize(Configuration conf,\n      ContainerTokenSecretManager containerTokenSecretManager,\n      RMContext rmContext)\n  throws IOException\n  {\n    if (!this.initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.containerTokenSecretManager \u003d containerTokenSecretManager;\n      this.rmContext \u003d rmContext;\n      this.clock \u003d new SystemClock();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.start();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      queueMgr \u003d new QueueManager(this);\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,52 @@\n+  public synchronized void reinitialize(Configuration conf,\n+      ContainerTokenSecretManager containerTokenSecretManager,\n+      RMContext rmContext)\n+  throws IOException\n+  {\n+    if (!this.initialized) {\n+      this.conf \u003d new FairSchedulerConfiguration(conf);\n+      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n+      this.containerTokenSecretManager \u003d containerTokenSecretManager;\n+      this.rmContext \u003d rmContext;\n+      this.clock \u003d new SystemClock();\n+      this.eventLog \u003d new FairSchedulerEventLog();\n+      eventLog.init(this.conf);\n+      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n+      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n+      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n+      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      assignMultiple \u003d this.conf.getAssignMultiple();\n+      maxAssign \u003d this.conf.getMaxAssign();\n+\n+      Thread updateThread \u003d new Thread(new UpdateThread());\n+      updateThread.start();\n+\n+      initialized \u003d true;\n+\n+      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+\n+      queueMgr \u003d new QueueManager(this);\n+\n+      try {\n+        queueMgr.initialize();\n+      }\n+      catch (Exception e) {\n+        throw new IOException(\"Failed to start FairScheduler\", e);\n+      }\n+    } else {\n+      this.conf \u003d new FairSchedulerConfiguration(conf);\n+      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n+      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      try {\n+       queueMgr.reloadAllocs();\n+\n+      }\n+      catch (Exception e) {\n+        throw new IOException(\"Failed to initialize FairScheduler\", e);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reinitialize(Configuration conf,\n      ContainerTokenSecretManager containerTokenSecretManager,\n      RMContext rmContext)\n  throws IOException\n  {\n    if (!this.initialized) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      this.rootMetrics \u003d QueueMetrics.forQueue(\"root\", null, true, conf);\n      this.containerTokenSecretManager \u003d containerTokenSecretManager;\n      this.rmContext \u003d rmContext;\n      this.clock \u003d new SystemClock();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumMemoryAllocation();\n      maximumAllocation \u003d this.conf.getMaximumMemoryAllocation();\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n\n      Thread updateThread \u003d new Thread(new UpdateThread());\n      updateThread.start();\n\n      initialized \u003d true;\n\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n\n      queueMgr \u003d new QueueManager(this);\n\n      try {\n        queueMgr.initialize();\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n    } else {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      userAsDefaultQueue \u003d this.conf.getUserAsDefaultQueue();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      try {\n       queueMgr.reloadAllocs();\n\n      }\n      catch (Exception e) {\n        throw new IOException(\"Failed to initialize FairScheduler\", e);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}