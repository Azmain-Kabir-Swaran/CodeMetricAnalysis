{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FifoCandidatesSelector.java",
  "functionName": "selectCandidates",
  "functionId": "selectCandidates___selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______clusterResource-Resource__totalPreemptionAllowed-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
  "functionStartLine": 61,
  "functionEndLine": 162,
  "numCommitsSeen": 12,
  "timeTaken": 4510,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ybodychange",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,102 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"skipping from queue\u003d\" + queueName\n-              + \" because it\u0027s a non-preemptable queue\");\n-        }\n+        LOG.debug(\"skipping from queue\u003d{} because it\u0027s a\"\n+            + \" non-preemptable queue\", queueName);\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       leafQueue.getReadLock().lock();\n       try {\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n                       clusterResource, selectedCandidates, curCandidates,\n                       totalPreemptionAllowed, false);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               curCandidates, totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources\n             .multiply(\n                 leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                 leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n             skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n             maxAMCapacityForThisQueue, totalPreemptionAllowed);\n       } finally {\n         leafQueue.getReadLock().unlock();\n       }\n     }\n \n     return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        LOG.debug(\"skipping from queue\u003d{} because it\u0027s a\"\n            + \" non-preemptable queue\", queueName);\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      leafQueue.getReadLock().lock();\n      try {\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates, curCandidates,\n                      totalPreemptionAllowed, false);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              curCandidates, totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources\n            .multiply(\n                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n            skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n            maxAMCapacityForThisQueue, totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,104 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n+      leafQueue.getReadLock().lock();\n       try {\n-        leafQueue.getReadLock().lock();\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n                       clusterResource, selectedCandidates, curCandidates,\n                       totalPreemptionAllowed, false);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               curCandidates, totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources\n             .multiply(\n                 leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                 leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n             skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n             maxAMCapacityForThisQueue, totalPreemptionAllowed);\n       } finally {\n         leafQueue.getReadLock().unlock();\n       }\n     }\n \n     return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      leafQueue.getReadLock().lock();\n      try {\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates, curCandidates,\n                      totalPreemptionAllowed, false);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              curCandidates, totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources\n            .multiply(\n                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n            skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n            maxAMCapacityForThisQueue, totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "commitDateOld": "25/05/18 9:06 AM",
      "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthorOld": "Eric E Payne",
      "daysBetweenCommits": 34.05,
      "commitsBetweenForRepo": 228,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n+    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       try {\n         leafQueue.getReadLock().lock();\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n-                      clusterResource, selectedCandidates,\n+                      clusterResource, selectedCandidates, curCandidates,\n                       totalPreemptionAllowed, false);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n-              totalPreemptionAllowed);\n+              curCandidates, totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources\n             .multiply(\n                 leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                 leafQueue.getMaxAMResourcePerQueuePercent());\n \n-        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n-            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n-            totalPreemptionAllowed);\n+        preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n+            skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n+            maxAMCapacityForThisQueue, totalPreemptionAllowed);\n       } finally {\n         leafQueue.getReadLock().unlock();\n       }\n     }\n \n-    return selectedCandidates;\n+    return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      try {\n        leafQueue.getReadLock().lock();\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates, curCandidates,\n                      totalPreemptionAllowed, false);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              curCandidates, totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources\n            .multiply(\n                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, curCandidates,\n            skippedAMContainerlist, resToObtainByPartition, skippedAMSize,\n            maxAMCapacityForThisQueue, totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 168.55,
      "commitsBetweenForRepo": 1747,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       try {\n         leafQueue.getReadLock().lock();\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n                       clusterResource, selectedCandidates,\n-                      totalPreemptionAllowed);\n+                      totalPreemptionAllowed, false);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources\n             .multiply(\n                 leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                 leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n             resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n             totalPreemptionAllowed);\n       } finally {\n         leafQueue.getReadLock().unlock();\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      try {\n        leafQueue.getReadLock().lock();\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates,\n                      totalPreemptionAllowed, false);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources\n            .multiply(\n                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/07/17 4:18 AM",
      "commitNameOld": "cf0d0844d6ae25d537391edb9b65fca05d1848e6",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 147.65,
      "commitsBetweenForRepo": 1200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       try {\n         leafQueue.getReadLock().lock();\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n                       clusterResource, selectedCandidates,\n                       totalPreemptionAllowed);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n-        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n-            Resources.multiply(clusterResource,\n-                leafQueue.getAbsoluteCapacity()),\n-            leafQueue.getMaxAMResourcePerQueuePercent());\n+        Resource maxAMCapacityForThisQueue \u003d Resources\n+            .multiply(\n+                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n+                leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n             resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n             totalPreemptionAllowed);\n       } finally {\n         leafQueue.getReadLock().unlock();\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      try {\n        leafQueue.getReadLock().lock();\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates,\n                      totalPreemptionAllowed);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources\n            .multiply(\n                leafQueue.getEffectiveCapacity(RMNodeLabelsManager.NO_LABEL),\n                leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5825. ProportionalPreemptionalPolicy should use readLock over LeafQueue instead of synchronized block. Contributed by Sunil G\n",
      "commitDate": "11/11/16 3:16 PM",
      "commitName": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthor": "Jian He",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 11.04,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,103 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n-      synchronized (leafQueue) {\n+      try {\n+        leafQueue.getReadLock().lock();\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                   .tryPreemptContainerAndDeductResToObtain(rc,\n                       preemptionContext, resToObtainByPartition, c,\n                       clusterResource, selectedCandidates,\n                       totalPreemptionAllowed);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n             Resources.multiply(clusterResource,\n                 leafQueue.getAbsoluteCapacity()),\n             leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n             resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n             totalPreemptionAllowed);\n+      } finally {\n+        leafQueue.getReadLock().unlock();\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      try {\n        leafQueue.getReadLock().lock();\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates,\n                      totalPreemptionAllowed);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n            Resources.multiply(clusterResource,\n                leafQueue.getAbsoluteCapacity()),\n            leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      } finally {\n        leafQueue.getReadLock().unlock();\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/07/16 2:54 PM",
      "commitNameOld": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 97.02,
      "commitsBetweenForRepo": 698,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,100 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n     // Previous selectors (with higher priority) could have already\n     // selected containers. We need to deduct preemptable resources\n     // based on already selected candidates.\n     CapacitySchedulerPreemptionUtils\n         .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n             selectedCandidates);\n \n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       synchronized (leafQueue) {\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n-              boolean preempted \u003d tryPreemptContainerAndDeductResToObtain(\n-                  resToObtainByPartition, c, clusterResource, selectedCandidates,\n-                  totalPreemptionAllowed);\n+              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n+                  .tryPreemptContainerAndDeductResToObtain(rc,\n+                      preemptionContext, resToObtainByPartition, c,\n+                      clusterResource, selectedCandidates,\n+                      totalPreemptionAllowed);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n               skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n             Resources.multiply(clusterResource,\n                 leafQueue.getAbsoluteCapacity()),\n             leafQueue.getMaxAMResourcePerQueuePercent());\n \n         preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n             resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n             totalPreemptionAllowed);\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      synchronized (leafQueue) {\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d CapacitySchedulerPreemptionUtils\n                  .tryPreemptContainerAndDeductResToObtain(rc,\n                      preemptionContext, resToObtainByPartition, c,\n                      clusterResource, selectedCandidates,\n                      totalPreemptionAllowed);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n            Resources.multiply(clusterResource,\n                leafQueue.getAbsoluteCapacity()),\n            leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/03/16 12:43 PM",
      "commitNameOld": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 36.01,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,98 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource, Resource totalPreemptionAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptionAllowed);\n \n-    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap \u003d\n-        new HashMap\u003c\u003e();\n+    // Previous selectors (with higher priority) could have already\n+    // selected containers. We need to deduct preemptable resources\n+    // based on already selected candidates.\n+    CapacitySchedulerPreemptionUtils\n+        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n+            selectedCandidates);\n+\n     List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n \n     // Loop all leaf queues\n     for (String queueName : preemptionContext.getLeafQueueNames()) {\n       // check if preemption disabled for the queue\n       if (preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"skipping from queue\u003d\" + queueName\n               + \" because it\u0027s a non-preemptable queue\");\n         }\n         continue;\n       }\n \n       // compute resToObtainByPartition considered inter-queue preemption\n       LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n           RMNodeLabelsManager.NO_LABEL).leafQueue;\n \n       Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   queueName, clusterResource);\n \n       synchronized (leafQueue) {\n         // go through all ignore-partition-exclusivity containers first to make\n         // sure such containers will be preemptionCandidates first\n         Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n             leafQueue.getIgnoreExclusivityRMContainers();\n         for (String partition : resToObtainByPartition.keySet()) {\n           if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n             TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                 ignorePartitionExclusivityContainers.get(partition);\n             // We will check container from reverse order, so latter submitted\n             // application\u0027s containers will be preemptionCandidates first.\n             for (RMContainer c : rmContainers.descendingSet()) {\n               if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                   selectedCandidates)) {\n                 // Skip already selected containers\n                 continue;\n               }\n               boolean preempted \u003d tryPreemptContainerAndDeductResToObtain(\n-                  resToObtainByPartition, c, clusterResource, preemptMap,\n+                  resToObtainByPartition, c, clusterResource, selectedCandidates,\n                   totalPreemptionAllowed);\n               if (!preempted) {\n                 continue;\n               }\n             }\n           }\n         }\n \n         // preempt other containers\n         Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n         Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n             leafQueue.getOrderingPolicy().getPreemptionIterator();\n         while (desc.hasNext()) {\n           FiCaSchedulerApp fc \u003d desc.next();\n           // When we complete preempt from one partition, we will remove from\n           // resToObtainByPartition, so when it becomes empty, we can get no\n           // more preemption is needed\n           if (resToObtainByPartition.isEmpty()) {\n             break;\n           }\n \n           preemptFrom(fc, clusterResource, resToObtainByPartition,\n-              skippedAMContainerlist, skippedAMSize, preemptMap,\n+              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n               totalPreemptionAllowed);\n         }\n \n         // Can try preempting AMContainers (still saving atmost\n         // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n         // required to be preemptionCandidates from this Queue.\n         Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n             Resources.multiply(clusterResource,\n                 leafQueue.getAbsoluteCapacity()),\n             leafQueue.getMaxAMResourcePerQueuePercent());\n \n-        preemptAMContainers(clusterResource, preemptMap, skippedAMContainerlist,\n+        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n             resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n             totalPreemptionAllowed);\n       }\n     }\n \n-    return preemptMap;\n+    return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    // Previous selectors (with higher priority) could have already\n    // selected containers. We need to deduct preemptable resources\n    // based on already selected candidates.\n    CapacitySchedulerPreemptionUtils\n        .deductPreemptableResourcesBasedSelectedCandidates(preemptionContext,\n            selectedCandidates);\n\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      synchronized (leafQueue) {\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d tryPreemptContainerAndDeductResToObtain(\n                  resToObtainByPartition, c, clusterResource, selectedCandidates,\n                  totalPreemptionAllowed);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, selectedCandidates,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n            Resources.multiply(clusterResource,\n                leafQueue.getAbsoluteCapacity()),\n            leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, selectedCandidates, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,93 @@\n+  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource clusterResource, Resource totalPreemptionAllowed) {\n+    // Calculate how much resources we need to preempt\n+    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n+        totalPreemptionAllowed);\n+\n+    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap \u003d\n+        new HashMap\u003c\u003e();\n+    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n+\n+    // Loop all leaf queues\n+    for (String queueName : preemptionContext.getLeafQueueNames()) {\n+      // check if preemption disabled for the queue\n+      if (preemptionContext.getQueueByPartition(queueName,\n+          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"skipping from queue\u003d\" + queueName\n+              + \" because it\u0027s a non-preemptable queue\");\n+        }\n+        continue;\n+      }\n+\n+      // compute resToObtainByPartition considered inter-queue preemption\n+      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n+          RMNodeLabelsManager.NO_LABEL).leafQueue;\n+\n+      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n+          CapacitySchedulerPreemptionUtils\n+              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n+                  queueName, clusterResource);\n+\n+      synchronized (leafQueue) {\n+        // go through all ignore-partition-exclusivity containers first to make\n+        // sure such containers will be preemptionCandidates first\n+        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n+            leafQueue.getIgnoreExclusivityRMContainers();\n+        for (String partition : resToObtainByPartition.keySet()) {\n+          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n+            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n+                ignorePartitionExclusivityContainers.get(partition);\n+            // We will check container from reverse order, so latter submitted\n+            // application\u0027s containers will be preemptionCandidates first.\n+            for (RMContainer c : rmContainers.descendingSet()) {\n+              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n+                  selectedCandidates)) {\n+                // Skip already selected containers\n+                continue;\n+              }\n+              boolean preempted \u003d tryPreemptContainerAndDeductResToObtain(\n+                  resToObtainByPartition, c, clusterResource, preemptMap,\n+                  totalPreemptionAllowed);\n+              if (!preempted) {\n+                continue;\n+              }\n+            }\n+          }\n+        }\n+\n+        // preempt other containers\n+        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n+        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n+            leafQueue.getOrderingPolicy().getPreemptionIterator();\n+        while (desc.hasNext()) {\n+          FiCaSchedulerApp fc \u003d desc.next();\n+          // When we complete preempt from one partition, we will remove from\n+          // resToObtainByPartition, so when it becomes empty, we can get no\n+          // more preemption is needed\n+          if (resToObtainByPartition.isEmpty()) {\n+            break;\n+          }\n+\n+          preemptFrom(fc, clusterResource, resToObtainByPartition,\n+              skippedAMContainerlist, skippedAMSize, preemptMap,\n+              totalPreemptionAllowed);\n+        }\n+\n+        // Can try preempting AMContainers (still saving atmost\n+        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n+        // required to be preemptionCandidates from this Queue.\n+        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n+            Resources.multiply(clusterResource,\n+                leafQueue.getAbsoluteCapacity()),\n+            leafQueue.getMaxAMResourcePerQueuePercent());\n+\n+        preemptAMContainers(clusterResource, preemptMap, skippedAMContainerlist,\n+            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n+            totalPreemptionAllowed);\n+      }\n+    }\n+\n+    return preemptMap;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource, Resource totalPreemptionAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptionAllowed);\n\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap \u003d\n        new HashMap\u003c\u003e();\n    List\u003cRMContainer\u003e skippedAMContainerlist \u003d new ArrayList\u003c\u003e();\n\n    // Loop all leaf queues\n    for (String queueName : preemptionContext.getLeafQueueNames()) {\n      // check if preemption disabled for the queue\n      if (preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).preemptionDisabled) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"skipping from queue\u003d\" + queueName\n              + \" because it\u0027s a non-preemptable queue\");\n        }\n        continue;\n      }\n\n      // compute resToObtainByPartition considered inter-queue preemption\n      LeafQueue leafQueue \u003d preemptionContext.getQueueByPartition(queueName,\n          RMNodeLabelsManager.NO_LABEL).leafQueue;\n\n      Map\u003cString, Resource\u003e resToObtainByPartition \u003d\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  queueName, clusterResource);\n\n      synchronized (leafQueue) {\n        // go through all ignore-partition-exclusivity containers first to make\n        // sure such containers will be preemptionCandidates first\n        Map\u003cString, TreeSet\u003cRMContainer\u003e\u003e ignorePartitionExclusivityContainers \u003d\n            leafQueue.getIgnoreExclusivityRMContainers();\n        for (String partition : resToObtainByPartition.keySet()) {\n          if (ignorePartitionExclusivityContainers.containsKey(partition)) {\n            TreeSet\u003cRMContainer\u003e rmContainers \u003d\n                ignorePartitionExclusivityContainers.get(partition);\n            // We will check container from reverse order, so latter submitted\n            // application\u0027s containers will be preemptionCandidates first.\n            for (RMContainer c : rmContainers.descendingSet()) {\n              if (CapacitySchedulerPreemptionUtils.isContainerAlreadySelected(c,\n                  selectedCandidates)) {\n                // Skip already selected containers\n                continue;\n              }\n              boolean preempted \u003d tryPreemptContainerAndDeductResToObtain(\n                  resToObtainByPartition, c, clusterResource, preemptMap,\n                  totalPreemptionAllowed);\n              if (!preempted) {\n                continue;\n              }\n            }\n          }\n        }\n\n        // preempt other containers\n        Resource skippedAMSize \u003d Resource.newInstance(0, 0);\n        Iterator\u003cFiCaSchedulerApp\u003e desc \u003d\n            leafQueue.getOrderingPolicy().getPreemptionIterator();\n        while (desc.hasNext()) {\n          FiCaSchedulerApp fc \u003d desc.next();\n          // When we complete preempt from one partition, we will remove from\n          // resToObtainByPartition, so when it becomes empty, we can get no\n          // more preemption is needed\n          if (resToObtainByPartition.isEmpty()) {\n            break;\n          }\n\n          preemptFrom(fc, clusterResource, resToObtainByPartition,\n              skippedAMContainerlist, skippedAMSize, preemptMap,\n              totalPreemptionAllowed);\n        }\n\n        // Can try preempting AMContainers (still saving atmost\n        // maxAMCapacityForThisQueue AMResource\u0027s) if more resources are\n        // required to be preemptionCandidates from this Queue.\n        Resource maxAMCapacityForThisQueue \u003d Resources.multiply(\n            Resources.multiply(clusterResource,\n                leafQueue.getAbsoluteCapacity()),\n            leafQueue.getMaxAMResourcePerQueuePercent());\n\n        preemptAMContainers(clusterResource, preemptMap, skippedAMContainerlist,\n            resToObtainByPartition, skippedAMSize, maxAMCapacityForThisQueue,\n            totalPreemptionAllowed);\n      }\n    }\n\n    return preemptMap;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java"
    }
  }
}