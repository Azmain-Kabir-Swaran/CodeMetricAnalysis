{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RegularContainerAllocator.java",
  "functionName": "tryAllocateOnNode",
  "functionId": "tryAllocateOnNode___clusterResource-Resource__node-FiCaSchedulerNode__schedulingMode-SchedulingMode__resourceLimits-ResourceLimits__schedulerKey-SchedulerRequestKey__reservedContainer-RMContainer",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
  "functionStartLine": 251,
  "functionEndLine": 281,
  "numCommitsSeen": 66,
  "timeTaken": 4513,
  "changeHistory": [
    "cbf20264838f536382a9d8c4cd2144faf6875c3a",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
    "ba2313d6145a1234777938a747187373f4cd58d9"
  ],
  "changeHistoryShort": {
    "cbf20264838f536382a9d8c4cd2144faf6875c3a": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Yrename,Ybodychange)",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": "Ymultichange(Yparameterchange,Ybodychange)",
    "ba2313d6145a1234777938a747187373f4cd58d9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cbf20264838f536382a9d8c4cd2144faf6875c3a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8528. Final states in ContainerAllocation might be modified externally causing unexpected allocation results. Contributed by Xintong Song.\n",
      "commitDate": "20/07/18 7:34 AM",
      "commitName": "cbf20264838f536382a9d8c4cd2144faf6875c3a",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n       RMContainer reservedContainer) {\n     ContainerAllocation result;\n \n     // Sanity checks before assigning to this node\n     result \u003d checkIfNodeBlackListed(node, schedulerKey);\n     if (null !\u003d result) {\n       return result;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n     // TODO, we may need to revisit here to see if we should add scheduling\n     // opportunity here\n     application.addSchedulingOpportunity(schedulerKey);\n \n     // Try to allocate containers on node\n     result \u003d\n         assignContainersOnNode(clusterResource, node, schedulerKey,\n             reservedContainer, schedulingMode, resourceLimits);\n     \n     if (null \u003d\u003d reservedContainer) {\n-      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n+      if (result.getAllocationState() \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n         // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n         application.subtractSchedulingOpportunity(schedulerKey);\n       }\n     }\n     \n     return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n\n    // Sanity checks before assigning to this node\n    result \u003d checkIfNodeBlackListed(node, schedulerKey);\n    if (null !\u003d result) {\n      return result;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    // TODO, we may need to revisit here to see if we should add scheduling\n    // opportunity here\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, schedulerKey,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.getAllocationState() \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(schedulerKey);\n      }\n    }\n    \n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "19/09/16 2:08 AM",
          "commitNameOld": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 49.38,
          "commitsBetweenForRepo": 429,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,31 @@\n-  ContainerAllocation preAllocation(Resource clusterResource,\n+  ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n       RMContainer reservedContainer) {\n     ContainerAllocation result;\n-    if (null \u003d\u003d reservedContainer) {\n-      // pre-check when allocating new container\n-      result \u003d\n-          preCheckForNewContainer(clusterResource, node, schedulingMode,\n-              resourceLimits, schedulerKey);\n-      if (null !\u003d result) {\n-        return result;\n-      }\n-    } else {\n-      // pre-check when allocating reserved container\n-      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n-        // Release\n-        return new ContainerAllocation(reservedContainer, null,\n-            AllocationState.QUEUE_SKIPPED);\n-      }\n+\n+    // Sanity checks before assigning to this node\n+    result \u003d checkIfNodeBlackListed(node, schedulerKey);\n+    if (null !\u003d result) {\n+      return result;\n     }\n \n+    // Inform the application it is about to get a scheduling opportunity\n+    // TODO, we may need to revisit here to see if we should add scheduling\n+    // opportunity here\n+    application.addSchedulingOpportunity(schedulerKey);\n+\n     // Try to allocate containers on node\n     result \u003d\n         assignContainersOnNode(clusterResource, node, schedulerKey,\n             reservedContainer, schedulingMode, resourceLimits);\n     \n     if (null \u003d\u003d reservedContainer) {\n       if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n         // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n         application.subtractSchedulingOpportunity(schedulerKey);\n       }\n     }\n     \n     return result;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n\n    // Sanity checks before assigning to this node\n    result \u003d checkIfNodeBlackListed(node, schedulerKey);\n    if (null !\u003d result) {\n      return result;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    // TODO, we may need to revisit here to see if we should add scheduling\n    // opportunity here\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, schedulerKey,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(schedulerKey);\n      }\n    }\n    \n    return result;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "preAllocation",
            "newValue": "tryAllocateOnNode"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "19/09/16 2:08 AM",
          "commitNameOld": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 49.38,
          "commitsBetweenForRepo": 429,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,31 @@\n-  ContainerAllocation preAllocation(Resource clusterResource,\n+  ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n       RMContainer reservedContainer) {\n     ContainerAllocation result;\n-    if (null \u003d\u003d reservedContainer) {\n-      // pre-check when allocating new container\n-      result \u003d\n-          preCheckForNewContainer(clusterResource, node, schedulingMode,\n-              resourceLimits, schedulerKey);\n-      if (null !\u003d result) {\n-        return result;\n-      }\n-    } else {\n-      // pre-check when allocating reserved container\n-      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n-        // Release\n-        return new ContainerAllocation(reservedContainer, null,\n-            AllocationState.QUEUE_SKIPPED);\n-      }\n+\n+    // Sanity checks before assigning to this node\n+    result \u003d checkIfNodeBlackListed(node, schedulerKey);\n+    if (null !\u003d result) {\n+      return result;\n     }\n \n+    // Inform the application it is about to get a scheduling opportunity\n+    // TODO, we may need to revisit here to see if we should add scheduling\n+    // opportunity here\n+    application.addSchedulingOpportunity(schedulerKey);\n+\n     // Try to allocate containers on node\n     result \u003d\n         assignContainersOnNode(clusterResource, node, schedulerKey,\n             reservedContainer, schedulingMode, resourceLimits);\n     \n     if (null \u003d\u003d reservedContainer) {\n       if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n         // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n         application.subtractSchedulingOpportunity(schedulerKey);\n       }\n     }\n     \n     return result;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  ContainerAllocation tryAllocateOnNode(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n\n    // Sanity checks before assigning to this node\n    result \u003d checkIfNodeBlackListed(node, schedulerKey);\n    if (null !\u003d result) {\n      return result;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    // TODO, we may need to revisit here to see if we should add scheduling\n    // opportunity here\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, schedulerKey,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(schedulerKey);\n      }\n    }\n    \n    return result;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
      "commitDate": "26/07/16 2:54 PM",
      "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "07/06/16 3:06 PM",
          "commitNameOld": "620325e81696fca140195b74929ed9eda2d5eb16",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 48.99,
          "commitsBetweenForRepo": 441,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n   ContainerAllocation preAllocation(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, Priority priority,\n+      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n       RMContainer reservedContainer) {\n     ContainerAllocation result;\n     if (null \u003d\u003d reservedContainer) {\n       // pre-check when allocating new container\n       result \u003d\n           preCheckForNewContainer(clusterResource, node, schedulingMode,\n-              resourceLimits, priority);\n+              resourceLimits, schedulerKey);\n       if (null !\u003d result) {\n         return result;\n       }\n     } else {\n       // pre-check when allocating reserved container\n-      if (application.getTotalRequiredResources(priority) \u003d\u003d 0) {\n+      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n         // Release\n         return new ContainerAllocation(reservedContainer, null,\n             AllocationState.QUEUE_SKIPPED);\n       }\n     }\n \n     // Try to allocate containers on node\n     result \u003d\n-        assignContainersOnNode(clusterResource, node, priority,\n+        assignContainersOnNode(clusterResource, node, schedulerKey,\n             reservedContainer, schedulingMode, resourceLimits);\n     \n     if (null \u003d\u003d reservedContainer) {\n       if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n         // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n-        application.subtractSchedulingOpportunity(priority);\n+        application.subtractSchedulingOpportunity(schedulerKey);\n       }\n     }\n     \n     return result;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  ContainerAllocation preAllocation(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n    if (null \u003d\u003d reservedContainer) {\n      // pre-check when allocating new container\n      result \u003d\n          preCheckForNewContainer(clusterResource, node, schedulingMode,\n              resourceLimits, schedulerKey);\n      if (null !\u003d result) {\n        return result;\n      }\n    } else {\n      // pre-check when allocating reserved container\n      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n        // Release\n        return new ContainerAllocation(reservedContainer, null,\n            AllocationState.QUEUE_SKIPPED);\n      }\n    }\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, schedulerKey,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(schedulerKey);\n      }\n    }\n    \n    return result;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, priority-Priority, reservedContainer-RMContainer]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey, reservedContainer-RMContainer]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "07/06/16 3:06 PM",
          "commitNameOld": "620325e81696fca140195b74929ed9eda2d5eb16",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 48.99,
          "commitsBetweenForRepo": 441,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n   ContainerAllocation preAllocation(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, Priority priority,\n+      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n       RMContainer reservedContainer) {\n     ContainerAllocation result;\n     if (null \u003d\u003d reservedContainer) {\n       // pre-check when allocating new container\n       result \u003d\n           preCheckForNewContainer(clusterResource, node, schedulingMode,\n-              resourceLimits, priority);\n+              resourceLimits, schedulerKey);\n       if (null !\u003d result) {\n         return result;\n       }\n     } else {\n       // pre-check when allocating reserved container\n-      if (application.getTotalRequiredResources(priority) \u003d\u003d 0) {\n+      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n         // Release\n         return new ContainerAllocation(reservedContainer, null,\n             AllocationState.QUEUE_SKIPPED);\n       }\n     }\n \n     // Try to allocate containers on node\n     result \u003d\n-        assignContainersOnNode(clusterResource, node, priority,\n+        assignContainersOnNode(clusterResource, node, schedulerKey,\n             reservedContainer, schedulingMode, resourceLimits);\n     \n     if (null \u003d\u003d reservedContainer) {\n       if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n         // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n-        application.subtractSchedulingOpportunity(priority);\n+        application.subtractSchedulingOpportunity(schedulerKey);\n       }\n     }\n     \n     return result;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  ContainerAllocation preAllocation(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n    if (null \u003d\u003d reservedContainer) {\n      // pre-check when allocating new container\n      result \u003d\n          preCheckForNewContainer(clusterResource, node, schedulingMode,\n              resourceLimits, schedulerKey);\n      if (null !\u003d result) {\n        return result;\n      }\n    } else {\n      // pre-check when allocating reserved container\n      if (application.getTotalRequiredResources(schedulerKey) \u003d\u003d 0) {\n        // Release\n        return new ContainerAllocation(reservedContainer, null,\n            AllocationState.QUEUE_SKIPPED);\n      }\n    }\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, schedulerKey,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(schedulerKey);\n      }\n    }\n    \n    return result;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "ba2313d6145a1234777938a747187373f4cd58d9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3983. Refactored CapacityScheduleri#FiCaSchedulerApp to easier extend container allocation logic. Contributed by Wangda Tan\n",
      "commitDate": "05/08/15 1:47 PM",
      "commitName": "ba2313d6145a1234777938a747187373f4cd58d9",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,36 @@\n+  ContainerAllocation preAllocation(Resource clusterResource,\n+      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n+      ResourceLimits resourceLimits, Priority priority,\n+      RMContainer reservedContainer) {\n+    ContainerAllocation result;\n+    if (null \u003d\u003d reservedContainer) {\n+      // pre-check when allocating new container\n+      result \u003d\n+          preCheckForNewContainer(clusterResource, node, schedulingMode,\n+              resourceLimits, priority);\n+      if (null !\u003d result) {\n+        return result;\n+      }\n+    } else {\n+      // pre-check when allocating reserved container\n+      if (application.getTotalRequiredResources(priority) \u003d\u003d 0) {\n+        // Release\n+        return new ContainerAllocation(reservedContainer, null,\n+            AllocationState.QUEUE_SKIPPED);\n+      }\n+    }\n+\n+    // Try to allocate containers on node\n+    result \u003d\n+        assignContainersOnNode(clusterResource, node, priority,\n+            reservedContainer, schedulingMode, resourceLimits);\n+    \n+    if (null \u003d\u003d reservedContainer) {\n+      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n+        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n+        application.subtractSchedulingOpportunity(priority);\n+      }\n+    }\n+    \n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  ContainerAllocation preAllocation(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, Priority priority,\n      RMContainer reservedContainer) {\n    ContainerAllocation result;\n    if (null \u003d\u003d reservedContainer) {\n      // pre-check when allocating new container\n      result \u003d\n          preCheckForNewContainer(clusterResource, node, schedulingMode,\n              resourceLimits, priority);\n      if (null !\u003d result) {\n        return result;\n      }\n    } else {\n      // pre-check when allocating reserved container\n      if (application.getTotalRequiredResources(priority) \u003d\u003d 0) {\n        // Release\n        return new ContainerAllocation(reservedContainer, null,\n            AllocationState.QUEUE_SKIPPED);\n      }\n    }\n\n    // Try to allocate containers on node\n    result \u003d\n        assignContainersOnNode(clusterResource, node, priority,\n            reservedContainer, schedulingMode, resourceLimits);\n    \n    if (null \u003d\u003d reservedContainer) {\n      if (result.state \u003d\u003d AllocationState.PRIORITY_SKIPPED) {\n        // Don\u0027t count \u0027skipped nodes\u0027 as a scheduling opportunity!\n        application.subtractSchedulingOpportunity(priority);\n      }\n    }\n    \n    return result;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java"
    }
  }
}