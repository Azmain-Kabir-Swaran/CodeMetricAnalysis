{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JavaKeyStoreProvider.java",
  "functionName": "flush",
  "functionId": "flush",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
  "functionStartLine": 530,
  "functionEndLine": 584,
  "numCommitsSeen": 26,
  "timeTaken": 1752,
  "changeHistory": [
    "5af572b6443715b7a741296c1bd520a1840f9a7c",
    "a78953c974e52abe73905b1901a2354696f4a5a0",
    "74fe84393d9a8c412f69bbf0cd0ad06f3cc85e85",
    "98a98ea0c57d01b875b820f53d43dbf885d07711",
    "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2",
    "77306291643838ed7b57b99d6497553314a525f2"
  ],
  "changeHistoryShort": {
    "5af572b6443715b7a741296c1bd520a1840f9a7c": "Ybodychange",
    "a78953c974e52abe73905b1901a2354696f4a5a0": "Ybodychange",
    "74fe84393d9a8c412f69bbf0cd0ad06f3cc85e85": "Ybodychange",
    "98a98ea0c57d01b875b820f53d43dbf885d07711": "Ybodychange",
    "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2": "Ybodychange",
    "77306291643838ed7b57b99d6497553314a525f2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5af572b6443715b7a741296c1bd520a1840f9a7c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13427. Eliminate needless uses of FileSystem#{exists(), isFile(), isDirectory()}. Contributed by Steve Loughran and Mingliang Liu\n",
      "commitDate": "15/11/16 10:57 AM",
      "commitName": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "17/05/16 5:44 PM",
      "commitNameOld": "7154ace71212e9fb9dd6209a92165fb075df7806",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 181.76,
      "commitsBetweenForRepo": 1418,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   public void flush() throws IOException {\n     Path newPath \u003d constructNewPath(path);\n     Path oldPath \u003d constructOldPath(path);\n     Path resetPath \u003d path;\n     writeLock.lock();\n     try {\n       if (!changed) {\n         return;\n       }\n       // Might exist if a backup has been restored etc.\n-      if (fs.exists(newPath)) {\n+      try {\n         renameOrFail(newPath, new Path(newPath.toString()\n             + \"_ORPHANED_\" + System.currentTimeMillis()));\n+      } catch (FileNotFoundException ignored) {\n       }\n-      if (fs.exists(oldPath)) {\n+      try {\n         renameOrFail(oldPath, new Path(oldPath.toString()\n             + \"_ORPHANED_\" + System.currentTimeMillis()));\n+      } catch (FileNotFoundException ignored) {\n       }\n       // put all of the updates into the keystore\n       for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n         try {\n           keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n               password, null);\n         } catch (KeyStoreException e) {\n           throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n         }\n       }\n \n       // Save old File first\n       boolean fileExisted \u003d backupToOld(oldPath);\n       if (fileExisted) {\n         resetPath \u003d oldPath;\n       }\n       // write out the keystore\n       // Write to _NEW path first :\n       try {\n         writeToNew(newPath);\n       } catch (IOException ioe) {\n         // rename _OLD back to curent and throw Exception\n         revertFromOld(oldPath, fileExisted);\n         resetPath \u003d path;\n         throw ioe;\n       }\n       // Rename _NEW to CURRENT and delete _OLD\n       cleanupNewAndOld(newPath, oldPath);\n       changed \u003d false;\n     } catch (IOException ioe) {\n       resetKeyStoreState(resetPath);\n       throw ioe;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    Path newPath \u003d constructNewPath(path);\n    Path oldPath \u003d constructOldPath(path);\n    Path resetPath \u003d path;\n    writeLock.lock();\n    try {\n      if (!changed) {\n        return;\n      }\n      // Might exist if a backup has been restored etc.\n      try {\n        renameOrFail(newPath, new Path(newPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      } catch (FileNotFoundException ignored) {\n      }\n      try {\n        renameOrFail(oldPath, new Path(oldPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      } catch (FileNotFoundException ignored) {\n      }\n      // put all of the updates into the keystore\n      for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n        try {\n          keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n              password, null);\n        } catch (KeyStoreException e) {\n          throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n        }\n      }\n\n      // Save old File first\n      boolean fileExisted \u003d backupToOld(oldPath);\n      if (fileExisted) {\n        resetPath \u003d oldPath;\n      }\n      // write out the keystore\n      // Write to _NEW path first :\n      try {\n        writeToNew(newPath);\n      } catch (IOException ioe) {\n        // rename _OLD back to curent and throw Exception\n        revertFromOld(oldPath, fileExisted);\n        resetPath \u003d path;\n        throw ioe;\n      }\n      // Rename _NEW to CURRENT and delete _OLD\n      cleanupNewAndOld(newPath, oldPath);\n      changed \u003d false;\n    } catch (IOException ioe) {\n      resetKeyStoreState(resetPath);\n      throw ioe;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "a78953c974e52abe73905b1901a2354696f4a5a0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11110. JavaKeystoreProvider should not report a key as created if it was not flushed to the backing file. (Arun Suresh via wang)\n",
      "commitDate": "29/09/14 1:10 PM",
      "commitName": "a78953c974e52abe73905b1901a2354696f4a5a0",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "29/08/14 2:21 PM",
      "commitNameOld": "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 30.95,
      "commitsBetweenForRepo": 310,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,53 @@\n   public void flush() throws IOException {\n     Path newPath \u003d constructNewPath(path);\n     Path oldPath \u003d constructOldPath(path);\n+    Path resetPath \u003d path;\n     writeLock.lock();\n     try {\n       if (!changed) {\n         return;\n       }\n       // Might exist if a backup has been restored etc.\n       if (fs.exists(newPath)) {\n         renameOrFail(newPath, new Path(newPath.toString()\n             + \"_ORPHANED_\" + System.currentTimeMillis()));\n       }\n       if (fs.exists(oldPath)) {\n         renameOrFail(oldPath, new Path(oldPath.toString()\n             + \"_ORPHANED_\" + System.currentTimeMillis()));\n       }\n       // put all of the updates into the keystore\n       for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n         try {\n           keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n               password, null);\n         } catch (KeyStoreException e) {\n           throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n         }\n       }\n \n       // Save old File first\n       boolean fileExisted \u003d backupToOld(oldPath);\n+      if (fileExisted) {\n+        resetPath \u003d oldPath;\n+      }\n       // write out the keystore\n       // Write to _NEW path first :\n       try {\n         writeToNew(newPath);\n       } catch (IOException ioe) {\n         // rename _OLD back to curent and throw Exception\n         revertFromOld(oldPath, fileExisted);\n+        resetPath \u003d path;\n         throw ioe;\n       }\n       // Rename _NEW to CURRENT and delete _OLD\n       cleanupNewAndOld(newPath, oldPath);\n       changed \u003d false;\n+    } catch (IOException ioe) {\n+      resetKeyStoreState(resetPath);\n+      throw ioe;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    Path newPath \u003d constructNewPath(path);\n    Path oldPath \u003d constructOldPath(path);\n    Path resetPath \u003d path;\n    writeLock.lock();\n    try {\n      if (!changed) {\n        return;\n      }\n      // Might exist if a backup has been restored etc.\n      if (fs.exists(newPath)) {\n        renameOrFail(newPath, new Path(newPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      }\n      if (fs.exists(oldPath)) {\n        renameOrFail(oldPath, new Path(oldPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      }\n      // put all of the updates into the keystore\n      for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n        try {\n          keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n              password, null);\n        } catch (KeyStoreException e) {\n          throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n        }\n      }\n\n      // Save old File first\n      boolean fileExisted \u003d backupToOld(oldPath);\n      if (fileExisted) {\n        resetPath \u003d oldPath;\n      }\n      // write out the keystore\n      // Write to _NEW path first :\n      try {\n        writeToNew(newPath);\n      } catch (IOException ioe) {\n        // rename _OLD back to curent and throw Exception\n        revertFromOld(oldPath, fileExisted);\n        resetPath \u003d path;\n        throw ioe;\n      }\n      // Rename _NEW to CURRENT and delete _OLD\n      cleanupNewAndOld(newPath, oldPath);\n      changed \u003d false;\n    } catch (IOException ioe) {\n      resetKeyStoreState(resetPath);\n      throw ioe;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "74fe84393d9a8c412f69bbf0cd0ad06f3cc85e85": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10224. JavaKeyStoreProvider has to protect against corrupting underlying store. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616908 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 5:00 PM",
      "commitName": "74fe84393d9a8c412f69bbf0cd0ad06f3cc85e85",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "04/07/14 10:31 AM",
      "commitNameOld": "7b5295513dce9768083ae53282013e31d74573c6",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 35.27,
      "commitsBetweenForRepo": 255,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,45 @@\n   public void flush() throws IOException {\n+    Path newPath \u003d constructNewPath(path);\n+    Path oldPath \u003d constructOldPath(path);\n     writeLock.lock();\n     try {\n       if (!changed) {\n         return;\n       }\n+      // Might exist if a backup has been restored etc.\n+      if (fs.exists(newPath)) {\n+        renameOrFail(newPath, new Path(newPath.toString()\n+            + \"_ORPHANED_\" + System.currentTimeMillis()));\n+      }\n+      if (fs.exists(oldPath)) {\n+        renameOrFail(oldPath, new Path(oldPath.toString()\n+            + \"_ORPHANED_\" + System.currentTimeMillis()));\n+      }\n       // put all of the updates into the keystore\n       for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n         try {\n           keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n               password, null);\n         } catch (KeyStoreException e) {\n           throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n         }\n       }\n+\n+      // Save old File first\n+      boolean fileExisted \u003d backupToOld(oldPath);\n       // write out the keystore\n-      FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n+      // Write to _NEW path first :\n       try {\n-        keyStore.store(out, password);\n-      } catch (KeyStoreException e) {\n-        throw new IOException(\"Can\u0027t store keystore \" + this, e);\n-      } catch (NoSuchAlgorithmException e) {\n-        throw new IOException(\"No such algorithm storing keystore \" + this, e);\n-      } catch (CertificateException e) {\n-        throw new IOException(\"Certificate exception storing keystore \" + this,\n-            e);\n+        writeToNew(newPath);\n+      } catch (IOException ioe) {\n+        // rename _OLD back to curent and throw Exception\n+        revertFromOld(oldPath, fileExisted);\n+        throw ioe;\n       }\n-      out.close();\n+      // Rename _NEW to CURRENT and delete _OLD\n+      cleanupNewAndOld(newPath, oldPath);\n       changed \u003d false;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    Path newPath \u003d constructNewPath(path);\n    Path oldPath \u003d constructOldPath(path);\n    writeLock.lock();\n    try {\n      if (!changed) {\n        return;\n      }\n      // Might exist if a backup has been restored etc.\n      if (fs.exists(newPath)) {\n        renameOrFail(newPath, new Path(newPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      }\n      if (fs.exists(oldPath)) {\n        renameOrFail(oldPath, new Path(oldPath.toString()\n            + \"_ORPHANED_\" + System.currentTimeMillis()));\n      }\n      // put all of the updates into the keystore\n      for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n        try {\n          keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n              password, null);\n        } catch (KeyStoreException e) {\n          throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n        }\n      }\n\n      // Save old File first\n      boolean fileExisted \u003d backupToOld(oldPath);\n      // write out the keystore\n      // Write to _NEW path first :\n      try {\n        writeToNew(newPath);\n      } catch (IOException ioe) {\n        // rename _OLD back to curent and throw Exception\n        revertFromOld(oldPath, fileExisted);\n        throw ioe;\n      }\n      // Rename _NEW to CURRENT and delete _OLD\n      cleanupNewAndOld(newPath, oldPath);\n      changed \u003d false;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "98a98ea0c57d01b875b820f53d43dbf885d07711": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10427. KeyProvider implementations should be thread safe. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/14 12:43 PM",
      "commitName": "98a98ea0c57d01b875b820f53d43dbf885d07711",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "28/03/14 8:57 AM",
      "commitNameOld": "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 12.16,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,33 @@\n   public void flush() throws IOException {\n-    if (!changed) {\n-      return;\n-    }\n-    // put all of the updates into the keystore\n-    for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n-      try {\n-        keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n-            password, null);\n-      } catch (KeyStoreException e) {\n-        throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n-      }\n-    }\n-    // write out the keystore\n-    FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n+    writeLock.lock();\n     try {\n-      keyStore.store(out, password);\n-    } catch (KeyStoreException e) {\n-      throw new IOException(\"Can\u0027t store keystore \" + this, e);\n-    } catch (NoSuchAlgorithmException e) {\n-      throw new IOException(\"No such algorithm storing keystore \" + this, e);\n-    } catch (CertificateException e) {\n-      throw new IOException(\"Certificate exception storing keystore \" + this,\n-          e);\n+      if (!changed) {\n+        return;\n+      }\n+      // put all of the updates into the keystore\n+      for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n+        try {\n+          keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n+              password, null);\n+        } catch (KeyStoreException e) {\n+          throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n+        }\n+      }\n+      // write out the keystore\n+      FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n+      try {\n+        keyStore.store(out, password);\n+      } catch (KeyStoreException e) {\n+        throw new IOException(\"Can\u0027t store keystore \" + this, e);\n+      } catch (NoSuchAlgorithmException e) {\n+        throw new IOException(\"No such algorithm storing keystore \" + this, e);\n+      } catch (CertificateException e) {\n+        throw new IOException(\"Certificate exception storing keystore \" + this,\n+            e);\n+      }\n+      out.close();\n+      changed \u003d false;\n+    } finally {\n+      writeLock.unlock();\n     }\n-    out.close();\n-    changed \u003d false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    writeLock.lock();\n    try {\n      if (!changed) {\n        return;\n      }\n      // put all of the updates into the keystore\n      for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n        try {\n          keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n              password, null);\n        } catch (KeyStoreException e) {\n          throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n        }\n      }\n      // write out the keystore\n      FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n      try {\n        keyStore.store(out, password);\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Can\u0027t store keystore \" + this, e);\n      } catch (NoSuchAlgorithmException e) {\n        throw new IOException(\"No such algorithm storing keystore \" + this, e);\n      } catch (CertificateException e) {\n        throw new IOException(\"Certificate exception storing keystore \" + this,\n            e);\n      }\n      out.close();\n      changed \u003d false;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10237. JavaKeyStoreProvider needs to set keystore permissions \ncorrectly. (Larry McCay via omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582784 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/14 8:57 AM",
      "commitName": "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "16/01/14 9:48 AM",
      "commitNameOld": "e05ff82bd95dd802233e2424e8eafbd7ec6944c5",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 70.92,
      "commitsBetweenForRepo": 617,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public void flush() throws IOException {\n     if (!changed) {\n       return;\n     }\n     // put all of the updates into the keystore\n     for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n       try {\n         keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n             password, null);\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n       }\n     }\n     // write out the keystore\n-    FSDataOutputStream out \u003d fs.create(path, true);\n+    FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n     try {\n       keyStore.store(out, password);\n     } catch (KeyStoreException e) {\n       throw new IOException(\"Can\u0027t store keystore \" + this, e);\n     } catch (NoSuchAlgorithmException e) {\n       throw new IOException(\"No such algorithm storing keystore \" + this, e);\n     } catch (CertificateException e) {\n       throw new IOException(\"Certificate exception storing keystore \" + this,\n           e);\n     }\n     out.close();\n     changed \u003d false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    if (!changed) {\n      return;\n    }\n    // put all of the updates into the keystore\n    for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n      try {\n        keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n            password, null);\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n      }\n    }\n    // write out the keystore\n    FSDataOutputStream out \u003d FileSystem.create(fs, path, permissions);\n    try {\n      keyStore.store(out, password);\n    } catch (KeyStoreException e) {\n      throw new IOException(\"Can\u0027t store keystore \" + this, e);\n    } catch (NoSuchAlgorithmException e) {\n      throw new IOException(\"No such algorithm storing keystore \" + this, e);\n    } catch (CertificateException e) {\n      throw new IOException(\"Certificate exception storing keystore \" + this,\n          e);\n    }\n    out.close();\n    changed \u003d false;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "77306291643838ed7b57b99d6497553314a525f2": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10141. Create KeyProvider API to separate encryption key storage\nfrom the applications. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552462 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/12/13 4:25 PM",
      "commitName": "77306291643838ed7b57b99d6497553314a525f2",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,28 @@\n+  public void flush() throws IOException {\n+    if (!changed) {\n+      return;\n+    }\n+    // put all of the updates into the keystore\n+    for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n+      try {\n+        keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n+            password, null);\n+      } catch (KeyStoreException e) {\n+        throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n+      }\n+    }\n+    // write out the keystore\n+    FSDataOutputStream out \u003d fs.create(path, true);\n+    try {\n+      keyStore.store(out, password);\n+    } catch (KeyStoreException e) {\n+      throw new IOException(\"Can\u0027t store keystore \" + this, e);\n+    } catch (NoSuchAlgorithmException e) {\n+      throw new IOException(\"No such algorithm storing keystore \" + this, e);\n+    } catch (CertificateException e) {\n+      throw new IOException(\"Certificate exception storing keystore \" + this,\n+          e);\n+    }\n+    out.close();\n+    changed \u003d false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void flush() throws IOException {\n    if (!changed) {\n      return;\n    }\n    // put all of the updates into the keystore\n    for(Map.Entry\u003cString, Metadata\u003e entry: cache.entrySet()) {\n      try {\n        keyStore.setKeyEntry(entry.getKey(), new KeyMetadata(entry.getValue()),\n            password, null);\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Can\u0027t set metadata key \" + entry.getKey(),e );\n      }\n    }\n    // write out the keystore\n    FSDataOutputStream out \u003d fs.create(path, true);\n    try {\n      keyStore.store(out, password);\n    } catch (KeyStoreException e) {\n      throw new IOException(\"Can\u0027t store keystore \" + this, e);\n    } catch (NoSuchAlgorithmException e) {\n      throw new IOException(\"No such algorithm storing keystore \" + this, e);\n    } catch (CertificateException e) {\n      throw new IOException(\"Certificate exception storing keystore \" + this,\n          e);\n    }\n    out.close();\n    changed \u003d false;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java"
    }
  }
}