{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ActivitiesManager.java",
  "functionName": "finishAppAllocationRecording",
  "functionId": "finishAppAllocationRecording___applicationId-ApplicationId__containerId-ContainerId__appState-ActivityState__diagnostic-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
  "functionStartLine": 429,
  "functionEndLine": 459,
  "numCommitsSeen": 16,
  "timeTaken": 2908,
  "changeHistory": [
    "09763925025a3709e6098186348e1afd80cb9f71",
    "1a47c2b7aed1ccd562d393b79772d01244ccab44",
    "7fa73fac2676875561269e9408215e012269a18c",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188"
  ],
  "changeHistoryShort": {
    "09763925025a3709e6098186348e1afd80cb9f71": "Ybodychange",
    "1a47c2b7aed1ccd562d393b79772d01244ccab44": "Ybodychange",
    "7fa73fac2676875561269e9408215e012269a18c": "Ybodychange",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Yintroduced"
  },
  "changeHistoryDetails": {
    "09763925025a3709e6098186348e1afd80cb9f71": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9590. Correct incompatible, incomplete and redundant activities. Contributed by Tao Yang.\n",
      "commitDate": "06/06/19 6:59 AM",
      "commitName": "09763925025a3709e6098186348e1afd80cb9f71",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "26/05/19 6:56 AM",
      "commitNameOld": "9f056d905f3d21faf0dc9bd42e14ea61313ee9e8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   void finishAppAllocationRecording(ApplicationId applicationId,\n       ContainerId containerId, ActivityState appState, String diagnostic) {\n     if (shouldRecordThisApp(applicationId)) {\n       long currTS \u003d SystemClock.getInstance().getTime();\n       AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n       appAllocation.updateAppContainerStateAndTime(containerId, appState,\n           currTS, diagnostic);\n \n       Queue\u003cAppAllocation\u003e appAllocations \u003d\n           completedAppAllocations.get(applicationId);\n       if (appAllocations \u003d\u003d null) {\n         appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n         Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n             completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n         if (curAppAllocations !\u003d null) {\n           appAllocations \u003d curAppAllocations;\n         }\n       }\n-      if (appAllocations.size() \u003d\u003d appActivitiesMaxQueueLength) {\n+      int curQueueLength \u003d appAllocations.size();\n+      while (curQueueLength \u003e\u003d appActivitiesMaxQueueLength) {\n         appAllocations.poll();\n+        --curQueueLength;\n       }\n       appAllocations.add(appAllocation);\n       Long stopTime \u003d\n           recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n       if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n         turnOffActivityMonitoringForApp(applicationId);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void finishAppAllocationRecording(ApplicationId applicationId,\n      ContainerId containerId, ActivityState appState, String diagnostic) {\n    if (shouldRecordThisApp(applicationId)) {\n      long currTS \u003d SystemClock.getInstance().getTime();\n      AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n      appAllocation.updateAppContainerStateAndTime(containerId, appState,\n          currTS, diagnostic);\n\n      Queue\u003cAppAllocation\u003e appAllocations \u003d\n          completedAppAllocations.get(applicationId);\n      if (appAllocations \u003d\u003d null) {\n        appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n        Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n            completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n        if (curAppAllocations !\u003d null) {\n          appAllocations \u003d curAppAllocations;\n        }\n      }\n      int curQueueLength \u003d appAllocations.size();\n      while (curQueueLength \u003e\u003d appActivitiesMaxQueueLength) {\n        appAllocations.poll();\n        --curQueueLength;\n      }\n      appAllocations.add(appAllocation);\n      Long stopTime \u003d\n          recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n      if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n        turnOffActivityMonitoringForApp(applicationId);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "1a47c2b7aed1ccd562d393b79772d01244ccab44": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9539.Improve cleanup process of app activities and make some conditions configurable. Contributed by Tao Yang.\n",
      "commitDate": "12/05/19 10:31 PM",
      "commitName": "1a47c2b7aed1ccd562d393b79772d01244ccab44",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "09/05/19 6:54 AM",
      "commitNameOld": "90add05caa6c48659f0c592ec391b30f2a76069e",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 3.65,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   void finishAppAllocationRecording(ApplicationId applicationId,\n       ContainerId containerId, ActivityState appState, String diagnostic) {\n     if (shouldRecordThisApp(applicationId)) {\n       long currTS \u003d SystemClock.getInstance().getTime();\n       AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n       appAllocation.updateAppContainerStateAndTime(containerId, appState,\n           currTS, diagnostic);\n \n       Queue\u003cAppAllocation\u003e appAllocations \u003d\n           completedAppAllocations.get(applicationId);\n       if (appAllocations \u003d\u003d null) {\n         appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n         Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n             completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n         if (curAppAllocations !\u003d null) {\n           appAllocations \u003d curAppAllocations;\n         }\n       }\n-      if (appAllocations.size() \u003d\u003d 1000) {\n+      if (appAllocations.size() \u003d\u003d appActivitiesMaxQueueLength) {\n         appAllocations.poll();\n       }\n       appAllocations.add(appAllocation);\n       Long stopTime \u003d\n           recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n       if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n         turnOffActivityMonitoringForApp(applicationId);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void finishAppAllocationRecording(ApplicationId applicationId,\n      ContainerId containerId, ActivityState appState, String diagnostic) {\n    if (shouldRecordThisApp(applicationId)) {\n      long currTS \u003d SystemClock.getInstance().getTime();\n      AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n      appAllocation.updateAppContainerStateAndTime(containerId, appState,\n          currTS, diagnostic);\n\n      Queue\u003cAppAllocation\u003e appAllocations \u003d\n          completedAppAllocations.get(applicationId);\n      if (appAllocations \u003d\u003d null) {\n        appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n        Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n            completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n        if (curAppAllocations !\u003d null) {\n          appAllocations \u003d curAppAllocations;\n        }\n      }\n      if (appAllocations.size() \u003d\u003d appActivitiesMaxQueueLength) {\n        appAllocations.poll();\n      }\n      appAllocations.add(appAllocation);\n      Long stopTime \u003d\n          recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n      if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n        turnOffActivityMonitoringForApp(applicationId);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "7fa73fac2676875561269e9408215e012269a18c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9439. Support asynchronized scheduling mode and multi-node lookup mechanism for app activities. Contributed by Tao Yang.\n",
      "commitDate": "15/04/19 9:12 AM",
      "commitName": "7fa73fac2676875561269e9408215e012269a18c",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "07/04/19 10:40 PM",
      "commitNameOld": "fc05b0e70e9bb556d6bdc00fa8735e18a6f90bc9",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 7.44,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,29 @@\n   void finishAppAllocationRecording(ApplicationId applicationId,\n       ContainerId containerId, ActivityState appState, String diagnostic) {\n     if (shouldRecordThisApp(applicationId)) {\n       long currTS \u003d SystemClock.getInstance().getTime();\n-      AppAllocation appAllocation \u003d appsAllocation.remove(applicationId);\n+      AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n       appAllocation.updateAppContainerStateAndTime(containerId, appState,\n           currTS, diagnostic);\n \n-      List\u003cAppAllocation\u003e appAllocations;\n-      if (completedAppAllocations.containsKey(applicationId)) {\n-        appAllocations \u003d completedAppAllocations.get(applicationId);\n-      } else {\n-        appAllocations \u003d new ArrayList\u003c\u003e();\n-        completedAppAllocations.put(applicationId, appAllocations);\n+      Queue\u003cAppAllocation\u003e appAllocations \u003d\n+          completedAppAllocations.get(applicationId);\n+      if (appAllocations \u003d\u003d null) {\n+        appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n+        Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n+            completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n+        if (curAppAllocations !\u003d null) {\n+          appAllocations \u003d curAppAllocations;\n+        }\n       }\n       if (appAllocations.size() \u003d\u003d 1000) {\n-        appAllocations.remove(0);\n+        appAllocations.poll();\n       }\n       appAllocations.add(appAllocation);\n-\n-      if (recordingAppActivitiesUntilSpecifiedTime.get(applicationId)\n-          \u003c\u003d currTS) {\n+      Long stopTime \u003d\n+          recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n+      if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n         turnOffActivityMonitoringForApp(applicationId);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void finishAppAllocationRecording(ApplicationId applicationId,\n      ContainerId containerId, ActivityState appState, String diagnostic) {\n    if (shouldRecordThisApp(applicationId)) {\n      long currTS \u003d SystemClock.getInstance().getTime();\n      AppAllocation appAllocation \u003d appsAllocation.get().remove(applicationId);\n      appAllocation.updateAppContainerStateAndTime(containerId, appState,\n          currTS, diagnostic);\n\n      Queue\u003cAppAllocation\u003e appAllocations \u003d\n          completedAppAllocations.get(applicationId);\n      if (appAllocations \u003d\u003d null) {\n        appAllocations \u003d new ConcurrentLinkedQueue\u003c\u003e();\n        Queue\u003cAppAllocation\u003e curAppAllocations \u003d\n            completedAppAllocations.putIfAbsent(applicationId, appAllocations);\n        if (curAppAllocations !\u003d null) {\n          appAllocations \u003d curAppAllocations;\n        }\n      }\n      if (appAllocations.size() \u003d\u003d 1000) {\n        appAllocations.poll();\n      }\n      appAllocations.add(appAllocation);\n      Long stopTime \u003d\n          recordingAppActivitiesUntilSpecifiedTime.get(applicationId);\n      if (stopTime !\u003d null \u0026\u0026 stopTime \u003c\u003d currTS) {\n        turnOffActivityMonitoringForApp(applicationId);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java",
      "extendedDetails": {}
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,26 @@\n+  void finishAppAllocationRecording(ApplicationId applicationId,\n+      ContainerId containerId, ActivityState appState, String diagnostic) {\n+    if (shouldRecordThisApp(applicationId)) {\n+      long currTS \u003d SystemClock.getInstance().getTime();\n+      AppAllocation appAllocation \u003d appsAllocation.remove(applicationId);\n+      appAllocation.updateAppContainerStateAndTime(containerId, appState,\n+          currTS, diagnostic);\n+\n+      List\u003cAppAllocation\u003e appAllocations;\n+      if (completedAppAllocations.containsKey(applicationId)) {\n+        appAllocations \u003d completedAppAllocations.get(applicationId);\n+      } else {\n+        appAllocations \u003d new ArrayList\u003c\u003e();\n+        completedAppAllocations.put(applicationId, appAllocations);\n+      }\n+      if (appAllocations.size() \u003d\u003d 1000) {\n+        appAllocations.remove(0);\n+      }\n+      appAllocations.add(appAllocation);\n+\n+      if (recordingAppActivitiesUntilSpecifiedTime.get(applicationId)\n+          \u003c\u003d currTS) {\n+        turnOffActivityMonitoringForApp(applicationId);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void finishAppAllocationRecording(ApplicationId applicationId,\n      ContainerId containerId, ActivityState appState, String diagnostic) {\n    if (shouldRecordThisApp(applicationId)) {\n      long currTS \u003d SystemClock.getInstance().getTime();\n      AppAllocation appAllocation \u003d appsAllocation.remove(applicationId);\n      appAllocation.updateAppContainerStateAndTime(containerId, appState,\n          currTS, diagnostic);\n\n      List\u003cAppAllocation\u003e appAllocations;\n      if (completedAppAllocations.containsKey(applicationId)) {\n        appAllocations \u003d completedAppAllocations.get(applicationId);\n      } else {\n        appAllocations \u003d new ArrayList\u003c\u003e();\n        completedAppAllocations.put(applicationId, appAllocations);\n      }\n      if (appAllocations.size() \u003d\u003d 1000) {\n        appAllocations.remove(0);\n      }\n      appAllocations.add(appAllocation);\n\n      if (recordingAppActivitiesUntilSpecifiedTime.get(applicationId)\n          \u003c\u003d currTS) {\n        turnOffActivityMonitoringForApp(applicationId);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/activities/ActivitiesManager.java"
    }
  }
}