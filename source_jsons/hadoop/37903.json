{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UserGroupMappingPlacementRule.java",
  "functionName": "initialize",
  "functionId": "initialize___scheduler-ResourceScheduler",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
  "functionStartLine": 280,
  "functionEndLine": 369,
  "numCommitsSeen": 34,
  "timeTaken": 11271,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "eca7e14c2fa95ded5ae47c149f9feb953138cd5b",
    "21ada4d1b029e08c0729a5d54b4235d2e8399205",
    "217b56ffdd5fa254f06734bc8cb6f04a02066f1a",
    "f8e36e03b4e65f173bf2330715dceafdb6111190",
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8",
    "a68d766e876631d7ee2e1a6504d4120ba628d178",
    "a90471b3e65326cc18ed31fe21aef654833b5883",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "eca7e14c2fa95ded5ae47c149f9feb953138cd5b": "Ybodychange",
    "21ada4d1b029e08c0729a5d54b4235d2e8399205": "Ybodychange",
    "217b56ffdd5fa254f06734bc8cb6f04a02066f1a": "Ybodychange",
    "f8e36e03b4e65f173bf2330715dceafdb6111190": "Ybodychange",
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8": "Ybodychange",
    "a68d766e876631d7ee2e1a6504d4120ba628d178": "Ymultichange(Yparameterchange,Ybodychange)",
    "a90471b3e65326cc18ed31fe21aef654833b5883": "Ymultichange(Yrename,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "23/03/20 5:31 AM",
      "commitNameOld": "d312991ead37a5f840577a39420a18f0621b09dc",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 1.95,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n+      //at this point mapping.getQueueName() return only the queue name, since\n+      //the config parsing have been changed making QueueMapping more consistent\n \n-      QueuePath queuePath \u003d QueuePlacementRuleUtils\n-              .extractQueuePath(mapping.getQueue());\n+      QueuePath queuePath \u003d mapping.getQueuePath();\n       if (isStaticQueueMapping(mapping)) {\n-        //Try getting queue by its leaf queue name\n-        // without splitting into parent/leaf queues\n-        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n+        //Try getting queue by its full path name, if it exists it is a static\n+        //leaf queue indeed, without any auto creation magic\n+        CSQueue queue \u003d queueManager.getQueue(mapping.getFullPath());\n         if (ifQueueDoesNotExist(queue)) {\n-          //Try getting the queue by extracting leaf and parent queue names\n-          //Assuming its a potential auto created leaf queue\n-          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n-\n-          if (ifQueueDoesNotExist(queue)) {\n-            //if leaf queue does not exist,\n-            // this could be a potential auto created leaf queue\n-            //validate if parent queue is specified,\n-            // then it should exist and\n-            // be an instance of AutoCreateEnabledParentQueue\n-            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n-                queueManager, mapping, queuePath);\n-            if (newMapping \u003d\u003d null) {\n-              throw new IOException(\n-                  \"mapping contains invalid or non-leaf queue \" + mapping\n-                      .getQueue());\n-            }\n-            newMappings.add(newMapping);\n-          } else{\n-            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n-                queue, mapping, queuePath);\n-            newMappings.add(newMapping);\n+          //We might not be able to find the queue, because the reference was\n+          // ambiguous this should only happen if the queue was referenced by\n+          // leaf name only\n+          if (queueManager.isAmbiguous(mapping.getFullPath())) {\n+            throw new IOException(\n+              \"mapping contains ambiguous leaf queue reference \" + mapping\n+                .getFullPath());\n           }\n-        } else{\n+\n+          //if leaf queue does not exist,\n+          // this could be a potential auto created leaf queue\n+          //validate if parent queue is specified,\n+          // then it should exist and\n+          // be an instance of AutoCreateEnabledParentQueue\n+          QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n+              queueManager, mapping, queuePath);\n+          if (newMapping \u003d\u003d null) {\n+            throw new IOException(\n+                \"mapping contains invalid or non-leaf queue \" + mapping\n+                    .getQueue());\n+          }\n+          newMappings.add(newMapping);\n+        } else {\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       this.mappings \u003d newMappings;\n       this.groups \u003d Groups.getUserToGroupsMappingService(\n           ((CapacityScheduler)scheduler).getConf());\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n      //at this point mapping.getQueueName() return only the queue name, since\n      //the config parsing have been changed making QueueMapping more consistent\n\n      QueuePath queuePath \u003d mapping.getQueuePath();\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its full path name, if it exists it is a static\n        //leaf queue indeed, without any auto creation magic\n        CSQueue queue \u003d queueManager.getQueue(mapping.getFullPath());\n        if (ifQueueDoesNotExist(queue)) {\n          //We might not be able to find the queue, because the reference was\n          // ambiguous this should only happen if the queue was referenced by\n          // leaf name only\n          if (queueManager.isAmbiguous(mapping.getFullPath())) {\n            throw new IOException(\n              \"mapping contains ambiguous leaf queue reference \" + mapping\n                .getFullPath());\n          }\n\n          //if leaf queue does not exist,\n          // this could be a potential auto created leaf queue\n          //validate if parent queue is specified,\n          // then it should exist and\n          // be an instance of AutoCreateEnabledParentQueue\n          QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n              queueManager, mapping, queuePath);\n          if (newMapping \u003d\u003d null) {\n            throw new IOException(\n                \"mapping contains invalid or non-leaf queue \" + mapping\n                    .getQueue());\n          }\n          newMappings.add(newMapping);\n        } else {\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.groups \u003d Groups.getUserToGroupsMappingService(\n          ((CapacityScheduler)scheduler).getConf());\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "eca7e14c2fa95ded5ae47c149f9feb953138cd5b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10053. Use Shared Group Mapping Service in Placement Rules.\n\nContributed by Wilfred Spiegelenburg.\n",
      "commitDate": "02/01/20 12:43 AM",
      "commitName": "eca7e14c2fa95ded5ae47c149f9feb953138cd5b",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "02/01/20 12:42 AM",
      "commitNameOld": "21ada4d1b029e08c0729a5d54b4235d2e8399205",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d QueuePlacementRuleUtils\n               .extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n-      Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n-      this.groups \u003d groups;\n+      this.groups \u003d Groups.getUserToGroupsMappingService(\n+          ((CapacityScheduler)scheduler).getConf());\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d QueuePlacementRuleUtils\n              .extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.groups \u003d Groups.getUserToGroupsMappingService(\n          ((CapacityScheduler)scheduler).getConf());\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "21ada4d1b029e08c0729a5d54b4235d2e8399205": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-10053. Use Shared Group Mapping Service in Placement Rules.\"\n\nThis reverts commit 217b56ffdd5fa254f06734bc8cb6f04a02066f1a.\n",
      "commitDate": "02/01/20 12:42 AM",
      "commitName": "21ada4d1b029e08c0729a5d54b4235d2e8399205",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "02/01/20 12:37 AM",
      "commitNameOld": "217b56ffdd5fa254f06734bc8cb6f04a02066f1a",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d QueuePlacementRuleUtils\n               .extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n+      Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n-      this.groups \u003d Groups.getUserToGroupsMappingService(\n-          ((CapacityScheduler)scheduler).getConf());\n+      this.groups \u003d groups;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d QueuePlacementRuleUtils\n              .extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "217b56ffdd5fa254f06734bc8cb6f04a02066f1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10053. Use Shared Group Mapping Service in Placement Rules.\n\nContributed by Wilfred Spiegelenburg.\n",
      "commitDate": "02/01/20 12:37 AM",
      "commitName": "217b56ffdd5fa254f06734bc8cb6f04a02066f1a",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "05/12/19 12:04 PM",
      "commitNameOld": "cf68857631fe12d3e3cabb53ab3029beab9457b7",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 27.52,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d QueuePlacementRuleUtils\n               .extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n-      Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n-      this.groups \u003d groups;\n+      this.groups \u003d Groups.getUserToGroupsMappingService(\n+          ((CapacityScheduler)scheduler).getConf());\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d QueuePlacementRuleUtils\n              .extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      this.mappings \u003d newMappings;\n      this.groups \u003d Groups.getUserToGroupsMappingService(\n          ((CapacityScheduler)scheduler).getConf());\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "f8e36e03b4e65f173bf2330715dceafdb6111190": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9966. Code duplication in UserGroupMappingPlacementRule (#1709)\n\n",
      "commitDate": "24/11/19 10:28 PM",
      "commitName": "f8e36e03b4e65f173bf2330715dceafdb6111190",
      "commitAuthor": "HUAN-PING SU",
      "commitDateOld": "11/11/19 4:28 AM",
      "commitNameOld": "30b93f914b7015d4567e199c51a2ebe727fee320",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 13.75,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,90 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n-      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n+      QueuePath queuePath \u003d QueuePlacementRuleUtils\n+              .extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n       this.groups \u003d groups;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d QueuePlacementRuleUtils\n              .extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9840. Capacity scheduler: add support for Secondary Group rule mapping. Contributed by Manikandan R\n",
      "commitDate": "15/10/19 8:22 AM",
      "commitName": "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "11/08/19 10:14 PM",
      "commitNameOld": "8fbf8b2eb09448e49297c0e93a6e10ae489e8745",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 64.42,
      "commitsBetweenForRepo": 564,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,89 @@\n   public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n     if (!(scheduler instanceof CapacityScheduler)) {\n       throw new IOException(\n           \"UserGroupMappingPlacementRule can be configured only for \"\n               + \"CapacityScheduler\");\n     }\n     CapacitySchedulerContext schedulerContext \u003d\n         (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n-    CapacitySchedulerQueueManager queueManager \u003d\n-        schedulerContext.getCapacitySchedulerQueueManager();\n+    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n       this.groups \u003d groups;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    queueManager \u003d schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "a68d766e876631d7ee2e1a6504d4120ba628d178": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
      "commitDate": "29/11/18 8:13 AM",
      "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
      "commitAuthor": "bibinchundatt",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
          "commitDate": "29/11/18 8:13 AM",
          "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
          "commitAuthor": "bibinchundatt",
          "commitDateOld": "12/06/18 8:35 AM",
          "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 170.03,
          "commitsBetweenForRepo": 1375,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,90 @@\n-  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+  public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n+    if (!(scheduler instanceof CapacityScheduler)) {\n+      throw new IOException(\n+          \"UserGroupMappingPlacementRule can be configured only for \"\n+              + \"CapacityScheduler\");\n+    }\n+    CapacitySchedulerContext schedulerContext \u003d\n+        (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n       this.groups \u003d groups;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "[schedulerContext-CapacitySchedulerContext]",
            "newValue": "[scheduler-ResourceScheduler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8948. PlacementRule interface should be for all YarnSchedulers. Contributed by Bibin A Chundatt.\n",
          "commitDate": "29/11/18 8:13 AM",
          "commitName": "a68d766e876631d7ee2e1a6504d4120ba628d178",
          "commitAuthor": "bibinchundatt",
          "commitDateOld": "12/06/18 8:35 AM",
          "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 170.03,
          "commitsBetweenForRepo": 1375,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,90 @@\n-  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+  public boolean initialize(ResourceScheduler scheduler)\n       throws IOException {\n+    if (!(scheduler instanceof CapacityScheduler)) {\n+      throw new IOException(\n+          \"UserGroupMappingPlacementRule can be configured only for \"\n+              + \"CapacityScheduler\");\n+    }\n+    CapacitySchedulerContext schedulerContext \u003d\n+        (CapacitySchedulerContext) scheduler;\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n       this.mappings \u003d newMappings;\n       this.groups \u003d groups;\n       this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n       return true;\n     }\n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(ResourceScheduler scheduler)\n      throws IOException {\n    if (!(scheduler instanceof CapacityScheduler)) {\n      throw new IOException(\n          \"UserGroupMappingPlacementRule can be configured only for \"\n              + \"CapacityScheduler\");\n    }\n    CapacitySchedulerContext schedulerContext \u003d\n        (CapacitySchedulerContext) scheduler;\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {}
        }
      ]
    },
    "a90471b3e65326cc18ed31fe21aef654833b5883": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
      "commitDate": "23/03/18 4:43 PM",
      "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
          "commitDate": "23/03/18 4:43 PM",
          "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "13/03/18 5:55 PM",
          "commitNameOld": "b167d60763f4b9ac69976df2da5d988e5faa85e0",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.95,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,83 @@\n-  public static UserGroupMappingPlacementRule get(\n-      CapacitySchedulerContext schedulerContext) throws IOException {\n+  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+      throws IOException {\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n-      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n-          newMappings, groups);\n+      this.mappings \u003d newMappings;\n+      this.groups \u003d groups;\n+      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      return true;\n     }\n-\n-    return null;\n+    return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "get",
            "newValue": "initialize"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
          "commitDate": "23/03/18 4:43 PM",
          "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "13/03/18 5:55 PM",
          "commitNameOld": "b167d60763f4b9ac69976df2da5d988e5faa85e0",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.95,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,83 @@\n-  public static UserGroupMappingPlacementRule get(\n-      CapacitySchedulerContext schedulerContext) throws IOException {\n+  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+      throws IOException {\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n-      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n-          newMappings, groups);\n+      this.mappings \u003d newMappings;\n+      this.groups \u003d groups;\n+      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      return true;\n     }\n-\n-    return null;\n+    return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "UserGroupMappingPlacementRule",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
          "commitDate": "23/03/18 4:43 PM",
          "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "13/03/18 5:55 PM",
          "commitNameOld": "b167d60763f4b9ac69976df2da5d988e5faa85e0",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.95,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,83 @@\n-  public static UserGroupMappingPlacementRule get(\n-      CapacitySchedulerContext schedulerContext) throws IOException {\n+  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+      throws IOException {\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n-      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n-          newMappings, groups);\n+      this.mappings \u003d newMappings;\n+      this.groups \u003d groups;\n+      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      return true;\n     }\n-\n-    return null;\n+    return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8016. Refine PlacementRule interface and add a app-name queue mapping rule as an example. (Zian Chen via wangda)\n\nChange-Id: I35caf1480e0f76f5f3a53528af09312e39414bbb\n",
          "commitDate": "23/03/18 4:43 PM",
          "commitName": "a90471b3e65326cc18ed31fe21aef654833b5883",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "13/03/18 5:55 PM",
          "commitNameOld": "b167d60763f4b9ac69976df2da5d988e5faa85e0",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 9.95,
          "commitsBetweenForRepo": 203,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,83 @@\n-  public static UserGroupMappingPlacementRule get(\n-      CapacitySchedulerContext schedulerContext) throws IOException {\n+  public boolean initialize(CapacitySchedulerContext schedulerContext)\n+      throws IOException {\n     CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n     boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n     LOG.info(\n         \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n \n     List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n \n     // Get new user/group mappings\n     List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n \n     CapacitySchedulerQueueManager queueManager \u003d\n         schedulerContext.getCapacitySchedulerQueueManager();\n \n     // check if mappings refer to valid queues\n     for (QueueMapping mapping : queueMappings) {\n \n       QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n       if (isStaticQueueMapping(mapping)) {\n         //Try getting queue by its leaf queue name\n         // without splitting into parent/leaf queues\n         CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n         if (ifQueueDoesNotExist(queue)) {\n           //Try getting the queue by extracting leaf and parent queue names\n           //Assuming its a potential auto created leaf queue\n           queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n \n           if (ifQueueDoesNotExist(queue)) {\n             //if leaf queue does not exist,\n             // this could be a potential auto created leaf queue\n             //validate if parent queue is specified,\n             // then it should exist and\n             // be an instance of AutoCreateEnabledParentQueue\n             QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                 queueManager, mapping, queuePath);\n             if (newMapping \u003d\u003d null) {\n               throw new IOException(\n                   \"mapping contains invalid or non-leaf queue \" + mapping\n                       .getQueue());\n             }\n             newMappings.add(newMapping);\n           } else{\n             QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                 queue, mapping, queuePath);\n             newMappings.add(newMapping);\n           }\n         } else{\n           // if queue exists, validate\n           //   if its an instance of leaf queue\n           //   if its an instance of auto created leaf queue,\n           // then extract parent queue name and update queue mapping\n           QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n               queue, mapping, queuePath);\n           newMappings.add(newMapping);\n         }\n       } else{\n         //If it is a dynamic queue mapping,\n         // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n         // validate\n         // if parent queue is specified, then\n         //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n         //\n         QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n             queueManager, mapping, queuePath);\n         if (newMapping !\u003d null) {\n           newMappings.add(newMapping);\n         } else{\n           newMappings.add(mapping);\n         }\n       }\n     }\n \n     // initialize groups if mappings are present\n     if (newMappings.size() \u003e 0) {\n       Groups groups \u003d new Groups(conf);\n-      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n-          newMappings, groups);\n+      this.mappings \u003d newMappings;\n+      this.groups \u003d groups;\n+      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n+      return true;\n     }\n-\n-    return null;\n+    return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean initialize(CapacitySchedulerContext schedulerContext)\n      throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      this.mappings \u003d newMappings;\n      this.groups \u003d groups;\n      this.overrideWithQueueMappings \u003d overrideWithQueueMappings;\n      return true;\n    }\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {}
        }
      ]
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,82 @@\n+  public static UserGroupMappingPlacementRule get(\n+      CapacitySchedulerContext schedulerContext) throws IOException {\n+    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n+    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n+    LOG.info(\n+        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n+\n+    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n+\n+    // Get new user/group mappings\n+    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n+\n+    CapacitySchedulerQueueManager queueManager \u003d\n+        schedulerContext.getCapacitySchedulerQueueManager();\n+\n+    // check if mappings refer to valid queues\n+    for (QueueMapping mapping : queueMappings) {\n+\n+      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n+      if (isStaticQueueMapping(mapping)) {\n+        //Try getting queue by its leaf queue name\n+        // without splitting into parent/leaf queues\n+        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n+        if (ifQueueDoesNotExist(queue)) {\n+          //Try getting the queue by extracting leaf and parent queue names\n+          //Assuming its a potential auto created leaf queue\n+          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n+\n+          if (ifQueueDoesNotExist(queue)) {\n+            //if leaf queue does not exist,\n+            // this could be a potential auto created leaf queue\n+            //validate if parent queue is specified,\n+            // then it should exist and\n+            // be an instance of AutoCreateEnabledParentQueue\n+            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n+                queueManager, mapping, queuePath);\n+            if (newMapping \u003d\u003d null) {\n+              throw new IOException(\n+                  \"mapping contains invalid or non-leaf queue \" + mapping\n+                      .getQueue());\n+            }\n+            newMappings.add(newMapping);\n+          } else{\n+            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n+                queue, mapping, queuePath);\n+            newMappings.add(newMapping);\n+          }\n+        } else{\n+          // if queue exists, validate\n+          //   if its an instance of leaf queue\n+          //   if its an instance of auto created leaf queue,\n+          // then extract parent queue name and update queue mapping\n+          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n+              queue, mapping, queuePath);\n+          newMappings.add(newMapping);\n+        }\n+      } else{\n+        //If it is a dynamic queue mapping,\n+        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n+        // validate\n+        // if parent queue is specified, then\n+        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n+        //\n+        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n+            queueManager, mapping, queuePath);\n+        if (newMapping !\u003d null) {\n+          newMappings.add(newMapping);\n+        } else{\n+          newMappings.add(mapping);\n+        }\n+      }\n+    }\n+\n+    // initialize groups if mappings are present\n+    if (newMappings.size() \u003e 0) {\n+      Groups groups \u003d new Groups(conf);\n+      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n+          newMappings, groups);\n+    }\n+\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static UserGroupMappingPlacementRule get(\n      CapacitySchedulerContext schedulerContext) throws IOException {\n    CapacitySchedulerConfiguration conf \u003d schedulerContext.getConfiguration();\n    boolean overrideWithQueueMappings \u003d conf.getOverrideWithQueueMappings();\n    LOG.info(\n        \"Initialized queue mappings, override: \" + overrideWithQueueMappings);\n\n    List\u003cQueueMapping\u003e queueMappings \u003d conf.getQueueMappings();\n\n    // Get new user/group mappings\n    List\u003cQueueMapping\u003e newMappings \u003d new ArrayList\u003c\u003e();\n\n    CapacitySchedulerQueueManager queueManager \u003d\n        schedulerContext.getCapacitySchedulerQueueManager();\n\n    // check if mappings refer to valid queues\n    for (QueueMapping mapping : queueMappings) {\n\n      QueuePath queuePath \u003d extractQueuePath(mapping.getQueue());\n      if (isStaticQueueMapping(mapping)) {\n        //Try getting queue by its leaf queue name\n        // without splitting into parent/leaf queues\n        CSQueue queue \u003d queueManager.getQueue(mapping.getQueue());\n        if (ifQueueDoesNotExist(queue)) {\n          //Try getting the queue by extracting leaf and parent queue names\n          //Assuming its a potential auto created leaf queue\n          queue \u003d queueManager.getQueue(queuePath.getLeafQueue());\n\n          if (ifQueueDoesNotExist(queue)) {\n            //if leaf queue does not exist,\n            // this could be a potential auto created leaf queue\n            //validate if parent queue is specified,\n            // then it should exist and\n            // be an instance of AutoCreateEnabledParentQueue\n            QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n                queueManager, mapping, queuePath);\n            if (newMapping \u003d\u003d null) {\n              throw new IOException(\n                  \"mapping contains invalid or non-leaf queue \" + mapping\n                      .getQueue());\n            }\n            newMappings.add(newMapping);\n          } else{\n            QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n                queue, mapping, queuePath);\n            newMappings.add(newMapping);\n          }\n        } else{\n          // if queue exists, validate\n          //   if its an instance of leaf queue\n          //   if its an instance of auto created leaf queue,\n          // then extract parent queue name and update queue mapping\n          QueueMapping newMapping \u003d validateAndGetQueueMapping(queueManager,\n              queue, mapping, queuePath);\n          newMappings.add(newMapping);\n        }\n      } else{\n        //If it is a dynamic queue mapping,\n        // we can safely assume leaf queue name does not have \u0027.\u0027 in it\n        // validate\n        // if parent queue is specified, then\n        //  parent queue exists and an instance of AutoCreateEnabledParentQueue\n        //\n        QueueMapping newMapping \u003d validateAndGetAutoCreatedQueueMapping(\n            queueManager, mapping, queuePath);\n        if (newMapping !\u003d null) {\n          newMappings.add(newMapping);\n        } else{\n          newMappings.add(mapping);\n        }\n      }\n    }\n\n    // initialize groups if mappings are present\n    if (newMappings.size() \u003e 0) {\n      Groups groups \u003d new Groups(conf);\n      return new UserGroupMappingPlacementRule(overrideWithQueueMappings,\n          newMappings, groups);\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java"
    }
  }
}