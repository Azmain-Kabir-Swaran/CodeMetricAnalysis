{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DecayRpcScheduler.java",
  "functionName": "addCost",
  "functionId": "addCost___identity-Object__costDelta-long",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
  "functionStartLine": 503,
  "functionEndLine": 530,
  "numCommitsSeen": 19,
  "timeTaken": 867,
  "changeHistory": [
    "129576f628d370def74e56112aba3a93e97bbf70"
  ],
  "changeHistoryShort": {
    "129576f628d370def74e56112aba3a93e97bbf70": "Yintroduced"
  },
  "changeHistoryDetails": {
    "129576f628d370def74e56112aba3a93e97bbf70": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14403. Cost-based extension to the RPC Fair Call Queue. Contributed by Christopher Gregorian.\n",
      "commitDate": "24/06/19 12:09 PM",
      "commitName": "129576f628d370def74e56112aba3a93e97bbf70",
      "commitAuthor": "Christopher Gregorian",
      "diff": "@@ -0,0 +1,28 @@\n+  private void addCost(Object identity, long costDelta) {\n+    // We will increment the cost, or create it if no such cost exists\n+    List\u003cAtomicLong\u003e cost \u003d this.callCosts.get(identity);\n+    if (cost \u003d\u003d null) {\n+      // Create the costs since no such cost exists.\n+      // idx 0 for decayed call cost\n+      // idx 1 for the raw call cost\n+      cost \u003d new ArrayList\u003cAtomicLong\u003e(2);\n+      cost.add(new AtomicLong(0));\n+      cost.add(new AtomicLong(0));\n+\n+      // Put it in, or get the AtomicInteger that was put in by another thread\n+      List\u003cAtomicLong\u003e otherCost \u003d callCosts.putIfAbsent(identity, cost);\n+      if (otherCost !\u003d null) {\n+        cost \u003d otherCost;\n+      }\n+    }\n+\n+    // Update the total\n+    totalDecayedCallCost.getAndAdd(costDelta);\n+    totalRawCallCost.getAndAdd(costDelta);\n+\n+    // At this point value is guaranteed to be not null. It may however have\n+    // been clobbered from callCosts. Nonetheless, we return what\n+    // we have.\n+    cost.get(1).getAndAdd(costDelta);\n+    cost.get(0).getAndAdd(costDelta);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void addCost(Object identity, long costDelta) {\n    // We will increment the cost, or create it if no such cost exists\n    List\u003cAtomicLong\u003e cost \u003d this.callCosts.get(identity);\n    if (cost \u003d\u003d null) {\n      // Create the costs since no such cost exists.\n      // idx 0 for decayed call cost\n      // idx 1 for the raw call cost\n      cost \u003d new ArrayList\u003cAtomicLong\u003e(2);\n      cost.add(new AtomicLong(0));\n      cost.add(new AtomicLong(0));\n\n      // Put it in, or get the AtomicInteger that was put in by another thread\n      List\u003cAtomicLong\u003e otherCost \u003d callCosts.putIfAbsent(identity, cost);\n      if (otherCost !\u003d null) {\n        cost \u003d otherCost;\n      }\n    }\n\n    // Update the total\n    totalDecayedCallCost.getAndAdd(costDelta);\n    totalRawCallCost.getAndAdd(costDelta);\n\n    // At this point value is guaranteed to be not null. It may however have\n    // been clobbered from callCosts. Nonetheless, we return what\n    // we have.\n    cost.get(1).getAndAdd(costDelta);\n    cost.get(0).getAndAdd(costDelta);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java"
    }
  }
}