{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockStorageMovementTracker.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockStorageMovementTracker.java",
  "functionStartLine": 59,
  "functionEndLine": 83,
  "numCommitsSeen": 10,
  "timeTaken": 4139,
  "changeHistory": [
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
    "3b601f2c0e16b84e35ebe5ecdcd06d3277eabb74",
    "e53f89ccc361615b254e3ecd270728573908c071",
    "695a402fcad20c711c5d845e0664c43fd6b06286",
    "24add8c2f89b63640672c016f03ebfa07d585a0d"
  ],
  "changeHistoryShort": {
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": "Ybodychange",
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10": "Yfilerename",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": "Ybodychange",
    "3b601f2c0e16b84e35ebe5ecdcd06d3277eabb74": "Ybodychange",
    "e53f89ccc361615b254e3ecd270728573908c071": "Ybodychange",
    "695a402fcad20c711c5d845e0664c43fd6b06286": "Ybodychange",
    "24add8c2f89b63640672c016f03ebfa07d585a0d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13165: [SPS]: Collects successfully moved block details via IBR. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,25 @@\n   public void run() {\n     while (running) {\n-      if (moverTaskFutures.size() \u003c\u003d 0) {\n-        try {\n-          synchronized (moverTaskFutures) {\n-            // Waiting for mover tasks.\n-            moverTaskFutures.wait(2000);\n-          }\n-        } catch (InterruptedException ignore) {\n-          // Sets interrupt flag of this thread.\n-          Thread.currentThread().interrupt();\n-        }\n-      }\n       try {\n-        Future\u003cBlockMovementAttemptFinished\u003e future \u003d\n-            moverCompletionService.take();\n+        Future\u003cBlockMovementAttemptFinished\u003e future \u003d moverCompletionService\n+            .take();\n         if (future !\u003d null) {\n           BlockMovementAttemptFinished result \u003d future.get();\n           LOG.debug(\"Completed block movement. {}\", result);\n-          Block block \u003d result.getBlock();\n-          List\u003cFuture\u003cBlockMovementAttemptFinished\u003e\u003e blocksMoving \u003d\n-              moverTaskFutures.get(block);\n-          if (blocksMoving \u003d\u003d null) {\n-            LOG.warn(\"Future task doesn\u0027t exist for block : {} \", block);\n-            continue;\n-          }\n-          blocksMoving.remove(future);\n-\n-          List\u003cBlockMovementAttemptFinished\u003e resultPerTrackIdList \u003d\n-              addMovementResultToBlockIdList(result);\n-\n-          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n-          if (blocksMoving.isEmpty() || moverTaskFutures.get(block) \u003d\u003d null) {\n-            synchronized (moverTaskFutures) {\n-              moverTaskFutures.remove(block);\n-            }\n-            if (running) {\n-              // handle completed or inprogress blocks movements per trackId.\n-              blksMovementsStatusHandler.handle(resultPerTrackIdList);\n-            }\n-            movementResults.remove(block);\n+          if (running \u0026\u0026 blksMovementsStatusHandler !\u003d null) {\n+            // handle completed block movement.\n+            blksMovementsStatusHandler.handle(result);\n           }\n         }\n       } catch (InterruptedException e) {\n         if (running) {\n           LOG.error(\"Exception while moving block replica to target storage\"\n               + \" type\", e);\n         }\n       } catch (ExecutionException e) {\n         // TODO: Do we need failure retries and implement the same if required.\n         LOG.error(\"Exception while moving block replica to target storage type\",\n             e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (running) {\n      try {\n        Future\u003cBlockMovementAttemptFinished\u003e future \u003d moverCompletionService\n            .take();\n        if (future !\u003d null) {\n          BlockMovementAttemptFinished result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          if (running \u0026\u0026 blksMovementsStatusHandler !\u003d null) {\n            // handle completed block movement.\n            blksMovementsStatusHandler.handle(result);\n          }\n        }\n      } catch (InterruptedException e) {\n        if (running) {\n          LOG.error(\"Exception while moving block replica to target storage\"\n              + \" type\", e);\n        }\n      } catch (ExecutionException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockStorageMovementTracker.java",
      "extendedDetails": {}
    },
    "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13033: [SPS]: Implement a mechanism to do file block movements for external SPS. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "b0cb8d9bb44c963ae686d2b5c1b70bc76b955e10",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "3159b39cf8ef704835325263154fb1a1cecc109d",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void run() {\n    while (running) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // Sets interrupt flag of this thread.\n          Thread.currentThread().interrupt();\n        }\n      }\n      try {\n        Future\u003cBlockMovementAttemptFinished\u003e future \u003d\n            moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementAttemptFinished result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          Block block \u003d result.getBlock();\n          List\u003cFuture\u003cBlockMovementAttemptFinished\u003e\u003e blocksMoving \u003d\n              moverTaskFutures.get(block);\n          if (blocksMoving \u003d\u003d null) {\n            LOG.warn(\"Future task doesn\u0027t exist for block : {} \", block);\n            continue;\n          }\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementAttemptFinished\u003e resultPerTrackIdList \u003d\n              addMovementResultToBlockIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty() || moverTaskFutures.get(block) \u003d\u003d null) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(block);\n            }\n            if (running) {\n              // handle completed or inprogress blocks movements per trackId.\n              blksMovementsStatusHandler.handle(resultPerTrackIdList);\n            }\n            movementResults.remove(block);\n          }\n        }\n      } catch (InterruptedException e) {\n        if (running) {\n          LOG.error(\"Exception while moving block replica to target storage\"\n              + \" type\", e);\n        }\n      } catch (ExecutionException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockStorageMovementTracker.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/sps/BlockStorageMovementTracker.java"
      }
    },
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12570: [SPS]: Refactor Co-ordinator datanode logic to track the block storage movements. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "3b601f2c0e16b84e35ebe5ecdcd06d3277eabb74",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,55 @@\n   public void run() {\n     while (running) {\n       if (moverTaskFutures.size() \u003c\u003d 0) {\n         try {\n           synchronized (moverTaskFutures) {\n             // Waiting for mover tasks.\n             moverTaskFutures.wait(2000);\n           }\n         } catch (InterruptedException ignore) {\n           // Sets interrupt flag of this thread.\n           Thread.currentThread().interrupt();\n         }\n       }\n       try {\n-        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n+        Future\u003cBlockMovementAttemptFinished\u003e future \u003d\n+            moverCompletionService.take();\n         if (future !\u003d null) {\n-          BlockMovementResult result \u003d future.get();\n+          BlockMovementAttemptFinished result \u003d future.get();\n           LOG.debug(\"Completed block movement. {}\", result);\n-          long trackId \u003d result.getTrackId();\n-          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n-              .get(trackId);\n+          Block block \u003d result.getBlock();\n+          List\u003cFuture\u003cBlockMovementAttemptFinished\u003e\u003e blocksMoving \u003d\n+              moverTaskFutures.get(block);\n           if (blocksMoving \u003d\u003d null) {\n-            LOG.warn(\"Future task doesn\u0027t exist for trackId \" + trackId);\n+            LOG.warn(\"Future task doesn\u0027t exist for block : {} \", block);\n             continue;\n           }\n           blocksMoving.remove(future);\n \n-          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n-              addMovementResultToTrackIdList(result);\n+          List\u003cBlockMovementAttemptFinished\u003e resultPerTrackIdList \u003d\n+              addMovementResultToBlockIdList(result);\n \n           // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n-          if (blocksMoving.isEmpty() || moverTaskFutures.get(trackId) \u003d\u003d null) {\n+          if (blocksMoving.isEmpty() || moverTaskFutures.get(block) \u003d\u003d null) {\n             synchronized (moverTaskFutures) {\n-              moverTaskFutures.remove(trackId);\n+              moverTaskFutures.remove(block);\n             }\n             if (running) {\n               // handle completed or inprogress blocks movements per trackId.\n               blksMovementsStatusHandler.handle(resultPerTrackIdList);\n             }\n-            movementResults.remove(trackId);\n+            movementResults.remove(block);\n           }\n         }\n       } catch (InterruptedException e) {\n         if (running) {\n           LOG.error(\"Exception while moving block replica to target storage\"\n               + \" type\", e);\n         }\n       } catch (ExecutionException e) {\n         // TODO: Do we need failure retries and implement the same if required.\n         LOG.error(\"Exception while moving block replica to target storage type\",\n             e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (running) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // Sets interrupt flag of this thread.\n          Thread.currentThread().interrupt();\n        }\n      }\n      try {\n        Future\u003cBlockMovementAttemptFinished\u003e future \u003d\n            moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementAttemptFinished result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          Block block \u003d result.getBlock();\n          List\u003cFuture\u003cBlockMovementAttemptFinished\u003e\u003e blocksMoving \u003d\n              moverTaskFutures.get(block);\n          if (blocksMoving \u003d\u003d null) {\n            LOG.warn(\"Future task doesn\u0027t exist for block : {} \", block);\n            continue;\n          }\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementAttemptFinished\u003e resultPerTrackIdList \u003d\n              addMovementResultToBlockIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty() || moverTaskFutures.get(block) \u003d\u003d null) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(block);\n            }\n            if (running) {\n              // handle completed or inprogress blocks movements per trackId.\n              blksMovementsStatusHandler.handle(resultPerTrackIdList);\n            }\n            movementResults.remove(block);\n          }\n        }\n      } catch (InterruptedException e) {\n        if (running) {\n          LOG.error(\"Exception while moving block replica to target storage\"\n              + \" type\", e);\n        }\n      } catch (ExecutionException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java",
      "extendedDetails": {}
    },
    "3b601f2c0e16b84e35ebe5ecdcd06d3277eabb74": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12152: [SPS]: Re-arrange StoragePolicySatisfyWorker stopping sequence to improve thread cleanup time. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "3b601f2c0e16b84e35ebe5ecdcd06d3277eabb74",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "e53f89ccc361615b254e3ecd270728573908c071",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,54 @@\n   public void run() {\n     while (running) {\n       if (moverTaskFutures.size() \u003c\u003d 0) {\n         try {\n           synchronized (moverTaskFutures) {\n             // Waiting for mover tasks.\n             moverTaskFutures.wait(2000);\n           }\n         } catch (InterruptedException ignore) {\n-          // ignore\n+          // Sets interrupt flag of this thread.\n+          Thread.currentThread().interrupt();\n         }\n       }\n       try {\n         Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n         if (future !\u003d null) {\n           BlockMovementResult result \u003d future.get();\n           LOG.debug(\"Completed block movement. {}\", result);\n           long trackId \u003d result.getTrackId();\n           List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n               .get(trackId);\n           if (blocksMoving \u003d\u003d null) {\n             LOG.warn(\"Future task doesn\u0027t exist for trackId \" + trackId);\n             continue;\n           }\n           blocksMoving.remove(future);\n \n           List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n               addMovementResultToTrackIdList(result);\n \n           // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n           if (blocksMoving.isEmpty() || moverTaskFutures.get(trackId) \u003d\u003d null) {\n             synchronized (moverTaskFutures) {\n               moverTaskFutures.remove(trackId);\n             }\n-            // handle completed or inprogress blocks movements per trackId.\n-            blksMovementsStatusHandler.handle(resultPerTrackIdList);\n+            if (running) {\n+              // handle completed or inprogress blocks movements per trackId.\n+              blksMovementsStatusHandler.handle(resultPerTrackIdList);\n+            }\n             movementResults.remove(trackId);\n           }\n         }\n-      } catch (ExecutionException | InterruptedException e) {\n+      } catch (InterruptedException e) {\n+        if (running) {\n+          LOG.error(\"Exception while moving block replica to target storage\"\n+              + \" type\", e);\n+        }\n+      } catch (ExecutionException e) {\n         // TODO: Do we need failure retries and implement the same if required.\n         LOG.error(\"Exception while moving block replica to target storage type\",\n             e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (running) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // Sets interrupt flag of this thread.\n          Thread.currentThread().interrupt();\n        }\n      }\n      try {\n        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementResult result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          long trackId \u003d result.getTrackId();\n          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n              .get(trackId);\n          if (blocksMoving \u003d\u003d null) {\n            LOG.warn(\"Future task doesn\u0027t exist for trackId \" + trackId);\n            continue;\n          }\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n              addMovementResultToTrackIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty() || moverTaskFutures.get(trackId) \u003d\u003d null) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(trackId);\n            }\n            if (running) {\n              // handle completed or inprogress blocks movements per trackId.\n              blksMovementsStatusHandler.handle(resultPerTrackIdList);\n            }\n            movementResults.remove(trackId);\n          }\n        }\n      } catch (InterruptedException e) {\n        if (running) {\n          LOG.error(\"Exception while moving block replica to target storage\"\n              + \" type\", e);\n        }\n      } catch (ExecutionException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java",
      "extendedDetails": {}
    },
    "e53f89ccc361615b254e3ecd270728573908c071": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11883: [SPS] : Handle NPE in BlockStorageMovementTracker when dropSPSWork() called. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "e53f89ccc361615b254e3ecd270728573908c071",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "695a402fcad20c711c5d845e0664c43fd6b06286",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,46 @@\n   public void run() {\n     while (running) {\n       if (moverTaskFutures.size() \u003c\u003d 0) {\n         try {\n           synchronized (moverTaskFutures) {\n             // Waiting for mover tasks.\n             moverTaskFutures.wait(2000);\n           }\n         } catch (InterruptedException ignore) {\n           // ignore\n         }\n       }\n       try {\n         Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n         if (future !\u003d null) {\n           BlockMovementResult result \u003d future.get();\n           LOG.debug(\"Completed block movement. {}\", result);\n           long trackId \u003d result.getTrackId();\n           List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n               .get(trackId);\n+          if (blocksMoving \u003d\u003d null) {\n+            LOG.warn(\"Future task doesn\u0027t exist for trackId \" + trackId);\n+            continue;\n+          }\n           blocksMoving.remove(future);\n \n           List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n               addMovementResultToTrackIdList(result);\n \n           // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n-          if (blocksMoving.isEmpty()) {\n+          if (blocksMoving.isEmpty() || moverTaskFutures.get(trackId) \u003d\u003d null) {\n             synchronized (moverTaskFutures) {\n               moverTaskFutures.remove(trackId);\n             }\n             // handle completed or inprogress blocks movements per trackId.\n             blksMovementsStatusHandler.handle(resultPerTrackIdList);\n             movementResults.remove(trackId);\n           }\n         }\n       } catch (ExecutionException | InterruptedException e) {\n         // TODO: Do we need failure retries and implement the same if required.\n         LOG.error(\"Exception while moving block replica to target storage type\",\n             e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (running) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n      try {\n        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementResult result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          long trackId \u003d result.getTrackId();\n          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n              .get(trackId);\n          if (blocksMoving \u003d\u003d null) {\n            LOG.warn(\"Future task doesn\u0027t exist for trackId \" + trackId);\n            continue;\n          }\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n              addMovementResultToTrackIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty() || moverTaskFutures.get(trackId) \u003d\u003d null) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(trackId);\n            }\n            // handle completed or inprogress blocks movements per trackId.\n            blksMovementsStatusHandler.handle(resultPerTrackIdList);\n            movementResults.remove(trackId);\n          }\n        }\n      } catch (ExecutionException | InterruptedException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java",
      "extendedDetails": {}
    },
    "695a402fcad20c711c5d845e0664c43fd6b06286": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11334: [SPS]: NN switch and rescheduling movements can lead to have more than one coordinator for same file blocks. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "695a402fcad20c711c5d845e0664c43fd6b06286",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "e34331c31d68cb22891db48011db5b36ad178af1",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public void run() {\n-    while (true) {\n+    while (running) {\n       if (moverTaskFutures.size() \u003c\u003d 0) {\n         try {\n           synchronized (moverTaskFutures) {\n             // Waiting for mover tasks.\n             moverTaskFutures.wait(2000);\n           }\n         } catch (InterruptedException ignore) {\n           // ignore\n         }\n       }\n       try {\n         Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n         if (future !\u003d null) {\n           BlockMovementResult result \u003d future.get();\n           LOG.debug(\"Completed block movement. {}\", result);\n           long trackId \u003d result.getTrackId();\n           List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n               .get(trackId);\n           blocksMoving.remove(future);\n \n           List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n               addMovementResultToTrackIdList(result);\n \n           // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n           if (blocksMoving.isEmpty()) {\n             synchronized (moverTaskFutures) {\n               moverTaskFutures.remove(trackId);\n             }\n-            // handle completed blocks movements per trackId.\n-            blksMovementscompletionHandler.handle(resultPerTrackIdList);\n+            // handle completed or inprogress blocks movements per trackId.\n+            blksMovementsStatusHandler.handle(resultPerTrackIdList);\n             movementResults.remove(trackId);\n           }\n         }\n       } catch (ExecutionException | InterruptedException e) {\n         // TODO: Do we need failure retries and implement the same if required.\n         LOG.error(\"Exception while moving block replica to target storage type\",\n             e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (running) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n      try {\n        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementResult result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          long trackId \u003d result.getTrackId();\n          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n              .get(trackId);\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n              addMovementResultToTrackIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty()) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(trackId);\n            }\n            // handle completed or inprogress blocks movements per trackId.\n            blksMovementsStatusHandler.handle(resultPerTrackIdList);\n            movementResults.remove(trackId);\n          }\n        }\n      } catch (ExecutionException | InterruptedException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java",
      "extendedDetails": {}
    },
    "24add8c2f89b63640672c016f03ebfa07d585a0d": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10884: [SPS]: Add block movement tracker to track the completion of block movement future tasks at DN. Contributed by Rakesh R\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "24add8c2f89b63640672c016f03ebfa07d585a0d",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,42 @@\n+  public void run() {\n+    while (true) {\n+      if (moverTaskFutures.size() \u003c\u003d 0) {\n+        try {\n+          synchronized (moverTaskFutures) {\n+            // Waiting for mover tasks.\n+            moverTaskFutures.wait(2000);\n+          }\n+        } catch (InterruptedException ignore) {\n+          // ignore\n+        }\n+      }\n+      try {\n+        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n+        if (future !\u003d null) {\n+          BlockMovementResult result \u003d future.get();\n+          LOG.debug(\"Completed block movement. {}\", result);\n+          long trackId \u003d result.getTrackId();\n+          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n+              .get(trackId);\n+          blocksMoving.remove(future);\n+\n+          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n+              addMovementResultToTrackIdList(result);\n+\n+          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n+          if (blocksMoving.isEmpty()) {\n+            synchronized (moverTaskFutures) {\n+              moverTaskFutures.remove(trackId);\n+            }\n+            // handle completed blocks movements per trackId.\n+            blksMovementscompletionHandler.handle(resultPerTrackIdList);\n+            movementResults.remove(trackId);\n+          }\n+        }\n+      } catch (ExecutionException | InterruptedException e) {\n+        // TODO: Do we need failure retries and implement the same if required.\n+        LOG.error(\"Exception while moving block replica to target storage type\",\n+            e);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    while (true) {\n      if (moverTaskFutures.size() \u003c\u003d 0) {\n        try {\n          synchronized (moverTaskFutures) {\n            // Waiting for mover tasks.\n            moverTaskFutures.wait(2000);\n          }\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n      try {\n        Future\u003cBlockMovementResult\u003e future \u003d moverCompletionService.take();\n        if (future !\u003d null) {\n          BlockMovementResult result \u003d future.get();\n          LOG.debug(\"Completed block movement. {}\", result);\n          long trackId \u003d result.getTrackId();\n          List\u003cFuture\u003cBlockMovementResult\u003e\u003e blocksMoving \u003d moverTaskFutures\n              .get(trackId);\n          blocksMoving.remove(future);\n\n          List\u003cBlockMovementResult\u003e resultPerTrackIdList \u003d\n              addMovementResultToTrackIdList(result);\n\n          // Completed all the scheduled blocks movement under this \u0027trackId\u0027.\n          if (blocksMoving.isEmpty()) {\n            synchronized (moverTaskFutures) {\n              moverTaskFutures.remove(trackId);\n            }\n            // handle completed blocks movements per trackId.\n            blksMovementscompletionHandler.handle(resultPerTrackIdList);\n            movementResults.remove(trackId);\n          }\n        }\n      } catch (ExecutionException | InterruptedException e) {\n        // TODO: Do we need failure retries and implement the same if required.\n        LOG.error(\"Exception while moving block replica to target storage type\",\n            e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockStorageMovementTracker.java"
    }
  }
}