{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeProxiesClient.java",
  "functionName": "getFailoverProxyProviderClass",
  "functionId": "getFailoverProxyProviderClass___conf-Configuration__nameNodeUri-URI",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/NameNodeProxiesClient.java",
  "functionStartLine": 284,
  "functionEndLine": 306,
  "numCommitsSeen": 100,
  "timeTaken": 3503,
  "changeHistory": [
    "63d9f1596c92206cce3b72e3214d2fb5f6242b90",
    "60da0e49e7316892d63e9c7cdc3214057e68009a",
    "33ade356b35223654a077103ed7fbed89f3f2321",
    "8c7a7e619699386f9e6991842558d78aa0c8053d",
    "f105784d6a28d2a0cedb619f0951de93d995e9da",
    "44389399d434bd534047993ac970b7f54eb1d637",
    "c69dfdd5e14af490790dff8227b11962ec816577",
    "481f84597bf842df45b068cc24c328112e8bcf40",
    "212678f036f4f96493bc14a584e758f97cf65573"
  ],
  "changeHistoryShort": {
    "63d9f1596c92206cce3b72e3214d2fb5f6242b90": "Ymovefromfile",
    "60da0e49e7316892d63e9c7cdc3214057e68009a": "Ybodychange",
    "33ade356b35223654a077103ed7fbed89f3f2321": "Ymultichange(Yparameterchange,Ybodychange)",
    "8c7a7e619699386f9e6991842558d78aa0c8053d": "Ymodifierchange",
    "f105784d6a28d2a0cedb619f0951de93d995e9da": "Ybodychange",
    "44389399d434bd534047993ac970b7f54eb1d637": "Ybodychange",
    "c69dfdd5e14af490790dff8227b11962ec816577": "Ymovefromfile",
    "481f84597bf842df45b068cc24c328112e8bcf40": "Ymodifierchange",
    "212678f036f4f96493bc14a584e758f97cf65573": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)"
  },
  "changeHistoryDetails": {
    "63d9f1596c92206cce3b72e3214d2fb5f6242b90": {
      "type": "Ymovefromfile",
      "commitMessage": "HDFS-9039. Separate client and server side methods of o.a.h.hdfs.NameNodeProxies. Contributed by Mingliang Liu.\n",
      "commitDate": "22/09/15 8:52 PM",
      "commitName": "63d9f1596c92206cce3b72e3214d2fb5f6242b90",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/09/15 9:08 AM",
      "commitNameOld": "cc2b4739902df60254dce2ddb23ef8f6ff2a3495",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n     String configKey \u003d HdfsClientConfigKeys.Failover.PROXY_PROVIDER_KEY_PREFIX\n         + \".\" + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n-      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n-          .getClass(configKey, null, FailoverProxyProvider.class);\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e)\n+          conf.getClass(configKey, null, FailoverProxyProvider.class);\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n    String configKey \u003d HdfsClientConfigKeys.Failover.PROXY_PROVIDER_KEY_PREFIX\n        + \".\" + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e)\n          conf.getClass(configKey, null, FailoverProxyProvider.class);\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/NameNodeProxiesClient.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/NameNodeProxiesClient.java",
        "oldMethodName": "getFailoverProxyProviderClass",
        "newMethodName": "getFailoverProxyProviderClass"
      }
    },
    "60da0e49e7316892d63e9c7cdc3214057e68009a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8084. Move dfs.client.failover.* confs from DFSConfigKeys to HdfsClientConfigKeys.Failover and fix typos in the dfs.http.client.* configuration keys.\n",
      "commitDate": "10/04/15 7:38 PM",
      "commitName": "60da0e49e7316892d63e9c7cdc3214057e68009a",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "10/04/15 2:48 PM",
      "commitNameOld": "2cc9514ad643ae49d30524743420ee9744e571bd",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,23 @@\n   public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n-  \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n-        + host;\n+    String configKey \u003d HdfsClientConfigKeys.Failover.PROXY_PROVIDER_KEY_PREFIX\n+        + \".\" + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n    String configKey \u003d HdfsClientConfigKeys.Failover.PROXY_PROVIDER_KEY_PREFIX\n        + \".\" + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
      "extendedDetails": {}
    },
    "33ade356b35223654a077103ed7fbed89f3f2321": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6334. Client failover proxy provider for IP failover based NN HA. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 9:19 AM",
      "commitName": "33ade356b35223654a077103ed7fbed89f3f2321",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6334. Client failover proxy provider for IP failover based NN HA. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594263 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/14 9:19 AM",
          "commitName": "33ade356b35223654a077103ed7fbed89f3f2321",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/02/14 11:48 AM",
          "commitNameOld": "d00605f8f0214ed8e2304db8688e140f0a1d62d8",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 73.85,
          "commitsBetweenForRepo": 483,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,24 @@\n   public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n-      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n+      Configuration conf, URI nameNodeUri) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n   \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n-      if (ret !\u003d null) {\n-        // If we found a proxy provider, then this URI should be a logical NN.\n-        // Given that, it shouldn\u0027t have a non-default port number.\n-        int port \u003d nameNodeUri.getPort();\n-        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\"Port \" + port + \" specified in URI \"\n-              + nameNodeUri + \" but host \u0027\" + host\n-              + \"\u0027 is a logical (HA) namenode\"\n-              + \" and does not use port information.\");\n-        }\n-      }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration, nameNodeUri-URI, xface-Class\u003cT\u003e]",
            "newValue": "[conf-Configuration, nameNodeUri-URI]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6334. Client failover proxy provider for IP failover based NN HA. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594263 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/05/14 9:19 AM",
          "commitName": "33ade356b35223654a077103ed7fbed89f3f2321",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/02/14 11:48 AM",
          "commitNameOld": "d00605f8f0214ed8e2304db8688e140f0a1d62d8",
          "commitAuthorOld": "Arpit Agarwal",
          "daysBetweenCommits": 73.85,
          "commitsBetweenForRepo": 483,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,24 @@\n   public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n-      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n+      Configuration conf, URI nameNodeUri) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n   \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n-      if (ret !\u003d null) {\n-        // If we found a proxy provider, then this URI should be a logical NN.\n-        // Given that, it shouldn\u0027t have a non-default port number.\n-        int port \u003d nameNodeUri.getPort();\n-        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\"Port \" + port + \" specified in URI \"\n-              + nameNodeUri + \" but host \u0027\" + host\n-              + \"\u0027 is a logical (HA) namenode\"\n-              + \" and does not use port information.\");\n-        }\n-      }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
          "extendedDetails": {}
        }
      ]
    },
    "8c7a7e619699386f9e6991842558d78aa0c8053d": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/13 12:51 AM",
      "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/07/13 3:59 AM",
      "commitNameOld": "a690a215dba6180090214675393431a589c37f24",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.87,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n-  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n   \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n           throw new IOException(\"Port \" + port + \" specified in URI \"\n               + nameNodeUri + \" but host \u0027\" + host\n               + \"\u0027 is a logical (HA) namenode\"\n               + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
      "extendedDetails": {
        "oldValue": "[private, static]",
        "newValue": "[public, static]"
      }
    },
    "f105784d6a28d2a0cedb619f0951de93d995e9da": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c -1354790 for reverting HDFS-3576 since it requires more changes.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 6:25 PM",
      "commitName": "f105784d6a28d2a0cedb619f0951de93d995e9da",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/06/12 6:11 PM",
      "commitNameOld": "44389399d434bd534047993ac970b7f54eb1d637",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n   \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n-        if (port \u003e 0 \u0026\u0026 port !\u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT) {\n+        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n           throw new IOException(\"Port \" + port + \" specified in URI \"\n               + nameNodeUri + \" but host \u0027\" + host\n               + \"\u0027 is a logical (HA) namenode\"\n               + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
      "extendedDetails": {}
    },
    "44389399d434bd534047993ac970b7f54eb1d637": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3576. Move the definition of the constant NameNode.DEFAULT_PORT to DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT.  Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 6:11 PM",
      "commitName": "44389399d434bd534047993ac970b7f54eb1d637",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/06/12 10:27 PM",
      "commitNameOld": "45fafc2b8fc1aab0a082600b0d50ad693491ea70",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 15.82,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n   \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n-        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n+        if (port \u003e 0 \u0026\u0026 port !\u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT) {\n           throw new IOException(\"Port \" + port + \" specified in URI \"\n               + nameNodeUri + \" but host \u0027\" + host\n               + \"\u0027 is a logical (HA) namenode\"\n               + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
      "extendedDetails": {}
    },
    "c69dfdd5e14af490790dff8227b11962ec816577": {
      "type": "Ymovefromfile",
      "commitMessage": "HDFS-2958. Sweep for remaining proxy construction which doesn\u0027t go through failover path.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1294811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/12 12:09 PM",
      "commitName": "c69dfdd5e14af490790dff8227b11962ec816577",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "28/02/12 10:38 AM",
      "commitNameOld": "1ab31b1715e9db498847725dadfb82b16f71143b",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n-\n+  \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n           throw new IOException(\"Port \" + port + \" specified in URI \"\n               + nameNodeUri + \" but host \u0027\" + host\n               + \"\u0027 is a logical (HA) namenode\"\n               + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n  \n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/NameNodeProxies.java",
        "oldMethodName": "getFailoverProxyProviderClass",
        "newMethodName": "getFailoverProxyProviderClass"
      }
    },
    "481f84597bf842df45b068cc24c328112e8bcf40": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-2904. Client support for getting delegation tokens. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1293486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/12 4:03 PM",
      "commitName": "481f84597bf842df45b068cc24c328112e8bcf40",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "06/02/12 12:21 AM",
      "commitNameOld": "c17b4f8eefe5b77b77761a0bb46b49cd1ea6965d",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 18.65,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n-  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n       Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n     String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n         + host;\n     try {\n       @SuppressWarnings(\"unchecked\")\n       Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n           .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n           throw new IOException(\"Port \" + port + \" specified in URI \"\n               + nameNodeUri + \" but host \u0027\" + host\n               + \"\u0027 is a logical (HA) namenode\"\n               + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n             + conf.get(configKey) + \" which is configured for authority \"\n             + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
      "extendedDetails": {
        "oldValue": "[public, static]",
        "newValue": "[private, static]"
      }
    },
    "212678f036f4f96493bc14a584e758f97cf65573": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/01/12 7:10 PM",
      "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 7:10 PM",
          "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "16/01/12 2:16 PM",
          "commitNameOld": "d880c7cc784cf636b2590fd98ea7c8ee67065a30",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  private Class\u003c?\u003e getFailoverProxyProviderClass(URI nameNodeUri, Configuration conf)\n-      throws IOException {\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\" + host;\n+    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n+        + host;\n     try {\n-      Class\u003c?\u003e ret \u003d conf.getClass(configKey, null);\n+      @SuppressWarnings(\"unchecked\")\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n+          .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\n-              \"Port \" + port + \" specified in URI \" + nameNodeUri +\n-              \" but host \u0027\" + host + \"\u0027 is a logical (HA) namenode\" +\n-              \" and does not use port information.\");\n+          throw new IOException(\"Port \" + port + \" specified in URI \"\n+              + nameNodeUri + \" but host \u0027\" + host\n+              + \"\u0027 is a logical (HA) namenode\"\n+              + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n-            + conf.get(configKey) + \" which is configured for authority \" + nameNodeUri,\n-            e);\n+            + conf.get(configKey) + \" which is configured for authority \"\n+            + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/DFSClient.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
            "oldMethodName": "getFailoverProxyProviderClass",
            "newMethodName": "getFailoverProxyProviderClass"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 7:10 PM",
          "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "16/01/12 2:16 PM",
          "commitNameOld": "d880c7cc784cf636b2590fd98ea7c8ee67065a30",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  private Class\u003c?\u003e getFailoverProxyProviderClass(URI nameNodeUri, Configuration conf)\n-      throws IOException {\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\" + host;\n+    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n+        + host;\n     try {\n-      Class\u003c?\u003e ret \u003d conf.getClass(configKey, null);\n+      @SuppressWarnings(\"unchecked\")\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n+          .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\n-              \"Port \" + port + \" specified in URI \" + nameNodeUri +\n-              \" but host \u0027\" + host + \"\u0027 is a logical (HA) namenode\" +\n-              \" and does not use port information.\");\n+          throw new IOException(\"Port \" + port + \" specified in URI \"\n+              + nameNodeUri + \" but host \u0027\" + host\n+              + \"\u0027 is a logical (HA) namenode\"\n+              + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n-            + conf.get(configKey) + \" which is configured for authority \" + nameNodeUri,\n-            e);\n+            + conf.get(configKey) + \" which is configured for authority \"\n+            + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
          "extendedDetails": {
            "oldValue": "Class\u003c?\u003e",
            "newValue": "Class\u003cFailoverProxyProvider\u003cT\u003e\u003e"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 7:10 PM",
          "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "16/01/12 2:16 PM",
          "commitNameOld": "d880c7cc784cf636b2590fd98ea7c8ee67065a30",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  private Class\u003c?\u003e getFailoverProxyProviderClass(URI nameNodeUri, Configuration conf)\n-      throws IOException {\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\" + host;\n+    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n+        + host;\n     try {\n-      Class\u003c?\u003e ret \u003d conf.getClass(configKey, null);\n+      @SuppressWarnings(\"unchecked\")\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n+          .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\n-              \"Port \" + port + \" specified in URI \" + nameNodeUri +\n-              \" but host \u0027\" + host + \"\u0027 is a logical (HA) namenode\" +\n-              \" and does not use port information.\");\n+          throw new IOException(\"Port \" + port + \" specified in URI \"\n+              + nameNodeUri + \" but host \u0027\" + host\n+              + \"\u0027 is a logical (HA) namenode\"\n+              + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n-            + conf.get(configKey) + \" which is configured for authority \" + nameNodeUri,\n-            e);\n+            + conf.get(configKey) + \" which is configured for authority \"\n+            + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 7:10 PM",
          "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "16/01/12 2:16 PM",
          "commitNameOld": "d880c7cc784cf636b2590fd98ea7c8ee67065a30",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  private Class\u003c?\u003e getFailoverProxyProviderClass(URI nameNodeUri, Configuration conf)\n-      throws IOException {\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\" + host;\n+    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n+        + host;\n     try {\n-      Class\u003c?\u003e ret \u003d conf.getClass(configKey, null);\n+      @SuppressWarnings(\"unchecked\")\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n+          .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\n-              \"Port \" + port + \" specified in URI \" + nameNodeUri +\n-              \" but host \u0027\" + host + \"\u0027 is a logical (HA) namenode\" +\n-              \" and does not use port information.\");\n+          throw new IOException(\"Port \" + port + \" specified in URI \"\n+              + nameNodeUri + \" but host \u0027\" + host\n+              + \"\u0027 is a logical (HA) namenode\"\n+              + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n-            + conf.get(configKey) + \" which is configured for authority \" + nameNodeUri,\n-            e);\n+            + conf.get(configKey) + \" which is configured for authority \"\n+            + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2767. ConfiguredFailoverProxyProvider should support NameNodeProtocol. Contributed by Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1232284 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/01/12 7:10 PM",
          "commitName": "212678f036f4f96493bc14a584e758f97cf65573",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "16/01/12 2:16 PM",
          "commitNameOld": "d880c7cc784cf636b2590fd98ea7c8ee67065a30",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 0.2,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  private Class\u003c?\u003e getFailoverProxyProviderClass(URI nameNodeUri, Configuration conf)\n-      throws IOException {\n+  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n     if (nameNodeUri \u003d\u003d null) {\n       return null;\n     }\n     String host \u003d nameNodeUri.getHost();\n \n-    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\" + host;\n+    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n+        + host;\n     try {\n-      Class\u003c?\u003e ret \u003d conf.getClass(configKey, null);\n+      @SuppressWarnings(\"unchecked\")\n+      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n+          .getClass(configKey, null, FailoverProxyProvider.class);\n       if (ret !\u003d null) {\n         // If we found a proxy provider, then this URI should be a logical NN.\n         // Given that, it shouldn\u0027t have a non-default port number.\n         int port \u003d nameNodeUri.getPort();\n         if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n-          throw new IOException(\n-              \"Port \" + port + \" specified in URI \" + nameNodeUri +\n-              \" but host \u0027\" + host + \"\u0027 is a logical (HA) namenode\" +\n-              \" and does not use port information.\");\n+          throw new IOException(\"Port \" + port + \" specified in URI \"\n+              + nameNodeUri + \" but host \u0027\" + host\n+              + \"\u0027 is a logical (HA) namenode\"\n+              + \" and does not use port information.\");\n         }\n       }\n       return ret;\n     } catch (RuntimeException e) {\n       if (e.getCause() instanceof ClassNotFoundException) {\n         throw new IOException(\"Could not load failover proxy provider class \"\n-            + conf.get(configKey) + \" which is configured for authority \" + nameNodeUri,\n-            e);\n+            + conf.get(configKey) + \" which is configured for authority \"\n+            + nameNodeUri, e);\n       } else {\n         throw e;\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static \u003cT\u003e Class\u003cFailoverProxyProvider\u003cT\u003e\u003e getFailoverProxyProviderClass(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface) throws IOException {\n    if (nameNodeUri \u003d\u003d null) {\n      return null;\n    }\n    String host \u003d nameNodeUri.getHost();\n\n    String configKey \u003d DFS_CLIENT_FAILOVER_PROXY_PROVIDER_KEY_PREFIX + \".\"\n        + host;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      Class\u003cFailoverProxyProvider\u003cT\u003e\u003e ret \u003d (Class\u003cFailoverProxyProvider\u003cT\u003e\u003e) conf\n          .getClass(configKey, null, FailoverProxyProvider.class);\n      if (ret !\u003d null) {\n        // If we found a proxy provider, then this URI should be a logical NN.\n        // Given that, it shouldn\u0027t have a non-default port number.\n        int port \u003d nameNodeUri.getPort();\n        if (port \u003e 0 \u0026\u0026 port !\u003d NameNode.DEFAULT_PORT) {\n          throw new IOException(\"Port \" + port + \" specified in URI \"\n              + nameNodeUri + \" but host \u0027\" + host\n              + \"\u0027 is a logical (HA) namenode\"\n              + \" and does not use port information.\");\n        }\n      }\n      return ret;\n    } catch (RuntimeException e) {\n      if (e.getCause() instanceof ClassNotFoundException) {\n        throw new IOException(\"Could not load failover proxy provider class \"\n            + conf.get(configKey) + \" which is configured for authority \"\n            + nameNodeUri, e);\n      } else {\n        throw e;\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/HAUtil.java",
          "extendedDetails": {
            "oldValue": "[nameNodeUri-URI, conf-Configuration]",
            "newValue": "[conf-Configuration, nameNodeUri-URI, xface-Class\u003cT\u003e]"
          }
        }
      ]
    }
  }
}