{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CSQueueUtils.java",
  "functionName": "updateUsedCapacity",
  "functionId": "updateUsedCapacity___rc-ResourceCalculator(modifiers-final)__totalPartitionResource-Resource(modifiers-final)__nodePartition-String__childQueue-AbstractCSQueue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
  "functionStartLine": 174,
  "functionEndLine": 252,
  "numCommitsSeen": 90,
  "timeTaken": 8533,
  "changeHistory": [
    "46f90581641feec37e285964df983d221bee5e1d",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "e9c2aa1bc383cb08784846534415bf17667d6e41",
    "0e065f2edead41f6f894c9d70def389af1c0f239",
    "21eb4284487d6f8e4beedb8a0c3168e952f224fc",
    "fc055a3cbe9545cf1c59421641c7b296aa33f953",
    "d573f09fb93dbb711d504620af5d73840ea063a6"
  ],
  "changeHistoryShort": {
    "46f90581641feec37e285964df983d221bee5e1d": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": "Yparameterchange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ymultichange(Yparameterchange,Ybodychange)",
    "e9c2aa1bc383cb08784846534415bf17667d6e41": "Ybodychange",
    "0e065f2edead41f6f894c9d70def389af1c0f239": "Ymultichange(Yparameterchange,Ybodychange)",
    "21eb4284487d6f8e4beedb8a0c3168e952f224fc": "Ymodifierchange",
    "fc055a3cbe9545cf1c59421641c7b296aa33f953": "Ybodychange",
    "d573f09fb93dbb711d504620af5d73840ea063a6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "46f90581641feec37e285964df983d221bee5e1d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8441. Typo in CSQueueUtils local variable names: queueGuranteedResource. Contributed by Szilard Nemeth.\n",
      "commitDate": "20/06/18 11:58 AM",
      "commitName": "46f90581641feec37e285964df983d221bee5e1d",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "18/12/17 5:24 AM",
      "commitNameOld": "001008958d8da008ed2e3be370ea4431fd023c97",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 184.23,
      "commitsBetweenForRepo": 1827,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n       final Resource totalPartitionResource, String nodePartition,\n       AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n \n-      Resource queueGuranteedResource \u003d childQueue\n+      Resource queueGuaranteedResource \u003d childQueue\n           .getEffectiveCapacity(nodePartition);\n \n       //TODO : Modify below code to support Absolute Resource configurations\n       // (YARN-5881) for AutoCreatedLeafQueue\n       if (Float.compare(queueCapacities.getAbsoluteCapacity\n               (nodePartition), 0f) \u003d\u003d 0\n           \u0026\u0026 childQueue instanceof AutoCreatedLeafQueue) {\n \n         //If absolute capacity is 0 for a leaf queue (could be a managed leaf\n         // queue, then use the leaf queue\u0027s template capacity to compute\n         // guaranteed resource for used capacity)\n \n         // queueGuaranteed \u003d totalPartitionedResource *\n         // absolute_capacity(partition)\n         ManagedParentQueue parentQueue \u003d (ManagedParentQueue)\n             childQueue.getParent();\n         QueueCapacities leafQueueTemplateCapacities \u003d parentQueue\n             .getLeafQueueTemplate()\n             .getQueueCapacities();\n-        queueGuranteedResource \u003d Resources.multiply(totalPartitionResource,\n+        queueGuaranteedResource \u003d Resources.multiply(totalPartitionResource,\n             leafQueueTemplateCapacities.getAbsoluteCapacity\n                 (nodePartition));\n       }\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n-      queueGuranteedResource \u003d\n-          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n+      queueGuaranteedResource \u003d\n+          Resources.max(rc, totalPartitionResource, queueGuaranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n-              queueGuranteedResource);\n+              queueGuaranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n-              queueGuranteedResource);\n+              queueGuaranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n \n     queueMetrics.setUsedCapacity(nodePartition,\n         queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n     queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n         queueCapacities.getAbsoluteUsedCapacity(\n             RMNodeLabelsManager.NO_LABEL));\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n\n      Resource queueGuaranteedResource \u003d childQueue\n          .getEffectiveCapacity(nodePartition);\n\n      //TODO : Modify below code to support Absolute Resource configurations\n      // (YARN-5881) for AutoCreatedLeafQueue\n      if (Float.compare(queueCapacities.getAbsoluteCapacity\n              (nodePartition), 0f) \u003d\u003d 0\n          \u0026\u0026 childQueue instanceof AutoCreatedLeafQueue) {\n\n        //If absolute capacity is 0 for a leaf queue (could be a managed leaf\n        // queue, then use the leaf queue\u0027s template capacity to compute\n        // guaranteed resource for used capacity)\n\n        // queueGuaranteed \u003d totalPartitionedResource *\n        // absolute_capacity(partition)\n        ManagedParentQueue parentQueue \u003d (ManagedParentQueue)\n            childQueue.getParent();\n        QueueCapacities leafQueueTemplateCapacities \u003d parentQueue\n            .getLeafQueueTemplate()\n            .getQueueCapacities();\n        queueGuaranteedResource \u003d Resources.multiply(totalPartitionResource,\n            leafQueueTemplateCapacities.getAbsoluteCapacity\n                (nodePartition));\n      }\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuaranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuaranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuaranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuaranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/12/17 3:07 PM",
      "commitNameOld": "74665e3a7d7f05644d9a5abad5a3f2d47597d6c8",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,79 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n       final Resource totalPartitionResource, String nodePartition,\n       AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n+\n       Resource queueGuranteedResource \u003d childQueue\n           .getEffectiveCapacity(nodePartition);\n \n+      //TODO : Modify below code to support Absolute Resource configurations\n+      // (YARN-5881) for AutoCreatedLeafQueue\n+      if (Float.compare(queueCapacities.getAbsoluteCapacity\n+              (nodePartition), 0f) \u003d\u003d 0\n+          \u0026\u0026 childQueue instanceof AutoCreatedLeafQueue) {\n+\n+        //If absolute capacity is 0 for a leaf queue (could be a managed leaf\n+        // queue, then use the leaf queue\u0027s template capacity to compute\n+        // guaranteed resource for used capacity)\n+\n+        // queueGuaranteed \u003d totalPartitionedResource *\n+        // absolute_capacity(partition)\n+        ManagedParentQueue parentQueue \u003d (ManagedParentQueue)\n+            childQueue.getParent();\n+        QueueCapacities leafQueueTemplateCapacities \u003d parentQueue\n+            .getLeafQueueTemplate()\n+            .getQueueCapacities();\n+        queueGuranteedResource \u003d Resources.multiply(totalPartitionResource,\n+            leafQueueTemplateCapacities.getAbsoluteCapacity\n+                (nodePartition));\n+      }\n+\n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n \n     queueMetrics.setUsedCapacity(nodePartition,\n         queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n     queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n         queueCapacities.getAbsoluteUsedCapacity(\n             RMNodeLabelsManager.NO_LABEL));\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n\n      Resource queueGuranteedResource \u003d childQueue\n          .getEffectiveCapacity(nodePartition);\n\n      //TODO : Modify below code to support Absolute Resource configurations\n      // (YARN-5881) for AutoCreatedLeafQueue\n      if (Float.compare(queueCapacities.getAbsoluteCapacity\n              (nodePartition), 0f) \u003d\u003d 0\n          \u0026\u0026 childQueue instanceof AutoCreatedLeafQueue) {\n\n        //If absolute capacity is 0 for a leaf queue (could be a managed leaf\n        // queue, then use the leaf queue\u0027s template capacity to compute\n        // guaranteed resource for used capacity)\n\n        // queueGuaranteed \u003d totalPartitionedResource *\n        // absolute_capacity(partition)\n        ManagedParentQueue parentQueue \u003d (ManagedParentQueue)\n            childQueue.getParent();\n        QueueCapacities leafQueueTemplateCapacities \u003d parentQueue\n            .getLeafQueueTemplate()\n            .getQueueCapacities();\n        queueGuranteedResource \u003d Resources.multiply(totalPartitionResource,\n            leafQueueTemplateCapacities.getAbsoluteCapacity\n                (nodePartition));\n      }\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-7538. Fix performance regression introduced by Capacity Scheduler absolute min/max resource refactoring. (Sunil G via wangda)\n\nChange-Id: Ic9bd7e599c56970fe01cb0e1bba6df7d1f77eb29\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n-      final Resource totalPartitionResource, Resource clusterResource,\n-      String nodePartition, AbstractCSQueue childQueue) {\n+      final Resource totalPartitionResource, String nodePartition,\n+      AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       Resource queueGuranteedResource \u003d childQueue\n           .getEffectiveCapacity(nodePartition);\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n \n     queueMetrics.setUsedCapacity(nodePartition,\n         queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n     queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n         queueCapacities.getAbsoluteUsedCapacity(\n             RMNodeLabelsManager.NO_LABEL));\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      Resource queueGuranteedResource \u003d childQueue\n          .getEffectiveCapacity(nodePartition);\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {
        "oldValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), clusterResource-Resource, nodePartition-String, childQueue-AbstractCSQueue]",
        "newValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), nodePartition-String, childQueue-AbstractCSQueue]"
      }
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
          "commitDate": "07/12/17 6:56 PM",
          "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "19/06/17 9:01 AM",
          "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 171.46,
          "commitsBetweenForRepo": 1316,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,56 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n-      final Resource totalPartitionResource, String nodePartition,\n-      AbstractCSQueue childQueue) {\n+      final Resource totalPartitionResource, Resource clusterResource,\n+      String nodePartition, AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n-      // queueGuaranteed \u003d totalPartitionedResource *\n-      // absolute_capacity(partition)\n-      Resource queueGuranteedResource \u003d\n-          Resources.multiply(totalPartitionResource,\n-              queueCapacities.getAbsoluteCapacity(nodePartition));\n+      Resource queueGuranteedResource \u003d childQueue\n+          .getEffectiveCapacity(nodePartition);\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n \n     queueMetrics.setUsedCapacity(nodePartition,\n         queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n     queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n         queueCapacities.getAbsoluteUsedCapacity(\n             RMNodeLabelsManager.NO_LABEL));\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, Resource clusterResource,\n      String nodePartition, AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      Resource queueGuranteedResource \u003d childQueue\n          .getEffectiveCapacity(nodePartition);\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
          "extendedDetails": {
            "oldValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), nodePartition-String, childQueue-AbstractCSQueue]",
            "newValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), clusterResource-Resource, nodePartition-String, childQueue-AbstractCSQueue]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
          "commitDate": "07/12/17 6:56 PM",
          "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "19/06/17 9:01 AM",
          "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 171.46,
          "commitsBetweenForRepo": 1316,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,56 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n-      final Resource totalPartitionResource, String nodePartition,\n-      AbstractCSQueue childQueue) {\n+      final Resource totalPartitionResource, Resource clusterResource,\n+      String nodePartition, AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n-      // queueGuaranteed \u003d totalPartitionedResource *\n-      // absolute_capacity(partition)\n-      Resource queueGuranteedResource \u003d\n-          Resources.multiply(totalPartitionResource,\n-              queueCapacities.getAbsoluteCapacity(nodePartition));\n+      Resource queueGuranteedResource \u003d childQueue\n+          .getEffectiveCapacity(nodePartition);\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n \n     queueMetrics.setUsedCapacity(nodePartition,\n         queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n     queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n         queueCapacities.getAbsoluteUsedCapacity(\n             RMNodeLabelsManager.NO_LABEL));\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, Resource clusterResource,\n      String nodePartition, AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      Resource queueGuranteedResource \u003d childQueue\n          .getEffectiveCapacity(nodePartition);\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "e9c2aa1bc383cb08784846534415bf17667d6e41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6467. CSQueueMetrics needs to update the current metrics for default partition only. Contributed by Manikandan R.\n",
      "commitDate": "19/06/17 9:01 AM",
      "commitName": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "11/04/17 6:44 AM",
      "commitNameOld": "0e065f2edead41f6f894c9d70def389af1c0f239",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 69.1,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n       final Resource totalPartitionResource, String nodePartition,\n       AbstractCSQueue childQueue) {\n     QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n     CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n     ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n     Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       // queueGuaranteed \u003d totalPartitionedResource *\n       // absolute_capacity(partition)\n       Resource queueGuranteedResource \u003d\n           Resources.multiply(totalPartitionResource,\n               queueCapacities.getAbsoluteCapacity(nodePartition));\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n \n     // QueueMetrics does not support per-label capacities,\n     // so we report values only for the default partition.\n-    if (nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n-      queueMetrics.setUsedCapacity(\n-          queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n-      queueMetrics.setAbsoluteUsedCapacity(\n-          queueCapacities.getAbsoluteUsedCapacity(\n-              RMNodeLabelsManager.NO_LABEL));\n-    }\n+\n+    queueMetrics.setUsedCapacity(nodePartition,\n+        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n+    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n+        queueCapacities.getAbsoluteUsedCapacity(\n+            RMNodeLabelsManager.NO_LABEL));\n+\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n\n    queueMetrics.setUsedCapacity(nodePartition,\n        queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n    queueMetrics.setAbsoluteUsedCapacity(nodePartition,\n        queueCapacities.getAbsoluteUsedCapacity(\n            RMNodeLabelsManager.NO_LABEL));\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "0e065f2edead41f6f894c9d70def389af1c0f239": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6195. Export UsedCapacity and AbsoluteUsedCapacity to JMX. Contributed by Benson Qiu\n",
      "commitDate": "11/04/17 6:44 AM",
      "commitName": "0e065f2edead41f6f894c9d70def389af1c0f239",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6195. Export UsedCapacity and AbsoluteUsedCapacity to JMX. Contributed by Benson Qiu\n",
          "commitDate": "11/04/17 6:44 AM",
          "commitName": "0e065f2edead41f6f894c9d70def389af1c0f239",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "15/07/16 11:40 AM",
          "commitNameOld": "24db9167f16ba643a186624b33a6b9b80020f476",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 269.79,
          "commitsBetweenForRepo": 1695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,59 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n-      final Resource totalPartitionResource, final Resource minimumAllocation,\n-      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n-      String nodePartition) {\n+      final Resource totalPartitionResource, String nodePartition,\n+      AbstractCSQueue childQueue) {\n+    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n+    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n+    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n+    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       // queueGuaranteed \u003d totalPartitionedResource *\n       // absolute_capacity(partition)\n       Resource queueGuranteedResource \u003d\n           Resources.multiply(totalPartitionResource,\n               queueCapacities.getAbsoluteCapacity(nodePartition));\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n+\n+    // QueueMetrics does not support per-label capacities,\n+    // so we report values only for the default partition.\n+    if (nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+      queueMetrics.setUsedCapacity(\n+          queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n+      queueMetrics.setAbsoluteUsedCapacity(\n+          queueCapacities.getAbsoluteUsedCapacity(\n+              RMNodeLabelsManager.NO_LABEL));\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n    if (nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n      queueMetrics.setUsedCapacity(\n          queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n      queueMetrics.setAbsoluteUsedCapacity(\n          queueCapacities.getAbsoluteUsedCapacity(\n              RMNodeLabelsManager.NO_LABEL));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
          "extendedDetails": {
            "oldValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), minimumAllocation-Resource(modifiers-final), queueResourceUsage-ResourceUsage, queueCapacities-QueueCapacities, nodePartition-String]",
            "newValue": "[rc-ResourceCalculator(modifiers-final), totalPartitionResource-Resource(modifiers-final), nodePartition-String, childQueue-AbstractCSQueue]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6195. Export UsedCapacity and AbsoluteUsedCapacity to JMX. Contributed by Benson Qiu\n",
          "commitDate": "11/04/17 6:44 AM",
          "commitName": "0e065f2edead41f6f894c9d70def389af1c0f239",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "15/07/16 11:40 AM",
          "commitNameOld": "24db9167f16ba643a186624b33a6b9b80020f476",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 269.79,
          "commitsBetweenForRepo": 1695,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,59 @@\n   public static void updateUsedCapacity(final ResourceCalculator rc,\n-      final Resource totalPartitionResource, final Resource minimumAllocation,\n-      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n-      String nodePartition) {\n+      final Resource totalPartitionResource, String nodePartition,\n+      AbstractCSQueue childQueue) {\n+    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n+    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n+    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n+    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       // queueGuaranteed \u003d totalPartitionedResource *\n       // absolute_capacity(partition)\n       Resource queueGuranteedResource \u003d\n           Resources.multiply(totalPartitionResource,\n               queueCapacities.getAbsoluteCapacity(nodePartition));\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n+\n+    // QueueMetrics does not support per-label capacities,\n+    // so we report values only for the default partition.\n+    if (nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n+      queueMetrics.setUsedCapacity(\n+          queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n+      queueMetrics.setAbsoluteUsedCapacity(\n+          queueCapacities.getAbsoluteUsedCapacity(\n+              RMNodeLabelsManager.NO_LABEL));\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, String nodePartition,\n      AbstractCSQueue childQueue) {\n    QueueCapacities queueCapacities \u003d childQueue.getQueueCapacities();\n    CSQueueMetrics queueMetrics \u003d childQueue.getMetrics();\n    ResourceUsage queueResourceUsage \u003d childQueue.getQueueResourceUsage();\n    Resource minimumAllocation \u003d childQueue.getMinimumAllocation();\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n\n    // QueueMetrics does not support per-label capacities,\n    // so we report values only for the default partition.\n    if (nodePartition.equals(CommonNodeLabelsManager.NO_LABEL)) {\n      queueMetrics.setUsedCapacity(\n          queueCapacities.getUsedCapacity(RMNodeLabelsManager.NO_LABEL));\n      queueMetrics.setAbsoluteUsedCapacity(\n          queueCapacities.getAbsoluteUsedCapacity(\n              RMNodeLabelsManager.NO_LABEL));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "21eb4284487d6f8e4beedb8a0c3168e952f224fc": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-4699. Scheduler UI and REST o/p is not in sync when -replaceLabelsOnNode is used to change label of a node. (Sunil G via wangda)\n",
      "commitDate": "05/04/16 4:24 PM",
      "commitName": "21eb4284487d6f8e4beedb8a0c3168e952f224fc",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/03/16 5:07 PM",
      "commitNameOld": "fc055a3cbe9545cf1c59421641c7b296aa33f953",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n-  private static void updateUsedCapacity(final ResourceCalculator rc,\n+  public static void updateUsedCapacity(final ResourceCalculator rc,\n       final Resource totalPartitionResource, final Resource minimumAllocation,\n       ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n       String nodePartition) {\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n     float reservedCapacity \u003d 0.0f;\n     float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       // queueGuaranteed \u003d totalPartitionedResource *\n       // absolute_capacity(partition)\n       Resource queueGuranteedResource \u003d\n           Resources.multiply(totalPartitionResource,\n               queueCapacities.getAbsoluteCapacity(nodePartition));\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n \n       Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n       reservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               queueGuranteedResource);\n       absoluteReservedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, resResource,\n               totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n     queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n     queueCapacities\n         .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, final Resource minimumAllocation,\n      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n      String nodePartition) {\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {
        "oldValue": "[private, static]",
        "newValue": "[public, static]"
      }
    },
    "fc055a3cbe9545cf1c59421641c7b296aa33f953": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4865. Track Reserved resources in ResourceUsage and QueueCapacities. (Sunil G via wangda)\n",
      "commitDate": "29/03/16 5:07 PM",
      "commitName": "fc055a3cbe9545cf1c59421641c7b296aa33f953",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/10/15 4:44 PM",
      "commitNameOld": "56e4f6237ae8b1852e82b186e08db3934f79a9db",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 155.02,
      "commitsBetweenForRepo": 997,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,46 @@\n   private static void updateUsedCapacity(final ResourceCalculator rc,\n       final Resource totalPartitionResource, final Resource minimumAllocation,\n       ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n       String nodePartition) {\n     float absoluteUsedCapacity \u003d 0.0f;\n     float usedCapacity \u003d 0.0f;\n+    float reservedCapacity \u003d 0.0f;\n+    float absoluteReservedCapacity \u003d 0.0f;\n \n     if (Resources.greaterThan(rc, totalPartitionResource,\n         totalPartitionResource, Resources.none())) {\n       // queueGuaranteed \u003d totalPartitionedResource *\n       // absolute_capacity(partition)\n       Resource queueGuranteedResource \u003d\n           Resources.multiply(totalPartitionResource,\n               queueCapacities.getAbsoluteCapacity(nodePartition));\n \n       // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n       queueGuranteedResource \u003d\n           Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n               minimumAllocation);\n \n       Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n       absoluteUsedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               totalPartitionResource);\n       usedCapacity \u003d\n           Resources.divide(rc, totalPartitionResource, usedResource,\n               queueGuranteedResource);\n+\n+      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n+      reservedCapacity \u003d\n+          Resources.divide(rc, totalPartitionResource, resResource,\n+              queueGuranteedResource);\n+      absoluteReservedCapacity \u003d\n+          Resources.divide(rc, totalPartitionResource, resResource,\n+              totalPartitionResource);\n     }\n \n     queueCapacities\n         .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n     queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n+    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n+    queueCapacities\n+        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, final Resource minimumAllocation,\n      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n      String nodePartition) {\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n    float reservedCapacity \u003d 0.0f;\n    float absoluteReservedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n\n      Resource resResource \u003d queueResourceUsage.getReserved(nodePartition);\n      reservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              queueGuranteedResource);\n      absoluteReservedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, resResource,\n              totalPartitionResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n    queueCapacities.setReservedCapacity(nodePartition, reservedCapacity);\n    queueCapacities\n        .setAbsoluteReservedCapacity(nodePartition, absoluteReservedCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java",
      "extendedDetails": {}
    },
    "d573f09fb93dbb711d504620af5d73840ea063a6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2696. Queue sorting in CapacityScheduler should consider node label. Contributed by Wangda Tan\n",
      "commitDate": "17/04/15 1:36 PM",
      "commitName": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,33 @@\n+  private static void updateUsedCapacity(final ResourceCalculator rc,\n+      final Resource totalPartitionResource, final Resource minimumAllocation,\n+      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n+      String nodePartition) {\n+    float absoluteUsedCapacity \u003d 0.0f;\n+    float usedCapacity \u003d 0.0f;\n+\n+    if (Resources.greaterThan(rc, totalPartitionResource,\n+        totalPartitionResource, Resources.none())) {\n+      // queueGuaranteed \u003d totalPartitionedResource *\n+      // absolute_capacity(partition)\n+      Resource queueGuranteedResource \u003d\n+          Resources.multiply(totalPartitionResource,\n+              queueCapacities.getAbsoluteCapacity(nodePartition));\n+\n+      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n+      queueGuranteedResource \u003d\n+          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n+              minimumAllocation);\n+\n+      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n+      absoluteUsedCapacity \u003d\n+          Resources.divide(rc, totalPartitionResource, usedResource,\n+              totalPartitionResource);\n+      usedCapacity \u003d\n+          Resources.divide(rc, totalPartitionResource, usedResource,\n+              queueGuranteedResource);\n+    }\n+\n+    queueCapacities\n+        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n+    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void updateUsedCapacity(final ResourceCalculator rc,\n      final Resource totalPartitionResource, final Resource minimumAllocation,\n      ResourceUsage queueResourceUsage, QueueCapacities queueCapacities,\n      String nodePartition) {\n    float absoluteUsedCapacity \u003d 0.0f;\n    float usedCapacity \u003d 0.0f;\n\n    if (Resources.greaterThan(rc, totalPartitionResource,\n        totalPartitionResource, Resources.none())) {\n      // queueGuaranteed \u003d totalPartitionedResource *\n      // absolute_capacity(partition)\n      Resource queueGuranteedResource \u003d\n          Resources.multiply(totalPartitionResource,\n              queueCapacities.getAbsoluteCapacity(nodePartition));\n\n      // make queueGuranteed \u003e\u003d minimum_allocation to avoid divided by 0.\n      queueGuranteedResource \u003d\n          Resources.max(rc, totalPartitionResource, queueGuranteedResource,\n              minimumAllocation);\n\n      Resource usedResource \u003d queueResourceUsage.getUsed(nodePartition);\n      absoluteUsedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              totalPartitionResource);\n      usedCapacity \u003d\n          Resources.divide(rc, totalPartitionResource, usedResource,\n              queueGuranteedResource);\n    }\n\n    queueCapacities\n        .setAbsoluteUsedCapacity(nodePartition, absoluteUsedCapacity);\n    queueCapacities.setUsedCapacity(nodePartition, usedCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CSQueueUtils.java"
    }
  }
}