{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JenkinsHash.java",
  "functionName": "hash",
  "functionId": "hash___key-byte[]__nbytes-int__initval-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java",
  "functionStartLine": 88,
  "functionEndLine": 245,
  "numCommitsSeen": 9,
  "timeTaken": 808,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int hash(byte[] key, int nbytes, int initval) {\n    int length \u003d nbytes;\n    long a, b, c;       // We use longs because we don\u0027t have unsigned ints\n    a \u003d b \u003d c \u003d (0x00000000deadbeefL + length + initval) \u0026 INT_MASK;\n    int offset \u003d 0;\n    for (; length \u003e 12; offset +\u003d 12, length -\u003d 12) {\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      \n      /*\n       * mix -- mix 3 32-bit values reversibly.\n       * This is reversible, so any information in (a,b,c) before mix() is\n       * still in (a,b,c) after mix().\n       * \n       * If four pairs of (a,b,c) inputs are run through mix(), or through\n       * mix() in reverse, there are at least 32 bits of the output that\n       * are sometimes the same for one pair and different for another pair.\n       * \n       * This was tested for:\n       * - pairs that differed by one bit, by two bits, in any combination\n       *   of top bits of (a,b,c), or in any combination of bottom bits of\n       *   (a,b,c).\n       * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n       *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n       *    is commonly produced by subtraction) look like a single 1-bit\n       *    difference.\n       * - the base values were pseudorandom, all zero but one bit set, or\n       *   all zero plus a counter that starts at zero.\n       * \n       * Some k values for my \"a-\u003dc; a^\u003drot(c,k); c+\u003db;\" arrangement that\n       * satisfy this are\n       *     4  6  8 16 19  4\n       *     9 15  3 18 27 15\n       *    14  9  3  7 17  3\n       * Well, \"9 15 3 18 27 15\" didn\u0027t quite get 32 bits diffing for \n       * \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n       * used http://burtleburtle.net/bob/hash/avalanche.html to choose\n       * the operations, constants, and arrangements of the variables.\n       * \n       * This does not achieve avalanche.  There are input bits of (a,b,c)\n       * that fail to affect some output bits of (a,b,c), especially of a.\n       * The most thoroughly mixed value is c, but it doesn\u0027t really even\n       * achieve avalanche in c.\n       * \n       * This allows some parallelism.  Read-after-writes are good at doubling\n       * the number of bits affected, so the goal of mixing pulls in the\n       * opposite direction as the goal of parallelism.  I did what I could.\n       * Rotates seem to cost as much as shifts on every machine I could lay\n       * my hands on, and rotates are much kinder to the top and bottom bits,\n       * so I used rotates.\n       *\n       * #define mix(a,b,c) \\\n       * { \\\n       *   a -\u003d c;  a ^\u003d rot(c, 4);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a, 6);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 8);  b +\u003d a; \\\n       *   a -\u003d c;  a ^\u003d rot(c,16);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a,19);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 4);  b +\u003d a; \\\n       * }\n       * \n       * mix(a,b,c);\n       */\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c, 4);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a, 6);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 8);  b \u003d (b + a) \u0026 INT_MASK;\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c,16);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a,19);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 4);  b \u003d (b + a) \u0026 INT_MASK;\n    }\n\n    //-------------------------------- last block: affect all 32 bits of (c)\n    switch (length) {                   // all the case statements fall through\n    case 12:\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 11:\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 10:\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  9:\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  8:\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  7:\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  6:\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  5:\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  4:\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  3:\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  2:\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  1:\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      break;\n    case  0:\n      return (int)(c \u0026 INT_MASK);\n    }\n    /*\n     * final -- final mixing of 3 32-bit values (a,b,c) into c\n     * \n     * Pairs of (a,b,c) values differing in only a few bits will usually\n     * produce values of c that look totally different.  This was tested for\n     * - pairs that differed by one bit, by two bits, in any combination\n     *   of top bits of (a,b,c), or in any combination of bottom bits of\n     *   (a,b,c).\n     * \n     * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n     *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n     *   is commonly produced by subtraction) look like a single 1-bit\n     *   difference.\n     * \n     * - the base values were pseudorandom, all zero but one bit set, or\n     *   all zero plus a counter that starts at zero.\n     * \n     * These constants passed:\n     *   14 11 25 16 4 14 24\n     *   12 14 25 16 4 14 24\n     * and these came close:\n     *    4  8 15 26 3 22 24\n     *   10  8 15 26 3 22 24\n     *   11  8 15 26 3 22 24\n     * \n     * #define final(a,b,c) \\\n     * { \n     *   c ^\u003d b; c -\u003d rot(b,14); \\\n     *   a ^\u003d c; a -\u003d rot(c,11); \\\n     *   b ^\u003d a; b -\u003d rot(a,25); \\\n     *   c ^\u003d b; c -\u003d rot(b,16); \\\n     *   a ^\u003d c; a -\u003d rot(c,4);  \\\n     *   b ^\u003d a; b -\u003d rot(a,14); \\\n     *   c ^\u003d b; c -\u003d rot(b,24); \\\n     * }\n     * \n     */\n    c ^\u003d b; c \u003d (c - rot(b,14)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,11)) \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,25)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,16)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,4))  \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,14)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,24)) \u0026 INT_MASK;\n\n    return (int)(c \u0026 INT_MASK);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int hash(byte[] key, int nbytes, int initval) {\n    int length \u003d nbytes;\n    long a, b, c;       // We use longs because we don\u0027t have unsigned ints\n    a \u003d b \u003d c \u003d (0x00000000deadbeefL + length + initval) \u0026 INT_MASK;\n    int offset \u003d 0;\n    for (; length \u003e 12; offset +\u003d 12, length -\u003d 12) {\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      \n      /*\n       * mix -- mix 3 32-bit values reversibly.\n       * This is reversible, so any information in (a,b,c) before mix() is\n       * still in (a,b,c) after mix().\n       * \n       * If four pairs of (a,b,c) inputs are run through mix(), or through\n       * mix() in reverse, there are at least 32 bits of the output that\n       * are sometimes the same for one pair and different for another pair.\n       * \n       * This was tested for:\n       * - pairs that differed by one bit, by two bits, in any combination\n       *   of top bits of (a,b,c), or in any combination of bottom bits of\n       *   (a,b,c).\n       * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n       *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n       *    is commonly produced by subtraction) look like a single 1-bit\n       *    difference.\n       * - the base values were pseudorandom, all zero but one bit set, or\n       *   all zero plus a counter that starts at zero.\n       * \n       * Some k values for my \"a-\u003dc; a^\u003drot(c,k); c+\u003db;\" arrangement that\n       * satisfy this are\n       *     4  6  8 16 19  4\n       *     9 15  3 18 27 15\n       *    14  9  3  7 17  3\n       * Well, \"9 15 3 18 27 15\" didn\u0027t quite get 32 bits diffing for \n       * \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n       * used http://burtleburtle.net/bob/hash/avalanche.html to choose\n       * the operations, constants, and arrangements of the variables.\n       * \n       * This does not achieve avalanche.  There are input bits of (a,b,c)\n       * that fail to affect some output bits of (a,b,c), especially of a.\n       * The most thoroughly mixed value is c, but it doesn\u0027t really even\n       * achieve avalanche in c.\n       * \n       * This allows some parallelism.  Read-after-writes are good at doubling\n       * the number of bits affected, so the goal of mixing pulls in the\n       * opposite direction as the goal of parallelism.  I did what I could.\n       * Rotates seem to cost as much as shifts on every machine I could lay\n       * my hands on, and rotates are much kinder to the top and bottom bits,\n       * so I used rotates.\n       *\n       * #define mix(a,b,c) \\\n       * { \\\n       *   a -\u003d c;  a ^\u003d rot(c, 4);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a, 6);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 8);  b +\u003d a; \\\n       *   a -\u003d c;  a ^\u003d rot(c,16);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a,19);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 4);  b +\u003d a; \\\n       * }\n       * \n       * mix(a,b,c);\n       */\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c, 4);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a, 6);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 8);  b \u003d (b + a) \u0026 INT_MASK;\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c,16);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a,19);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 4);  b \u003d (b + a) \u0026 INT_MASK;\n    }\n\n    //-------------------------------- last block: affect all 32 bits of (c)\n    switch (length) {                   // all the case statements fall through\n    case 12:\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 11:\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 10:\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  9:\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  8:\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  7:\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  6:\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  5:\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  4:\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  3:\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  2:\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  1:\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      break;\n    case  0:\n      return (int)(c \u0026 INT_MASK);\n    }\n    /*\n     * final -- final mixing of 3 32-bit values (a,b,c) into c\n     * \n     * Pairs of (a,b,c) values differing in only a few bits will usually\n     * produce values of c that look totally different.  This was tested for\n     * - pairs that differed by one bit, by two bits, in any combination\n     *   of top bits of (a,b,c), or in any combination of bottom bits of\n     *   (a,b,c).\n     * \n     * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n     *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n     *   is commonly produced by subtraction) look like a single 1-bit\n     *   difference.\n     * \n     * - the base values were pseudorandom, all zero but one bit set, or\n     *   all zero plus a counter that starts at zero.\n     * \n     * These constants passed:\n     *   14 11 25 16 4 14 24\n     *   12 14 25 16 4 14 24\n     * and these came close:\n     *    4  8 15 26 3 22 24\n     *   10  8 15 26 3 22 24\n     *   11  8 15 26 3 22 24\n     * \n     * #define final(a,b,c) \\\n     * { \n     *   c ^\u003d b; c -\u003d rot(b,14); \\\n     *   a ^\u003d c; a -\u003d rot(c,11); \\\n     *   b ^\u003d a; b -\u003d rot(a,25); \\\n     *   c ^\u003d b; c -\u003d rot(b,16); \\\n     *   a ^\u003d c; a -\u003d rot(c,4);  \\\n     *   b ^\u003d a; b -\u003d rot(a,14); \\\n     *   c ^\u003d b; c -\u003d rot(b,24); \\\n     * }\n     * \n     */\n    c ^\u003d b; c \u003d (c - rot(b,14)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,11)) \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,25)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,16)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,4))  \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,14)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,24)) \u0026 INT_MASK;\n\n    return (int)(c \u0026 INT_MASK);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/util/hash/JenkinsHash.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/util/hash/JenkinsHash.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int hash(byte[] key, int nbytes, int initval) {\n    int length \u003d nbytes;\n    long a, b, c;       // We use longs because we don\u0027t have unsigned ints\n    a \u003d b \u003d c \u003d (0x00000000deadbeefL + length + initval) \u0026 INT_MASK;\n    int offset \u003d 0;\n    for (; length \u003e 12; offset +\u003d 12, length -\u003d 12) {\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      \n      /*\n       * mix -- mix 3 32-bit values reversibly.\n       * This is reversible, so any information in (a,b,c) before mix() is\n       * still in (a,b,c) after mix().\n       * \n       * If four pairs of (a,b,c) inputs are run through mix(), or through\n       * mix() in reverse, there are at least 32 bits of the output that\n       * are sometimes the same for one pair and different for another pair.\n       * \n       * This was tested for:\n       * - pairs that differed by one bit, by two bits, in any combination\n       *   of top bits of (a,b,c), or in any combination of bottom bits of\n       *   (a,b,c).\n       * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n       *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n       *    is commonly produced by subtraction) look like a single 1-bit\n       *    difference.\n       * - the base values were pseudorandom, all zero but one bit set, or\n       *   all zero plus a counter that starts at zero.\n       * \n       * Some k values for my \"a-\u003dc; a^\u003drot(c,k); c+\u003db;\" arrangement that\n       * satisfy this are\n       *     4  6  8 16 19  4\n       *     9 15  3 18 27 15\n       *    14  9  3  7 17  3\n       * Well, \"9 15 3 18 27 15\" didn\u0027t quite get 32 bits diffing for \n       * \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n       * used http://burtleburtle.net/bob/hash/avalanche.html to choose\n       * the operations, constants, and arrangements of the variables.\n       * \n       * This does not achieve avalanche.  There are input bits of (a,b,c)\n       * that fail to affect some output bits of (a,b,c), especially of a.\n       * The most thoroughly mixed value is c, but it doesn\u0027t really even\n       * achieve avalanche in c.\n       * \n       * This allows some parallelism.  Read-after-writes are good at doubling\n       * the number of bits affected, so the goal of mixing pulls in the\n       * opposite direction as the goal of parallelism.  I did what I could.\n       * Rotates seem to cost as much as shifts on every machine I could lay\n       * my hands on, and rotates are much kinder to the top and bottom bits,\n       * so I used rotates.\n       *\n       * #define mix(a,b,c) \\\n       * { \\\n       *   a -\u003d c;  a ^\u003d rot(c, 4);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a, 6);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 8);  b +\u003d a; \\\n       *   a -\u003d c;  a ^\u003d rot(c,16);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a,19);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 4);  b +\u003d a; \\\n       * }\n       * \n       * mix(a,b,c);\n       */\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c, 4);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a, 6);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 8);  b \u003d (b + a) \u0026 INT_MASK;\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c,16);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a,19);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 4);  b \u003d (b + a) \u0026 INT_MASK;\n    }\n\n    //-------------------------------- last block: affect all 32 bits of (c)\n    switch (length) {                   // all the case statements fall through\n    case 12:\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 11:\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 10:\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  9:\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  8:\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  7:\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  6:\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  5:\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  4:\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  3:\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  2:\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  1:\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      break;\n    case  0:\n      return (int)(c \u0026 INT_MASK);\n    }\n    /*\n     * final -- final mixing of 3 32-bit values (a,b,c) into c\n     * \n     * Pairs of (a,b,c) values differing in only a few bits will usually\n     * produce values of c that look totally different.  This was tested for\n     * - pairs that differed by one bit, by two bits, in any combination\n     *   of top bits of (a,b,c), or in any combination of bottom bits of\n     *   (a,b,c).\n     * \n     * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n     *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n     *   is commonly produced by subtraction) look like a single 1-bit\n     *   difference.\n     * \n     * - the base values were pseudorandom, all zero but one bit set, or\n     *   all zero plus a counter that starts at zero.\n     * \n     * These constants passed:\n     *   14 11 25 16 4 14 24\n     *   12 14 25 16 4 14 24\n     * and these came close:\n     *    4  8 15 26 3 22 24\n     *   10  8 15 26 3 22 24\n     *   11  8 15 26 3 22 24\n     * \n     * #define final(a,b,c) \\\n     * { \n     *   c ^\u003d b; c -\u003d rot(b,14); \\\n     *   a ^\u003d c; a -\u003d rot(c,11); \\\n     *   b ^\u003d a; b -\u003d rot(a,25); \\\n     *   c ^\u003d b; c -\u003d rot(b,16); \\\n     *   a ^\u003d c; a -\u003d rot(c,4);  \\\n     *   b ^\u003d a; b -\u003d rot(a,14); \\\n     *   c ^\u003d b; c -\u003d rot(b,24); \\\n     * }\n     * \n     */\n    c ^\u003d b; c \u003d (c - rot(b,14)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,11)) \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,25)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,16)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,4))  \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,14)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,24)) \u0026 INT_MASK;\n\n    return (int)(c \u0026 INT_MASK);\n  }",
      "path": "common/src/java/org/apache/hadoop/util/hash/JenkinsHash.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/util/hash/JenkinsHash.java",
        "newPath": "common/src/java/org/apache/hadoop/util/hash/JenkinsHash.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,158 @@\n+  public int hash(byte[] key, int nbytes, int initval) {\n+    int length \u003d nbytes;\n+    long a, b, c;       // We use longs because we don\u0027t have unsigned ints\n+    a \u003d b \u003d c \u003d (0x00000000deadbeefL + length + initval) \u0026 INT_MASK;\n+    int offset \u003d 0;\n+    for (; length \u003e 12; offset +\u003d 12, length -\u003d 12) {\n+      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+      \n+      /*\n+       * mix -- mix 3 32-bit values reversibly.\n+       * This is reversible, so any information in (a,b,c) before mix() is\n+       * still in (a,b,c) after mix().\n+       * \n+       * If four pairs of (a,b,c) inputs are run through mix(), or through\n+       * mix() in reverse, there are at least 32 bits of the output that\n+       * are sometimes the same for one pair and different for another pair.\n+       * \n+       * This was tested for:\n+       * - pairs that differed by one bit, by two bits, in any combination\n+       *   of top bits of (a,b,c), or in any combination of bottom bits of\n+       *   (a,b,c).\n+       * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+       *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n+       *    is commonly produced by subtraction) look like a single 1-bit\n+       *    difference.\n+       * - the base values were pseudorandom, all zero but one bit set, or\n+       *   all zero plus a counter that starts at zero.\n+       * \n+       * Some k values for my \"a-\u003dc; a^\u003drot(c,k); c+\u003db;\" arrangement that\n+       * satisfy this are\n+       *     4  6  8 16 19  4\n+       *     9 15  3 18 27 15\n+       *    14  9  3  7 17  3\n+       * Well, \"9 15 3 18 27 15\" didn\u0027t quite get 32 bits diffing for \n+       * \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n+       * used http://burtleburtle.net/bob/hash/avalanche.html to choose\n+       * the operations, constants, and arrangements of the variables.\n+       * \n+       * This does not achieve avalanche.  There are input bits of (a,b,c)\n+       * that fail to affect some output bits of (a,b,c), especially of a.\n+       * The most thoroughly mixed value is c, but it doesn\u0027t really even\n+       * achieve avalanche in c.\n+       * \n+       * This allows some parallelism.  Read-after-writes are good at doubling\n+       * the number of bits affected, so the goal of mixing pulls in the\n+       * opposite direction as the goal of parallelism.  I did what I could.\n+       * Rotates seem to cost as much as shifts on every machine I could lay\n+       * my hands on, and rotates are much kinder to the top and bottom bits,\n+       * so I used rotates.\n+       *\n+       * #define mix(a,b,c) \\\n+       * { \\\n+       *   a -\u003d c;  a ^\u003d rot(c, 4);  c +\u003d b; \\\n+       *   b -\u003d a;  b ^\u003d rot(a, 6);  a +\u003d c; \\\n+       *   c -\u003d b;  c ^\u003d rot(b, 8);  b +\u003d a; \\\n+       *   a -\u003d c;  a ^\u003d rot(c,16);  c +\u003d b; \\\n+       *   b -\u003d a;  b ^\u003d rot(a,19);  a +\u003d c; \\\n+       *   c -\u003d b;  c ^\u003d rot(b, 4);  b +\u003d a; \\\n+       * }\n+       * \n+       * mix(a,b,c);\n+       */\n+      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c, 4);  c \u003d (c + b) \u0026 INT_MASK;\n+      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a, 6);  a \u003d (a + c) \u0026 INT_MASK;\n+      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 8);  b \u003d (b + a) \u0026 INT_MASK;\n+      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c,16);  c \u003d (c + b) \u0026 INT_MASK;\n+      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a,19);  a \u003d (a + c) \u0026 INT_MASK;\n+      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 4);  b \u003d (b + a) \u0026 INT_MASK;\n+    }\n+\n+    //-------------------------------- last block: affect all 32 bits of (c)\n+    switch (length) {                   // all the case statements fall through\n+    case 12:\n+      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case 11:\n+      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case 10:\n+      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  9:\n+      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+    case  8:\n+      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  7:\n+      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  6:\n+      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  5:\n+      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+    case  4:\n+      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  3:\n+      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  2:\n+      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n+    case  1:\n+      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n+      break;\n+    case  0:\n+      return (int)(c \u0026 INT_MASK);\n+    }\n+    /*\n+     * final -- final mixing of 3 32-bit values (a,b,c) into c\n+     * \n+     * Pairs of (a,b,c) values differing in only a few bits will usually\n+     * produce values of c that look totally different.  This was tested for\n+     * - pairs that differed by one bit, by two bits, in any combination\n+     *   of top bits of (a,b,c), or in any combination of bottom bits of\n+     *   (a,b,c).\n+     * \n+     * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n+     *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n+     *   is commonly produced by subtraction) look like a single 1-bit\n+     *   difference.\n+     * \n+     * - the base values were pseudorandom, all zero but one bit set, or\n+     *   all zero plus a counter that starts at zero.\n+     * \n+     * These constants passed:\n+     *   14 11 25 16 4 14 24\n+     *   12 14 25 16 4 14 24\n+     * and these came close:\n+     *    4  8 15 26 3 22 24\n+     *   10  8 15 26 3 22 24\n+     *   11  8 15 26 3 22 24\n+     * \n+     * #define final(a,b,c) \\\n+     * { \n+     *   c ^\u003d b; c -\u003d rot(b,14); \\\n+     *   a ^\u003d c; a -\u003d rot(c,11); \\\n+     *   b ^\u003d a; b -\u003d rot(a,25); \\\n+     *   c ^\u003d b; c -\u003d rot(b,16); \\\n+     *   a ^\u003d c; a -\u003d rot(c,4);  \\\n+     *   b ^\u003d a; b -\u003d rot(a,14); \\\n+     *   c ^\u003d b; c -\u003d rot(b,24); \\\n+     * }\n+     * \n+     */\n+    c ^\u003d b; c \u003d (c - rot(b,14)) \u0026 INT_MASK;\n+    a ^\u003d c; a \u003d (a - rot(c,11)) \u0026 INT_MASK;\n+    b ^\u003d a; b \u003d (b - rot(a,25)) \u0026 INT_MASK;\n+    c ^\u003d b; c \u003d (c - rot(b,16)) \u0026 INT_MASK;\n+    a ^\u003d c; a \u003d (a - rot(c,4))  \u0026 INT_MASK;\n+    b ^\u003d a; b \u003d (b - rot(a,14)) \u0026 INT_MASK;\n+    c ^\u003d b; c \u003d (c - rot(b,24)) \u0026 INT_MASK;\n+\n+    return (int)(c \u0026 INT_MASK);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int hash(byte[] key, int nbytes, int initval) {\n    int length \u003d nbytes;\n    long a, b, c;       // We use longs because we don\u0027t have unsigned ints\n    a \u003d b \u003d c \u003d (0x00000000deadbeefL + length + initval) \u0026 INT_MASK;\n    int offset \u003d 0;\n    for (; length \u003e 12; offset +\u003d 12, length -\u003d 12) {\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n      \n      /*\n       * mix -- mix 3 32-bit values reversibly.\n       * This is reversible, so any information in (a,b,c) before mix() is\n       * still in (a,b,c) after mix().\n       * \n       * If four pairs of (a,b,c) inputs are run through mix(), or through\n       * mix() in reverse, there are at least 32 bits of the output that\n       * are sometimes the same for one pair and different for another pair.\n       * \n       * This was tested for:\n       * - pairs that differed by one bit, by two bits, in any combination\n       *   of top bits of (a,b,c), or in any combination of bottom bits of\n       *   (a,b,c).\n       * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n       *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n       *    is commonly produced by subtraction) look like a single 1-bit\n       *    difference.\n       * - the base values were pseudorandom, all zero but one bit set, or\n       *   all zero plus a counter that starts at zero.\n       * \n       * Some k values for my \"a-\u003dc; a^\u003drot(c,k); c+\u003db;\" arrangement that\n       * satisfy this are\n       *     4  6  8 16 19  4\n       *     9 15  3 18 27 15\n       *    14  9  3  7 17  3\n       * Well, \"9 15 3 18 27 15\" didn\u0027t quite get 32 bits diffing for \n       * \"differ\" defined as + with a one-bit base and a two-bit delta.  I\n       * used http://burtleburtle.net/bob/hash/avalanche.html to choose\n       * the operations, constants, and arrangements of the variables.\n       * \n       * This does not achieve avalanche.  There are input bits of (a,b,c)\n       * that fail to affect some output bits of (a,b,c), especially of a.\n       * The most thoroughly mixed value is c, but it doesn\u0027t really even\n       * achieve avalanche in c.\n       * \n       * This allows some parallelism.  Read-after-writes are good at doubling\n       * the number of bits affected, so the goal of mixing pulls in the\n       * opposite direction as the goal of parallelism.  I did what I could.\n       * Rotates seem to cost as much as shifts on every machine I could lay\n       * my hands on, and rotates are much kinder to the top and bottom bits,\n       * so I used rotates.\n       *\n       * #define mix(a,b,c) \\\n       * { \\\n       *   a -\u003d c;  a ^\u003d rot(c, 4);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a, 6);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 8);  b +\u003d a; \\\n       *   a -\u003d c;  a ^\u003d rot(c,16);  c +\u003d b; \\\n       *   b -\u003d a;  b ^\u003d rot(a,19);  a +\u003d c; \\\n       *   c -\u003d b;  c ^\u003d rot(b, 4);  b +\u003d a; \\\n       * }\n       * \n       * mix(a,b,c);\n       */\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c, 4);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a, 6);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 8);  b \u003d (b + a) \u0026 INT_MASK;\n      a \u003d (a - c) \u0026 INT_MASK;  a ^\u003d rot(c,16);  c \u003d (c + b) \u0026 INT_MASK;\n      b \u003d (b - a) \u0026 INT_MASK;  b ^\u003d rot(a,19);  a \u003d (a + c) \u0026 INT_MASK;\n      c \u003d (c - b) \u0026 INT_MASK;  c ^\u003d rot(b, 4);  b \u003d (b + a) \u0026 INT_MASK;\n    }\n\n    //-------------------------------- last block: affect all 32 bits of (c)\n    switch (length) {                   // all the case statements fall through\n    case 12:\n      c \u003d (c + (((key[offset + 11] \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 11:\n      c \u003d (c + (((key[offset + 10] \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case 10:\n      c \u003d (c + (((key[offset + 9]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  9:\n      c \u003d (c + (key[offset + 8]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  8:\n      b \u003d (b + (((key[offset + 7]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  7:\n      b \u003d (b + (((key[offset + 6]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  6:\n      b \u003d (b + (((key[offset + 5]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  5:\n      b \u003d (b + (key[offset + 4]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n    case  4:\n      a \u003d (a + (((key[offset + 3]  \u0026 BYTE_MASK) \u003c\u003c 24) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  3:\n      a \u003d (a + (((key[offset + 2]  \u0026 BYTE_MASK) \u003c\u003c 16) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  2:\n      a \u003d (a + (((key[offset + 1]  \u0026 BYTE_MASK) \u003c\u003c  8) \u0026 INT_MASK)) \u0026 INT_MASK;\n    case  1:\n      a \u003d (a + (key[offset + 0]    \u0026 BYTE_MASK)) \u0026 INT_MASK;\n      break;\n    case  0:\n      return (int)(c \u0026 INT_MASK);\n    }\n    /*\n     * final -- final mixing of 3 32-bit values (a,b,c) into c\n     * \n     * Pairs of (a,b,c) values differing in only a few bits will usually\n     * produce values of c that look totally different.  This was tested for\n     * - pairs that differed by one bit, by two bits, in any combination\n     *   of top bits of (a,b,c), or in any combination of bottom bits of\n     *   (a,b,c).\n     * \n     * - \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n     *   the output delta to a Gray code (a^(a\u003e\u003e1)) so a string of 1\u0027s (as\n     *   is commonly produced by subtraction) look like a single 1-bit\n     *   difference.\n     * \n     * - the base values were pseudorandom, all zero but one bit set, or\n     *   all zero plus a counter that starts at zero.\n     * \n     * These constants passed:\n     *   14 11 25 16 4 14 24\n     *   12 14 25 16 4 14 24\n     * and these came close:\n     *    4  8 15 26 3 22 24\n     *   10  8 15 26 3 22 24\n     *   11  8 15 26 3 22 24\n     * \n     * #define final(a,b,c) \\\n     * { \n     *   c ^\u003d b; c -\u003d rot(b,14); \\\n     *   a ^\u003d c; a -\u003d rot(c,11); \\\n     *   b ^\u003d a; b -\u003d rot(a,25); \\\n     *   c ^\u003d b; c -\u003d rot(b,16); \\\n     *   a ^\u003d c; a -\u003d rot(c,4);  \\\n     *   b ^\u003d a; b -\u003d rot(a,14); \\\n     *   c ^\u003d b; c -\u003d rot(b,24); \\\n     * }\n     * \n     */\n    c ^\u003d b; c \u003d (c - rot(b,14)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,11)) \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,25)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,16)) \u0026 INT_MASK;\n    a ^\u003d c; a \u003d (a - rot(c,4))  \u0026 INT_MASK;\n    b ^\u003d a; b \u003d (b - rot(a,14)) \u0026 INT_MASK;\n    c ^\u003d b; c \u003d (c - rot(b,24)) \u0026 INT_MASK;\n\n    return (int)(c \u0026 INT_MASK);\n  }",
      "path": "src/java/org/apache/hadoop/util/hash/JenkinsHash.java"
    }
  }
}