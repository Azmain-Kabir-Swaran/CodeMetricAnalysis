{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LevelDBCacheTimelineStore.java",
  "functionName": "getIterator",
  "functionId": "getIterator___startId-EntityIdentifier__startTimeMax-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/LevelDBCacheTimelineStore.java",
  "functionStartLine": 232,
  "functionEndLine": 300,
  "numCommitsSeen": 7,
  "timeTaken": 1594,
  "changeHistory": [
    "71e0b0d8005ea1952dc7e582db15c2ac09df7c91",
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99"
  ],
  "changeHistoryShort": {
    "71e0b0d8005ea1952dc7e582db15c2ac09df7c91": "Ymultichange(Yreturntypechange,Ybodychange)",
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": "Yintroduced"
  },
  "changeHistoryDetails": {
    "71e0b0d8005ea1952dc7e582db15c2ac09df7c91": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-9040.  Fixed memory leak in LevelDBCacheTimelineStore and DBIterator.\n            Contributed by Tarun Parimi\n",
      "commitDate": "17/12/18 9:04 AM",
      "commitName": "71e0b0d8005ea1952dc7e582db15c2ac09df7c91",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-9040.  Fixed memory leak in LevelDBCacheTimelineStore and DBIterator.\n            Contributed by Tarun Parimi\n",
          "commitDate": "17/12/18 9:04 AM",
          "commitName": "71e0b0d8005ea1952dc7e582db15c2ac09df7c91",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "09/08/17 7:58 AM",
          "commitNameOld": "63cfcb90ac6fbb79ba9ed6b3044cd999fc74e58c",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 495.09,
          "commitsBetweenForRepo": 4351,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,69 @@\n-    private Iterator\u003cV\u003e getIterator(\n+    private CloseableIterator\u003cV\u003e getIterator(\n         EntityIdentifier startId, long startTimeMax) {\n \n       final DBIterator internalDbIterator \u003d entityDb.iterator();\n \n       // we need to iterate from the first element with key greater than or\n       // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n       // key who does not have prefix ENTITY_STORATE_PREFIX\n \n       // decide end prefix\n       LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n           \u003d LeveldbUtils.KeyBuilder.newInstance();\n       entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n       final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n       // decide start prefix on top of end prefix and seek\n       final byte[] startTimeBytes\n           \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n       entityPrefixKeyBuilder.add(startTimeBytes, true);\n       if (startId !\u003d null) {\n         entityPrefixKeyBuilder.add(startId.getId());\n       }\n       final byte[] startPrefixBytes\n           \u003d entityPrefixKeyBuilder.getBytesForLookup();\n       internalDbIterator.seek(startPrefixBytes);\n \n-      return new Iterator\u003cV\u003e() {\n+      return new CloseableIterator\u003cV\u003e() {\n         @Override\n         public boolean hasNext() {\n           if (!internalDbIterator.hasNext()) {\n             return false;\n           }\n           Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n           if (LeveldbUtils.prefixMatches(\n               prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n             return true;\n           }\n           return false;\n         }\n \n         @Override\n         public V next() {\n           if (hasNext()) {\n             Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n             try {\n               V result \u003d getEntityForKey(nextRaw.getKey());\n               return result;\n             } catch (IOException e) {\n               LOG.error(\"GenericObjectMapper cannot read key from key \"\n                   + nextRaw.getKey()\n                   + \" into an object. Read aborted! \");\n               LOG.error(e.getMessage());\n             }\n           }\n           return null;\n         }\n \n         // We do not support remove operations within one iteration\n         @Override\n         public void remove() {\n           LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n               + \" use cases. \");\n         }\n+\n+        @Override\n+        public void close() throws IOException {\n+          internalDbIterator.close();\n+        }\n       };\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private CloseableIterator\u003cV\u003e getIterator(\n        EntityIdentifier startId, long startTimeMax) {\n\n      final DBIterator internalDbIterator \u003d entityDb.iterator();\n\n      // we need to iterate from the first element with key greater than or\n      // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n      // key who does not have prefix ENTITY_STORATE_PREFIX\n\n      // decide end prefix\n      LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n          \u003d LeveldbUtils.KeyBuilder.newInstance();\n      entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n      final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      // decide start prefix on top of end prefix and seek\n      final byte[] startTimeBytes\n          \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n      entityPrefixKeyBuilder.add(startTimeBytes, true);\n      if (startId !\u003d null) {\n        entityPrefixKeyBuilder.add(startId.getId());\n      }\n      final byte[] startPrefixBytes\n          \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      internalDbIterator.seek(startPrefixBytes);\n\n      return new CloseableIterator\u003cV\u003e() {\n        @Override\n        public boolean hasNext() {\n          if (!internalDbIterator.hasNext()) {\n            return false;\n          }\n          Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n          if (LeveldbUtils.prefixMatches(\n              prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n            return true;\n          }\n          return false;\n        }\n\n        @Override\n        public V next() {\n          if (hasNext()) {\n            Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n            try {\n              V result \u003d getEntityForKey(nextRaw.getKey());\n              return result;\n            } catch (IOException e) {\n              LOG.error(\"GenericObjectMapper cannot read key from key \"\n                  + nextRaw.getKey()\n                  + \" into an object. Read aborted! \");\n              LOG.error(e.getMessage());\n            }\n          }\n          return null;\n        }\n\n        // We do not support remove operations within one iteration\n        @Override\n        public void remove() {\n          LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n              + \" use cases. \");\n        }\n\n        @Override\n        public void close() throws IOException {\n          internalDbIterator.close();\n        }\n      };\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/LevelDBCacheTimelineStore.java",
          "extendedDetails": {
            "oldValue": "Iterator\u003cV\u003e",
            "newValue": "CloseableIterator\u003cV\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9040.  Fixed memory leak in LevelDBCacheTimelineStore and DBIterator.\n            Contributed by Tarun Parimi\n",
          "commitDate": "17/12/18 9:04 AM",
          "commitName": "71e0b0d8005ea1952dc7e582db15c2ac09df7c91",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "09/08/17 7:58 AM",
          "commitNameOld": "63cfcb90ac6fbb79ba9ed6b3044cd999fc74e58c",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 495.09,
          "commitsBetweenForRepo": 4351,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,69 @@\n-    private Iterator\u003cV\u003e getIterator(\n+    private CloseableIterator\u003cV\u003e getIterator(\n         EntityIdentifier startId, long startTimeMax) {\n \n       final DBIterator internalDbIterator \u003d entityDb.iterator();\n \n       // we need to iterate from the first element with key greater than or\n       // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n       // key who does not have prefix ENTITY_STORATE_PREFIX\n \n       // decide end prefix\n       LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n           \u003d LeveldbUtils.KeyBuilder.newInstance();\n       entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n       final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n       // decide start prefix on top of end prefix and seek\n       final byte[] startTimeBytes\n           \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n       entityPrefixKeyBuilder.add(startTimeBytes, true);\n       if (startId !\u003d null) {\n         entityPrefixKeyBuilder.add(startId.getId());\n       }\n       final byte[] startPrefixBytes\n           \u003d entityPrefixKeyBuilder.getBytesForLookup();\n       internalDbIterator.seek(startPrefixBytes);\n \n-      return new Iterator\u003cV\u003e() {\n+      return new CloseableIterator\u003cV\u003e() {\n         @Override\n         public boolean hasNext() {\n           if (!internalDbIterator.hasNext()) {\n             return false;\n           }\n           Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n           if (LeveldbUtils.prefixMatches(\n               prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n             return true;\n           }\n           return false;\n         }\n \n         @Override\n         public V next() {\n           if (hasNext()) {\n             Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n             try {\n               V result \u003d getEntityForKey(nextRaw.getKey());\n               return result;\n             } catch (IOException e) {\n               LOG.error(\"GenericObjectMapper cannot read key from key \"\n                   + nextRaw.getKey()\n                   + \" into an object. Read aborted! \");\n               LOG.error(e.getMessage());\n             }\n           }\n           return null;\n         }\n \n         // We do not support remove operations within one iteration\n         @Override\n         public void remove() {\n           LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n               + \" use cases. \");\n         }\n+\n+        @Override\n+        public void close() throws IOException {\n+          internalDbIterator.close();\n+        }\n       };\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private CloseableIterator\u003cV\u003e getIterator(\n        EntityIdentifier startId, long startTimeMax) {\n\n      final DBIterator internalDbIterator \u003d entityDb.iterator();\n\n      // we need to iterate from the first element with key greater than or\n      // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n      // key who does not have prefix ENTITY_STORATE_PREFIX\n\n      // decide end prefix\n      LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n          \u003d LeveldbUtils.KeyBuilder.newInstance();\n      entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n      final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      // decide start prefix on top of end prefix and seek\n      final byte[] startTimeBytes\n          \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n      entityPrefixKeyBuilder.add(startTimeBytes, true);\n      if (startId !\u003d null) {\n        entityPrefixKeyBuilder.add(startId.getId());\n      }\n      final byte[] startPrefixBytes\n          \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      internalDbIterator.seek(startPrefixBytes);\n\n      return new CloseableIterator\u003cV\u003e() {\n        @Override\n        public boolean hasNext() {\n          if (!internalDbIterator.hasNext()) {\n            return false;\n          }\n          Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n          if (LeveldbUtils.prefixMatches(\n              prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n            return true;\n          }\n          return false;\n        }\n\n        @Override\n        public V next() {\n          if (hasNext()) {\n            Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n            try {\n              V result \u003d getEntityForKey(nextRaw.getKey());\n              return result;\n            } catch (IOException e) {\n              LOG.error(\"GenericObjectMapper cannot read key from key \"\n                  + nextRaw.getKey()\n                  + \" into an object. Read aborted! \");\n              LOG.error(e.getMessage());\n            }\n          }\n          return null;\n        }\n\n        // We do not support remove operations within one iteration\n        @Override\n        public void remove() {\n          LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n              + \" use cases. \");\n        }\n\n        @Override\n        public void close() throws IOException {\n          internalDbIterator.close();\n        }\n      };\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/LevelDBCacheTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4219. New levelDB cache storage for timeline v1.5. Contributed by\nLi Lu\n",
      "commitDate": "28/01/16 2:24 PM",
      "commitName": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
      "commitAuthor": "Xuan",
      "diff": "@@ -0,0 +1,64 @@\n+    private Iterator\u003cV\u003e getIterator(\n+        EntityIdentifier startId, long startTimeMax) {\n+\n+      final DBIterator internalDbIterator \u003d entityDb.iterator();\n+\n+      // we need to iterate from the first element with key greater than or\n+      // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n+      // key who does not have prefix ENTITY_STORATE_PREFIX\n+\n+      // decide end prefix\n+      LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n+          \u003d LeveldbUtils.KeyBuilder.newInstance();\n+      entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n+      final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n+      // decide start prefix on top of end prefix and seek\n+      final byte[] startTimeBytes\n+          \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n+      entityPrefixKeyBuilder.add(startTimeBytes, true);\n+      if (startId !\u003d null) {\n+        entityPrefixKeyBuilder.add(startId.getId());\n+      }\n+      final byte[] startPrefixBytes\n+          \u003d entityPrefixKeyBuilder.getBytesForLookup();\n+      internalDbIterator.seek(startPrefixBytes);\n+\n+      return new Iterator\u003cV\u003e() {\n+        @Override\n+        public boolean hasNext() {\n+          if (!internalDbIterator.hasNext()) {\n+            return false;\n+          }\n+          Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n+          if (LeveldbUtils.prefixMatches(\n+              prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n+            return true;\n+          }\n+          return false;\n+        }\n+\n+        @Override\n+        public V next() {\n+          if (hasNext()) {\n+            Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n+            try {\n+              V result \u003d getEntityForKey(nextRaw.getKey());\n+              return result;\n+            } catch (IOException e) {\n+              LOG.error(\"GenericObjectMapper cannot read key from key \"\n+                  + nextRaw.getKey()\n+                  + \" into an object. Read aborted! \");\n+              LOG.error(e.getMessage());\n+            }\n+          }\n+          return null;\n+        }\n+\n+        // We do not support remove operations within one iteration\n+        @Override\n+        public void remove() {\n+          LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n+              + \" use cases. \");\n+        }\n+      };\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private Iterator\u003cV\u003e getIterator(\n        EntityIdentifier startId, long startTimeMax) {\n\n      final DBIterator internalDbIterator \u003d entityDb.iterator();\n\n      // we need to iterate from the first element with key greater than or\n      // equal to ENTITY_STORAGE_PREFIX!maxTS(!startId), but stop on the first\n      // key who does not have prefix ENTITY_STORATE_PREFIX\n\n      // decide end prefix\n      LeveldbUtils.KeyBuilder entityPrefixKeyBuilder\n          \u003d LeveldbUtils.KeyBuilder.newInstance();\n      entityPrefixKeyBuilder.add(ENTITY_STORAGE_PREFIX);\n      final byte[] prefixBytes \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      // decide start prefix on top of end prefix and seek\n      final byte[] startTimeBytes\n          \u003d GenericObjectMapper.writeReverseOrderedLong(startTimeMax);\n      entityPrefixKeyBuilder.add(startTimeBytes, true);\n      if (startId !\u003d null) {\n        entityPrefixKeyBuilder.add(startId.getId());\n      }\n      final byte[] startPrefixBytes\n          \u003d entityPrefixKeyBuilder.getBytesForLookup();\n      internalDbIterator.seek(startPrefixBytes);\n\n      return new Iterator\u003cV\u003e() {\n        @Override\n        public boolean hasNext() {\n          if (!internalDbIterator.hasNext()) {\n            return false;\n          }\n          Map.Entry\u003cbyte[], byte[]\u003e nextEntry \u003d internalDbIterator.peekNext();\n          if (LeveldbUtils.prefixMatches(\n              prefixBytes, prefixBytes.length, nextEntry.getKey())) {\n            return true;\n          }\n          return false;\n        }\n\n        @Override\n        public V next() {\n          if (hasNext()) {\n            Map.Entry\u003cbyte[], byte[]\u003e nextRaw \u003d internalDbIterator.next();\n            try {\n              V result \u003d getEntityForKey(nextRaw.getKey());\n              return result;\n            } catch (IOException e) {\n              LOG.error(\"GenericObjectMapper cannot read key from key \"\n                  + nextRaw.getKey()\n                  + \" into an object. Read aborted! \");\n              LOG.error(e.getMessage());\n            }\n          }\n          return null;\n        }\n\n        // We do not support remove operations within one iteration\n        @Override\n        public void remove() {\n          LOG.error(\"LevelDB map adapter does not support iterate-and-remove\"\n              + \" use cases. \");\n        }\n      };\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/LevelDBCacheTimelineStore.java"
    }
  }
}