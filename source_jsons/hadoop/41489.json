{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "initScheduler",
  "functionId": "initScheduler___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 1413,
  "functionEndLine": 1484,
  "numCommitsSeen": 226,
  "timeTaken": 12998,
  "changeHistory": [
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d",
    "5257f50abb71905ef3068fd45541d00ce9e8f355",
    "889df6f1949921371d6d55dff93d3818d03be3bb",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
    "ba12f87dcb0e406da57cdd1ad17677ac2367f425",
    "86bc6425d425913899f1d951498bd040e453b3d0",
    "370f1c6283813dc1c7d001f44930e3c79c140c54",
    "4cc9479dae2bfb7d14d29b55d103eea9fa35a586",
    "bb34ae955496c1aa595dc1186153d605a41f5378",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
    "fa531788fd7c9eee70808818a2f6aec9bdc3bec7",
    "74dd14225059322825f706120aa57cf673820daf",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
    "10468529a9b858bd945e7ecb063c9c1438efa474",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "04ded558b03ee0fbf68a611cf1f25508b4447e44",
    "7e2837f830382835838c82398db6fc9823d612a7",
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "14864e9c7c879c15b5fa2d1776614ec83152918f",
    "c0b49ff10728bb70bb60e6cb5973976f0466d247",
    "c88402f36d4066b18310c1fd61469f71b8d8eb13",
    "ff7758299151e3b69c27314010b4ef3a9fda3b41",
    "a4ba451802c6c61a0c804809740d46dd76059f25"
  ],
  "changeHistoryShort": {
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d": "Ybodychange",
    "5257f50abb71905ef3068fd45541d00ce9e8f355": "Ybodychange",
    "889df6f1949921371d6d55dff93d3818d03be3bb": "Ybodychange",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": "Ybodychange",
    "ba12f87dcb0e406da57cdd1ad17677ac2367f425": "Ybodychange",
    "86bc6425d425913899f1d951498bd040e453b3d0": "Ybodychange",
    "370f1c6283813dc1c7d001f44930e3c79c140c54": "Ybodychange",
    "4cc9479dae2bfb7d14d29b55d103eea9fa35a586": "Ybodychange",
    "bb34ae955496c1aa595dc1186153d605a41f5378": "Ybodychange",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": "Ybodychange",
    "fa531788fd7c9eee70808818a2f6aec9bdc3bec7": "Ybodychange",
    "74dd14225059322825f706120aa57cf673820daf": "Ybodychange",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": "Ybodychange",
    "10468529a9b858bd945e7ecb063c9c1438efa474": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ybodychange",
    "04ded558b03ee0fbf68a611cf1f25508b4447e44": "Ybodychange",
    "7e2837f830382835838c82398db6fc9823d612a7": "Ybodychange",
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "14864e9c7c879c15b5fa2d1776614ec83152918f": "Ybodychange",
    "c0b49ff10728bb70bb60e6cb5973976f0466d247": "Ybodychange",
    "c88402f36d4066b18310c1fd61469f71b8d8eb13": "Ybodychange",
    "ff7758299151e3b69c27314010b4ef3a9fda3b41": "Ybodychange",
    "a4ba451802c6c61a0c804809740d46dd76059f25": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5cc7873a4723a6c8e8e001d008fcd522eec0433d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9699. Migration tool that help to generate CS config based on FS config [Phase 1]. Contributed by Peter Bacsko\n",
      "commitDate": "14/10/19 8:19 AM",
      "commitName": "5cc7873a4723a6c8e8e001d008fcd522eec0433d",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "09/04/19 10:59 AM",
      "commitNameOld": "cfec455c452d85229ef2f9d83e6f7fc827946b59",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 187.89,
      "commitsBetweenForRepo": 1457,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     writeLock.lock();\n     try {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(this);\n       queueMgr.initialize();\n \n-      if (continuousSchedulingEnabled) {\n+      if (continuousSchedulingEnabled \u0026\u0026 !migration) {\n         // Continuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n-      if (this.conf.getPreemptionEnabled()) {\n+      if (this.conf.getPreemptionEnabled() \u0026\u0026 !migration) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    writeLock.lock();\n    try {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(this);\n      queueMgr.initialize();\n\n      if (continuousSchedulingEnabled \u0026\u0026 !migration) {\n        // Continuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled() \u0026\u0026 !migration) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "5257f50abb71905ef3068fd45541d00ce9e8f355": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "25/03/19 10:47 PM",
      "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
      "commitAuthor": "yufei",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 10.27,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,72 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     writeLock.lock();\n     try {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n-      allocConf \u003d new AllocationConfiguration(conf);\n-      try {\n-        queueMgr.initialize(conf);\n-      } catch (Exception e) {\n-        throw new IOException(\"Failed to start FairScheduler\", e);\n-      }\n+      allocConf \u003d new AllocationConfiguration(this);\n+      queueMgr.initialize();\n \n       if (continuousSchedulingEnabled) {\n         // Continuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    writeLock.lock();\n    try {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(this);\n      queueMgr.initialize();\n\n      if (continuousSchedulingEnabled) {\n        // Continuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "889df6f1949921371d6d55dff93d3818d03be3bb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7948. Enable fair scheduler to refresh maximum allocation for multiple resource types. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "02/08/18 10:10 AM",
      "commitName": "889df6f1949921371d6d55dff93d3818d03be3bb",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "31/07/18 3:01 PM",
      "commitNameOld": "c7ebcd76bf3dd14127336951f2be3de772e7826a",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     writeLock.lock();\n     try {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n-        // Contiuous scheduling is deprecated log it on startup\n+        // Continuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    writeLock.lock();\n    try {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // Continuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7133. Clean up lock-try order in fair scheduler. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "24/07/18 12:46 PM",
      "commitName": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/06/18 11:12 AM",
      "commitNameOld": "c190ac2be88e574b3322cdc73a7c0af0cef708b2",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 43.07,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n         // Contiuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    writeLock.lock();\n    try {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // Contiuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ba12f87dcb0e406da57cdd1ad17677ac2367f425": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8390. Fix API incompatible changes in FairScheduler\u0027s AllocationFileLoaderService. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "04/06/18 9:15 AM",
      "commitName": "ba12f87dcb0e406da57cdd1ad17677ac2367f425",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "24/05/18 5:12 PM",
      "commitNameOld": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 10.67,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n         // Contiuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n+    allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // Contiuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "86bc6425d425913899f1d951498bd040e453b3d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8191. Fair scheduler: queue deletion without RM restart. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "24/05/18 5:12 PM",
      "commitName": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "21/05/18 8:10 AM",
      "commitNameOld": "f48fec83d0f2d1a781a141ad7216463c5526321f",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 3.38,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n         // Contiuous scheduling is deprecated log it on startup\n         LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n             \"because it can cause scheduler slowness due to locking issues. \" +\n             \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n-    allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // Contiuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "370f1c6283813dc1c7d001f44930e3c79c140c54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6486. FairScheduler: Deprecate continuous scheduling. (Contributed by Wilfred Spiegelenburg)\n",
      "commitDate": "16/01/18 2:46 PM",
      "commitName": "370f1c6283813dc1c7d001f44930e3c79c140c54",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "09/01/18 4:59 PM",
      "commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
      "commitAuthorOld": "Miklos Szegedi",
      "daysBetweenCommits": 6.91,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n+        // Contiuous scheduling is deprecated log it on startup\n+        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n+            \"because it can cause scheduler slowness due to locking issues. \" +\n+            \"Schedulers should use assignmultiple as a replacement.\");\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // Contiuous scheduling is deprecated log it on startup\n        LOG.warn(\"Continuous scheduling is turned ON. It is deprecated \" +\n            \"because it can cause scheduler slowness due to locking issues. \" +\n            \"Schedulers should use assignmultiple as a replacement.\");\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4cc9479dae2bfb7d14d29b55d103eea9fa35a586": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7524. Remove unused FairSchedulerEventLog. (Contributed by Wilfred Spiegelenburg)\n",
      "commitDate": "22/11/17 2:18 PM",
      "commitName": "4cc9479dae2bfb7d14d29b55d103eea9fa35a586",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "15/11/17 10:03 AM",
      "commitNameOld": "b246c547490dd94271806ca4caf1e5f199f0fb09",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 7.18,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,72 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n-      this.eventLog \u003d new FairSchedulerEventLog();\n-      eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bb34ae955496c1aa595dc1186153d605a41f5378": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7146. Many RM unit tests failing with FairScheduler (rkanter)\n",
      "commitDate": "13/09/17 3:44 PM",
      "commitName": "bb34ae955496c1aa595dc1186153d605a41f5378",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,74 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n-      updateThread \u003d new UpdateThread();\n-      updateThread.setName(\"FairSchedulerUpdateThread\");\n-      updateThread.setUncaughtExceptionHandler(\n-          new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n-      updateThread.setDaemon(true);\n-\n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5587. Add support for resource profiles. (vvasudev via asuresh)\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "11/09/17 8:42 PM",
      "commitNameOld": "fa531788fd7c9eee70808818a2f6aec9bdc3bec7",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n-      minimumAllocation \u003d this.conf.getMinimumAllocation();\n-      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n+      minimumAllocation \u003d super.getMinimumAllocation();\n+      initMaximumResourceCapability(super.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setUncaughtExceptionHandler(\n           new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setUncaughtExceptionHandler(\n          new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "fa531788fd7c9eee70808818a2f6aec9bdc3bec7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7132. FairScheduler.initScheduler() contains a surprising unary plus. (Yeliang Cang via Haibo Chen)\n",
      "commitDate": "11/09/17 8:42 PM",
      "commitName": "fa531788fd7c9eee70808818a2f6aec9bdc3bec7",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "23/08/17 9:56 AM",
      "commitNameOld": "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 19.45,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n-            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n+            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setUncaughtExceptionHandler(\n           new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setUncaughtExceptionHandler(\n             new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setUncaughtExceptionHandler(\n          new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "74dd14225059322825f706120aa57cf673820daf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5798. Set UncaughtExceptionHandler for all FairScheduler threads. (Yufei Gu via kasha)\n",
      "commitDate": "16/02/17 12:03 AM",
      "commitName": "74dd14225059322825f706120aa57cf673820daf",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "15/02/17 11:16 PM",
      "commitNameOld": "6c25dbcdc0517a825b92fb16444aa1d3761e160c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,80 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n+      updateThread.setUncaughtExceptionHandler(\n+          new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n+        schedulingThread.setUncaughtExceptionHandler(\n+            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setUncaughtExceptionHandler(\n          new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setUncaughtExceptionHandler(\n            new RMCriticalThreadUncaughtExceptionHandler(rmContext));\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4997. Update fair scheduler to use pluggable auth provider (Contributed by Tao Jie via Daniel Templeton)\n",
      "commitDate": "30/11/16 9:50 AM",
      "commitName": "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n \n       if (this.conf.getPreemptionEnabled()) {\n         createPreemptionThread();\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      authorizer \u003d YarnAuthorizationProvider.getInstance(conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "10468529a9b858bd945e7ecb063c9c1438efa474": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4752. Improved preemption in FairScheduler. (kasha)\n\nContains:\nYARN-5605. Preempt containers (all on one node) to meet the requirement of starved applications\nYARN-5821. Drop left-over preemption-related code and clean up method visibilities in the Schedulable hierarchy\nYARN-5783. Verify identification of starved applications.\nYARN-5819. Verify fairshare and minshare preemption\nYARN-5885. Cleanup YARN-4752 branch for merge\n\nChange-Id: Iee0962377d019dd64dc69a020725d2eaf360858c\n",
      "commitDate": "23/11/16 9:48 PM",
      "commitName": "10468529a9b858bd945e7ecb063c9c1438efa474",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "22/11/16 11:16 AM",
      "commitNameOld": "83cc7263af632939dc3b2ee58d8f03f98ed4d96a",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.44,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n-      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-      preemptionUtilizationThreshold \u003d\n-          this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-      preemptionInterval \u003d this.conf.getPreemptionInterval();\n-      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \"\n             + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n+\n+      if (this.conf.getPreemptionEnabled()) {\n+        createPreemptionThread();\n+      }\n     } finally {\n       writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n\n      if (this.conf.getPreemptionEnabled()) {\n        createPreemptionThread();\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/10/16 6:03 AM",
      "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 1.47,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,76 @@\n   private void initScheduler(Configuration conf) throws IOException {\n-    synchronized (this) {\n+    try {\n+      writeLock.lock();\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n-      continuousSchedulingSleepMs \u003d\n-          this.conf.getContinuousSchedulingSleepMs();\n+      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       preemptionUtilizationThreshold \u003d\n           this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n-            + \" is invalid, so using default value \" +\n-            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n+            + \" is invalid, so using default value \"\n+            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n-      this.applications \u003d new ConcurrentHashMap\u003c\n-          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n+      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n+    } finally {\n+      writeLock.unlock();\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \"\n            + +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "04ded558b03ee0fbf68a611cf1f25508b4447e44": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5035. FairScheduler: Adjust maxAssign dynamically when assignMultiple is turned on. (kasha)\n",
      "commitDate": "26/05/16 2:41 PM",
      "commitName": "04ded558b03ee0fbf68a611cf1f25508b4447e44",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "05/05/16 12:56 PM",
      "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.07,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     synchronized (this) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n           this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       preemptionUtilizationThreshold \u003d\n           this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n+      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \" +\n             +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\n           ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssignDynamic \u003d this.conf.isMaxAssignDynamic();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "7e2837f830382835838c82398db6fc9823d612a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4270. Limit application resource reservation on nodes for non-node/rack specific requests (asuresh)\n",
      "commitDate": "19/10/15 8:00 PM",
      "commitName": "7e2837f830382835838c82398db6fc9823d612a7",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/10/15 5:12 PM",
      "commitNameOld": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 4.12,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     synchronized (this) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n           this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       preemptionUtilizationThreshold \u003d\n           this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+      reservableNodesRatio \u003d this.conf.getReservableNodes();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \" +\n             +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\n           ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      reservableNodesRatio \u003d this.conf.getReservableNodes();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3920. FairScheduler container reservation on a node should be configurable to limit it to large containers (adhoot via asuresh)\n",
      "commitDate": "18/09/15 2:02 PM",
      "commitName": "94dec5a9164cd9bc573fbf74e76bcff9e7c5c637",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "13/09/15 6:07 PM",
      "commitNameOld": "332b520a480994b7bd56c135f7941aad30b05e9c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     synchronized (this) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n+      updateReservationThreshold();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n           this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       preemptionUtilizationThreshold \u003d\n           this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \" +\n             +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\n           ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      updateReservationThreshold();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "21/11/14 10:32 AM",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "14/11/14 3:18 PM",
      "commitNameOld": "1a47f890ba3cb22b6262f47c1f1af2990559bb89",
      "commitAuthorOld": "Sandy Ryza",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void initScheduler(Configuration conf) throws IOException {\n     synchronized (this) {\n       this.conf \u003d new FairSchedulerConfiguration(conf);\n       validateConf(this.conf);\n       minimumAllocation \u003d this.conf.getMinimumAllocation();\n-      maximumAllocation \u003d this.conf.getMaximumAllocation();\n+      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       incrAllocation \u003d this.conf.getIncrementAllocation();\n       continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n       continuousSchedulingSleepMs \u003d\n           this.conf.getContinuousSchedulingSleepMs();\n       nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n       rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n       nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n       rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n       preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n       preemptionUtilizationThreshold \u003d\n           this.conf.getPreemptionUtilizationThreshold();\n       assignMultiple \u003d this.conf.getAssignMultiple();\n       maxAssign \u003d this.conf.getMaxAssign();\n       sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n       preemptionInterval \u003d this.conf.getPreemptionInterval();\n       waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n       usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n       updateInterval \u003d this.conf.getUpdateInterval();\n       if (updateInterval \u003c 0) {\n         updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n         LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n             + \" is invalid, so using default value \" +\n             +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n             + \" ms instead\");\n       }\n \n       rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n       fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n       // This stores per-application scheduling information\n       this.applications \u003d new ConcurrentHashMap\u003c\n           ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n       this.eventLog \u003d new FairSchedulerEventLog();\n       eventLog.init(this.conf);\n \n       allocConf \u003d new AllocationConfiguration(conf);\n       try {\n         queueMgr.initialize(conf);\n       } catch (Exception e) {\n         throw new IOException(\"Failed to start FairScheduler\", e);\n       }\n \n       updateThread \u003d new UpdateThread();\n       updateThread.setName(\"FairSchedulerUpdateThread\");\n       updateThread.setDaemon(true);\n \n       if (continuousSchedulingEnabled) {\n         // start continuous scheduling thread\n         schedulingThread \u003d new ContinuousSchedulingThread();\n         schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n         schedulingThread.setDaemon(true);\n       }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-2608. FairScheduler: Potential deadlocks in loading alloc files and clock access. (Wei Yan via kasha)\n",
      "commitDate": "25/09/14 5:42 PM",
      "commitName": "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-2608. FairScheduler: Potential deadlocks in loading alloc files and clock access. (Wei Yan via kasha)\n",
          "commitDate": "25/09/14 5:42 PM",
          "commitName": "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "18/09/14 11:03 AM",
          "commitNameOld": "485c96e3cb9b0b05d6e490b4773506da83ebc61d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.28,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,72 @@\n-  private synchronized void initScheduler(Configuration conf)\n-      throws IOException {\n-    this.conf \u003d new FairSchedulerConfiguration(conf);\n-    validateConf(this.conf);\n-    minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    maximumAllocation \u003d this.conf.getMaximumAllocation();\n-    incrAllocation \u003d this.conf.getIncrementAllocation();\n-    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n-    continuousSchedulingSleepMs \u003d\n-        this.conf.getContinuousSchedulingSleepMs();\n-    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n-    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n-    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-    preemptionUtilizationThreshold \u003d\n-        this.conf.getPreemptionUtilizationThreshold();\n-    assignMultiple \u003d this.conf.getAssignMultiple();\n-    maxAssign \u003d this.conf.getMaxAssign();\n-    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-    preemptionInterval \u003d this.conf.getPreemptionInterval();\n-    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n-    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+  private void initScheduler(Configuration conf) throws IOException {\n+    synchronized (this) {\n+      this.conf \u003d new FairSchedulerConfiguration(conf);\n+      validateConf(this.conf);\n+      minimumAllocation \u003d this.conf.getMinimumAllocation();\n+      maximumAllocation \u003d this.conf.getMaximumAllocation();\n+      incrAllocation \u003d this.conf.getIncrementAllocation();\n+      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n+      continuousSchedulingSleepMs \u003d\n+          this.conf.getContinuousSchedulingSleepMs();\n+      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n+      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n+      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      preemptionUtilizationThreshold \u003d\n+          this.conf.getPreemptionUtilizationThreshold();\n+      assignMultiple \u003d this.conf.getAssignMultiple();\n+      maxAssign \u003d this.conf.getMaxAssign();\n+      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+      preemptionInterval \u003d this.conf.getPreemptionInterval();\n+      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n+      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n-    updateInterval \u003d this.conf.getUpdateInterval();\n-    if (updateInterval \u003c 0) {\n-      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n-      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n-              + \" is invalid, so using default value \" +\n-              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n-              + \" ms instead\");\n-    }\n+      updateInterval \u003d this.conf.getUpdateInterval();\n+      if (updateInterval \u003c 0) {\n+        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n+        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n+            + \" is invalid, so using default value \" +\n+            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n+            + \" ms instead\");\n+      }\n \n-    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n-    fsOpDurations \u003d FSOpDurations.getInstance(true);\n+      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n+      fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n-    // This stores per-application scheduling information\n-    this.applications \u003d new ConcurrentHashMap\u003c\n-        ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n-    this.eventLog \u003d new FairSchedulerEventLog();\n-    eventLog.init(this.conf);\n+      // This stores per-application scheduling information\n+      this.applications \u003d new ConcurrentHashMap\u003c\n+          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n+      this.eventLog \u003d new FairSchedulerEventLog();\n+      eventLog.init(this.conf);\n \n-    allocConf \u003d new AllocationConfiguration(conf);\n-    try {\n-      queueMgr.initialize(conf);\n-    } catch (Exception e) {\n-      throw new IOException(\"Failed to start FairScheduler\", e);\n-    }\n+      allocConf \u003d new AllocationConfiguration(conf);\n+      try {\n+        queueMgr.initialize(conf);\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to start FairScheduler\", e);\n+      }\n \n-    updateThread \u003d new UpdateThread();\n-    updateThread.setName(\"FairSchedulerUpdateThread\");\n-    updateThread.setDaemon(true);\n+      updateThread \u003d new UpdateThread();\n+      updateThread.setName(\"FairSchedulerUpdateThread\");\n+      updateThread.setDaemon(true);\n \n-    if (continuousSchedulingEnabled) {\n-      // start continuous scheduling thread\n-      schedulingThread \u003d new ContinuousSchedulingThread();\n-      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n-      schedulingThread.setDaemon(true);\n+      if (continuousSchedulingEnabled) {\n+        // start continuous scheduling thread\n+        schedulingThread \u003d new ContinuousSchedulingThread();\n+        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n+        schedulingThread.setDaemon(true);\n+      }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2608. FairScheduler: Potential deadlocks in loading alloc files and clock access. (Wei Yan via kasha)\n",
          "commitDate": "25/09/14 5:42 PM",
          "commitName": "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "18/09/14 11:03 AM",
          "commitNameOld": "485c96e3cb9b0b05d6e490b4773506da83ebc61d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.28,
          "commitsBetweenForRepo": 86,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,71 +1,72 @@\n-  private synchronized void initScheduler(Configuration conf)\n-      throws IOException {\n-    this.conf \u003d new FairSchedulerConfiguration(conf);\n-    validateConf(this.conf);\n-    minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    maximumAllocation \u003d this.conf.getMaximumAllocation();\n-    incrAllocation \u003d this.conf.getIncrementAllocation();\n-    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n-    continuousSchedulingSleepMs \u003d\n-        this.conf.getContinuousSchedulingSleepMs();\n-    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n-    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n-    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n-    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n-    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n-    preemptionUtilizationThreshold \u003d\n-        this.conf.getPreemptionUtilizationThreshold();\n-    assignMultiple \u003d this.conf.getAssignMultiple();\n-    maxAssign \u003d this.conf.getMaxAssign();\n-    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n-    preemptionInterval \u003d this.conf.getPreemptionInterval();\n-    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n-    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+  private void initScheduler(Configuration conf) throws IOException {\n+    synchronized (this) {\n+      this.conf \u003d new FairSchedulerConfiguration(conf);\n+      validateConf(this.conf);\n+      minimumAllocation \u003d this.conf.getMinimumAllocation();\n+      maximumAllocation \u003d this.conf.getMaximumAllocation();\n+      incrAllocation \u003d this.conf.getIncrementAllocation();\n+      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n+      continuousSchedulingSleepMs \u003d\n+          this.conf.getContinuousSchedulingSleepMs();\n+      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n+      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n+      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+      preemptionUtilizationThreshold \u003d\n+          this.conf.getPreemptionUtilizationThreshold();\n+      assignMultiple \u003d this.conf.getAssignMultiple();\n+      maxAssign \u003d this.conf.getMaxAssign();\n+      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+      preemptionInterval \u003d this.conf.getPreemptionInterval();\n+      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n+      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n-    updateInterval \u003d this.conf.getUpdateInterval();\n-    if (updateInterval \u003c 0) {\n-      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n-      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n-              + \" is invalid, so using default value \" +\n-              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n-              + \" ms instead\");\n-    }\n+      updateInterval \u003d this.conf.getUpdateInterval();\n+      if (updateInterval \u003c 0) {\n+        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n+        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n+            + \" is invalid, so using default value \" +\n+            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n+            + \" ms instead\");\n+      }\n \n-    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n-    fsOpDurations \u003d FSOpDurations.getInstance(true);\n+      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n+      fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n-    // This stores per-application scheduling information\n-    this.applications \u003d new ConcurrentHashMap\u003c\n-        ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n-    this.eventLog \u003d new FairSchedulerEventLog();\n-    eventLog.init(this.conf);\n+      // This stores per-application scheduling information\n+      this.applications \u003d new ConcurrentHashMap\u003c\n+          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n+      this.eventLog \u003d new FairSchedulerEventLog();\n+      eventLog.init(this.conf);\n \n-    allocConf \u003d new AllocationConfiguration(conf);\n-    try {\n-      queueMgr.initialize(conf);\n-    } catch (Exception e) {\n-      throw new IOException(\"Failed to start FairScheduler\", e);\n-    }\n+      allocConf \u003d new AllocationConfiguration(conf);\n+      try {\n+        queueMgr.initialize(conf);\n+      } catch (Exception e) {\n+        throw new IOException(\"Failed to start FairScheduler\", e);\n+      }\n \n-    updateThread \u003d new UpdateThread();\n-    updateThread.setName(\"FairSchedulerUpdateThread\");\n-    updateThread.setDaemon(true);\n+      updateThread \u003d new UpdateThread();\n+      updateThread.setName(\"FairSchedulerUpdateThread\");\n+      updateThread.setDaemon(true);\n \n-    if (continuousSchedulingEnabled) {\n-      // start continuous scheduling thread\n-      schedulingThread \u003d new ContinuousSchedulingThread();\n-      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n-      schedulingThread.setDaemon(true);\n+      if (continuousSchedulingEnabled) {\n+        // start continuous scheduling thread\n+        schedulingThread \u003d new ContinuousSchedulingThread();\n+        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n+        schedulingThread.setDaemon(true);\n+      }\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initScheduler(Configuration conf) throws IOException {\n    synchronized (this) {\n      this.conf \u003d new FairSchedulerConfiguration(conf);\n      validateConf(this.conf);\n      minimumAllocation \u003d this.conf.getMinimumAllocation();\n      maximumAllocation \u003d this.conf.getMaximumAllocation();\n      incrAllocation \u003d this.conf.getIncrementAllocation();\n      continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n      continuousSchedulingSleepMs \u003d\n          this.conf.getContinuousSchedulingSleepMs();\n      nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n      rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n      nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n      rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n      preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n      preemptionUtilizationThreshold \u003d\n          this.conf.getPreemptionUtilizationThreshold();\n      assignMultiple \u003d this.conf.getAssignMultiple();\n      maxAssign \u003d this.conf.getMaxAssign();\n      sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n      preemptionInterval \u003d this.conf.getPreemptionInterval();\n      waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n      usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n      updateInterval \u003d this.conf.getUpdateInterval();\n      if (updateInterval \u003c 0) {\n        updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n        LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n            + \" is invalid, so using default value \" +\n            +FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n            + \" ms instead\");\n      }\n\n      rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n      fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n      // This stores per-application scheduling information\n      this.applications \u003d new ConcurrentHashMap\u003c\n          ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n      this.eventLog \u003d new FairSchedulerEventLog();\n      eventLog.init(this.conf);\n\n      allocConf \u003d new AllocationConfiguration(conf);\n      try {\n        queueMgr.initialize(conf);\n      } catch (Exception e) {\n        throw new IOException(\"Failed to start FairScheduler\", e);\n      }\n\n      updateThread \u003d new UpdateThread();\n      updateThread.setName(\"FairSchedulerUpdateThread\");\n      updateThread.setDaemon(true);\n\n      if (continuousSchedulingEnabled) {\n        // start continuous scheduling thread\n        schedulingThread \u003d new ContinuousSchedulingThread();\n        schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n        schedulingThread.setDaemon(true);\n      }\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   private synchronized void initScheduler(Configuration conf)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n         this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     preemptionUtilizationThreshold \u003d\n         this.conf.getPreemptionUtilizationThreshold();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n     updateInterval \u003d this.conf.getUpdateInterval();\n     if (updateInterval \u003c 0) {\n       updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n       LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n               + \" is invalid, so using default value \" +\n               + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n               + \" ms instead\");\n     }\n \n     rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n     fsOpDurations \u003d FSOpDurations.getInstance(true);\n \n     // This stores per-application scheduling information\n-    this.applications \u003d\n-        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n+    this.applications \u003d new ConcurrentHashMap\u003c\n+        ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n     this.eventLog \u003d new FairSchedulerEventLog();\n     eventLog.init(this.conf);\n \n     allocConf \u003d new AllocationConfiguration(conf);\n     try {\n       queueMgr.initialize(conf);\n     } catch (Exception e) {\n       throw new IOException(\"Failed to start FairScheduler\", e);\n     }\n \n     updateThread \u003d new UpdateThread();\n     updateThread.setName(\"FairSchedulerUpdateThread\");\n     updateThread.setDaemon(true);\n \n     if (continuousSchedulingEnabled) {\n       // start continuous scheduling thread\n       schedulingThread \u003d new ContinuousSchedulingThread();\n       schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n       schedulingThread.setDaemon(true);\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    updateInterval \u003d this.conf.getUpdateInterval();\n    if (updateInterval \u003c 0) {\n      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n              + \" is invalid, so using default value \" +\n              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n              + \" ms instead\");\n    }\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n    // This stores per-application scheduling information\n    this.applications \u003d new ConcurrentHashMap\u003c\n        ApplicationId, SchedulerApplication\u003cFSAppAttempt\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new UpdateThread();\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new ContinuousSchedulingThread();\n      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "14864e9c7c879c15b5fa2d1776614ec83152918f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2352. FairScheduler: Collect metrics on duration of critical methods that affect performance. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616769 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 7:17 AM",
      "commitName": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "29/07/14 10:41 AM",
      "commitNameOld": "c0b49ff10728bb70bb60e6cb5973976f0466d247",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.86,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n   private synchronized void initScheduler(Configuration conf)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n         this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     preemptionUtilizationThreshold \u003d\n         this.conf.getPreemptionUtilizationThreshold();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n     updateInterval \u003d this.conf.getUpdateInterval();\n     if (updateInterval \u003c 0) {\n       updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n       LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n               + \" is invalid, so using default value \" +\n               + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n               + \" ms instead\");\n     }\n \n     rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n+    fsOpDurations \u003d FSOpDurations.getInstance(true);\n+\n     // This stores per-application scheduling information\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n     this.eventLog \u003d new FairSchedulerEventLog();\n     eventLog.init(this.conf);\n \n     allocConf \u003d new AllocationConfiguration(conf);\n     try {\n       queueMgr.initialize(conf);\n     } catch (Exception e) {\n       throw new IOException(\"Failed to start FairScheduler\", e);\n     }\n \n     updateThread \u003d new UpdateThread();\n     updateThread.setName(\"FairSchedulerUpdateThread\");\n     updateThread.setDaemon(true);\n \n     if (continuousSchedulingEnabled) {\n       // start continuous scheduling thread\n       schedulingThread \u003d new ContinuousSchedulingThread();\n       schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n       schedulingThread.setDaemon(true);\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    updateInterval \u003d this.conf.getUpdateInterval();\n    if (updateInterval \u003c 0) {\n      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n              + \" is invalid, so using default value \" +\n              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n              + \" ms instead\");\n    }\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    fsOpDurations \u003d FSOpDurations.getInstance(true);\n\n    // This stores per-application scheduling information\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new UpdateThread();\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new ContinuousSchedulingThread();\n      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "c0b49ff10728bb70bb60e6cb5973976f0466d247": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2328. FairScheduler: Verify update and continuous scheduling threads are stopped when the scheduler is stopped. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614432 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/14 10:41 AM",
      "commitName": "c0b49ff10728bb70bb60e6cb5973976f0466d247",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/07/14 10:00 PM",
      "commitNameOld": "c88402f36d4066b18310c1fd61469f71b8d8eb13",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 6.53,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,69 @@\n   private synchronized void initScheduler(Configuration conf)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n         this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     preemptionUtilizationThreshold \u003d\n         this.conf.getPreemptionUtilizationThreshold();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n     updateInterval \u003d this.conf.getUpdateInterval();\n     if (updateInterval \u003c 0) {\n       updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n       LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n               + \" is invalid, so using default value \" +\n               + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n               + \" ms instead\");\n     }\n \n     rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n     // This stores per-application scheduling information\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n     this.eventLog \u003d new FairSchedulerEventLog();\n     eventLog.init(this.conf);\n \n     allocConf \u003d new AllocationConfiguration(conf);\n     try {\n       queueMgr.initialize(conf);\n     } catch (Exception e) {\n       throw new IOException(\"Failed to start FairScheduler\", e);\n     }\n \n-    updateThread \u003d new Thread(new UpdateThread());\n+    updateThread \u003d new UpdateThread();\n     updateThread.setName(\"FairSchedulerUpdateThread\");\n     updateThread.setDaemon(true);\n \n     if (continuousSchedulingEnabled) {\n       // start continuous scheduling thread\n-      schedulingThread \u003d new Thread(\n-          new Runnable() {\n-            @Override\n-            public void run() {\n-              while (!Thread.currentThread().isInterrupted()) {\n-                try {\n-                  continuousSchedulingAttempt();\n-                  Thread.sleep(getContinuousSchedulingSleepMs());\n-                } catch (InterruptedException e) {\n-                  LOG.error(\"Continuous scheduling thread interrupted. Exiting. \",\n-                      e);\n-                  return;\n-                }\n-              }\n-            }\n-          }\n-      );\n-      schedulingThread.setName(\"ContinuousScheduling\");\n+      schedulingThread \u003d new ContinuousSchedulingThread();\n+      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n       schedulingThread.setDaemon(true);\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    updateInterval \u003d this.conf.getUpdateInterval();\n    if (updateInterval \u003c 0) {\n      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n              + \" is invalid, so using default value \" +\n              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n              + \" ms instead\");\n    }\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    // This stores per-application scheduling information\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new UpdateThread();\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new ContinuousSchedulingThread();\n      schedulingThread.setName(\"FairSchedulerContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "c88402f36d4066b18310c1fd61469f71b8d8eb13": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2313. Livelock can occur in FairScheduler when there are lots of running apps (Tsuyoshi Ozawa via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612769 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/14 10:00 PM",
      "commitName": "c88402f36d4066b18310c1fd61469f71b8d8eb13",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "22/07/14 3:44 PM",
      "commitNameOld": "ff7758299151e3b69c27314010b4ef3a9fda3b41",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,85 @@\n   private synchronized void initScheduler(Configuration conf)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n         this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     preemptionUtilizationThreshold \u003d\n         this.conf.getPreemptionUtilizationThreshold();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n+    updateInterval \u003d this.conf.getUpdateInterval();\n+    if (updateInterval \u003c 0) {\n+      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n+      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n+              + \" is invalid, so using default value \" +\n+              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n+              + \" ms instead\");\n+    }\n+\n     rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n     // This stores per-application scheduling information\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n     this.eventLog \u003d new FairSchedulerEventLog();\n     eventLog.init(this.conf);\n \n     allocConf \u003d new AllocationConfiguration(conf);\n     try {\n       queueMgr.initialize(conf);\n     } catch (Exception e) {\n       throw new IOException(\"Failed to start FairScheduler\", e);\n     }\n \n     updateThread \u003d new Thread(new UpdateThread());\n     updateThread.setName(\"FairSchedulerUpdateThread\");\n     updateThread.setDaemon(true);\n \n     if (continuousSchedulingEnabled) {\n       // start continuous scheduling thread\n       schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n               while (!Thread.currentThread().isInterrupted()) {\n                 try {\n                   continuousSchedulingAttempt();\n                   Thread.sleep(getContinuousSchedulingSleepMs());\n                 } catch (InterruptedException e) {\n                   LOG.error(\"Continuous scheduling thread interrupted. Exiting. \",\n                       e);\n                   return;\n                 }\n               }\n             }\n           }\n       );\n       schedulingThread.setName(\"ContinuousScheduling\");\n       schedulingThread.setDaemon(true);\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    updateInterval \u003d this.conf.getUpdateInterval();\n    if (updateInterval \u003c 0) {\n      updateInterval \u003d FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS;\n      LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS\n              + \" is invalid, so using default value \" +\n              + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS\n              + \" ms instead\");\n    }\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    // This stores per-application scheduling information\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new Thread(new UpdateThread());\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              while (!Thread.currentThread().isInterrupted()) {\n                try {\n                  continuousSchedulingAttempt();\n                  Thread.sleep(getContinuousSchedulingSleepMs());\n                } catch (InterruptedException e) {\n                  LOG.error(\"Continuous scheduling thread interrupted. Exiting. \",\n                      e);\n                  return;\n                }\n              }\n            }\n          }\n      );\n      schedulingThread.setName(\"ContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ff7758299151e3b69c27314010b4ef3a9fda3b41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2273. NPE in ContinuousScheduling thread when we lose a node. (Wei Yan via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/14 3:44 PM",
      "commitName": "ff7758299151e3b69c27314010b4ef3a9fda3b41",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "18/07/14 5:12 PM",
      "commitNameOld": "8871d8ed9fb1e4b21943477dcbaa13ef22ea7b8e",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 3.94,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,76 @@\n   private synchronized void initScheduler(Configuration conf)\n       throws IOException {\n     this.conf \u003d new FairSchedulerConfiguration(conf);\n     validateConf(this.conf);\n     minimumAllocation \u003d this.conf.getMinimumAllocation();\n     maximumAllocation \u003d this.conf.getMaximumAllocation();\n     incrAllocation \u003d this.conf.getIncrementAllocation();\n     continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n     continuousSchedulingSleepMs \u003d\n         this.conf.getContinuousSchedulingSleepMs();\n     nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n     rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n     nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n     rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n     preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n     preemptionUtilizationThreshold \u003d\n         this.conf.getPreemptionUtilizationThreshold();\n     assignMultiple \u003d this.conf.getAssignMultiple();\n     maxAssign \u003d this.conf.getMaxAssign();\n     sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n     preemptionInterval \u003d this.conf.getPreemptionInterval();\n     waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n     usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n \n     rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n     // This stores per-application scheduling information\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n     this.eventLog \u003d new FairSchedulerEventLog();\n     eventLog.init(this.conf);\n \n     allocConf \u003d new AllocationConfiguration(conf);\n     try {\n       queueMgr.initialize(conf);\n     } catch (Exception e) {\n       throw new IOException(\"Failed to start FairScheduler\", e);\n     }\n \n     updateThread \u003d new Thread(new UpdateThread());\n     updateThread.setName(\"FairSchedulerUpdateThread\");\n     updateThread.setDaemon(true);\n \n     if (continuousSchedulingEnabled) {\n       // start continuous scheduling thread\n       schedulingThread \u003d new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n-              continuousScheduling();\n+              while (!Thread.currentThread().isInterrupted()) {\n+                try {\n+                  continuousSchedulingAttempt();\n+                  Thread.sleep(getContinuousSchedulingSleepMs());\n+                } catch (InterruptedException e) {\n+                  LOG.error(\"Continuous scheduling thread interrupted. Exiting. \",\n+                      e);\n+                  return;\n+                }\n+              }\n             }\n           }\n       );\n       schedulingThread.setName(\"ContinuousScheduling\");\n       schedulingThread.setDaemon(true);\n     }\n \n     allocsLoader.init(conf);\n     allocsLoader.setReloadListener(new AllocationReloadListener());\n     // If we fail to load allocations file on initialize, we want to fail\n     // immediately.  After a successful load, exceptions on future reloads\n     // will just result in leaving things as they are.\n     try {\n       allocsLoader.reloadAllocations();\n     } catch (Exception e) {\n       throw new IOException(\"Failed to initialize FairScheduler\", e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    // This stores per-application scheduling information\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new Thread(new UpdateThread());\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              while (!Thread.currentThread().isInterrupted()) {\n                try {\n                  continuousSchedulingAttempt();\n                  Thread.sleep(getContinuousSchedulingSleepMs());\n                } catch (InterruptedException e) {\n                  LOG.error(\"Continuous scheduling thread interrupted. Exiting. \",\n                      e);\n                  return;\n                }\n              }\n            }\n          }\n      );\n      schedulingThread.setName(\"ContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a4ba451802c6c61a0c804809740d46dd76059f25": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1474. Make schedulers services. (Tsuyoshi Ozawa via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598908 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/14 12:33 PM",
      "commitName": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,67 @@\n+  private synchronized void initScheduler(Configuration conf)\n+      throws IOException {\n+    this.conf \u003d new FairSchedulerConfiguration(conf);\n+    validateConf(this.conf);\n+    minimumAllocation \u003d this.conf.getMinimumAllocation();\n+    maximumAllocation \u003d this.conf.getMaximumAllocation();\n+    incrAllocation \u003d this.conf.getIncrementAllocation();\n+    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n+    continuousSchedulingSleepMs \u003d\n+        this.conf.getContinuousSchedulingSleepMs();\n+    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n+    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n+    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n+    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n+    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n+    preemptionUtilizationThreshold \u003d\n+        this.conf.getPreemptionUtilizationThreshold();\n+    assignMultiple \u003d this.conf.getAssignMultiple();\n+    maxAssign \u003d this.conf.getMaxAssign();\n+    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n+    preemptionInterval \u003d this.conf.getPreemptionInterval();\n+    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n+    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+\n+    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n+    // This stores per-application scheduling information\n+    this.applications \u003d\n+        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n+    this.eventLog \u003d new FairSchedulerEventLog();\n+    eventLog.init(this.conf);\n+\n+    allocConf \u003d new AllocationConfiguration(conf);\n+    try {\n+      queueMgr.initialize(conf);\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to start FairScheduler\", e);\n+    }\n+\n+    updateThread \u003d new Thread(new UpdateThread());\n+    updateThread.setName(\"FairSchedulerUpdateThread\");\n+    updateThread.setDaemon(true);\n+\n+    if (continuousSchedulingEnabled) {\n+      // start continuous scheduling thread\n+      schedulingThread \u003d new Thread(\n+          new Runnable() {\n+            @Override\n+            public void run() {\n+              continuousScheduling();\n+            }\n+          }\n+      );\n+      schedulingThread.setName(\"ContinuousScheduling\");\n+      schedulingThread.setDaemon(true);\n+    }\n+\n+    allocsLoader.init(conf);\n+    allocsLoader.setReloadListener(new AllocationReloadListener());\n+    // If we fail to load allocations file on initialize, we want to fail\n+    // immediately.  After a successful load, exceptions on future reloads\n+    // will just result in leaving things as they are.\n+    try {\n+      allocsLoader.reloadAllocations();\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to initialize FairScheduler\", e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration conf)\n      throws IOException {\n    this.conf \u003d new FairSchedulerConfiguration(conf);\n    validateConf(this.conf);\n    minimumAllocation \u003d this.conf.getMinimumAllocation();\n    maximumAllocation \u003d this.conf.getMaximumAllocation();\n    incrAllocation \u003d this.conf.getIncrementAllocation();\n    continuousSchedulingEnabled \u003d this.conf.isContinuousSchedulingEnabled();\n    continuousSchedulingSleepMs \u003d\n        this.conf.getContinuousSchedulingSleepMs();\n    nodeLocalityThreshold \u003d this.conf.getLocalityThresholdNode();\n    rackLocalityThreshold \u003d this.conf.getLocalityThresholdRack();\n    nodeLocalityDelayMs \u003d this.conf.getLocalityDelayNodeMs();\n    rackLocalityDelayMs \u003d this.conf.getLocalityDelayRackMs();\n    preemptionEnabled \u003d this.conf.getPreemptionEnabled();\n    preemptionUtilizationThreshold \u003d\n        this.conf.getPreemptionUtilizationThreshold();\n    assignMultiple \u003d this.conf.getAssignMultiple();\n    maxAssign \u003d this.conf.getMaxAssign();\n    sizeBasedWeight \u003d this.conf.getSizeBasedWeight();\n    preemptionInterval \u003d this.conf.getPreemptionInterval();\n    waitTimeBeforeKill \u003d this.conf.getWaitTimeBeforeKill();\n    usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n\n    rootMetrics \u003d FSQueueMetrics.forQueue(\"root\", null, true, conf);\n    // This stores per-application scheduling information\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,SchedulerApplication\u003cFSSchedulerApp\u003e\u003e();\n    this.eventLog \u003d new FairSchedulerEventLog();\n    eventLog.init(this.conf);\n\n    allocConf \u003d new AllocationConfiguration(conf);\n    try {\n      queueMgr.initialize(conf);\n    } catch (Exception e) {\n      throw new IOException(\"Failed to start FairScheduler\", e);\n    }\n\n    updateThread \u003d new Thread(new UpdateThread());\n    updateThread.setName(\"FairSchedulerUpdateThread\");\n    updateThread.setDaemon(true);\n\n    if (continuousSchedulingEnabled) {\n      // start continuous scheduling thread\n      schedulingThread \u003d new Thread(\n          new Runnable() {\n            @Override\n            public void run() {\n              continuousScheduling();\n            }\n          }\n      );\n      schedulingThread.setName(\"ContinuousScheduling\");\n      schedulingThread.setDaemon(true);\n    }\n\n    allocsLoader.init(conf);\n    allocsLoader.setReloadListener(new AllocationReloadListener());\n    // If we fail to load allocations file on initialize, we want to fail\n    // immediately.  After a successful load, exceptions on future reloads\n    // will just result in leaving things as they are.\n    try {\n      allocsLoader.reloadAllocations();\n    } catch (Exception e) {\n      throw new IOException(\"Failed to initialize FairScheduler\", e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}