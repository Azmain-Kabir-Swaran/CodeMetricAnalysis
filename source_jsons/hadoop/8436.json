{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirAttrOp.java",
  "functionName": "unprotectedSetReplication",
  "functionId": "unprotectedSetReplication___fsd-FSDirectory__iip-INodesInPath__replication-short",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
  "functionStartLine": 367,
  "functionEndLine": 414,
  "numCommitsSeen": 294,
  "timeTaken": 11446,
  "changeHistory": [
    "9122b9b6493d315c8910fbc06eaba96273ee335c",
    "a78db9919065d06ced8122229530f44cc7369857",
    "48b9d5fd2a96728b1118be217ca597c4098e99ca",
    "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6",
    "ddf4e785475affead2f7c070b9f151de0fcb9024",
    "745d04be59accf80feda0ad38efcc74ba362f2ca",
    "6e3fcffe291faec40fa9214f4880a35a952836c4",
    "6d5da9484185ca9f585195d6da069b9cd5be4044",
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
    "f2231cebcddc80f0b753c4a7cb45ee4040846951",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f",
    "0689363343a281a6f7f6f395227668bddc2663eb",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795"
  ],
  "changeHistoryShort": {
    "9122b9b6493d315c8910fbc06eaba96273ee335c": "Ybodychange",
    "a78db9919065d06ced8122229530f44cc7369857": "Ybodychange",
    "48b9d5fd2a96728b1118be217ca597c4098e99ca": "Ymultichange(Yparameterchange,Ybodychange)",
    "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6": "Ybodychange",
    "ddf4e785475affead2f7c070b9f151de0fcb9024": "Ybodychange",
    "745d04be59accf80feda0ad38efcc74ba362f2ca": "Ymultichange(Yparameterchange,Ybodychange)",
    "6e3fcffe291faec40fa9214f4880a35a952836c4": "Yreturntypechange",
    "6d5da9484185ca9f585195d6da069b9cd5be4044": "Ybodychange",
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f": "Ybodychange",
    "f2231cebcddc80f0b753c4a7cb45ee4040846951": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": "Ybodychange",
    "0689363343a281a6f7f6f395227668bddc2663eb": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange"
  },
  "changeHistoryDetails": {
    "9122b9b6493d315c8910fbc06eaba96273ee335c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14521. Suppress setReplication logging. Contributed by Kihwal Lee\n",
      "commitDate": "30/05/19 3:28 PM",
      "commitName": "9122b9b6493d315c8910fbc06eaba96273ee335c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/02/19 11:06 AM",
      "commitNameOld": "f4ae00c5301c0dd8923783ac6dca2d296c289254",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 94.14,
      "commitsBetweenForRepo": 635,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static BlockInfo[] unprotectedSetReplication(\n       FSDirectory fsd, INodesInPath iip, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n       // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n \n     INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n     long size \u003d file.computeFileSize(true, true);\n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n     if (oldBR \u003e replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n     }\n     for (BlockInfo b : file.getBlocks()) {\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n-        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n+        FSDirectory.LOG.debug(\"Decreasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, iip.getPath());\n       } else if (oldBR \u003c targetReplication) {\n-        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n+        FSDirectory.LOG.debug(\"Increasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, iip.getPath());\n       } else {\n-        FSDirectory.LOG.info(\"Replication remains unchanged at {} for {}\",\n+        FSDirectory.LOG.debug(\"Replication remains unchanged at {} for {}\",\n                              oldBR, iip.getPath());\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, INodesInPath iip, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    long size \u003d file.computeFileSize(true, true);\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    if (oldBR \u003e replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n    }\n    for (BlockInfo b : file.getBlocks()) {\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.debug(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else if (oldBR \u003c targetReplication) {\n        FSDirectory.LOG.debug(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else {\n        FSDirectory.LOG.debug(\"Replication remains unchanged at {} for {}\",\n                             oldBR, iip.getPath());\n      }\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "a78db9919065d06ced8122229530f44cc7369857": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12932. Fix confusing LOG message for block replication. Contributed by Chao Sun.\n",
      "commitDate": "20/12/17 8:55 AM",
      "commitName": "a78db9919065d06ced8122229530f44cc7369857",
      "commitAuthor": "Wei Yan",
      "commitDateOld": "29/08/17 4:57 PM",
      "commitNameOld": "cf93d60d3f032000e5b78a08d320793d78799f3d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 112.71,
      "commitsBetweenForRepo": 989,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,48 @@\n   static BlockInfo[] unprotectedSetReplication(\n       FSDirectory fsd, INodesInPath iip, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n       // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n \n     INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n     long size \u003d file.computeFileSize(true, true);\n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n     if (oldBR \u003e replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n     }\n     for (BlockInfo b : file.getBlocks()) {\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n         FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, iip.getPath());\n-      } else {\n+      } else if (oldBR \u003c targetReplication) {\n         FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, iip.getPath());\n+      } else {\n+        FSDirectory.LOG.info(\"Replication remains unchanged at {} for {}\",\n+                             oldBR, iip.getPath());\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, INodesInPath iip, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    long size \u003d file.computeFileSize(true, true);\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    if (oldBR \u003e replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n    }\n    for (BlockInfo b : file.getBlocks()) {\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else if (oldBR \u003c targetReplication) {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else {\n        FSDirectory.LOG.info(\"Replication remains unchanged at {} for {}\",\n                             oldBR, iip.getPath());\n      }\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "48b9d5fd2a96728b1118be217ca597c4098e99ca": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10955. Pass IIP for FSDirAttr methods. Contributed by Daryn Sharp.\n",
      "commitDate": "06/10/16 2:33 PM",
      "commitName": "48b9d5fd2a96728b1118be217ca597c4098e99ca",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10955. Pass IIP for FSDirAttr methods. Contributed by Daryn Sharp.\n",
          "commitDate": "06/10/16 2:33 PM",
          "commitName": "48b9d5fd2a96728b1118be217ca597c4098e99ca",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "23/09/16 10:37 AM",
          "commitNameOld": "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 13.16,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,45 @@\n   static BlockInfo[] unprotectedSetReplication(\n-      FSDirectory fsd, String src, short replication)\n+      FSDirectory fsd, INodesInPath iip, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n-    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n       // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n \n     INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n     long size \u003d file.computeFileSize(true, true);\n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n     if (oldBR \u003e replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n     }\n     for (BlockInfo b : file.getBlocks()) {\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n         FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n-                             oldBR, targetReplication, src);\n+                             oldBR, targetReplication, iip.getPath());\n       } else {\n         FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n-                             oldBR, targetReplication, src);\n+                             oldBR, targetReplication, iip.getPath());\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, INodesInPath iip, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    long size \u003d file.computeFileSize(true, true);\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    if (oldBR \u003e replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n    }\n    for (BlockInfo b : file.getBlocks()) {\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      }\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, replication-short]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, replication-short]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10955. Pass IIP for FSDirAttr methods. Contributed by Daryn Sharp.\n",
          "commitDate": "06/10/16 2:33 PM",
          "commitName": "48b9d5fd2a96728b1118be217ca597c4098e99ca",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "23/09/16 10:37 AM",
          "commitNameOld": "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 13.16,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,45 @@\n   static BlockInfo[] unprotectedSetReplication(\n-      FSDirectory fsd, String src, short replication)\n+      FSDirectory fsd, INodesInPath iip, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n-    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n       // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n \n     INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n     long size \u003d file.computeFileSize(true, true);\n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n     if (oldBR \u003e replication) {\n       fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n     }\n     for (BlockInfo b : file.getBlocks()) {\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n         FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n-                             oldBR, targetReplication, src);\n+                             oldBR, targetReplication, iip.getPath());\n       } else {\n         FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n-                             oldBR, targetReplication, src);\n+                             oldBR, targetReplication, iip.getPath());\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, INodesInPath iip, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    long size \u003d file.computeFileSize(true, true);\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    if (oldBR \u003e replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n    }\n    for (BlockInfo b : file.getBlocks()) {\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, iip.getPath());\n      }\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10843. Update space quota when a UC block is completed rather than committed. Contributed by Erik Krogen.",
      "commitDate": "23/09/16 10:37 AM",
      "commitName": "a5bb88c8e0fd4bd19b6d377fecbe1d2d441514f6",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "19/08/16 7:12 AM",
      "commitNameOld": "2550371f66c49fe0e40aadaa68744311270084ce",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 35.14,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,46 @@\n   static BlockInfo[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n       // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n \n     INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n+    long size \u003d file.computeFileSize(true, true);\n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n-      long size \u003d file.computeFileSize(true, true);\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n+    if (oldBR \u003e replication) {\n+      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n+    }\n     for (BlockInfo b : file.getBlocks()) {\n-      if (oldBR \u003d\u003d targetReplication) {\n-        continue;\n-      }\n-      if (oldBR \u003e replication) {\n-        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n-                        true);\n-      }\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n         FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, src);\n       } else {\n         FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, src);\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    long size \u003d file.computeFileSize(true, true);\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    if (oldBR \u003e replication) {\n      fsd.updateCount(iip, 0L, size, oldBR, targetReplication, true);\n    }\n    for (BlockInfo b : file.getBlocks()) {\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      }\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "ddf4e785475affead2f7c070b9f151de0fcb9024": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8937. Erasure coding: do not throw exception when setting replication factor on EC files. Contributed by Gao Rui.\n",
      "commitDate": "02/09/15 11:45 AM",
      "commitName": "ddf4e785475affead2f7c070b9f151de0fcb9024",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "01/09/15 2:30 PM",
      "commitNameOld": "ab56fcdb1219d03713b408dd3a95d7405635254d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,50 @@\n   static BlockInfo[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n       SnapshotAccessControlException, UnsupportedActionException {\n     assert fsd.hasWriteLock();\n \n     final BlockManager bm \u003d fsd.getBlockManager();\n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n-    if (inode \u003d\u003d null || !inode.isFile()) {\n+    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n+      // TODO we do not support replication on stripe layout files yet\n       return null;\n     }\n-    INodeFile file \u003d inode.asFile();\n-    if (file.isStriped()) {\n-      throw new UnsupportedActionException(\n-          \"Cannot set replication to a file with striped blocks\");\n-    }\n \n+    INodeFile file \u003d inode.asFile();\n     // Make sure the directory has sufficient quotas\n     short oldBR \u003d file.getPreferredBlockReplication();\n \n     // Ensure the quota does not exceed\n     if (oldBR \u003c replication) {\n       long size \u003d file.computeFileSize(true, true);\n       fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n     short targetReplication \u003d (short) Math.max(\n         replication, file.getPreferredBlockReplication());\n \n     for (BlockInfo b : file.getBlocks()) {\n       if (oldBR \u003d\u003d targetReplication) {\n         continue;\n       }\n       if (oldBR \u003e replication) {\n         fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n                         true);\n       }\n       bm.setReplication(oldBR, targetReplication, b);\n     }\n \n     if (oldBR !\u003d -1) {\n       if (oldBR \u003e targetReplication) {\n         FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, src);\n       } else {\n         FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                              oldBR, targetReplication, src);\n       }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n      SnapshotAccessControlException, UnsupportedActionException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile() || inode.asFile().isStriped()) {\n      // TODO we do not support replication on stripe layout files yet\n      return null;\n    }\n\n    INodeFile file \u003d inode.asFile();\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      long size \u003d file.computeFileSize(true, true);\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    for (BlockInfo b : file.getBlocks()) {\n      if (oldBR \u003d\u003d targetReplication) {\n        continue;\n      }\n      if (oldBR \u003e replication) {\n        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n                        true);\n      }\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      }\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "745d04be59accf80feda0ad38efcc74ba362f2ca": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
      "commitDate": "22/08/15 12:09 AM",
      "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
          "commitDate": "22/08/15 12:09 AM",
          "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "05/08/15 10:40 PM",
          "commitNameOld": "cc71ad80e184fc6e5043729e8cfcf6a62ca3e71f",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 16.06,
          "commitsBetweenForRepo": 79,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,49 @@\n   static BlockInfo[] unprotectedSetReplication(\n-      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      FSDirectory fsd, String src, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n+    final BlockManager bm \u003d fsd.getBlockManager();\n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n-    final short oldBR \u003d file.getPreferredBlockReplication();\n \n-    // before setFileReplication, check for increasing block replication.\n-    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n-    if (replication \u003e oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n-      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n+    // Make sure the directory has sufficient quotas\n+    short oldBR \u003d file.getPreferredBlockReplication();\n+\n+    // Ensure the quota does not exceed\n+    if (oldBR \u003c replication) {\n+      long size \u003d file.computeFileSize(true, true);\n+      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n+    short targetReplication \u003d (short) Math.max(\n+        replication, file.getPreferredBlockReplication());\n \n-    final short newBR \u003d file.getPreferredBlockReplication();\n-    // check newBR \u003c oldBR case.\n-    if (newBR \u003c oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n-      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n+    for (BlockInfo b : file.getBlocks()) {\n+      if (oldBR \u003d\u003d targetReplication) {\n+        continue;\n+      }\n+      if (oldBR \u003e replication) {\n+        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n+                        true);\n+      }\n+      bm.setReplication(oldBR, targetReplication, b);\n     }\n \n-    if (blockRepls !\u003d null) {\n-      blockRepls[0] \u003d oldBR;\n-      blockRepls[1] \u003d newBR;\n+    if (oldBR !\u003d -1) {\n+      if (oldBR \u003e targetReplication) {\n+        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n+                             oldBR, targetReplication, src);\n+      } else {\n+        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n+                             oldBR, targetReplication, src);\n+      }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      long size \u003d file.computeFileSize(true, true);\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    for (BlockInfo b : file.getBlocks()) {\n      if (oldBR \u003d\u003d targetReplication) {\n        continue;\n      }\n      if (oldBR \u003e replication) {\n        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n                        true);\n      }\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      }\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, src-String, replication-short, blockRepls-short[]]",
            "newValue": "[fsd-FSDirectory, src-String, replication-short]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
          "commitDate": "22/08/15 12:09 AM",
          "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "05/08/15 10:40 PM",
          "commitNameOld": "cc71ad80e184fc6e5043729e8cfcf6a62ca3e71f",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 16.06,
          "commitsBetweenForRepo": 79,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,49 @@\n   static BlockInfo[] unprotectedSetReplication(\n-      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      FSDirectory fsd, String src, short replication)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n+    final BlockManager bm \u003d fsd.getBlockManager();\n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n-    final short oldBR \u003d file.getPreferredBlockReplication();\n \n-    // before setFileReplication, check for increasing block replication.\n-    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n-    if (replication \u003e oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n-      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n+    // Make sure the directory has sufficient quotas\n+    short oldBR \u003d file.getPreferredBlockReplication();\n+\n+    // Ensure the quota does not exceed\n+    if (oldBR \u003c replication) {\n+      long size \u003d file.computeFileSize(true, true);\n+      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n+    short targetReplication \u003d (short) Math.max(\n+        replication, file.getPreferredBlockReplication());\n \n-    final short newBR \u003d file.getPreferredBlockReplication();\n-    // check newBR \u003c oldBR case.\n-    if (newBR \u003c oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n-      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n+    for (BlockInfo b : file.getBlocks()) {\n+      if (oldBR \u003d\u003d targetReplication) {\n+        continue;\n+      }\n+      if (oldBR \u003e replication) {\n+        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n+                        true);\n+      }\n+      bm.setReplication(oldBR, targetReplication, b);\n     }\n \n-    if (blockRepls !\u003d null) {\n-      blockRepls[0] \u003d oldBR;\n-      blockRepls[1] \u003d newBR;\n+    if (oldBR !\u003d -1) {\n+      if (oldBR \u003e targetReplication) {\n+        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n+                             oldBR, targetReplication, src);\n+      } else {\n+        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n+                             oldBR, targetReplication, src);\n+      }\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final BlockManager bm \u003d fsd.getBlockManager();\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n\n    // Make sure the directory has sufficient quotas\n    short oldBR \u003d file.getPreferredBlockReplication();\n\n    // Ensure the quota does not exceed\n    if (oldBR \u003c replication) {\n      long size \u003d file.computeFileSize(true, true);\n      fsd.updateCount(iip, 0L, size, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    short targetReplication \u003d (short) Math.max(\n        replication, file.getPreferredBlockReplication());\n\n    for (BlockInfo b : file.getBlocks()) {\n      if (oldBR \u003d\u003d targetReplication) {\n        continue;\n      }\n      if (oldBR \u003e replication) {\n        fsd.updateCount(iip, 0L, b.getNumBytes(), oldBR, targetReplication,\n                        true);\n      }\n      bm.setReplication(oldBR, targetReplication, b);\n    }\n\n    if (oldBR !\u003d -1) {\n      if (oldBR \u003e targetReplication) {\n        FSDirectory.LOG.info(\"Decreasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      } else {\n        FSDirectory.LOG.info(\"Increasing replication from {} to {} for {}\",\n                             oldBR, targetReplication, src);\n      }\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "6e3fcffe291faec40fa9214f4880a35a952836c4": {
      "type": "Yreturntypechange",
      "commitMessage": "HDFS-8608. Merge HDFS-7912 to trunk and branch-2 (track BlockInfo instead of Block in UnderReplicatedBlocks and PendingReplicationBlocks). Contributed by Zhe Zhang.\n",
      "commitDate": "17/06/15 8:05 AM",
      "commitName": "6e3fcffe291faec40fa9214f4880a35a952836c4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "12/05/15 6:29 AM",
      "commitNameOld": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 36.07,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n-  static Block[] unprotectedSetReplication(\n+  static BlockInfo[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication, short[] blockRepls)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getPreferredBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n \n     final short newBR \u003d file.getPreferredBlockReplication();\n     // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static BlockInfo[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getPreferredBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getPreferredBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {
        "oldValue": "Block[]",
        "newValue": "BlockInfo[]"
      }
    },
    "6d5da9484185ca9f585195d6da069b9cd5be4044": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8255. Rename getBlockReplication to getPreferredBlockReplication. (Contributed by Zhe Zhang)\n",
      "commitDate": "12/05/15 6:29 AM",
      "commitName": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthor": "yliu",
      "commitDateOld": "08/05/15 11:09 PM",
      "commitNameOld": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.31,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   static Block[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication, short[] blockRepls)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n-    final short oldBR \u003d file.getBlockReplication();\n+    final short oldBR \u003d file.getPreferredBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n \n-    final short newBR \u003d file.getBlockReplication();\n+    final short newBR \u003d file.getPreferredBlockReplication();\n     // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getPreferredBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getPreferredBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8327. Compute storage type quotas in INodeFile.computeQuotaDeltaForTruncate(). Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:09 PM",
      "commitName": "02a4a22b9c0e22c2e7dd6ec85edd5c5a167fe19f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 76.27,
      "commitsBetweenForRepo": 733,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   static Block[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication, short[] blockRepls)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed()/oldBR;\n+      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n \n     final short newBR \u003d file.getBlockReplication();\n     // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n-      long dsDelta \u003d file.storagespaceConsumed()/newBR;\n+      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / oldBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed(null).getStorageSpace() / newBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "f2231cebcddc80f0b753c4a7cb45ee4040846951": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7775. Use consistent naming for NN-internal quota related types and functions. (Contributed bu Xiaoyu Yao)\n",
      "commitDate": "13/02/15 9:01 PM",
      "commitName": "f2231cebcddc80f0b753c4a7cb45ee4040846951",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "11/02/15 10:41 AM",
      "commitNameOld": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   static Block[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication, short[] blockRepls)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n-      long dsDelta \u003d file.diskspaceConsumed()/oldBR;\n+      long dsDelta \u003d file.storagespaceConsumed()/oldBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n \n     final short newBR \u003d file.getBlockReplication();\n     // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n-      long dsDelta \u003d file.diskspaceConsumed()/newBR;\n+      long dsDelta \u003d file.storagespaceConsumed()/newBR;\n       fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed()/oldBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d file.storagespaceConsumed()/newBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 54.97,
      "commitsBetweenForRepo": 369,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   static Block[] unprotectedSetReplication(\n       FSDirectory fsd, String src, short replication, short[] blockRepls)\n       throws QuotaExceededException, UnresolvedLinkException,\n              SnapshotAccessControlException {\n     assert fsd.hasWriteLock();\n \n     final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n-      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n-      fsd.updateCount(iip, 0, dsDelta, true);\n+      long dsDelta \u003d file.diskspaceConsumed()/oldBR;\n+      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n \n     final short newBR \u003d file.getBlockReplication();\n     // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n-      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n-      fsd.updateCount(iip, 0, dsDelta, true);\n+      long dsDelta \u003d file.diskspaceConsumed()/newBR;\n+      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d file.diskspaceConsumed()/oldBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, replication, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d file.diskspaceConsumed()/newBR;\n      fsd.updateCount(iip, 0L, dsDelta, oldBR, newBR, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
      "extendedDetails": {}
    },
    "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7506. Consolidate implementation of setting inode attributes into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "15/12/14 10:40 AM",
      "commitName": "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7506. Consolidate implementation of setting inode attributes into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "15/12/14 10:40 AM",
          "commitName": "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/12/14 10:30 AM",
          "commitNameOld": "6e13fc62e1f284f22fd0089f06ce281198bc7c2a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  Block[] unprotectedSetReplication(String src, short replication,\n-      short[] blockRepls) throws QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException {\n-    assert hasWriteLock();\n+  static Block[] unprotectedSetReplication(\n+      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      throws QuotaExceededException, UnresolvedLinkException,\n+             SnapshotAccessControlException {\n+    assert fsd.hasWriteLock();\n \n-    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n+    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n+    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n-    \n-    final short newBR \u003d file.getBlockReplication(); \n-    // check newBR \u003c oldBR case. \n+\n+    final short newBR \u003d file.getBlockReplication();\n+    // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
            "oldMethodName": "unprotectedSetReplication",
            "newMethodName": "unprotectedSetReplication"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7506. Consolidate implementation of setting inode attributes into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "15/12/14 10:40 AM",
          "commitName": "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/12/14 10:30 AM",
          "commitNameOld": "6e13fc62e1f284f22fd0089f06ce281198bc7c2a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  Block[] unprotectedSetReplication(String src, short replication,\n-      short[] blockRepls) throws QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException {\n-    assert hasWriteLock();\n+  static Block[] unprotectedSetReplication(\n+      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      throws QuotaExceededException, UnresolvedLinkException,\n+             SnapshotAccessControlException {\n+    assert fsd.hasWriteLock();\n \n-    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n+    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n+    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n-    \n-    final short newBR \u003d file.getBlockReplication(); \n-    // check newBR \u003c oldBR case. \n+\n+    final short newBR \u003d file.getBlockReplication();\n+    // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7506. Consolidate implementation of setting inode attributes into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "15/12/14 10:40 AM",
          "commitName": "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/12/14 10:30 AM",
          "commitNameOld": "6e13fc62e1f284f22fd0089f06ce281198bc7c2a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  Block[] unprotectedSetReplication(String src, short replication,\n-      short[] blockRepls) throws QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException {\n-    assert hasWriteLock();\n+  static Block[] unprotectedSetReplication(\n+      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      throws QuotaExceededException, UnresolvedLinkException,\n+             SnapshotAccessControlException {\n+    assert fsd.hasWriteLock();\n \n-    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n+    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n+    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n-    \n-    final short newBR \u003d file.getBlockReplication(); \n-    // check newBR \u003c oldBR case. \n+\n+    final short newBR \u003d file.getBlockReplication();\n+    // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7506. Consolidate implementation of setting inode attributes into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "15/12/14 10:40 AM",
          "commitName": "832ebd8cb63d91b4aa4bfed412b9799b3b9be4a7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/12/14 10:30 AM",
          "commitNameOld": "6e13fc62e1f284f22fd0089f06ce281198bc7c2a",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  Block[] unprotectedSetReplication(String src, short replication,\n-      short[] blockRepls) throws QuotaExceededException,\n-      UnresolvedLinkException, SnapshotAccessControlException {\n-    assert hasWriteLock();\n+  static Block[] unprotectedSetReplication(\n+      FSDirectory fsd, String src, short replication, short[] blockRepls)\n+      throws QuotaExceededException, UnresolvedLinkException,\n+             SnapshotAccessControlException {\n+    assert fsd.hasWriteLock();\n \n-    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n+    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n-    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n+    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     file.setFileReplication(replication, iip.getLatestSnapshotId());\n-    \n-    final short newBR \u003d file.getBlockReplication(); \n-    // check newBR \u003c oldBR case. \n+\n+    final short newBR \u003d file.getBlockReplication();\n+    // check newBR \u003c oldBR case.\n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n-      updateCount(iip, 0, dsDelta, true);\n+      fsd.updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static Block[] unprotectedSetReplication(\n      FSDirectory fsd, String src, short replication, short[] blockRepls)\n      throws QuotaExceededException, UnresolvedLinkException,\n             SnapshotAccessControlException {\n    assert fsd.hasWriteLock();\n\n    final INodesInPath iip \u003d fsd.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet.\n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n\n    final short newBR \u003d file.getBlockReplication();\n    // check newBR \u003c oldBR case.\n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      fsd.updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAttrOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, replication-short, blockRepls-short[]]",
            "newValue": "[fsd-FSDirectory, src-String, replication-short, blockRepls-short[]]"
          }
        }
      ]
    },
    "80691b073fe7c104a8684c0a8900a1657bcdc03f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6838. Code cleanup for unnecessary INode replacement. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617361 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 2:28 PM",
      "commitName": "80691b073fe7c104a8684c0a8900a1657bcdc03f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "04/08/14 8:44 AM",
      "commitNameOld": "431857d09dac2a9554f7ee8a6a92ae05844d0066",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 7.24,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,36 @@\n   Block[] unprotectedSetReplication(String src, short replication,\n       short[] blockRepls) throws QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException {\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet. \n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n-    file \u003d file.setFileReplication(replication, iip.getLatestSnapshotId(),\n-        inodeMap);\n+    file.setFileReplication(replication, iip.getLatestSnapshotId());\n     \n     final short newBR \u003d file.getBlockReplication(); \n     // check newBR \u003c oldBR case. \n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block[] unprotectedSetReplication(String src, short replication,\n      short[] blockRepls) throws QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException {\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    file.setFileReplication(replication, iip.getLatestSnapshotId());\n    \n    final short newBR \u003d file.getBlockReplication(); \n    // check newBR \u003c oldBR case. \n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0689363343a281a6f7f6f395227668bddc2663eb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/14 10:44 AM",
      "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/04/14 7:05 PM",
      "commitNameOld": "10a037cccb00c9f791da394bf2dc05985fb80612",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   Block[] unprotectedSetReplication(String src, short replication,\n       short[] blockRepls) throws QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException {\n     assert hasWriteLock();\n \n-    final INodesInPath iip \u003d rootDir.getINodesInPath4Write(src, true);\n+    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet. \n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n     file \u003d file.setFileReplication(replication, iip.getLatestSnapshotId(),\n         inodeMap);\n     \n     final short newBR \u003d file.getBlockReplication(); \n     // check newBR \u003c oldBR case. \n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block[] unprotectedSetReplication(String src, short replication,\n      short[] blockRepls) throws QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException {\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    file \u003d file.setFileReplication(replication, iip.getLatestSnapshotId(),\n        inodeMap);\n    \n    final short newBR \u003d file.getBlockReplication(); \n    // check newBR \u003c oldBR case. \n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   Block[] unprotectedSetReplication(String src, short replication,\n       short[] blockRepls) throws QuotaExceededException,\n       UnresolvedLinkException, SnapshotAccessControlException {\n     assert hasWriteLock();\n \n     final INodesInPath iip \u003d rootDir.getINodesInPath4Write(src, true);\n     final INode inode \u003d iip.getLastINode();\n     if (inode \u003d\u003d null || !inode.isFile()) {\n       return null;\n     }\n     INodeFile file \u003d inode.asFile();\n     final short oldBR \u003d file.getBlockReplication();\n \n     // before setFileReplication, check for increasing block replication.\n     // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n     // if replication \u003c oldBR, we don\u0027t know newBR yet. \n     if (replication \u003e oldBR) {\n       long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n-    file \u003d file.setFileReplication(replication, iip.getLatestSnapshot(),\n+    file \u003d file.setFileReplication(replication, iip.getLatestSnapshotId(),\n         inodeMap);\n     \n     final short newBR \u003d file.getBlockReplication(); \n     // check newBR \u003c oldBR case. \n     if (newBR \u003c oldBR) {\n       long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n       updateCount(iip, 0, dsDelta, true);\n     }\n \n     if (blockRepls !\u003d null) {\n       blockRepls[0] \u003d oldBR;\n       blockRepls[1] \u003d newBR;\n     }\n     return file.getBlocks();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Block[] unprotectedSetReplication(String src, short replication,\n      short[] blockRepls) throws QuotaExceededException,\n      UnresolvedLinkException, SnapshotAccessControlException {\n    assert hasWriteLock();\n\n    final INodesInPath iip \u003d rootDir.getINodesInPath4Write(src, true);\n    final INode inode \u003d iip.getLastINode();\n    if (inode \u003d\u003d null || !inode.isFile()) {\n      return null;\n    }\n    INodeFile file \u003d inode.asFile();\n    final short oldBR \u003d file.getBlockReplication();\n\n    // before setFileReplication, check for increasing block replication.\n    // if replication \u003e oldBR, then newBR \u003d\u003d replication.\n    // if replication \u003c oldBR, we don\u0027t know newBR yet. \n    if (replication \u003e oldBR) {\n      long dsDelta \u003d (replication - oldBR)*(file.diskspaceConsumed()/oldBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    file \u003d file.setFileReplication(replication, iip.getLatestSnapshotId(),\n        inodeMap);\n    \n    final short newBR \u003d file.getBlockReplication(); \n    // check newBR \u003c oldBR case. \n    if (newBR \u003c oldBR) {\n      long dsDelta \u003d (newBR - oldBR)*(file.diskspaceConsumed()/newBR);\n      updateCount(iip, 0, dsDelta, true);\n    }\n\n    if (blockRepls !\u003d null) {\n      blockRepls[0] \u003d oldBR;\n      blockRepls[1] \u003d newBR;\n    }\n    return file.getBlocks();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    }
  }
}