{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CosNFileSystem.java",
  "functionName": "rename",
  "functionId": "rename___src-Path__dst-Path",
  "sourceFilePath": "hadoop-cloud-storage-project/hadoop-cos/src/main/java/org/apache/hadoop/fs/cosn/CosNFileSystem.java",
  "functionStartLine": 604,
  "functionEndLine": 700,
  "numCommitsSeen": 1,
  "timeTaken": 347,
  "changeHistory": [
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2"
  ],
  "changeHistoryShort": {
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15616. Incorporate Tencent Cloud COS File System Implementation. Contributed by Yang Yu.\n",
      "commitDate": "27/09/19 1:53 AM",
      "commitName": "8a9ede5cff816b66afc37e7c9d2b33aee48795d2",
      "commitAuthor": "Sammi Chen",
      "diff": "@@ -0,0 +1,97 @@\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.debug(\"Rename source path: [{}] to dest path: [{}].\", src, dst);\n+\n+    // Renaming the root directory is not allowed\n+    if (src.isRoot()) {\n+      LOG.debug(\"Cannot rename the root directory of a filesystem.\");\n+      return false;\n+    }\n+\n+    // check the source path whether exists or not\n+    FileStatus srcFileStatus \u003d this.getFileStatus(src);\n+\n+    // Source path and destination path are not allowed to be the same\n+    if (src.equals(dst)) {\n+      LOG.debug(\"Source path and dest path refer to \"\n+          + \"the same file or directory: [{}].\", dst);\n+      throw new IOException(\"Source path and dest path refer \"\n+          + \"the same file or directory\");\n+    }\n+\n+    // It is not allowed to rename a parent directory to its subdirectory\n+    Path dstParentPath;\n+    for (dstParentPath \u003d dst.getParent();\n+         null !\u003d dstParentPath \u0026\u0026 !src.equals(dstParentPath);\n+         dstParentPath \u003d dstParentPath.getParent()) {\n+      // Recursively find the common parent path of the source and\n+      // destination paths.\n+      LOG.debug(\"Recursively find the common parent directory of the source \"\n+              + \"and destination paths. The currently found parent path: {}\",\n+          dstParentPath);\n+    }\n+\n+    if (null !\u003d dstParentPath) {\n+      LOG.debug(\"It is not allowed to rename a parent directory:[{}] \"\n+          + \"to its subdirectory:[{}].\", src, dst);\n+      throw new IOException(String.format(\n+          \"It is not allowed to rename a parent directory: %s \"\n+              + \"to its subdirectory: %s\", src, dst));\n+    }\n+\n+    FileStatus dstFileStatus;\n+    try {\n+      dstFileStatus \u003d this.getFileStatus(dst);\n+\n+      // The destination path exists and is a file,\n+      // and the rename operation is not allowed.\n+      if (dstFileStatus.isFile()) {\n+        throw new FileAlreadyExistsException(String.format(\n+            \"File: %s already exists\", dstFileStatus.getPath()));\n+      } else {\n+        // The destination path is an existing directory,\n+        // and it is checked whether there is a file or directory\n+        // with the same name as the source path under the destination path\n+        dst \u003d new Path(dst, src.getName());\n+        FileStatus[] statuses;\n+        try {\n+          statuses \u003d this.listStatus(dst);\n+        } catch (FileNotFoundException e) {\n+          statuses \u003d null;\n+        }\n+        if (null !\u003d statuses \u0026\u0026 statuses.length \u003e 0) {\n+          LOG.debug(\"Cannot rename source file: [{}] to dest file: [{}], \"\n+              + \"because the file already exists.\", src, dst);\n+          throw new FileAlreadyExistsException(\n+              String.format(\n+                  \"File: %s already exists\", dst\n+              )\n+          );\n+        }\n+      }\n+    } catch (FileNotFoundException e) {\n+      // destination path not exists\n+      Path tempDstParentPath \u003d dst.getParent();\n+      FileStatus dstParentStatus \u003d this.getFileStatus(tempDstParentPath);\n+      if (!dstParentStatus.isDirectory()) {\n+        throw new IOException(String.format(\n+            \"Cannot rename %s to %s, %s is a file\", src, dst, dst.getParent()\n+        ));\n+      }\n+      // The default root directory is definitely there.\n+    }\n+\n+    boolean result;\n+    if (srcFileStatus.isDirectory()) {\n+      result \u003d this.copyDirectory(src, dst);\n+    } else {\n+      result \u003d this.copyFile(src, dst);\n+    }\n+\n+    if (!result) {\n+      //Since rename is a non-atomic operation, after copy fails,\n+      // it is not allowed to delete the data of the original path.\n+      return false;\n+    } else {\n+      return this.delete(src, true);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.debug(\"Rename source path: [{}] to dest path: [{}].\", src, dst);\n\n    // Renaming the root directory is not allowed\n    if (src.isRoot()) {\n      LOG.debug(\"Cannot rename the root directory of a filesystem.\");\n      return false;\n    }\n\n    // check the source path whether exists or not\n    FileStatus srcFileStatus \u003d this.getFileStatus(src);\n\n    // Source path and destination path are not allowed to be the same\n    if (src.equals(dst)) {\n      LOG.debug(\"Source path and dest path refer to \"\n          + \"the same file or directory: [{}].\", dst);\n      throw new IOException(\"Source path and dest path refer \"\n          + \"the same file or directory\");\n    }\n\n    // It is not allowed to rename a parent directory to its subdirectory\n    Path dstParentPath;\n    for (dstParentPath \u003d dst.getParent();\n         null !\u003d dstParentPath \u0026\u0026 !src.equals(dstParentPath);\n         dstParentPath \u003d dstParentPath.getParent()) {\n      // Recursively find the common parent path of the source and\n      // destination paths.\n      LOG.debug(\"Recursively find the common parent directory of the source \"\n              + \"and destination paths. The currently found parent path: {}\",\n          dstParentPath);\n    }\n\n    if (null !\u003d dstParentPath) {\n      LOG.debug(\"It is not allowed to rename a parent directory:[{}] \"\n          + \"to its subdirectory:[{}].\", src, dst);\n      throw new IOException(String.format(\n          \"It is not allowed to rename a parent directory: %s \"\n              + \"to its subdirectory: %s\", src, dst));\n    }\n\n    FileStatus dstFileStatus;\n    try {\n      dstFileStatus \u003d this.getFileStatus(dst);\n\n      // The destination path exists and is a file,\n      // and the rename operation is not allowed.\n      if (dstFileStatus.isFile()) {\n        throw new FileAlreadyExistsException(String.format(\n            \"File: %s already exists\", dstFileStatus.getPath()));\n      } else {\n        // The destination path is an existing directory,\n        // and it is checked whether there is a file or directory\n        // with the same name as the source path under the destination path\n        dst \u003d new Path(dst, src.getName());\n        FileStatus[] statuses;\n        try {\n          statuses \u003d this.listStatus(dst);\n        } catch (FileNotFoundException e) {\n          statuses \u003d null;\n        }\n        if (null !\u003d statuses \u0026\u0026 statuses.length \u003e 0) {\n          LOG.debug(\"Cannot rename source file: [{}] to dest file: [{}], \"\n              + \"because the file already exists.\", src, dst);\n          throw new FileAlreadyExistsException(\n              String.format(\n                  \"File: %s already exists\", dst\n              )\n          );\n        }\n      }\n    } catch (FileNotFoundException e) {\n      // destination path not exists\n      Path tempDstParentPath \u003d dst.getParent();\n      FileStatus dstParentStatus \u003d this.getFileStatus(tempDstParentPath);\n      if (!dstParentStatus.isDirectory()) {\n        throw new IOException(String.format(\n            \"Cannot rename %s to %s, %s is a file\", src, dst, dst.getParent()\n        ));\n      }\n      // The default root directory is definitely there.\n    }\n\n    boolean result;\n    if (srcFileStatus.isDirectory()) {\n      result \u003d this.copyDirectory(src, dst);\n    } else {\n      result \u003d this.copyFile(src, dst);\n    }\n\n    if (!result) {\n      //Since rename is a non-atomic operation, after copy fails,\n      // it is not allowed to delete the data of the original path.\n      return false;\n    } else {\n      return this.delete(src, true);\n    }\n  }",
      "path": "hadoop-cloud-storage-project/hadoop-cos/src/main/java/org/apache/hadoop/fs/cosn/CosNFileSystem.java"
    }
  }
}