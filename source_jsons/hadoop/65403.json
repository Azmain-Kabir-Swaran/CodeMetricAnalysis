{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3Guard.java",
  "functionName": "nonAuthoritativeUnion",
  "functionId": "nonAuthoritativeUnion___ms-MetadataStore(modifiers-final)__path-Path(modifiers-final)__backingStatuses-List__S3AFileStatus__(modifiers-final)__dirMeta-DirListingMetadata(modifiers-final)__timeProvider-ITtlTimeProvider(modifiers-final)__operationState-BulkOperationState(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
  "functionStartLine": 445,
  "functionEndLine": 501,
  "numCommitsSeen": 25,
  "timeTaken": 1189,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,57 @@\n+  private static void nonAuthoritativeUnion(\n+      final MetadataStore ms,\n+      final Path path,\n+      final List\u003cS3AFileStatus\u003e backingStatuses,\n+      final DirListingMetadata dirMeta,\n+      final ITtlTimeProvider timeProvider,\n+      final BulkOperationState operationState) throws IOException {\n+    List\u003cPathMetadata\u003e entriesToAdd \u003d new ArrayList\u003c\u003e(backingStatuses.size());\n+    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n+\n+    final Map\u003cPath, PathMetadata\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n+        .collect(Collectors.toMap(pm -\u003e pm.getFileStatus().getPath(), pm -\u003e pm));\n+    for (S3AFileStatus s : backingStatuses) {\n+      final Path statusPath \u003d s.getPath();\n+      if (deleted.contains(statusPath)) {\n+        continue;\n+      }\n+\n+      // this is the record in dynamo\n+      PathMetadata pathMetadata \u003d dirMetaMap.get(statusPath);\n+\n+      // in non-auth listings, we compare the file status of the metastore\n+      // list with those in the FS, and overwrite the MS entry if\n+      // either of two conditions are met\n+      // - there is no entry in the metastore and\n+      //   DIR_MERGE_UPDATES_ALL_RECORDS_NONAUTH is compiled to true\n+      // - there is an entry in the metastore the FS entry is newer.\n+      boolean shouldUpdate;\n+      if (pathMetadata !\u003d null) {\n+        // entry is in DDB; check modification time\n+        shouldUpdate \u003d s.getModificationTime() \u003e (pathMetadata.getFileStatus())\n+            .getModificationTime();\n+        // create an updated record.\n+        pathMetadata \u003d new PathMetadata(s);\n+      } else {\n+        // entry is not present. Create for insertion into dirMeta\n+        pathMetadata \u003d new PathMetadata(s);\n+        // use hard-coded policy about updating\n+        shouldUpdate \u003d DIR_MERGE_UPDATES_ALL_RECORDS_NONAUTH;\n+      }\n+      if (shouldUpdate) {\n+        // we do want to update DDB and the listing with a new entry.\n+        LOG.debug(\"Update ms with newer metadata of: {}\", s);\n+        // ensure it gets into the dirListing\n+        // add to the list of entries to add later,\n+        entriesToAdd.add(pathMetadata);\n+      }\n+      // add the entry to the union; no-op if it was already there.\n+      dirMeta.put(pathMetadata);\n+    }\n+\n+    if (!entriesToAdd.isEmpty()) {\n+        // non-auth, just push out the updated entry list\n+      LOG.debug(\"Adding {} entries under directory {}\", entriesToAdd.size(), path);\n+      putWithTtl(ms, entriesToAdd, timeProvider, operationState);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void nonAuthoritativeUnion(\n      final MetadataStore ms,\n      final Path path,\n      final List\u003cS3AFileStatus\u003e backingStatuses,\n      final DirListingMetadata dirMeta,\n      final ITtlTimeProvider timeProvider,\n      final BulkOperationState operationState) throws IOException {\n    List\u003cPathMetadata\u003e entriesToAdd \u003d new ArrayList\u003c\u003e(backingStatuses.size());\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    final Map\u003cPath, PathMetadata\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(pm -\u003e pm.getFileStatus().getPath(), pm -\u003e pm));\n    for (S3AFileStatus s : backingStatuses) {\n      final Path statusPath \u003d s.getPath();\n      if (deleted.contains(statusPath)) {\n        continue;\n      }\n\n      // this is the record in dynamo\n      PathMetadata pathMetadata \u003d dirMetaMap.get(statusPath);\n\n      // in non-auth listings, we compare the file status of the metastore\n      // list with those in the FS, and overwrite the MS entry if\n      // either of two conditions are met\n      // - there is no entry in the metastore and\n      //   DIR_MERGE_UPDATES_ALL_RECORDS_NONAUTH is compiled to true\n      // - there is an entry in the metastore the FS entry is newer.\n      boolean shouldUpdate;\n      if (pathMetadata !\u003d null) {\n        // entry is in DDB; check modification time\n        shouldUpdate \u003d s.getModificationTime() \u003e (pathMetadata.getFileStatus())\n            .getModificationTime();\n        // create an updated record.\n        pathMetadata \u003d new PathMetadata(s);\n      } else {\n        // entry is not present. Create for insertion into dirMeta\n        pathMetadata \u003d new PathMetadata(s);\n        // use hard-coded policy about updating\n        shouldUpdate \u003d DIR_MERGE_UPDATES_ALL_RECORDS_NONAUTH;\n      }\n      if (shouldUpdate) {\n        // we do want to update DDB and the listing with a new entry.\n        LOG.debug(\"Update ms with newer metadata of: {}\", s);\n        // ensure it gets into the dirListing\n        // add to the list of entries to add later,\n        entriesToAdd.add(pathMetadata);\n      }\n      // add the entry to the union; no-op if it was already there.\n      dirMeta.put(pathMetadata);\n    }\n\n    if (!entriesToAdd.isEmpty()) {\n        // non-auth, just push out the updated entry list\n      LOG.debug(\"Adding {} entries under directory {}\", entriesToAdd.size(), path);\n      putWithTtl(ms, entriesToAdd, timeProvider, operationState);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java"
    }
  }
}