{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3GuardTool.java",
  "functionName": "run",
  "functionId": "run___args-String[]__out-PrintStream",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
  "functionStartLine": 1037,
  "functionEndLine": 1058,
  "numCommitsSeen": 42,
  "timeTaken": 4705,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "875a3e97dd4a26fe224a1858c54d1b4512db6be3",
    "4e273a31f66013b7c20e8114451f5bc6c741f2cc",
    "1093a73689912f78547e6d23023be2fd1c7ddc85",
    "f274fe33ea359d26a31efec42a856320a0dbb5f4",
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "875a3e97dd4a26fe224a1858c54d1b4512db6be3": "Ybodychange",
    "4e273a31f66013b7c20e8114451f5bc6c741f2cc": "Ybodychange",
    "1093a73689912f78547e6d23023be2fd1c7ddc85": "Ybodychange",
    "f274fe33ea359d26a31efec42a856320a0dbb5f4": "Ybodychange",
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/12/19 6:51 AM",
      "commitNameOld": "875a3e97dd4a26fe224a1858c54d1b4512db6be3",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 30.85,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,50 @@\n     public int run(String[] args, PrintStream out) throws\n         InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         out.println(USAGE);\n         throw invalidArgs(\"no arguments\");\n       }\n-      int exitValue \u003d EXIT_SUCCESS;\n-\n-      final CommandFormat commandFormat \u003d getCommandFormat();\n-\n-      // check if there\u0027s more than one arguments\n-      int flags \u003d 0;\n-      if (commandFormat.getOpt(CHECK_FLAG)) {\n-        flags++;\n-      }\n-      if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n-        flags++;\n-      }\n-      if (flags \u003e 1) {\n-        out.println(USAGE);\n-        throw invalidArgs(\"There should be only one parameter used for checking.\");\n-      }\n-\n+      maybeInitFilesystem(paths);\n+      initMetadataStore(false);\n       String s3Path \u003d paths.get(0);\n-      try {\n-        initS3AFileSystem(s3Path);\n-      } catch (Exception e) {\n-        errorln(\"Failed to initialize S3AFileSystem from path: \" + s3Path);\n-        throw e;\n-      }\n \n       URI uri \u003d toUri(s3Path);\n-      Path root;\n+      Path auditPath;\n       if (uri.getPath().isEmpty()) {\n-        root \u003d new Path(\"/\");\n+        auditPath \u003d new Path(\"/\");\n       } else {\n-        root \u003d new Path(uri.getPath());\n+        auditPath \u003d new Path(uri.getPath());\n       }\n \n       final S3AFileSystem fs \u003d getFilesystem();\n-      initMetadataStore(false);\n       final MetadataStore ms \u003d getStore();\n \n-      if (ms \u003d\u003d null ||\n-          !(ms instanceof DynamoDBMetadataStore)) {\n-        errorln(s3Path + \" path uses metadata store: \" + ms);\n-        errorln(NAME + \" can be only used with a DynamoDB backed s3a bucket.\");\n+      if (!(ms instanceof DynamoDBMetadataStore)) {\n+        errorln(s3Path + \" path uses MS: \" + ms);\n+        errorln(NAME + \" can be only used with a DynamoDB-backed S3Guard table.\");\n         errorln(USAGE);\n         return ERROR;\n       }\n \n-      List\u003cS3GuardFsck.ComparePair\u003e violations;\n-\n+      final CommandFormat commandFormat \u003d getCommandFormat();\n       if (commandFormat.getOpt(CHECK_FLAG)) {\n-        // do the check\n-        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n-        try {\n-          violations \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n-        } catch (IOException e) {\n-          throw e;\n+        // check that the path is auth\n+        if (!fs.allowAuthoritative(auditPath)) {\n+          // path isn\u0027t considered auth in the S3A bucket info\n+          errorln(\"Path \" + auditPath\n+              + \" is not configured to be authoritative\");\n+          return AuthoritativeAuditOperation.ERROR_PATH_NOT_AUTH_IN_FS;\n         }\n-      } else if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n-        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n-        violations \u003d s3GuardFsck.checkDdbInternalConsistency(fs.qualify(root));\n-      } else {\n-        errorln(\"No supported operation is selected.\");\n-        errorln(USAGE);\n-        return ERROR;\n       }\n \n+      final AuthoritativeAuditOperation audit \u003d new AuthoritativeAuditOperation(\n+          fs.createStoreContext(),\n+          (DynamoDBMetadataStore) ms,\n+          commandFormat.getOpt(REQUIRE_AUTH),\n+          commandFormat.getOpt(VERBOSE));\n+      audit.audit(fs.qualify(auditPath));\n+\n       out.flush();\n-\n-      // We fail if there were compare pairs, as the returned compare pairs\n-      // contain issues.\n-      if (violations \u003d\u003d null || violations.size() \u003e 0) {\n-        exitValue \u003d EXIT_FAIL;\n-      }\n-      return exitValue;\n+      return EXIT_SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out) throws\n        InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        out.println(USAGE);\n        throw invalidArgs(\"no arguments\");\n      }\n      maybeInitFilesystem(paths);\n      initMetadataStore(false);\n      String s3Path \u003d paths.get(0);\n\n      URI uri \u003d toUri(s3Path);\n      Path auditPath;\n      if (uri.getPath().isEmpty()) {\n        auditPath \u003d new Path(\"/\");\n      } else {\n        auditPath \u003d new Path(uri.getPath());\n      }\n\n      final S3AFileSystem fs \u003d getFilesystem();\n      final MetadataStore ms \u003d getStore();\n\n      if (!(ms instanceof DynamoDBMetadataStore)) {\n        errorln(s3Path + \" path uses MS: \" + ms);\n        errorln(NAME + \" can be only used with a DynamoDB-backed S3Guard table.\");\n        errorln(USAGE);\n        return ERROR;\n      }\n\n      final CommandFormat commandFormat \u003d getCommandFormat();\n      if (commandFormat.getOpt(CHECK_FLAG)) {\n        // check that the path is auth\n        if (!fs.allowAuthoritative(auditPath)) {\n          // path isn\u0027t considered auth in the S3A bucket info\n          errorln(\"Path \" + auditPath\n              + \" is not configured to be authoritative\");\n          return AuthoritativeAuditOperation.ERROR_PATH_NOT_AUTH_IN_FS;\n        }\n      }\n\n      final AuthoritativeAuditOperation audit \u003d new AuthoritativeAuditOperation(\n          fs.createStoreContext(),\n          (DynamoDBMetadataStore) ms,\n          commandFormat.getOpt(REQUIRE_AUTH),\n          commandFormat.getOpt(VERBOSE));\n      audit.audit(fs.qualify(auditPath));\n\n      out.flush();\n      return EXIT_SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "875a3e97dd4a26fe224a1858c54d1b4512db6be3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16424. S3Guard fsck: Check internal consistency of the MetadataStore (#1691). Contributed by Gabor Bota.\n\n",
      "commitDate": "10/12/19 6:51 AM",
      "commitName": "875a3e97dd4a26fe224a1858c54d1b4512db6be3",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "18/11/19 4:56 AM",
      "commitNameOld": "cad540819fb28a3c269906ee29fdc05d346f360c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 22.08,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,80 @@\n     public int run(String[] args, PrintStream out) throws\n         InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         out.println(USAGE);\n         throw invalidArgs(\"no arguments\");\n       }\n       int exitValue \u003d EXIT_SUCCESS;\n \n+      final CommandFormat commandFormat \u003d getCommandFormat();\n+\n+      // check if there\u0027s more than one arguments\n+      int flags \u003d 0;\n+      if (commandFormat.getOpt(CHECK_FLAG)) {\n+        flags++;\n+      }\n+      if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n+        flags++;\n+      }\n+      if (flags \u003e 1) {\n+        out.println(USAGE);\n+        throw invalidArgs(\"There should be only one parameter used for checking.\");\n+      }\n+\n       String s3Path \u003d paths.get(0);\n       try {\n         initS3AFileSystem(s3Path);\n       } catch (Exception e) {\n         errorln(\"Failed to initialize S3AFileSystem from path: \" + s3Path);\n         throw e;\n       }\n \n       URI uri \u003d toUri(s3Path);\n       Path root;\n       if (uri.getPath().isEmpty()) {\n         root \u003d new Path(\"/\");\n       } else {\n         root \u003d new Path(uri.getPath());\n       }\n \n       final S3AFileSystem fs \u003d getFilesystem();\n       initMetadataStore(false);\n       final MetadataStore ms \u003d getStore();\n \n       if (ms \u003d\u003d null ||\n           !(ms instanceof DynamoDBMetadataStore)) {\n-        errorln(s3Path + \" path uses MS: \" + ms);\n+        errorln(s3Path + \" path uses metadata store: \" + ms);\n         errorln(NAME + \" can be only used with a DynamoDB backed s3a bucket.\");\n         errorln(USAGE);\n         return ERROR;\n       }\n \n-      final CommandFormat commandFormat \u003d getCommandFormat();\n+      List\u003cS3GuardFsck.ComparePair\u003e violations;\n+\n       if (commandFormat.getOpt(CHECK_FLAG)) {\n         // do the check\n         S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n         try {\n-          final List\u003cS3GuardFsck.ComparePair\u003e comparePairs\n-              \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n-          if (comparePairs.size() \u003e 0) {\n-            exitValue \u003d EXIT_FAIL;\n-          }\n+          violations \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n         } catch (IOException e) {\n           throw e;\n         }\n+      } else if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n+        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n+        violations \u003d s3GuardFsck.checkDdbInternalConsistency(fs.qualify(root));\n       } else {\n         errorln(\"No supported operation is selected.\");\n         errorln(USAGE);\n         return ERROR;\n       }\n \n       out.flush();\n+\n+      // We fail if there were compare pairs, as the returned compare pairs\n+      // contain issues.\n+      if (violations \u003d\u003d null || violations.size() \u003e 0) {\n+        exitValue \u003d EXIT_FAIL;\n+      }\n       return exitValue;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out) throws\n        InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        out.println(USAGE);\n        throw invalidArgs(\"no arguments\");\n      }\n      int exitValue \u003d EXIT_SUCCESS;\n\n      final CommandFormat commandFormat \u003d getCommandFormat();\n\n      // check if there\u0027s more than one arguments\n      int flags \u003d 0;\n      if (commandFormat.getOpt(CHECK_FLAG)) {\n        flags++;\n      }\n      if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n        flags++;\n      }\n      if (flags \u003e 1) {\n        out.println(USAGE);\n        throw invalidArgs(\"There should be only one parameter used for checking.\");\n      }\n\n      String s3Path \u003d paths.get(0);\n      try {\n        initS3AFileSystem(s3Path);\n      } catch (Exception e) {\n        errorln(\"Failed to initialize S3AFileSystem from path: \" + s3Path);\n        throw e;\n      }\n\n      URI uri \u003d toUri(s3Path);\n      Path root;\n      if (uri.getPath().isEmpty()) {\n        root \u003d new Path(\"/\");\n      } else {\n        root \u003d new Path(uri.getPath());\n      }\n\n      final S3AFileSystem fs \u003d getFilesystem();\n      initMetadataStore(false);\n      final MetadataStore ms \u003d getStore();\n\n      if (ms \u003d\u003d null ||\n          !(ms instanceof DynamoDBMetadataStore)) {\n        errorln(s3Path + \" path uses metadata store: \" + ms);\n        errorln(NAME + \" can be only used with a DynamoDB backed s3a bucket.\");\n        errorln(USAGE);\n        return ERROR;\n      }\n\n      List\u003cS3GuardFsck.ComparePair\u003e violations;\n\n      if (commandFormat.getOpt(CHECK_FLAG)) {\n        // do the check\n        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n        try {\n          violations \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n        } catch (IOException e) {\n          throw e;\n        }\n      } else if (commandFormat.getOpt(DDB_MS_CONSISTENCY_FLAG)) {\n        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n        violations \u003d s3GuardFsck.checkDdbInternalConsistency(fs.qualify(root));\n      } else {\n        errorln(\"No supported operation is selected.\");\n        errorln(USAGE);\n        return ERROR;\n      }\n\n      out.flush();\n\n      // We fail if there were compare pairs, as the returned compare pairs\n      // contain issues.\n      if (violations \u003d\u003d null || violations.size() \u003e 0) {\n        exitValue \u003d EXIT_FAIL;\n      }\n      return exitValue;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "4e273a31f66013b7c20e8114451f5bc6c741f2cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16423. S3Guard fsck: Check metadata consistency between S3 and metadatastore (log) (#1208). Contributed by Gabor Bota.\n\nChange-Id: I6bbb331b6c0a41c61043e482b95504fda8a50596",
      "commitDate": "12/09/19 4:12 AM",
      "commitName": "4e273a31f66013b7c20e8114451f5bc6c741f2cc",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 56.87,
      "commitsBetweenForRepo": 505,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,59 @@\n-    public int run(String[] args, PrintStream out)\n-        throws InterruptedException, IOException {\n+    public int run(String[] args, PrintStream out) throws\n+        InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n-        errorln(getUsage());\n-        throw invalidArgs(\"No options specified\");\n+        out.println(USAGE);\n+        throw invalidArgs(\"no arguments\");\n       }\n-      processArgs(paths, out);\n-      promptBeforeAbort(out);\n-      processUploads(out);\n+      int exitValue \u003d EXIT_SUCCESS;\n+\n+      String s3Path \u003d paths.get(0);\n+      try {\n+        initS3AFileSystem(s3Path);\n+      } catch (Exception e) {\n+        errorln(\"Failed to initialize S3AFileSystem from path: \" + s3Path);\n+        throw e;\n+      }\n+\n+      URI uri \u003d toUri(s3Path);\n+      Path root;\n+      if (uri.getPath().isEmpty()) {\n+        root \u003d new Path(\"/\");\n+      } else {\n+        root \u003d new Path(uri.getPath());\n+      }\n+\n+      final S3AFileSystem fs \u003d getFilesystem();\n+      initMetadataStore(false);\n+      final MetadataStore ms \u003d getStore();\n+\n+      if (ms \u003d\u003d null ||\n+          !(ms instanceof DynamoDBMetadataStore)) {\n+        errorln(s3Path + \" path uses MS: \" + ms);\n+        errorln(NAME + \" can be only used with a DynamoDB backed s3a bucket.\");\n+        errorln(USAGE);\n+        return ERROR;\n+      }\n+\n+      final CommandFormat commandFormat \u003d getCommandFormat();\n+      if (commandFormat.getOpt(CHECK_FLAG)) {\n+        // do the check\n+        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n+        try {\n+          final List\u003cS3GuardFsck.ComparePair\u003e comparePairs\n+              \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n+          if (comparePairs.size() \u003e 0) {\n+            exitValue \u003d EXIT_FAIL;\n+          }\n+        } catch (IOException e) {\n+          throw e;\n+        }\n+      } else {\n+        errorln(\"No supported operation is selected.\");\n+        errorln(USAGE);\n+        return ERROR;\n+      }\n \n       out.flush();\n-      return SUCCESS;\n+      return exitValue;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out) throws\n        InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        out.println(USAGE);\n        throw invalidArgs(\"no arguments\");\n      }\n      int exitValue \u003d EXIT_SUCCESS;\n\n      String s3Path \u003d paths.get(0);\n      try {\n        initS3AFileSystem(s3Path);\n      } catch (Exception e) {\n        errorln(\"Failed to initialize S3AFileSystem from path: \" + s3Path);\n        throw e;\n      }\n\n      URI uri \u003d toUri(s3Path);\n      Path root;\n      if (uri.getPath().isEmpty()) {\n        root \u003d new Path(\"/\");\n      } else {\n        root \u003d new Path(uri.getPath());\n      }\n\n      final S3AFileSystem fs \u003d getFilesystem();\n      initMetadataStore(false);\n      final MetadataStore ms \u003d getStore();\n\n      if (ms \u003d\u003d null ||\n          !(ms instanceof DynamoDBMetadataStore)) {\n        errorln(s3Path + \" path uses MS: \" + ms);\n        errorln(NAME + \" can be only used with a DynamoDB backed s3a bucket.\");\n        errorln(USAGE);\n        return ERROR;\n      }\n\n      final CommandFormat commandFormat \u003d getCommandFormat();\n      if (commandFormat.getOpt(CHECK_FLAG)) {\n        // do the check\n        S3GuardFsck s3GuardFsck \u003d new S3GuardFsck(fs, ms);\n        try {\n          final List\u003cS3GuardFsck.ComparePair\u003e comparePairs\n              \u003d s3GuardFsck.compareS3ToMs(fs.qualify(root));\n          if (comparePairs.size() \u003e 0) {\n            exitValue \u003d EXIT_FAIL;\n          }\n        } catch (IOException e) {\n          throw e;\n        }\n      } else {\n        errorln(\"No supported operation is selected.\");\n        errorln(USAGE);\n        return ERROR;\n      }\n\n      out.flush();\n      return exitValue;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "1093a73689912f78547e6d23023be2fd1c7ddc85": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\nContributed by Aaron Fabbri\n",
      "commitDate": "18/01/18 5:13 AM",
      "commitName": "1093a73689912f78547e6d23023be2fd1c7ddc85",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/01/18 4:35 AM",
      "commitNameOld": "f274fe33ea359d26a31efec42a856320a0dbb5f4",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,14 @@\n     public int run(String[] args, PrintStream out)\n         throws InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         errorln(getUsage());\n-        throw invalidArgs(\"No bucket specified\");\n+        throw invalidArgs(\"No options specified\");\n       }\n-      String s3Path \u003d paths.get(0);\n-      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n-          toUri(s3Path), getConf());\n-      setFilesystem(fs);\n-      Configuration conf \u003d fs.getConf();\n-      URI fsUri \u003d fs.getUri();\n-      MetadataStore store \u003d fs.getMetadataStore();\n-      println(out, \"Filesystem %s\", fsUri);\n-      println(out, \"Location: %s\", fs.getBucketLocation());\n-      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n-      boolean authMode \u003d false;\n-      if (usingS3Guard) {\n-        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n-            fsUri, store.toString());\n-        printOption(out, \"Authoritative S3Guard\",\n-            METADATASTORE_AUTHORITATIVE, \"false\");\n-        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n-        printStoreDiagnostics(out, store);\n-      } else {\n-        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n-      }\n-      boolean magic \u003d fs.hasCapability(\n-          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n-      println(out, \"The \\\"magic\\\" committer %s supported\",\n-          magic ? \"is\" : \"is not\");\n-\n-      println(out, \"%nS3A Client\");\n-\n-      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n-      println(out, \"\\tEndpoint: %s\u003d%s\",\n-          ENDPOINT,\n-          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n-      String encryption \u003d\n-          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n-              \"none\");\n-      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n-\n-      CommandFormat commands \u003d getCommandFormat();\n-      if (usingS3Guard) {\n-        if (commands.getOpt(UNGUARDED_FLAG)) {\n-          throw badState(\"S3Guard is enabled for %s\", fsUri);\n-        }\n-        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n-          throw badState(\"S3Guard is enabled for %s,\"\n-              + \" but not in authoritative mode\", fsUri);\n-        }\n-        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n-          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n-              fsUri);\n-        }\n-      } else {\n-        if (commands.getOpt(GUARDED_FLAG)) {\n-          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n-        }\n-      }\n-      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n-        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n-      }\n-\n-      String desiredEncryption \u003d getCommandFormat()\n-          .getOptValue(ENCRYPTION_FLAG);\n-      if (StringUtils.isNotEmpty(desiredEncryption)\n-          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n-        throw badState(\"Bucket %s: required encryption is %s\"\n-                    + \" but actual encryption is %s\",\n-                fsUri, desiredEncryption, encryption);\n-      }\n+      processArgs(paths, out);\n+      promptBeforeAbort(out);\n+      processUploads(out);\n \n       out.flush();\n       return SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out)\n        throws InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        errorln(getUsage());\n        throw invalidArgs(\"No options specified\");\n      }\n      processArgs(paths, out);\n      promptBeforeAbort(out);\n      processUploads(out);\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "f274fe33ea359d26a31efec42a856320a0dbb5f4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\"\n\nThis reverts commit 35ad9b1dd279b769381ea1625d9bf776c309c5cb.\n",
      "commitDate": "18/01/18 4:35 AM",
      "commitName": "f274fe33ea359d26a31efec42a856320a0dbb5f4",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 30.64,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,78 @@\n     public int run(String[] args, PrintStream out)\n         throws InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         errorln(getUsage());\n-        throw invalidArgs(\"No options specified\");\n+        throw invalidArgs(\"No bucket specified\");\n       }\n-      processArgs(paths, out);\n-      promptBeforeAbort(out);\n-      processUploads(out);\n+      String s3Path \u003d paths.get(0);\n+      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n+          toUri(s3Path), getConf());\n+      setFilesystem(fs);\n+      Configuration conf \u003d fs.getConf();\n+      URI fsUri \u003d fs.getUri();\n+      MetadataStore store \u003d fs.getMetadataStore();\n+      println(out, \"Filesystem %s\", fsUri);\n+      println(out, \"Location: %s\", fs.getBucketLocation());\n+      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n+      boolean authMode \u003d false;\n+      if (usingS3Guard) {\n+        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n+            fsUri, store.toString());\n+        printOption(out, \"Authoritative S3Guard\",\n+            METADATASTORE_AUTHORITATIVE, \"false\");\n+        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n+        printStoreDiagnostics(out, store);\n+      } else {\n+        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n+      }\n+      boolean magic \u003d fs.hasCapability(\n+          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n+      println(out, \"The \\\"magic\\\" committer %s supported\",\n+          magic ? \"is\" : \"is not\");\n+\n+      println(out, \"%nS3A Client\");\n+\n+      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n+      println(out, \"\\tEndpoint: %s\u003d%s\",\n+          ENDPOINT,\n+          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n+      String encryption \u003d\n+          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n+              \"none\");\n+      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n+\n+      CommandFormat commands \u003d getCommandFormat();\n+      if (usingS3Guard) {\n+        if (commands.getOpt(UNGUARDED_FLAG)) {\n+          throw badState(\"S3Guard is enabled for %s\", fsUri);\n+        }\n+        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n+          throw badState(\"S3Guard is enabled for %s,\"\n+              + \" but not in authoritative mode\", fsUri);\n+        }\n+        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n+          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n+              fsUri);\n+        }\n+      } else {\n+        if (commands.getOpt(GUARDED_FLAG)) {\n+          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n+        }\n+      }\n+      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n+        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n+      }\n+\n+      String desiredEncryption \u003d getCommandFormat()\n+          .getOptValue(ENCRYPTION_FLAG);\n+      if (StringUtils.isNotEmpty(desiredEncryption)\n+          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n+        throw badState(\"Bucket %s: required encryption is %s\"\n+                    + \" but actual encryption is %s\",\n+                fsUri, desiredEncryption, encryption);\n+      }\n \n       out.flush();\n       return SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out)\n        throws InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        errorln(getUsage());\n        throw invalidArgs(\"No bucket specified\");\n      }\n      String s3Path \u003d paths.get(0);\n      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n          toUri(s3Path), getConf());\n      setFilesystem(fs);\n      Configuration conf \u003d fs.getConf();\n      URI fsUri \u003d fs.getUri();\n      MetadataStore store \u003d fs.getMetadataStore();\n      println(out, \"Filesystem %s\", fsUri);\n      println(out, \"Location: %s\", fs.getBucketLocation());\n      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n      boolean authMode \u003d false;\n      if (usingS3Guard) {\n        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n            fsUri, store.toString());\n        printOption(out, \"Authoritative S3Guard\",\n            METADATASTORE_AUTHORITATIVE, \"false\");\n        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n        printStoreDiagnostics(out, store);\n      } else {\n        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n      }\n      boolean magic \u003d fs.hasCapability(\n          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n      println(out, \"The \\\"magic\\\" committer %s supported\",\n          magic ? \"is\" : \"is not\");\n\n      println(out, \"%nS3A Client\");\n\n      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n      println(out, \"\\tEndpoint: %s\u003d%s\",\n          ENDPOINT,\n          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n      String encryption \u003d\n          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n              \"none\");\n      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n\n      CommandFormat commands \u003d getCommandFormat();\n      if (usingS3Guard) {\n        if (commands.getOpt(UNGUARDED_FLAG)) {\n          throw badState(\"S3Guard is enabled for %s\", fsUri);\n        }\n        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n          throw badState(\"S3Guard is enabled for %s,\"\n              + \" but not in authoritative mode\", fsUri);\n        }\n        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n              fsUri);\n        }\n      } else {\n        if (commands.getOpt(GUARDED_FLAG)) {\n          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n        }\n      }\n      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n      }\n\n      String desiredEncryption \u003d getCommandFormat()\n          .getOptValue(ENCRYPTION_FLAG);\n      if (StringUtils.isNotEmpty(desiredEncryption)\n          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n        throw badState(\"Bucket %s: required encryption is %s\"\n                    + \" but actual encryption is %s\",\n                fsUri, desiredEncryption, encryption);\n      }\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\nContributed by Aaron Fabbri\n",
      "commitDate": "18/12/17 1:19 PM",
      "commitName": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "22/11/17 7:28 AM",
      "commitNameOld": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 26.24,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,14 @@\n     public int run(String[] args, PrintStream out)\n         throws InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         errorln(getUsage());\n-        throw invalidArgs(\"No bucket specified\");\n+        throw invalidArgs(\"No options specified\");\n       }\n-      String s3Path \u003d paths.get(0);\n-      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n-          toUri(s3Path), getConf());\n-      setFilesystem(fs);\n-      Configuration conf \u003d fs.getConf();\n-      URI fsUri \u003d fs.getUri();\n-      MetadataStore store \u003d fs.getMetadataStore();\n-      println(out, \"Filesystem %s\", fsUri);\n-      println(out, \"Location: %s\", fs.getBucketLocation());\n-      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n-      boolean authMode \u003d false;\n-      if (usingS3Guard) {\n-        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n-            fsUri, store.toString());\n-        printOption(out, \"Authoritative S3Guard\",\n-            METADATASTORE_AUTHORITATIVE, \"false\");\n-        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n-        printStoreDiagnostics(out, store);\n-      } else {\n-        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n-      }\n-      boolean magic \u003d fs.hasCapability(\n-          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n-      println(out, \"The \\\"magic\\\" committer %s supported\",\n-          magic ? \"is\" : \"is not\");\n-\n-      println(out, \"%nS3A Client\");\n-\n-      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n-      println(out, \"\\tEndpoint: %s\u003d%s\",\n-          ENDPOINT,\n-          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n-      String encryption \u003d\n-          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n-              \"none\");\n-      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n-\n-      CommandFormat commands \u003d getCommandFormat();\n-      if (usingS3Guard) {\n-        if (commands.getOpt(UNGUARDED_FLAG)) {\n-          throw badState(\"S3Guard is enabled for %s\", fsUri);\n-        }\n-        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n-          throw badState(\"S3Guard is enabled for %s,\"\n-              + \" but not in authoritative mode\", fsUri);\n-        }\n-        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n-          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n-              fsUri);\n-        }\n-      } else {\n-        if (commands.getOpt(GUARDED_FLAG)) {\n-          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n-        }\n-      }\n-      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n-        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n-      }\n-\n-      String desiredEncryption \u003d getCommandFormat()\n-          .getOptValue(ENCRYPTION_FLAG);\n-      if (StringUtils.isNotEmpty(desiredEncryption)\n-          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n-        throw badState(\"Bucket %s: required encryption is %s\"\n-                    + \" but actual encryption is %s\",\n-                fsUri, desiredEncryption, encryption);\n-      }\n+      processArgs(paths, out);\n+      promptBeforeAbort(out);\n+      processUploads(out);\n \n       out.flush();\n       return SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out)\n        throws InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        errorln(getUsage());\n        throw invalidArgs(\"No options specified\");\n      }\n      processArgs(paths, out);\n      promptBeforeAbort(out);\n      processUploads(out);\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,78 @@\n     public int run(String[] args, PrintStream out)\n         throws InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n       if (paths.isEmpty()) {\n         errorln(getUsage());\n         throw invalidArgs(\"No bucket specified\");\n       }\n       String s3Path \u003d paths.get(0);\n       S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n           toUri(s3Path), getConf());\n       setFilesystem(fs);\n       Configuration conf \u003d fs.getConf();\n       URI fsUri \u003d fs.getUri();\n       MetadataStore store \u003d fs.getMetadataStore();\n       println(out, \"Filesystem %s\", fsUri);\n       println(out, \"Location: %s\", fs.getBucketLocation());\n       boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n       boolean authMode \u003d false;\n       if (usingS3Guard) {\n         out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n             fsUri, store.toString());\n         printOption(out, \"Authoritative S3Guard\",\n             METADATASTORE_AUTHORITATIVE, \"false\");\n         authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n         printStoreDiagnostics(out, store);\n       } else {\n         println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n       }\n+      boolean magic \u003d fs.hasCapability(\n+          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n+      println(out, \"The \\\"magic\\\" committer %s supported\",\n+          magic ? \"is\" : \"is not\");\n+\n       println(out, \"%nS3A Client\");\n \n       String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n       println(out, \"\\tEndpoint: %s\u003d%s\",\n           ENDPOINT,\n           StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n       String encryption \u003d\n           printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n               \"none\");\n       printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n \n       CommandFormat commands \u003d getCommandFormat();\n       if (usingS3Guard) {\n         if (commands.getOpt(UNGUARDED_FLAG)) {\n           throw badState(\"S3Guard is enabled for %s\", fsUri);\n         }\n         if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n           throw badState(\"S3Guard is enabled for %s,\"\n               + \" but not in authoritative mode\", fsUri);\n         }\n         if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n           throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n               fsUri);\n         }\n       } else {\n         if (commands.getOpt(GUARDED_FLAG)) {\n           throw badState(\"S3Guard is not enabled for %s\", fsUri);\n         }\n       }\n+      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n+        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n+      }\n \n       String desiredEncryption \u003d getCommandFormat()\n           .getOptValue(ENCRYPTION_FLAG);\n       if (StringUtils.isNotEmpty(desiredEncryption)\n           \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n         throw badState(\"Bucket %s: required encryption is %s\"\n                     + \" but actual encryption is %s\",\n                 fsUri, desiredEncryption, encryption);\n       }\n \n       out.flush();\n       return SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out)\n        throws InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        errorln(getUsage());\n        throw invalidArgs(\"No bucket specified\");\n      }\n      String s3Path \u003d paths.get(0);\n      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n          toUri(s3Path), getConf());\n      setFilesystem(fs);\n      Configuration conf \u003d fs.getConf();\n      URI fsUri \u003d fs.getUri();\n      MetadataStore store \u003d fs.getMetadataStore();\n      println(out, \"Filesystem %s\", fsUri);\n      println(out, \"Location: %s\", fs.getBucketLocation());\n      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n      boolean authMode \u003d false;\n      if (usingS3Guard) {\n        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n            fsUri, store.toString());\n        printOption(out, \"Authoritative S3Guard\",\n            METADATASTORE_AUTHORITATIVE, \"false\");\n        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n        printStoreDiagnostics(out, store);\n      } else {\n        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n      }\n      boolean magic \u003d fs.hasCapability(\n          CommitConstants.STORE_CAPABILITY_MAGIC_COMMITTER);\n      println(out, \"The \\\"magic\\\" committer %s supported\",\n          magic ? \"is\" : \"is not\");\n\n      println(out, \"%nS3A Client\");\n\n      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n      println(out, \"\\tEndpoint: %s\u003d%s\",\n          ENDPOINT,\n          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n      String encryption \u003d\n          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n              \"none\");\n      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n\n      CommandFormat commands \u003d getCommandFormat();\n      if (usingS3Guard) {\n        if (commands.getOpt(UNGUARDED_FLAG)) {\n          throw badState(\"S3Guard is enabled for %s\", fsUri);\n        }\n        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n          throw badState(\"S3Guard is enabled for %s,\"\n              + \" but not in authoritative mode\", fsUri);\n        }\n        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n              fsUri);\n        }\n      } else {\n        if (commands.getOpt(GUARDED_FLAG)) {\n          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n        }\n      }\n      if (commands.getOpt(MAGIC_FLAG) \u0026\u0026 !magic) {\n        throw badState(\"The magic committer is not enabled for %s\", fsUri);\n      }\n\n      String desiredEncryption \u003d getCommandFormat()\n          .getOptValue(ENCRYPTION_FLAG);\n      if (StringUtils.isNotEmpty(desiredEncryption)\n          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n        throw badState(\"Bucket %s: required encryption is %s\"\n                    + \" but actual encryption is %s\",\n                fsUri, desiredEncryption, encryption);\n      }\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14220 Enhance S3GuardTool with bucket-info and set-capacity commands, tests. Contributed by Steve Loughran\n",
      "commitDate": "25/09/17 3:59 PM",
      "commitName": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "01/09/17 6:13 AM",
      "commitNameOld": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 24.41,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,70 @@\n-    public int run(String[] args, PrintStream out) throws\n-        InterruptedException, IOException {\n+    public int run(String[] args, PrintStream out)\n+        throws InterruptedException, IOException {\n       List\u003cString\u003e paths \u003d parseArgs(args);\n-      if (!parseDynamoDBRegion(paths)) {\n-        System.err.println(USAGE);\n-        return INVALID_ARGUMENT;\n+      if (paths.isEmpty()) {\n+        errorln(getUsage());\n+        throw invalidArgs(\"No bucket specified\");\n       }\n-      initMetadataStore(false);\n+      String s3Path \u003d paths.get(0);\n+      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n+          toUri(s3Path), getConf());\n+      setFilesystem(fs);\n+      Configuration conf \u003d fs.getConf();\n+      URI fsUri \u003d fs.getUri();\n+      MetadataStore store \u003d fs.getMetadataStore();\n+      println(out, \"Filesystem %s\", fsUri);\n+      println(out, \"Location: %s\", fs.getBucketLocation());\n+      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n+      boolean authMode \u003d false;\n+      if (usingS3Guard) {\n+        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n+            fsUri, store.toString());\n+        printOption(out, \"Authoritative S3Guard\",\n+            METADATASTORE_AUTHORITATIVE, \"false\");\n+        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n+        printStoreDiagnostics(out, store);\n+      } else {\n+        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n+      }\n+      println(out, \"%nS3A Client\");\n \n-      Configuration conf \u003d getConf();\n-      long confDelta \u003d conf.getLong(Constants.S3GUARD_CLI_PRUNE_AGE, 0);\n+      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n+      println(out, \"\\tEndpoint: %s\u003d%s\",\n+          ENDPOINT,\n+          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n+      String encryption \u003d\n+          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n+              \"none\");\n+      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n \n-      long cliDelta \u003d 0;\n-      cliDelta +\u003d getDeltaComponent(TimeUnit.DAYS, \"days\");\n-      cliDelta +\u003d getDeltaComponent(TimeUnit.HOURS, \"hours\");\n-      cliDelta +\u003d getDeltaComponent(TimeUnit.MINUTES, \"minutes\");\n-      cliDelta +\u003d getDeltaComponent(TimeUnit.SECONDS, \"seconds\");\n-\n-      if (confDelta \u003c\u003d 0 \u0026\u0026 cliDelta \u003c\u003d 0) {\n-        System.err.println(\n-            \"You must specify a positive age for metadata to prune.\");\n+      CommandFormat commands \u003d getCommandFormat();\n+      if (usingS3Guard) {\n+        if (commands.getOpt(UNGUARDED_FLAG)) {\n+          throw badState(\"S3Guard is enabled for %s\", fsUri);\n+        }\n+        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n+          throw badState(\"S3Guard is enabled for %s,\"\n+              + \" but not in authoritative mode\", fsUri);\n+        }\n+        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n+          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n+              fsUri);\n+        }\n+      } else {\n+        if (commands.getOpt(GUARDED_FLAG)) {\n+          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n+        }\n       }\n \n-      // A delta provided on the CLI overrides if one is configured\n-      long delta \u003d confDelta;\n-      if (cliDelta \u003e 0) {\n-        delta \u003d cliDelta;\n+      String desiredEncryption \u003d getCommandFormat()\n+          .getOptValue(ENCRYPTION_FLAG);\n+      if (StringUtils.isNotEmpty(desiredEncryption)\n+          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n+        throw badState(\"Bucket %s: required encryption is %s\"\n+                    + \" but actual encryption is %s\",\n+                fsUri, desiredEncryption, encryption);\n       }\n \n-      long now \u003d System.currentTimeMillis();\n-      long divide \u003d now - delta;\n-\n-      getStore().prune(divide);\n-\n       out.flush();\n       return SUCCESS;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out)\n        throws InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (paths.isEmpty()) {\n        errorln(getUsage());\n        throw invalidArgs(\"No bucket specified\");\n      }\n      String s3Path \u003d paths.get(0);\n      S3AFileSystem fs \u003d (S3AFileSystem) FileSystem.newInstance(\n          toUri(s3Path), getConf());\n      setFilesystem(fs);\n      Configuration conf \u003d fs.getConf();\n      URI fsUri \u003d fs.getUri();\n      MetadataStore store \u003d fs.getMetadataStore();\n      println(out, \"Filesystem %s\", fsUri);\n      println(out, \"Location: %s\", fs.getBucketLocation());\n      boolean usingS3Guard \u003d !(store instanceof NullMetadataStore);\n      boolean authMode \u003d false;\n      if (usingS3Guard) {\n        out.printf(\"Filesystem %s is using S3Guard with store %s%n\",\n            fsUri, store.toString());\n        printOption(out, \"Authoritative S3Guard\",\n            METADATASTORE_AUTHORITATIVE, \"false\");\n        authMode \u003d conf.getBoolean(METADATASTORE_AUTHORITATIVE, false);\n        printStoreDiagnostics(out, store);\n      } else {\n        println(out, \"Filesystem %s is not using S3Guard\", fsUri);\n      }\n      println(out, \"%nS3A Client\");\n\n      String endpoint \u003d conf.getTrimmed(ENDPOINT, \"\");\n      println(out, \"\\tEndpoint: %s\u003d%s\",\n          ENDPOINT,\n          StringUtils.isNotEmpty(endpoint) ? endpoint : \"(unset)\");\n      String encryption \u003d\n          printOption(out, \"\\tEncryption\", SERVER_SIDE_ENCRYPTION_ALGORITHM,\n              \"none\");\n      printOption(out, \"\\tInput seek policy\", INPUT_FADVISE, INPUT_FADV_NORMAL);\n\n      CommandFormat commands \u003d getCommandFormat();\n      if (usingS3Guard) {\n        if (commands.getOpt(UNGUARDED_FLAG)) {\n          throw badState(\"S3Guard is enabled for %s\", fsUri);\n        }\n        if (commands.getOpt(AUTH_FLAG) \u0026\u0026 !authMode) {\n          throw badState(\"S3Guard is enabled for %s,\"\n              + \" but not in authoritative mode\", fsUri);\n        }\n        if (commands.getOpt(NONAUTH_FLAG) \u0026\u0026 authMode) {\n          throw badState(\"S3Guard is enabled in authoritative mode for %s\",\n              fsUri);\n        }\n      } else {\n        if (commands.getOpt(GUARDED_FLAG)) {\n          throw badState(\"S3Guard is not enabled for %s\", fsUri);\n        }\n      }\n\n      String desiredEncryption \u003d getCommandFormat()\n          .getOptValue(ENCRYPTION_FLAG);\n      if (StringUtils.isNotEmpty(desiredEncryption)\n          \u0026\u0026 !desiredEncryption.equalsIgnoreCase(encryption)) {\n        throw badState(\"Bucket %s: required encryption is %s\"\n                    + \" but actual encryption is %s\",\n                fsUri, desiredEncryption, encryption);\n      }\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,37 @@\n+    public int run(String[] args, PrintStream out) throws\n+        InterruptedException, IOException {\n+      List\u003cString\u003e paths \u003d parseArgs(args);\n+      if (!parseDynamoDBRegion(paths)) {\n+        System.err.println(USAGE);\n+        return INVALID_ARGUMENT;\n+      }\n+      initMetadataStore(false);\n+\n+      Configuration conf \u003d getConf();\n+      long confDelta \u003d conf.getLong(Constants.S3GUARD_CLI_PRUNE_AGE, 0);\n+\n+      long cliDelta \u003d 0;\n+      cliDelta +\u003d getDeltaComponent(TimeUnit.DAYS, \"days\");\n+      cliDelta +\u003d getDeltaComponent(TimeUnit.HOURS, \"hours\");\n+      cliDelta +\u003d getDeltaComponent(TimeUnit.MINUTES, \"minutes\");\n+      cliDelta +\u003d getDeltaComponent(TimeUnit.SECONDS, \"seconds\");\n+\n+      if (confDelta \u003c\u003d 0 \u0026\u0026 cliDelta \u003c\u003d 0) {\n+        System.err.println(\n+            \"You must specify a positive age for metadata to prune.\");\n+      }\n+\n+      // A delta provided on the CLI overrides if one is configured\n+      long delta \u003d confDelta;\n+      if (cliDelta \u003e 0) {\n+        delta \u003d cliDelta;\n+      }\n+\n+      long now \u003d System.currentTimeMillis();\n+      long divide \u003d now - delta;\n+\n+      getStore().prune(divide);\n+\n+      out.flush();\n+      return SUCCESS;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public int run(String[] args, PrintStream out) throws\n        InterruptedException, IOException {\n      List\u003cString\u003e paths \u003d parseArgs(args);\n      if (!parseDynamoDBRegion(paths)) {\n        System.err.println(USAGE);\n        return INVALID_ARGUMENT;\n      }\n      initMetadataStore(false);\n\n      Configuration conf \u003d getConf();\n      long confDelta \u003d conf.getLong(Constants.S3GUARD_CLI_PRUNE_AGE, 0);\n\n      long cliDelta \u003d 0;\n      cliDelta +\u003d getDeltaComponent(TimeUnit.DAYS, \"days\");\n      cliDelta +\u003d getDeltaComponent(TimeUnit.HOURS, \"hours\");\n      cliDelta +\u003d getDeltaComponent(TimeUnit.MINUTES, \"minutes\");\n      cliDelta +\u003d getDeltaComponent(TimeUnit.SECONDS, \"seconds\");\n\n      if (confDelta \u003c\u003d 0 \u0026\u0026 cliDelta \u003c\u003d 0) {\n        System.err.println(\n            \"You must specify a positive age for metadata to prune.\");\n      }\n\n      // A delta provided on the CLI overrides if one is configured\n      long delta \u003d confDelta;\n      if (cliDelta \u003e 0) {\n        delta \u003d cliDelta;\n      }\n\n      long now \u003d System.currentTimeMillis();\n      long divide \u003d now - delta;\n\n      getStore().prune(divide);\n\n      out.flush();\n      return SUCCESS;\n    }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3GuardTool.java"
    }
  }
}