{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Mover.java",
  "functionName": "processFile",
  "functionId": "processFile___fullPath-String__status-HdfsLocatedFileStatus__result-Result",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
  "functionStartLine": 377,
  "functionEndLine": 435,
  "numCommitsSeen": 141,
  "timeTaken": 5705,
  "changeHistory": [
    "0e560f3b8d194c10dce06443979df4074e14b0db",
    "675e9a8f57570771a0219d95940681b067d36b94",
    "b85603e3f85e85da406241b991f3a9974384c3aa",
    "23b1a7bdf1b546c1e29d7010cf139b6d700461fc",
    "17eae9ebb30a3b106c4f6ae0c5374a3ab83abd8a"
  ],
  "changeHistoryShort": {
    "0e560f3b8d194c10dce06443979df4074e14b0db": "Ybodychange",
    "675e9a8f57570771a0219d95940681b067d36b94": "Ymultichange(Yparameterchange,Ybodychange)",
    "b85603e3f85e85da406241b991f3a9974384c3aa": "Ymultichange(Yparameterchange,Ybodychange)",
    "23b1a7bdf1b546c1e29d7010cf139b6d700461fc": "Ybodychange",
    "17eae9ebb30a3b106c4f6ae0c5374a3ab83abd8a": "Ybodychange"
  },
  "changeHistoryDetails": {
    "0e560f3b8d194c10dce06443979df4074e14b0db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12681. Make HdfsLocatedFileStatus a subtype of LocatedFileStatus\n",
      "commitDate": "29/11/17 8:28 PM",
      "commitName": "0e560f3b8d194c10dce06443979df4074e14b0db",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "15/11/17 7:20 PM",
      "commitNameOld": "675e9a8f57570771a0219d95940681b067d36b94",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 14.05,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n     private void processFile(String fullPath, HdfsLocatedFileStatus status,\n         Result result) {\n       byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         try {\n           // get default policy from namenode\n           policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n           return;\n         }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n-      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n+      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
      "extendedDetails": {}
    },
    "675e9a8f57570771a0219d95940681b067d36b94": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\"\n\nThis reverts commit b85603e3f85e85da406241b991f3a9974384c3aa.\n",
      "commitDate": "15/11/17 7:20 PM",
      "commitName": "675e9a8f57570771a0219d95940681b067d36b94",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\"\n\nThis reverts commit b85603e3f85e85da406241b991f3a9974384c3aa.\n",
          "commitDate": "15/11/17 7:20 PM",
          "commitName": "675e9a8f57570771a0219d95940681b067d36b94",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "03/11/17 2:30 PM",
          "commitNameOld": "b85603e3f85e85da406241b991f3a9974384c3aa",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 12.24,
          "commitsBetweenForRepo": 169,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-    private void processFile(String fullPath, HdfsFileStatus status,\n+    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n         Result result) {\n       byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         try {\n           // get default policy from namenode\n           policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n           return;\n         }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n-      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n+      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
          "extendedDetails": {
            "oldValue": "[fullPath-String, status-HdfsFileStatus, result-Result]",
            "newValue": "[fullPath-String, status-HdfsLocatedFileStatus, result-Result]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\"\n\nThis reverts commit b85603e3f85e85da406241b991f3a9974384c3aa.\n",
          "commitDate": "15/11/17 7:20 PM",
          "commitName": "675e9a8f57570771a0219d95940681b067d36b94",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "03/11/17 2:30 PM",
          "commitNameOld": "b85603e3f85e85da406241b991f3a9974384c3aa",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 12.24,
          "commitsBetweenForRepo": 169,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-    private void processFile(String fullPath, HdfsFileStatus status,\n+    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n         Result result) {\n       byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         try {\n           // get default policy from namenode\n           policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n           return;\n         }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n-      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n+      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
          "extendedDetails": {}
        }
      ]
    },
    "b85603e3f85e85da406241b991f3a9974384c3aa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\n",
      "commitDate": "03/11/17 2:30 PM",
      "commitName": "b85603e3f85e85da406241b991f3a9974384c3aa",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\n",
          "commitDate": "03/11/17 2:30 PM",
          "commitName": "b85603e3f85e85da406241b991f3a9974384c3aa",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "14/08/17 9:57 PM",
          "commitNameOld": "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 80.69,
          "commitsBetweenForRepo": 678,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n+    private void processFile(String fullPath, HdfsFileStatus status,\n         Result result) {\n       byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         try {\n           // get default policy from namenode\n           policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n           return;\n         }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n-      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n+      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processFile(String fullPath, HdfsFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
          "extendedDetails": {
            "oldValue": "[fullPath-String, status-HdfsLocatedFileStatus, result-Result]",
            "newValue": "[fullPath-String, status-HdfsFileStatus, result-Result]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12681. Fold HdfsLocatedFileStatus into HdfsFileStatus.\n",
          "commitDate": "03/11/17 2:30 PM",
          "commitName": "b85603e3f85e85da406241b991f3a9974384c3aa",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "14/08/17 9:57 PM",
          "commitNameOld": "645a8f2a4d09acb5a21820f52ee78784d9e4cc8a",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 80.69,
          "commitsBetweenForRepo": 678,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,59 @@\n-    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n+    private void processFile(String fullPath, HdfsFileStatus status,\n         Result result) {\n       byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         try {\n           // get default policy from namenode\n           policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n         } catch (IOException e) {\n           LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n           return;\n         }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n-      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n+      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void processFile(String fullPath, HdfsFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getLocatedBlocks();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
          "extendedDetails": {}
        }
      ]
    },
    "23b1a7bdf1b546c1e29d7010cf139b6d700461fc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11163. Mover should move the file blocks to default storage once policy is unset. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "11/04/17 10:03 PM",
      "commitName": "23b1a7bdf1b546c1e29d7010cf139b6d700461fc",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "13/12/16 5:09 PM",
      "commitNameOld": "e24a923db50879f7dbe5d2afac0e6757089fb07d",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 119.16,
      "commitsBetweenForRepo": 631,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,59 @@\n     private void processFile(String fullPath, HdfsLocatedFileStatus status,\n         Result result) {\n-      final byte policyId \u003d status.getStoragePolicy();\n-      // currently we ignore files with unspecified storage policy\n+      byte policyId \u003d status.getStoragePolicy();\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n-        return;\n+        try {\n+          // get default policy from namenode\n+          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n+        } catch (IOException e) {\n+          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n+          return;\n+        }\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n       final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n           if (ErasureCodingPolicyManager\n               .checkStoragePolicySuitableForECStripedMode(policyId)) {\n             types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n           } else {\n             // Currently we support only limited policies (HOT, COLD, ALLSSD)\n             // for EC striped mode files.\n             // Mover tool will ignore to move the blocks if the storage policy\n             // is not in EC Striped mode supported policies\n             LOG.warn(\"The storage policy \" + policy.getName()\n                 + \" is not suitable for Striped EC files. \"\n                 + \"So, Ignoring to move the blocks\");\n             return;\n           }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      byte policyId \u003d status.getStoragePolicy();\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        try {\n          // get default policy from namenode\n          policyId \u003d dfs.getServerDefaults().getDefaultStoragePolicyId();\n        } catch (IOException e) {\n          LOG.warn(\"Failed to get default policy for \" + fullPath, e);\n          return;\n        }\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
      "extendedDetails": {}
    },
    "17eae9ebb30a3b106c4f6ae0c5374a3ab83abd8a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10473: Allow only suitable storage policies to be set on striped files. Contributed by Uma Maheswara Rao G\n",
      "commitDate": "22/06/16 11:17 AM",
      "commitName": "17eae9ebb30a3b106c4f6ae0c5374a3ab83abd8a",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "24/05/16 12:49 PM",
      "commitNameOld": "15ed080e3610b7526eff12391de780948a75fa7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 28.94,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,54 @@\n     private void processFile(String fullPath, HdfsLocatedFileStatus status,\n         Result result) {\n       final byte policyId \u003d status.getStoragePolicy();\n       // currently we ignore files with unspecified storage policy\n       if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n         return;\n       }\n       final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n       if (policy \u003d\u003d null) {\n         LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n         return;\n       }\n       List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n           status.getReplication());\n \n       final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n       final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n       final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n       List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n       for (int i \u003d 0; i \u003c lbs.size(); i++) {\n         if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n           // last block is incomplete, skip it\n           continue;\n         }\n         LocatedBlock lb \u003d lbs.get(i);\n         if (lb.isStriped()) {\n-          types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n+          if (ErasureCodingPolicyManager\n+              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n+            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n+          } else {\n+            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n+            // for EC striped mode files.\n+            // Mover tool will ignore to move the blocks if the storage policy\n+            // is not in EC Striped mode supported policies\n+            LOG.warn(\"The storage policy \" + policy.getName()\n+                + \" is not suitable for Striped EC files. \"\n+                + \"So, Ignoring to move the blocks\");\n+            return;\n+          }\n         }\n         final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n             lb.getStorageTypes());\n         if (!diff.removeOverlap(true)) {\n           if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n             result.updateHasRemaining(diff.existing.size() \u003e 1\n                 \u0026\u0026 diff.expected.size() \u003e 1);\n             // One block scheduled successfully, set noBlockMoved to false\n             result.setNoBlockMoved(false);\n           } else {\n             result.updateHasRemaining(true);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void processFile(String fullPath, HdfsLocatedFileStatus status,\n        Result result) {\n      final byte policyId \u003d status.getStoragePolicy();\n      // currently we ignore files with unspecified storage policy\n      if (policyId \u003d\u003d HdfsConstants.BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) {\n        return;\n      }\n      final BlockStoragePolicy policy \u003d blockStoragePolicies[policyId];\n      if (policy \u003d\u003d null) {\n        LOG.warn(\"Failed to get the storage policy of file \" + fullPath);\n        return;\n      }\n      List\u003cStorageType\u003e types \u003d policy.chooseStorageTypes(\n          status.getReplication());\n\n      final ErasureCodingPolicy ecPolicy \u003d status.getErasureCodingPolicy();\n      final LocatedBlocks locatedBlocks \u003d status.getBlockLocations();\n      final boolean lastBlkComplete \u003d locatedBlocks.isLastBlockComplete();\n      List\u003cLocatedBlock\u003e lbs \u003d locatedBlocks.getLocatedBlocks();\n      for (int i \u003d 0; i \u003c lbs.size(); i++) {\n        if (i \u003d\u003d lbs.size() - 1 \u0026\u0026 !lastBlkComplete) {\n          // last block is incomplete, skip it\n          continue;\n        }\n        LocatedBlock lb \u003d lbs.get(i);\n        if (lb.isStriped()) {\n          if (ErasureCodingPolicyManager\n              .checkStoragePolicySuitableForECStripedMode(policyId)) {\n            types \u003d policy.chooseStorageTypes((short) lb.getLocations().length);\n          } else {\n            // Currently we support only limited policies (HOT, COLD, ALLSSD)\n            // for EC striped mode files.\n            // Mover tool will ignore to move the blocks if the storage policy\n            // is not in EC Striped mode supported policies\n            LOG.warn(\"The storage policy \" + policy.getName()\n                + \" is not suitable for Striped EC files. \"\n                + \"So, Ignoring to move the blocks\");\n            return;\n          }\n        }\n        final StorageTypeDiff diff \u003d new StorageTypeDiff(types,\n            lb.getStorageTypes());\n        if (!diff.removeOverlap(true)) {\n          if (scheduleMoves4Block(diff, lb, ecPolicy)) {\n            result.updateHasRemaining(diff.existing.size() \u003e 1\n                \u0026\u0026 diff.expected.size() \u003e 1);\n            // One block scheduled successfully, set noBlockMoved to false\n            result.setNoBlockMoved(false);\n          } else {\n            result.updateHasRemaining(true);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
      "extendedDetails": {}
    }
  }
}