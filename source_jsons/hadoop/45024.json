{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientAsyncImpl.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
  "functionStartLine": 345,
  "functionEndLine": 435,
  "numCommitsSeen": 41,
  "timeTaken": 6689,
  "changeHistory": [
    "6926fd0ec634df2576bbc9f45e9636b99260db72",
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
    "95d4ec7fc07605d1ed6eabf066cd5413eb3fe465",
    "3ebe6a7819292ce6bd557e36137531b59890c845",
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3",
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "1238fa71f8e62cecde6e2437d1b83ad3922295f8",
    "64a2d5be91a7f344aadf820481c542c967bc46a8",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661",
    "3cd386bd97c05f2bc5d95014f9cf34d0dc4588ee",
    "0d02ab8729630ad3cfb4300702927333b1d349e3",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7",
    "7ff280fca9af45b98cee2336e78803da46b0f8a5",
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9",
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
    "9c453d4432a6ce75afab2087017781e614cc320f",
    "b980f2aa4e0191811e963ae4118c53af9cb4f1b8",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
    "9fcfbf5f51f2557566694377f94a556226585d68",
    "978012b9b6b18985fd60ec5b26c38693a6e86f9a",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
    "28bac402953a4337deedf0472611f5775c7a74c9"
  ],
  "changeHistoryShort": {
    "6926fd0ec634df2576bbc9f45e9636b99260db72": "Ybodychange",
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385": "Ybodychange",
    "95d4ec7fc07605d1ed6eabf066cd5413eb3fe465": "Ybodychange",
    "3ebe6a7819292ce6bd557e36137531b59890c845": "Ybodychange",
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3": "Ybodychange",
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "1238fa71f8e62cecde6e2437d1b83ad3922295f8": "Ybodychange",
    "64a2d5be91a7f344aadf820481c542c967bc46a8": "Ybodychange",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": "Ybodychange",
    "3cd386bd97c05f2bc5d95014f9cf34d0dc4588ee": "Ybodychange",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ybodychange",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Ybodychange",
    "7ff280fca9af45b98cee2336e78803da46b0f8a5": "Ybodychange",
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9": "Ybodychange",
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574": "Ybodychange",
    "9c453d4432a6ce75afab2087017781e614cc320f": "Ybodychange",
    "b980f2aa4e0191811e963ae4118c53af9cb4f1b8": "Ybodychange",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": "Yfilerename",
    "9fcfbf5f51f2557566694377f94a556226585d68": "Ybodychange",
    "978012b9b6b18985fd60ec5b26c38693a6e86f9a": "Ybodychange",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": "Ybodychange",
    "28bac402953a4337deedf0472611f5775c7a74c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6926fd0ec634df2576bbc9f45e9636b99260db72": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8758. Support getting PreemptionMessage when using AMRMClientAsyn. (Zian Chen via wangda)\n\nChange-Id: Ibf5d165f49957b582eeadeb41dc285c84d2f05e7\n",
      "commitDate": "04/10/18 10:31 AM",
      "commitName": "6926fd0ec634df2576bbc9f45e9636b99260db72",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "30/07/18 5:44 PM",
      "commitNameOld": "3e06a5dcea8224ba71aec284df23b47d536bb06d",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 65.7,
      "commitsBetweenForRepo": 585,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,91 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d null;\n           if (response.getCollectorInfo() !\u003d null) {\n             collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n           }\n \n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n             timelineClient.\n                 setTimelineCollectorInfo(response.getCollectorInfo());\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n+          PreemptionMessage preemptionMessage \u003d response.getPreemptionMessage();\n+          if (preemptionMessage !\u003d null) {\n+            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n+              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n+                  .onPreemptionMessageReceived(preemptionMessage);\n+            }\n+          }\n+\n           if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n             if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersReceivedFromPreviousAttempts(\n                       response.getContainersFromPreviousAttempts());\n             }\n           }\n           List\u003cRejectedSchedulingRequest\u003e rejectedSchedulingRequests \u003d\n               response.getRejectedSchedulingRequests();\n           if (!rejectedSchedulingRequests.isEmpty()) {\n             if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onRequestsRejected(rejectedSchedulingRequests);\n             }\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n            timelineClient.\n                setTimelineCollectorInfo(response.getCollectorInfo());\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          PreemptionMessage preemptionMessage \u003d response.getPreemptionMessage();\n          if (preemptionMessage !\u003d null) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onPreemptionMessageReceived(preemptionMessage);\n            }\n          }\n\n          if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersReceivedFromPreviousAttempts(\n                      response.getContainersFromPreviousAttempts());\n            }\n          }\n          List\u003cRejectedSchedulingRequest\u003e rejectedSchedulingRequests \u003d\n              response.getRejectedSchedulingRequests();\n          if (!rejectedSchedulingRequests.isEmpty()) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onRequestsRejected(rejectedSchedulingRequests);\n            }\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "29d9e4d5814900d5c59d77fe05d32186d4ad9385": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6619. AMRMClient Changes to use the PlacementConstraint and SchcedulingRequest objects. (Arun Suresh via wangda)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "29d9e4d5814900d5c59d77fe05d32186d4ad9385",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/12/17 5:10 PM",
      "commitNameOld": "95d4ec7fc07605d1ed6eabf066cd5413eb3fe465",
      "commitAuthorOld": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "daysBetweenCommits": 47.35,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,83 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d null;\n           if (response.getCollectorInfo() !\u003d null) {\n             collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n           }\n \n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n             timelineClient.\n                 setTimelineCollectorInfo(response.getCollectorInfo());\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n           if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n             if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersReceivedFromPreviousAttempts(\n                       response.getContainersFromPreviousAttempts());\n             }\n           }\n+          List\u003cRejectedSchedulingRequest\u003e rejectedSchedulingRequests \u003d\n+              response.getRejectedSchedulingRequests();\n+          if (!rejectedSchedulingRequests.isEmpty()) {\n+            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n+              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n+                  .onRequestsRejected(rejectedSchedulingRequests);\n+            }\n+          }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n            timelineClient.\n                setTimelineCollectorInfo(response.getCollectorInfo());\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersReceivedFromPreviousAttempts(\n                      response.getContainersFromPreviousAttempts());\n            }\n          }\n          List\u003cRejectedSchedulingRequest\u003e rejectedSchedulingRequests \u003d\n              response.getRejectedSchedulingRequests();\n          if (!rejectedSchedulingRequests.isEmpty()) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onRequestsRejected(rejectedSchedulingRequests);\n            }\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "95d4ec7fc07605d1ed6eabf066cd5413eb3fe465": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7565. Addendum to fix an incompatible change. Contributed by Wangda Tan.\n",
      "commitDate": "14/12/17 5:10 PM",
      "commitName": "95d4ec7fc07605d1ed6eabf066cd5413eb3fe465",
      "commitAuthor": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "commitDateOld": "12/12/17 1:35 PM",
      "commitNameOld": "3ebe6a7819292ce6bd557e36137531b59890c845",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,75 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d null;\n           if (response.getCollectorInfo() !\u003d null) {\n             collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n           }\n \n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n             timelineClient.\n                 setTimelineCollectorInfo(response.getCollectorInfo());\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n           if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n-            handler.onContainersReceivedFromPreviousAttempts(\n-                response.getContainersFromPreviousAttempts());\n+            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n+              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n+                  .onContainersReceivedFromPreviousAttempts(\n+                      response.getContainersFromPreviousAttempts());\n+            }\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n            timelineClient.\n                setTimelineCollectorInfo(response.getCollectorInfo());\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n            if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersReceivedFromPreviousAttempts(\n                      response.getContainersFromPreviousAttempts());\n            }\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "3ebe6a7819292ce6bd557e36137531b59890c845": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7565. Yarn service pre-maturely releases the container after AM restart. Contributed by Chandni Singh\n",
      "commitDate": "12/12/17 1:35 PM",
      "commitName": "3ebe6a7819292ce6bd557e36137531b59890c845",
      "commitAuthor": "Jian He",
      "commitDateOld": "31/10/17 1:09 AM",
      "commitNameOld": "c02d2ba50db8a355ea03081c3984b2ea0c375a3f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 42.56,
      "commitsBetweenForRepo": 335,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,72 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d null;\n           if (response.getCollectorInfo() !\u003d null) {\n             collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n           }\n \n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n             timelineClient.\n                 setTimelineCollectorInfo(response.getCollectorInfo());\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n+\n+          if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n+            handler.onContainersReceivedFromPreviousAttempts(\n+                response.getContainersFromPreviousAttempts());\n+          }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n            timelineClient.\n                setTimelineCollectorInfo(response.getCollectorInfo());\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          if (!response.getContainersFromPreviousAttempts().isEmpty()) {\n            handler.onContainersReceivedFromPreviousAttempts(\n                response.getContainersFromPreviousAttempts());\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6838. [ATSv2 Security] Add timeline delegation token received in allocate response to UGI. Contributed by Varun Saxena\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "08f40bcc7f4174857bb1fc7c8eb1108d5caaafb3",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,67 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d null;\n           if (response.getCollectorInfo() !\u003d null) {\n             collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n           }\n \n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n-          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n-              \u0026\u0026 !collectorAddress.isEmpty()) {\n-            if (collectorAddr \u003d\u003d null\n-                || !collectorAddr.equals(collectorAddress)) {\n-              collectorAddr \u003d collectorAddress;\n-              timelineClient.setTimelineServiceAddress(collectorAddress);\n-              LOG.info(\"collectorAddress \" + collectorAddress);\n-            }\n+          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n+            timelineClient.\n+                setTimelineCollectorInfo(response.getCollectorInfo());\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 response.getCollectorInfo() !\u003d null) {\n            timelineClient.\n                setTimelineCollectorInfo(response.getCollectorInfo());\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6130. [ATSv2 Security] Generate a delegation token for AM when app collector is created and pass it to AM via NM and RM. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "16/02/17 11:41 AM",
      "commitNameOld": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 194.43,
      "commitsBetweenForRepo": 1158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,72 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n-          String collectorAddress \u003d response.getCollectorAddr();\n+          String collectorAddress \u003d null;\n+          if (response.getCollectorInfo() !\u003d null) {\n+            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n+          }\n+\n           TimelineV2Client timelineClient \u003d\n               client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d null;\n          if (response.getCollectorInfo() !\u003d null) {\n            collectorAddress \u003d response.getCollectorInfo().getCollectorAddr();\n          }\n\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "14/02/17 6:09 AM",
      "commitNameOld": "aaf106fde35ec97e2e2ea4d7a67434038c4273ac",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.debug(\"Interrupted while waiting for queue\", ex);\n             Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d response.getCollectorAddr();\n-          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n+          TimelineV2Client timelineClient \u003d\n+              client.getRegisteredTimelineV2Client();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineV2Client timelineClient \u003d\n              client.getRegisteredTimelineV2Client();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "1238fa71f8e62cecde6e2437d1b83ad3922295f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6166. Unnecessary INFO logs in AMRMClientAsyncImpl$CallbackHandlerThread.run (Contributed by Grant Whiteheart via Daniel Templeton)\n",
      "commitDate": "10/02/17 9:46 AM",
      "commitName": "1238fa71f8e62cecde6e2437d1b83ad3922295f8",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "14/12/16 2:33 PM",
      "commitNameOld": "64a2d5be91a7f344aadf820481c542c967bc46a8",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 57.8,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           Object object;\n           try {\n             object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n-            LOG.info(\"Interrupted while waiting for queue\", ex);\n+            LOG.debug(\"Interrupted while waiting for queue\", ex);\n+            Thread.currentThread().interrupt();\n             continue;\n           }\n           if (object instanceof Throwable) {\n             progress \u003d handler.getProgress();\n             handler.onError((Throwable) object);\n             continue;\n           }\n \n           AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d response.getCollectorAddr();\n           TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.debug(\"Interrupted while waiting for queue\", ex);\n            Thread.currentThread().interrupt();\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "64a2d5be91a7f344aadf820481c542c967bc46a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5999. AMRMClientAsync will stop if any exceptions thrown on allocate call. Contributed by Jian He\n",
      "commitDate": "14/12/16 2:33 PM",
      "commitName": "64a2d5be91a7f344aadf820481c542c967bc46a8",
      "commitAuthor": "Xuan",
      "commitDateOld": "30/08/16 3:52 PM",
      "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 105.99,
      "commitsBetweenForRepo": 764,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n-          AllocateResponse response;\n-          if(savedException !\u003d null) {\n-            LOG.error(\"Stopping callback due to: \", savedException);\n-            handler.onError(savedException);\n-            return;\n-          }\n+          Object object;\n           try {\n-            response \u003d responseQueue.take();\n+            object \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n+          if (object instanceof Throwable) {\n+            progress \u003d handler.getProgress();\n+            handler.onError((Throwable) object);\n+            continue;\n+          }\n \n+          AllocateResponse response \u003d (AllocateResponse) object;\n           String collectorAddress \u003d response.getCollectorAddr();\n           TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          Object object;\n          try {\n            object \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n          if (object instanceof Throwable) {\n            progress \u003d handler.getProgress();\n            handler.onError((Throwable) object);\n            continue;\n          }\n\n          AllocateResponse response \u003d (AllocateResponse) object;\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
      "commitDate": "30/08/16 3:52 PM",
      "commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "09/08/16 9:58 AM",
      "commitNameOld": "3cd386bd97c05f2bc5d95014f9cf34d0dc4588ee",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 21.25,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,65 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n \n           String collectorAddress \u003d response.getCollectorAddr();\n           TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n-            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n-            changed.addAll(response.getIncreasedContainers());\n-            changed.addAll(response.getDecreasedContainers());\n+            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n+            changed.addAll(response.getUpdatedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n-                  .onContainersResourceChanged(changed);\n+                  .onContainersUpdated(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cUpdatedContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getUpdatedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersUpdated(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "3cd386bd97c05f2bc5d95014f9cf34d0dc4588ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5474. Typo mistake in AMRMClient#getRegisteredTimeineClient API. Contributed by Naganarasimha G R.\n",
      "commitDate": "09/08/16 9:58 AM",
      "commitName": "3cd386bd97c05f2bc5d95014f9cf34d0dc4588ee",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 30.05,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n \n           String collectorAddress \u003d response.getCollectorAddr();\n-          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n+          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n           if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n               \u0026\u0026 !collectorAddress.isEmpty()) {\n             if (collectorAddr \u003d\u003d null\n                 || !collectorAddr.equals(collectorAddress)) {\n               collectorAddr \u003d collectorAddress;\n               timelineClient.setTimelineServiceAddress(collectorAddress);\n               LOG.info(\"collectorAddress \" + collectorAddress);\n             }\n           }\n \n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getIncreasedContainers());\n             changed.addAll(response.getDecreasedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersResourceChanged(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimelineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getIncreasedContainers());\n            changed.addAll(response.getDecreasedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersResourceChanged(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n+\n+          String collectorAddress \u003d response.getCollectorAddr();\n+          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n+          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n+              \u0026\u0026 !collectorAddress.isEmpty()) {\n+            if (collectorAddr \u003d\u003d null\n+                || !collectorAddr.equals(collectorAddress)) {\n+              collectorAddr \u003d collectorAddress;\n+              timelineClient.setTimelineServiceAddress(collectorAddress);\n+              LOG.info(\"collectorAddress \" + collectorAddress);\n+            }\n+          }\n+\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getIncreasedContainers());\n             changed.addAll(response.getDecreasedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersResourceChanged(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n-\n-          String collectorAddress \u003d response.getCollectorAddr();\n-          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n-          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n-              \u0026\u0026 !collectorAddress.isEmpty()) {\n-            if (collectorAddr \u003d\u003d null ||\n-                !collectorAddr.equals(collectorAddress)) {\n-              collectorAddr \u003d collectorAddress;\n-              timelineClient.setTimelineServiceAddress(collectorAddress);\n-            }\n-          }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null\n                || !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n              LOG.info(\"collectorAddress \" + collectorAddress);\n            }\n          }\n\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getIncreasedContainers());\n            changed.addAll(response.getDecreasedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersResourceChanged(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getIncreasedContainers());\n             changed.addAll(response.getDecreasedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersResourceChanged(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n-          \n-          String aggregatorAddress \u003d response.getAggregatorAddr();\n+\n+          String collectorAddress \u003d response.getCollectorAddr();\n           TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n-          if (timelineClient !\u003d null \u0026\u0026 aggregatorAddress !\u003d null \n-              \u0026\u0026 !aggregatorAddress.isEmpty()) {\n-            if (aggregatorAddr \u003d\u003d null || \n-                !aggregatorAddr.equals(aggregatorAddress)) {\n-              aggregatorAddr \u003d aggregatorAddress;\n-              timelineClient.setTimelineServiceAddress(aggregatorAddress);\n+          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n+              \u0026\u0026 !collectorAddress.isEmpty()) {\n+            if (collectorAddr \u003d\u003d null ||\n+                !collectorAddr.equals(collectorAddress)) {\n+              collectorAddr \u003d collectorAddress;\n+              timelineClient.setTimelineServiceAddress(collectorAddress);\n             }\n           }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getIncreasedContainers());\n            changed.addAll(response.getDecreasedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersResourceChanged(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          String collectorAddress \u003d response.getCollectorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n          if (timelineClient !\u003d null \u0026\u0026 collectorAddress !\u003d null\n              \u0026\u0026 !collectorAddress.isEmpty()) {\n            if (collectorAddr \u003d\u003d null ||\n                !collectorAddr.equals(collectorAddress)) {\n              collectorAddr \u003d collectorAddress;\n              timelineClient.setTimelineServiceAddress(collectorAddress);\n            }\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "12/11/15 11:50 AM",
      "commitNameOld": "7ff280fca9af45b98cee2336e78803da46b0f8a5",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 240.83,
      "commitsBetweenForRepo": 1538,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,64 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n             // RM side of the implementation guarantees that there are\n             // no duplications between increased and decreased containers\n             List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n             changed.addAll(response.getIncreasedContainers());\n             changed.addAll(response.getDecreasedContainers());\n             if (!changed.isEmpty()) {\n               ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                   .onContainersResourceChanged(changed);\n             }\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n-\n+          \n+          String aggregatorAddress \u003d response.getAggregatorAddr();\n+          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n+          if (timelineClient !\u003d null \u0026\u0026 aggregatorAddress !\u003d null \n+              \u0026\u0026 !aggregatorAddress.isEmpty()) {\n+            if (aggregatorAddr \u003d\u003d null || \n+                !aggregatorAddr.equals(aggregatorAddress)) {\n+              aggregatorAddr \u003d aggregatorAddress;\n+              timelineClient.setTimelineServiceAddress(aggregatorAddress);\n+            }\n+          }\n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getIncreasedContainers());\n            changed.addAll(response.getDecreasedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersResourceChanged(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n          \n          String aggregatorAddress \u003d response.getAggregatorAddr();\n          TimelineClient timelineClient \u003d client.getRegisteredTimeineClient();\n          if (timelineClient !\u003d null \u0026\u0026 aggregatorAddress !\u003d null \n              \u0026\u0026 !aggregatorAddress.isEmpty()) {\n            if (aggregatorAddr \u003d\u003d null || \n                !aggregatorAddr.equals(aggregatorAddress)) {\n              aggregatorAddr \u003d aggregatorAddress;\n              timelineClient.setTimelineServiceAddress(aggregatorAddress);\n            }\n          }\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "7ff280fca9af45b98cee2336e78803da46b0f8a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1509. Make AMRMClient support send increase container request and get increased/decreased containers. (Meng Ding via wangda)\n",
      "commitDate": "12/11/15 11:50 AM",
      "commitName": "7ff280fca9af45b98cee2336e78803da46b0f8a5",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "04/02/15 12:52 PM",
      "commitNameOld": "e04e8fa8103fb58c2e449d78af6cbf5b552279f4",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 280.96,
      "commitsBetweenForRepo": 2443,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,54 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n+          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n+            // RM side of the implementation guarantees that there are\n+            // no duplications between increased and decreased containers\n+            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n+            changed.addAll(response.getIncreasedContainers());\n+            changed.addAll(response.getDecreasedContainers());\n+            if (!changed.isEmpty()) {\n+              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n+                  .onContainersResourceChanged(changed);\n+            }\n+          }\n+\n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          if (handler instanceof AMRMClientAsync.AbstractCallbackHandler) {\n            // RM side of the implementation guarantees that there are\n            // no duplications between increased and decreased containers\n            List\u003cContainer\u003e changed \u003d new ArrayList\u003c\u003e();\n            changed.addAll(response.getIncreasedContainers());\n            changed.addAll(response.getDecreasedContainers());\n            if (!changed.isEmpty()) {\n              ((AMRMClientAsync.AbstractCallbackHandler) handler)\n                  .onContainersResourceChanged(changed);\n            }\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "0f3b6900be1a3b2e4624f31f84656f4a32dadce9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2209. Replaced AM resync/shutdown command with corresponding exceptions and made related MR changes. Contributed by Jian He.\n",
      "commitDate": "23/10/14 9:56 PM",
      "commitName": "0f3b6900be1a3b2e4624f31f84656f4a32dadce9",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/07/14 11:25 AM",
      "commitNameOld": "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 106.44,
      "commitsBetweenForRepo": 1032,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,42 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n-\n-          if (response.getAMCommand() !\u003d null) {\n-            switch(response.getAMCommand()) {\n-            case AM_SHUTDOWN:\n-              handler.onShutdownRequest();\n-              LOG.info(\"Shutdown requested. Stopping callback.\");\n-              return;\n-            default:\n-              String msg \u003d\n-                    \"Unhandled value of RM AMCommand: \" + response.getAMCommand();\n-              LOG.error(msg);\n-              throw new YarnRuntimeException(msg);\n-            }\n-          }\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1366. Changed AMRMClient to re-register with RM and send outstanding requests back to RM on work-preserving RM restart. Contributed by Rohith\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1609254 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/14 11:25 AM",
      "commitName": "d751a61e5a8b65cb74f18d82f9a1249bfa5d4574",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/10/13 9:46 PM",
      "commitNameOld": "b623e188c90c53bce9aad8e52ced8b482e4dd79d",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 254.57,
      "commitsBetweenForRepo": 1681,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n     public void run() {\n       while (true) {\n         if (!keepRunning) {\n           return;\n         }\n         try {\n           AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             return;\n           }\n           try {\n             response \u003d responseQueue.take();\n           } catch (InterruptedException ex) {\n             LOG.info(\"Interrupted while waiting for queue\", ex);\n             continue;\n           }\n \n           if (response.getAMCommand() !\u003d null) {\n             switch(response.getAMCommand()) {\n-            case AM_RESYNC:\n             case AM_SHUTDOWN:\n               handler.onShutdownRequest();\n               LOG.info(\"Shutdown requested. Stopping callback.\");\n               return;\n             default:\n               String msg \u003d\n                     \"Unhandled value of RM AMCommand: \" + response.getAMCommand();\n               LOG.error(msg);\n               throw new YarnRuntimeException(msg);\n             }\n           }\n           List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n           if (!updatedNodes.isEmpty()) {\n             handler.onNodesUpdated(updatedNodes);\n           }\n \n           List\u003cContainerStatus\u003e completed \u003d\n               response.getCompletedContainersStatuses();\n           if (!completed.isEmpty()) {\n             handler.onContainersCompleted(completed);\n           }\n \n           List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n           if (!allocated.isEmpty()) {\n             handler.onContainersAllocated(allocated);\n           }\n \n           progress \u003d handler.getProgress();\n         } catch (Throwable ex) {\n           handler.onError(ex);\n           // re-throw exception to end the thread\n           throw new YarnRuntimeException(ex);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n\n          if (response.getAMCommand() !\u003d null) {\n            switch(response.getAMCommand()) {\n            case AM_SHUTDOWN:\n              handler.onShutdownRequest();\n              LOG.info(\"Shutdown requested. Stopping callback.\");\n              return;\n            default:\n              String msg \u003d\n                    \"Unhandled value of RM AMCommand: \" + response.getAMCommand();\n              LOG.error(msg);\n              throw new YarnRuntimeException(msg);\n            }\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "9c453d4432a6ce75afab2087017781e614cc320f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-875. Application can hang if AMRMClientAsync callback thread has exception (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506750 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/13 3:13 PM",
      "commitName": "9c453d4432a6ce75afab2087017781e614cc320f",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "18/07/13 5:57 PM",
      "commitNameOld": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 5.89,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,57 @@\n     public void run() {\n-      while (keepRunning) {\n-        AllocateResponse response;\n+      while (true) {\n+        if (!keepRunning) {\n+          return;\n+        }\n         try {\n+          AllocateResponse response;\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n-            break;\n-          }\n-          response \u003d responseQueue.take();\n-        } catch (InterruptedException ex) {\n-          LOG.info(\"Interrupted while waiting for queue\", ex);\n-          continue;\n-        }\n-\n-        if (response.getAMCommand() !\u003d null) {\n-          switch(response.getAMCommand()) {\n-          case AM_RESYNC:\n-          case AM_SHUTDOWN:\n-            handler.onShutdownRequest();\n-            LOG.info(\"Shutdown requested. Stopping callback.\");\n             return;\n-          default:\n-            String msg \u003d\n-                  \"Unhandled value of AMCommand: \" + response.getAMCommand();\n-            LOG.error(msg);\n-            throw new YarnRuntimeException(msg);\n           }\n-        }\n-        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n-        if (!updatedNodes.isEmpty()) {\n-          handler.onNodesUpdated(updatedNodes);\n-        }\n-        \n-        List\u003cContainerStatus\u003e completed \u003d\n-            response.getCompletedContainersStatuses();\n-        if (!completed.isEmpty()) {\n-          handler.onContainersCompleted(completed);\n-        }\n+          try {\n+            response \u003d responseQueue.take();\n+          } catch (InterruptedException ex) {\n+            LOG.info(\"Interrupted while waiting for queue\", ex);\n+            continue;\n+          }\n \n-        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n-        if (!allocated.isEmpty()) {\n-          handler.onContainersAllocated(allocated);\n+          if (response.getAMCommand() !\u003d null) {\n+            switch(response.getAMCommand()) {\n+            case AM_RESYNC:\n+            case AM_SHUTDOWN:\n+              handler.onShutdownRequest();\n+              LOG.info(\"Shutdown requested. Stopping callback.\");\n+              return;\n+            default:\n+              String msg \u003d\n+                    \"Unhandled value of RM AMCommand: \" + response.getAMCommand();\n+              LOG.error(msg);\n+              throw new YarnRuntimeException(msg);\n+            }\n+          }\n+          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n+          if (!updatedNodes.isEmpty()) {\n+            handler.onNodesUpdated(updatedNodes);\n+          }\n+\n+          List\u003cContainerStatus\u003e completed \u003d\n+              response.getCompletedContainersStatuses();\n+          if (!completed.isEmpty()) {\n+            handler.onContainersCompleted(completed);\n+          }\n+\n+          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n+          if (!allocated.isEmpty()) {\n+            handler.onContainersAllocated(allocated);\n+          }\n+\n+          progress \u003d handler.getProgress();\n+        } catch (Throwable ex) {\n+          handler.onError(ex);\n+          // re-throw exception to end the thread\n+          throw new YarnRuntimeException(ex);\n         }\n-        \n-        progress \u003d handler.getProgress();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (true) {\n        if (!keepRunning) {\n          return;\n        }\n        try {\n          AllocateResponse response;\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            return;\n          }\n          try {\n            response \u003d responseQueue.take();\n          } catch (InterruptedException ex) {\n            LOG.info(\"Interrupted while waiting for queue\", ex);\n            continue;\n          }\n\n          if (response.getAMCommand() !\u003d null) {\n            switch(response.getAMCommand()) {\n            case AM_RESYNC:\n            case AM_SHUTDOWN:\n              handler.onShutdownRequest();\n              LOG.info(\"Shutdown requested. Stopping callback.\");\n              return;\n            default:\n              String msg \u003d\n                    \"Unhandled value of RM AMCommand: \" + response.getAMCommand();\n              LOG.error(msg);\n              throw new YarnRuntimeException(msg);\n            }\n          }\n          List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n          if (!updatedNodes.isEmpty()) {\n            handler.onNodesUpdated(updatedNodes);\n          }\n\n          List\u003cContainerStatus\u003e completed \u003d\n              response.getCompletedContainersStatuses();\n          if (!completed.isEmpty()) {\n            handler.onContainersCompleted(completed);\n          }\n\n          List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n          if (!allocated.isEmpty()) {\n            handler.onContainersAllocated(allocated);\n          }\n\n          progress \u003d handler.getProgress();\n        } catch (Throwable ex) {\n          handler.onError(ex);\n          // re-throw exception to end the thread\n          throw new YarnRuntimeException(ex);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "b980f2aa4e0191811e963ae4118c53af9cb4f1b8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-763. AMRMClientAsync should stop heartbeating after receiving shutdown from RM (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502914 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/07/13 4:30 PM",
      "commitName": "b980f2aa4e0191811e963ae4118c53af9cb4f1b8",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "20/06/13 5:08 PM",
      "commitNameOld": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 22.97,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,48 @@\n     public void run() {\n       while (keepRunning) {\n         AllocateResponse response;\n         try {\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             break;\n           }\n           response \u003d responseQueue.take();\n         } catch (InterruptedException ex) {\n           LOG.info(\"Interrupted while waiting for queue\", ex);\n           continue;\n         }\n \n         if (response.getAMCommand() !\u003d null) {\n-          boolean stop \u003d false;\n           switch(response.getAMCommand()) {\n           case AM_RESYNC:\n           case AM_SHUTDOWN:\n             handler.onShutdownRequest();\n             LOG.info(\"Shutdown requested. Stopping callback.\");\n-            stop \u003d true;\n-            break;\n+            return;\n           default:\n             String msg \u003d\n                   \"Unhandled value of AMCommand: \" + response.getAMCommand();\n             LOG.error(msg);\n             throw new YarnRuntimeException(msg);\n           }\n-          if(stop) {\n-            // should probably stop heartbeating also YARN-763\n-            break;\n-          }\n         }\n         List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n         if (!updatedNodes.isEmpty()) {\n           handler.onNodesUpdated(updatedNodes);\n         }\n         \n         List\u003cContainerStatus\u003e completed \u003d\n             response.getCompletedContainersStatuses();\n         if (!completed.isEmpty()) {\n           handler.onContainersCompleted(completed);\n         }\n \n         List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n         if (!allocated.isEmpty()) {\n           handler.onContainersAllocated(allocated);\n         }\n         \n         progress \u003d handler.getProgress();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            break;\n          }\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\", ex);\n          continue;\n        }\n\n        if (response.getAMCommand() !\u003d null) {\n          switch(response.getAMCommand()) {\n          case AM_RESYNC:\n          case AM_SHUTDOWN:\n            handler.onShutdownRequest();\n            LOG.info(\"Shutdown requested. Stopping callback.\");\n            return;\n          default:\n            String msg \u003d\n                  \"Unhandled value of AMCommand: \" + response.getAMCommand();\n            LOG.error(msg);\n            throw new YarnRuntimeException(msg);\n          }\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n        \n        progress \u003d handler.getProgress();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {}
    },
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": {
      "type": "Yfilerename",
      "commitMessage": "YARN-834. Fixed annotations for yarn-client module, reorganized packages and clearly differentiated *Async apis. Contributed by Arun C Murthy and Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 9:02 PM",
      "commitName": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 8:10 PM",
      "commitNameOld": "2b14656ab5050dd75935b64681cdc25fb49db94f",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            break;\n          }\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\", ex);\n          continue;\n        }\n\n        if (response.getAMCommand() !\u003d null) {\n          boolean stop \u003d false;\n          switch(response.getAMCommand()) {\n          case AM_RESYNC:\n          case AM_SHUTDOWN:\n            handler.onShutdownRequest();\n            LOG.info(\"Shutdown requested. Stopping callback.\");\n            stop \u003d true;\n            break;\n          default:\n            String msg \u003d\n                  \"Unhandled value of AMCommand: \" + response.getAMCommand();\n            LOG.error(msg);\n            throw new YarnRuntimeException(msg);\n          }\n          if(stop) {\n            // should probably stop heartbeating also YARN-763\n            break;\n          }\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n        \n        progress \u003d handler.getProgress();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientAsync.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/async/impl/AMRMClientAsyncImpl.java"
      }
    },
    "9fcfbf5f51f2557566694377f94a556226585d68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-759. Create Command enum in AllocateResponse (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490470 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 4:33 PM",
      "commitName": "9fcfbf5f51f2557566694377f94a556226585d68",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "03/06/13 10:53 PM",
      "commitNameOld": "978012b9b6b18985fd60ec5b26c38693a6e86f9a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.74,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,54 @@\n     public void run() {\n       while (keepRunning) {\n         AllocateResponse response;\n         try {\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             break;\n           }\n           response \u003d responseQueue.take();\n         } catch (InterruptedException ex) {\n           LOG.info(\"Interrupted while waiting for queue\", ex);\n           continue;\n         }\n \n-        if (response.getResync()) {\n-          handler.onRebootRequest();\n-          LOG.info(\"Reboot requested. Stopping callback.\");\n-          break;\n+        if (response.getAMCommand() !\u003d null) {\n+          boolean stop \u003d false;\n+          switch(response.getAMCommand()) {\n+          case AM_RESYNC:\n+          case AM_SHUTDOWN:\n+            handler.onShutdownRequest();\n+            LOG.info(\"Shutdown requested. Stopping callback.\");\n+            stop \u003d true;\n+            break;\n+          default:\n+            String msg \u003d\n+                  \"Unhandled value of AMCommand: \" + response.getAMCommand();\n+            LOG.error(msg);\n+            throw new YarnRuntimeException(msg);\n+          }\n+          if(stop) {\n+            // should probably stop heartbeating also YARN-763\n+            break;\n+          }\n         }\n         List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n         if (!updatedNodes.isEmpty()) {\n           handler.onNodesUpdated(updatedNodes);\n         }\n         \n         List\u003cContainerStatus\u003e completed \u003d\n             response.getCompletedContainersStatuses();\n         if (!completed.isEmpty()) {\n           handler.onContainersCompleted(completed);\n         }\n \n         List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n         if (!allocated.isEmpty()) {\n           handler.onContainersAllocated(allocated);\n         }\n         \n         progress \u003d handler.getProgress();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            break;\n          }\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\", ex);\n          continue;\n        }\n\n        if (response.getAMCommand() !\u003d null) {\n          boolean stop \u003d false;\n          switch(response.getAMCommand()) {\n          case AM_RESYNC:\n          case AM_SHUTDOWN:\n            handler.onShutdownRequest();\n            LOG.info(\"Shutdown requested. Stopping callback.\");\n            stop \u003d true;\n            break;\n          default:\n            String msg \u003d\n                  \"Unhandled value of AMCommand: \" + response.getAMCommand();\n            LOG.error(msg);\n            throw new YarnRuntimeException(msg);\n          }\n          if(stop) {\n            // should probably stop heartbeating also YARN-763\n            break;\n          }\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n        \n        progress \u003d handler.getProgress();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientAsync.java",
      "extendedDetails": {}
    },
    "978012b9b6b18985fd60ec5b26c38693a6e86f9a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-755. Renamed AllocateResponse.reboot to AllocateResponse.resync. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:53 PM",
      "commitName": "978012b9b6b18985fd60ec5b26c38693a6e86f9a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     public void run() {\n       while (keepRunning) {\n         AllocateResponse response;\n         try {\n           if(savedException !\u003d null) {\n             LOG.error(\"Stopping callback due to: \", savedException);\n             handler.onError(savedException);\n             break;\n           }\n           response \u003d responseQueue.take();\n         } catch (InterruptedException ex) {\n           LOG.info(\"Interrupted while waiting for queue\", ex);\n           continue;\n         }\n \n-        if (response.getReboot()) {\n+        if (response.getResync()) {\n           handler.onRebootRequest();\n           LOG.info(\"Reboot requested. Stopping callback.\");\n           break;\n         }\n         List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n         if (!updatedNodes.isEmpty()) {\n           handler.onNodesUpdated(updatedNodes);\n         }\n         \n         List\u003cContainerStatus\u003e completed \u003d\n             response.getCompletedContainersStatuses();\n         if (!completed.isEmpty()) {\n           handler.onContainersCompleted(completed);\n         }\n \n         List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n         if (!allocated.isEmpty()) {\n           handler.onContainersAllocated(allocated);\n         }\n         \n         progress \u003d handler.getProgress();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            break;\n          }\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\", ex);\n          continue;\n        }\n\n        if (response.getResync()) {\n          handler.onRebootRequest();\n          LOG.info(\"Reboot requested. Stopping callback.\");\n          break;\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n        \n        progress \u003d handler.getProgress();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientAsync.java",
      "extendedDetails": {}
    },
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-660. Improve AMRMClient with matching requests (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 1:23 AM",
      "commitName": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "08/05/13 10:32 PM",
      "commitNameOld": "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 23.12,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,39 @@\n     public void run() {\n       while (keepRunning) {\n         AllocateResponse response;\n         try {\n+          if(savedException !\u003d null) {\n+            LOG.error(\"Stopping callback due to: \", savedException);\n+            handler.onError(savedException);\n+            break;\n+          }\n           response \u003d responseQueue.take();\n         } catch (InterruptedException ex) {\n-          LOG.info(\"Interrupted while waiting for queue\");\n+          LOG.info(\"Interrupted while waiting for queue\", ex);\n           continue;\n         }\n \n         if (response.getReboot()) {\n           handler.onRebootRequest();\n+          LOG.info(\"Reboot requested. Stopping callback.\");\n+          break;\n         }\n         List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n         if (!updatedNodes.isEmpty()) {\n           handler.onNodesUpdated(updatedNodes);\n         }\n         \n         List\u003cContainerStatus\u003e completed \u003d\n             response.getCompletedContainersStatuses();\n         if (!completed.isEmpty()) {\n           handler.onContainersCompleted(completed);\n         }\n \n         List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n         if (!allocated.isEmpty()) {\n           handler.onContainersAllocated(allocated);\n         }\n+        \n+        progress \u003d handler.getProgress();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          if(savedException !\u003d null) {\n            LOG.error(\"Stopping callback due to: \", savedException);\n            handler.onError(savedException);\n            break;\n          }\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\", ex);\n          continue;\n        }\n\n        if (response.getReboot()) {\n          handler.onRebootRequest();\n          LOG.info(\"Reboot requested. Stopping callback.\");\n          break;\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n        \n        progress \u003d handler.getProgress();\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientAsync.java",
      "extendedDetails": {}
    },
    "28bac402953a4337deedf0472611f5775c7a74c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-417. Create AMRMClient wrapper that provides asynchronous callbacks. (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459555 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 3:26 PM",
      "commitName": "28bac402953a4337deedf0472611f5775c7a74c9",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,30 @@\n+    public void run() {\n+      while (keepRunning) {\n+        AllocateResponse response;\n+        try {\n+          response \u003d responseQueue.take();\n+        } catch (InterruptedException ex) {\n+          LOG.info(\"Interrupted while waiting for queue\");\n+          continue;\n+        }\n+\n+        if (response.getReboot()) {\n+          handler.onRebootRequest();\n+        }\n+        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n+        if (!updatedNodes.isEmpty()) {\n+          handler.onNodesUpdated(updatedNodes);\n+        }\n+        \n+        List\u003cContainerStatus\u003e completed \u003d\n+            response.getCompletedContainersStatuses();\n+        if (!completed.isEmpty()) {\n+          handler.onContainersCompleted(completed);\n+        }\n+\n+        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n+        if (!allocated.isEmpty()) {\n+          handler.onContainersAllocated(allocated);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      while (keepRunning) {\n        AllocateResponse response;\n        try {\n          response \u003d responseQueue.take();\n        } catch (InterruptedException ex) {\n          LOG.info(\"Interrupted while waiting for queue\");\n          continue;\n        }\n\n        if (response.getReboot()) {\n          handler.onRebootRequest();\n        }\n        List\u003cNodeReport\u003e updatedNodes \u003d response.getUpdatedNodes();\n        if (!updatedNodes.isEmpty()) {\n          handler.onNodesUpdated(updatedNodes);\n        }\n        \n        List\u003cContainerStatus\u003e completed \u003d\n            response.getCompletedContainersStatuses();\n        if (!completed.isEmpty()) {\n          handler.onContainersCompleted(completed);\n        }\n\n        List\u003cContainer\u003e allocated \u003d response.getAllocatedContainers();\n        if (!allocated.isEmpty()) {\n          handler.onContainersAllocated(allocated);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientAsync.java"
    }
  }
}