{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HBaseTimelineSchemaCreator.java",
  "functionName": "createTimelineSchema",
  "functionId": "createTimelineSchema___args-String[]",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineSchemaCreator.java",
  "functionStartLine": 77,
  "functionEndLine": 152,
  "numCommitsSeen": 2,
  "timeTaken": 481,
  "changeHistory": [
    "713ded6b15dc0b5e4205a7812a62225377e0b32b"
  ],
  "changeHistoryShort": {
    "713ded6b15dc0b5e4205a7812a62225377e0b32b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "713ded6b15dc0b5e4205a7812a62225377e0b32b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-9150 Making TimelineSchemaCreator support different backends for Timeline Schema Creation in ATSv2. Contributed by Sushil Ks\n",
      "commitDate": "15/01/19 9:28 PM",
      "commitName": "713ded6b15dc0b5e4205a7812a62225377e0b32b",
      "commitAuthor": "Vrushali C",
      "diff": "@@ -0,0 +1,76 @@\n+  public void createTimelineSchema(String[] args) throws Exception {\n+\n+    LOG.info(\"Starting the schema creation\");\n+    Configuration hbaseConf \u003d\n+        HBaseTimelineStorageUtils.getTimelineServiceHBaseConf(\n+            new YarnConfiguration());\n+    // Grab input args and allow for -Dxyz style arguments\n+    String[] otherArgs \u003d new GenericOptionsParser(hbaseConf, args)\n+        .getRemainingArgs();\n+\n+    // Grab the arguments we\u0027re looking for.\n+    CommandLine commandLine \u003d parseArgs(otherArgs);\n+\n+    if (commandLine.hasOption(HELP_SHORT)) {\n+      // -help option has the highest precedence\n+      printUsage();\n+    } else if (commandLine.hasOption(CREATE_TABLES_SHORT)) {\n+      // Grab the entityTableName argument\n+      String entityTableName \u003d commandLine.getOptionValue(\n+          ENTITY_TABLE_NAME_SHORT);\n+      if (StringUtils.isNotBlank(entityTableName)) {\n+        hbaseConf.set(EntityTableRW.TABLE_NAME_CONF_NAME, entityTableName);\n+      }\n+      // Grab the entity metrics TTL\n+      String entityTableMetricsTTL \u003d commandLine.getOptionValue(\n+          ENTITY_METRICS_TTL_OPTION_SHORT);\n+      if (StringUtils.isNotBlank(entityTableMetricsTTL)) {\n+        int entityMetricsTTL \u003d Integer.parseInt(entityTableMetricsTTL);\n+        new EntityTableRW().setMetricsTTL(entityMetricsTTL, hbaseConf);\n+      }\n+      // Grab the appToflowTableName argument\n+      String appToflowTableName \u003d commandLine.getOptionValue(\n+          APP_TO_FLOW_TABLE_NAME_SHORT);\n+      if (StringUtils.isNotBlank(appToflowTableName)) {\n+        hbaseConf.set(\n+            AppToFlowTableRW.TABLE_NAME_CONF_NAME, appToflowTableName);\n+      }\n+      // Grab the applicationTableName argument\n+      String applicationTableName \u003d commandLine.getOptionValue(\n+          APP_TABLE_NAME_SHORT);\n+      if (StringUtils.isNotBlank(applicationTableName)) {\n+        hbaseConf.set(ApplicationTableRW.TABLE_NAME_CONF_NAME,\n+            applicationTableName);\n+      }\n+      // Grab the application metrics TTL\n+      String applicationTableMetricsTTL \u003d commandLine.getOptionValue(\n+          APP_METRICS_TTL_OPTION_SHORT);\n+      if (StringUtils.isNotBlank(applicationTableMetricsTTL)) {\n+        int appMetricsTTL \u003d Integer.parseInt(applicationTableMetricsTTL);\n+        new ApplicationTableRW().setMetricsTTL(appMetricsTTL, hbaseConf);\n+      }\n+\n+      // Grab the subApplicationTableName argument\n+      String subApplicationTableName \u003d commandLine.getOptionValue(\n+          SUB_APP_TABLE_NAME_SHORT);\n+      if (StringUtils.isNotBlank(subApplicationTableName)) {\n+        hbaseConf.set(SubApplicationTableRW.TABLE_NAME_CONF_NAME,\n+            subApplicationTableName);\n+      }\n+      // Grab the subApplication metrics TTL\n+      String subApplicationTableMetricsTTL \u003d commandLine\n+          .getOptionValue(SUB_APP_METRICS_TTL_OPTION_SHORT);\n+      if (StringUtils.isNotBlank(subApplicationTableMetricsTTL)) {\n+        int subAppMetricsTTL \u003d Integer.parseInt(subApplicationTableMetricsTTL);\n+        new SubApplicationTableRW().setMetricsTTL(subAppMetricsTTL, hbaseConf);\n+      }\n+\n+      // create all table schemas in hbase\n+      final boolean skipExisting \u003d commandLine.hasOption(\n+          SKIP_EXISTING_TABLE_OPTION_SHORT);\n+      createAllSchemas(hbaseConf, skipExisting);\n+    } else {\n+      // print usage information if -create is not specified\n+      printUsage();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void createTimelineSchema(String[] args) throws Exception {\n\n    LOG.info(\"Starting the schema creation\");\n    Configuration hbaseConf \u003d\n        HBaseTimelineStorageUtils.getTimelineServiceHBaseConf(\n            new YarnConfiguration());\n    // Grab input args and allow for -Dxyz style arguments\n    String[] otherArgs \u003d new GenericOptionsParser(hbaseConf, args)\n        .getRemainingArgs();\n\n    // Grab the arguments we\u0027re looking for.\n    CommandLine commandLine \u003d parseArgs(otherArgs);\n\n    if (commandLine.hasOption(HELP_SHORT)) {\n      // -help option has the highest precedence\n      printUsage();\n    } else if (commandLine.hasOption(CREATE_TABLES_SHORT)) {\n      // Grab the entityTableName argument\n      String entityTableName \u003d commandLine.getOptionValue(\n          ENTITY_TABLE_NAME_SHORT);\n      if (StringUtils.isNotBlank(entityTableName)) {\n        hbaseConf.set(EntityTableRW.TABLE_NAME_CONF_NAME, entityTableName);\n      }\n      // Grab the entity metrics TTL\n      String entityTableMetricsTTL \u003d commandLine.getOptionValue(\n          ENTITY_METRICS_TTL_OPTION_SHORT);\n      if (StringUtils.isNotBlank(entityTableMetricsTTL)) {\n        int entityMetricsTTL \u003d Integer.parseInt(entityTableMetricsTTL);\n        new EntityTableRW().setMetricsTTL(entityMetricsTTL, hbaseConf);\n      }\n      // Grab the appToflowTableName argument\n      String appToflowTableName \u003d commandLine.getOptionValue(\n          APP_TO_FLOW_TABLE_NAME_SHORT);\n      if (StringUtils.isNotBlank(appToflowTableName)) {\n        hbaseConf.set(\n            AppToFlowTableRW.TABLE_NAME_CONF_NAME, appToflowTableName);\n      }\n      // Grab the applicationTableName argument\n      String applicationTableName \u003d commandLine.getOptionValue(\n          APP_TABLE_NAME_SHORT);\n      if (StringUtils.isNotBlank(applicationTableName)) {\n        hbaseConf.set(ApplicationTableRW.TABLE_NAME_CONF_NAME,\n            applicationTableName);\n      }\n      // Grab the application metrics TTL\n      String applicationTableMetricsTTL \u003d commandLine.getOptionValue(\n          APP_METRICS_TTL_OPTION_SHORT);\n      if (StringUtils.isNotBlank(applicationTableMetricsTTL)) {\n        int appMetricsTTL \u003d Integer.parseInt(applicationTableMetricsTTL);\n        new ApplicationTableRW().setMetricsTTL(appMetricsTTL, hbaseConf);\n      }\n\n      // Grab the subApplicationTableName argument\n      String subApplicationTableName \u003d commandLine.getOptionValue(\n          SUB_APP_TABLE_NAME_SHORT);\n      if (StringUtils.isNotBlank(subApplicationTableName)) {\n        hbaseConf.set(SubApplicationTableRW.TABLE_NAME_CONF_NAME,\n            subApplicationTableName);\n      }\n      // Grab the subApplication metrics TTL\n      String subApplicationTableMetricsTTL \u003d commandLine\n          .getOptionValue(SUB_APP_METRICS_TTL_OPTION_SHORT);\n      if (StringUtils.isNotBlank(subApplicationTableMetricsTTL)) {\n        int subAppMetricsTTL \u003d Integer.parseInt(subApplicationTableMetricsTTL);\n        new SubApplicationTableRW().setMetricsTTL(subAppMetricsTTL, hbaseConf);\n      }\n\n      // create all table schemas in hbase\n      final boolean skipExisting \u003d commandLine.hasOption(\n          SKIP_EXISTING_TABLE_OPTION_SHORT);\n      createAllSchemas(hbaseConf, skipExisting);\n    } else {\n      // print usage information if -create is not specified\n      printUsage();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineSchemaCreator.java"
    }
  }
}