{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockBlobAppendStream.java",
  "functionName": "setBlocksCountAndBlockIdPrefix",
  "functionId": "setBlocksCountAndBlockIdPrefix___blockEntries-List__BlockEntry__",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
  "functionStartLine": 628,
  "functionEndLine": 662,
  "numCommitsSeen": 12,
  "timeTaken": 3886,
  "changeHistory": [
    "13eda5000304099d1145631f9be13ce8a00b600d",
    "b43de80031d1272e8a08ea5bd31027efe45e9d70",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9"
  ],
  "changeHistoryShort": {
    "13eda5000304099d1145631f9be13ce8a00b600d": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "b43de80031d1272e8a08ea5bd31027efe45e9d70": "Ymultichange(Yrename,Ybodychange)",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "13eda5000304099d1145631f9be13ce8a00b600d": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
      "commitDate": "07/09/17 10:35 AM",
      "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
          "commitDate": "07/09/17 10:35 AM",
          "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "03/04/17 8:13 PM",
          "commitNameOld": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 156.6,
          "commitsBetweenForRepo": 957,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,35 @@\n-  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n+  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n \n-    try {\n+    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n \n-      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n+      Random sequenceGenerator \u003d new Random();\n \n-        List\u003cBlockEntry\u003e blockEntries \u003d\n-            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n+      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n+          ? blockEntries.get(0).getId()\n+          : \"\";\n+      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n+      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n+          0);\n \n-        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n-        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n-        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n+      if (!blockEntries.isEmpty()\n+          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n \n-        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n+        // If blob has already been created with 2.2.0, append subsequent blocks\n+        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n+        // was done before; and don\u0027t use blockIdPrefix\n+        this.blockIdPrefix \u003d \"\";\n+        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+            + sequenceGenerator.nextInt(\n+                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+        nextBlockCount +\u003d blockEntries.size();\n \n-          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n-          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n-          this.blockIdPrefix \u003d \"\";\n-          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n-              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n-          nextBlockCount +\u003d blockEntries.size();\n+      } else {\n \n-        } else {\n-\n-          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n-          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n-          this.blockIdPrefix \u003d prefix;\n-          nextBlockCount \u003d blockEntries.size();\n-\n-        }\n-\n+        // If there are no existing blocks, create the first block with newer\n+        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n+        // append subsequent blocks with newer version (4.2.0) blockId\n+        this.blockIdPrefix \u003d prefix;\n+        nextBlockCount \u003d blockEntries.size();\n       }\n-\n-    } catch (StorageException ex) {\n-      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n-          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n-      throw new IOException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n\n    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n\n      Random sequenceGenerator \u003d new Random();\n\n      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n          ? blockEntries.get(0).getId()\n          : \"\";\n      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n          0);\n\n      if (!blockEntries.isEmpty()\n          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n\n        // If blob has already been created with 2.2.0, append subsequent blocks\n        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n        // was done before; and don\u0027t use blockIdPrefix\n        this.blockIdPrefix \u003d \"\";\n        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n            + sequenceGenerator.nextInt(\n                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n        nextBlockCount +\u003d blockEntries.size();\n\n      } else {\n\n        // If there are no existing blocks, create the first block with newer\n        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n        // append subsequent blocks with newer version (4.2.0) blockId\n        this.blockIdPrefix \u003d prefix;\n        nextBlockCount \u003d blockEntries.size();\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[blockEntries-List\u003cBlockEntry\u003e]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
          "commitDate": "07/09/17 10:35 AM",
          "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "03/04/17 8:13 PM",
          "commitNameOld": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 156.6,
          "commitsBetweenForRepo": 957,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,35 @@\n-  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n+  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n \n-    try {\n+    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n \n-      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n+      Random sequenceGenerator \u003d new Random();\n \n-        List\u003cBlockEntry\u003e blockEntries \u003d\n-            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n+      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n+          ? blockEntries.get(0).getId()\n+          : \"\";\n+      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n+      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n+          0);\n \n-        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n-        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n-        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n+      if (!blockEntries.isEmpty()\n+          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n \n-        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n+        // If blob has already been created with 2.2.0, append subsequent blocks\n+        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n+        // was done before; and don\u0027t use blockIdPrefix\n+        this.blockIdPrefix \u003d \"\";\n+        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+            + sequenceGenerator.nextInt(\n+                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+        nextBlockCount +\u003d blockEntries.size();\n \n-          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n-          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n-          this.blockIdPrefix \u003d \"\";\n-          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n-              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n-          nextBlockCount +\u003d blockEntries.size();\n+      } else {\n \n-        } else {\n-\n-          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n-          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n-          this.blockIdPrefix \u003d prefix;\n-          nextBlockCount \u003d blockEntries.size();\n-\n-        }\n-\n+        // If there are no existing blocks, create the first block with newer\n+        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n+        // append subsequent blocks with newer version (4.2.0) blockId\n+        this.blockIdPrefix \u003d prefix;\n+        nextBlockCount \u003d blockEntries.size();\n       }\n-\n-    } catch (StorageException ex) {\n-      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n-          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n-      throw new IOException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n\n    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n\n      Random sequenceGenerator \u003d new Random();\n\n      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n          ? blockEntries.get(0).getId()\n          : \"\";\n      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n          0);\n\n      if (!blockEntries.isEmpty()\n          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n\n        // If blob has already been created with 2.2.0, append subsequent blocks\n        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n        // was done before; and don\u0027t use blockIdPrefix\n        this.blockIdPrefix \u003d \"\";\n        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n            + sequenceGenerator.nextInt(\n                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n        nextBlockCount +\u003d blockEntries.size();\n\n      } else {\n\n        // If there are no existing blocks, create the first block with newer\n        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n        // append subsequent blocks with newer version (4.2.0) blockId\n        this.blockIdPrefix \u003d prefix;\n        nextBlockCount \u003d blockEntries.size();\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
          "commitDate": "07/09/17 10:35 AM",
          "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "03/04/17 8:13 PM",
          "commitNameOld": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 156.6,
          "commitsBetweenForRepo": 957,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,35 @@\n-  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n+  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n \n-    try {\n+    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n \n-      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n+      Random sequenceGenerator \u003d new Random();\n \n-        List\u003cBlockEntry\u003e blockEntries \u003d\n-            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n+      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n+          ? blockEntries.get(0).getId()\n+          : \"\";\n+      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n+      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n+          0);\n \n-        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n-        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n-        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n+      if (!blockEntries.isEmpty()\n+          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n \n-        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n+        // If blob has already been created with 2.2.0, append subsequent blocks\n+        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n+        // was done before; and don\u0027t use blockIdPrefix\n+        this.blockIdPrefix \u003d \"\";\n+        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+            + sequenceGenerator.nextInt(\n+                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+        nextBlockCount +\u003d blockEntries.size();\n \n-          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n-          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n-          this.blockIdPrefix \u003d \"\";\n-          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n-              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n-          nextBlockCount +\u003d blockEntries.size();\n+      } else {\n \n-        } else {\n-\n-          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n-          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n-          this.blockIdPrefix \u003d prefix;\n-          nextBlockCount \u003d blockEntries.size();\n-\n-        }\n-\n+        // If there are no existing blocks, create the first block with newer\n+        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n+        // append subsequent blocks with newer version (4.2.0) blockId\n+        this.blockIdPrefix \u003d prefix;\n+        nextBlockCount \u003d blockEntries.size();\n       }\n-\n-    } catch (StorageException ex) {\n-      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n-          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n-      throw new IOException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setBlocksCountAndBlockIdPrefix(List\u003cBlockEntry\u003e blockEntries) {\n\n    if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix \u003d\u003d null) {\n\n      Random sequenceGenerator \u003d new Random();\n\n      String blockZeroBlockId \u003d (!blockEntries.isEmpty())\n          ? blockEntries.get(0).getId()\n          : \"\";\n      String prefix \u003d UUID.randomUUID().toString() + \"-\";\n      String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix,\n          0);\n\n      if (!blockEntries.isEmpty()\n          \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n\n        // If blob has already been created with 2.2.0, append subsequent blocks\n        // with older version (2.2.0) blockId compute nextBlockCount, the way it\n        // was done before; and don\u0027t use blockIdPrefix\n        this.blockIdPrefix \u003d \"\";\n        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n            + sequenceGenerator.nextInt(\n                Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n        nextBlockCount +\u003d blockEntries.size();\n\n      } else {\n\n        // If there are no existing blocks, create the first block with newer\n        // version (4.2.0) blockId. If blob has already been created with 4.2.0,\n        // append subsequent blocks with newer version (4.2.0) blockId\n        this.blockIdPrefix \u003d prefix;\n        nextBlockCount \u003d blockEntries.size();\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "b43de80031d1272e8a08ea5bd31027efe45e9d70": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HADOOP-13354. Update WASB driver to use the latest version (4.2.0) of SDK for Microsoft Azure Storage Clients. Contributed by Sivaguru Sankaridurg.\n",
      "commitDate": "27/07/16 3:50 PM",
      "commitName": "b43de80031d1272e8a08ea5bd31027efe45e9d70",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-13354. Update WASB driver to use the latest version (4.2.0) of SDK for Microsoft Azure Storage Clients. Contributed by Sivaguru Sankaridurg.\n",
          "commitDate": "27/07/16 3:50 PM",
          "commitName": "b43de80031d1272e8a08ea5bd31027efe45e9d70",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "18/01/16 9:08 AM",
          "commitNameOld": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 191.24,
          "commitsBetweenForRepo": 1373,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,39 @@\n-  private void setBlocksCount() throws IOException {\n+  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n+\n     try {\n \n-      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT) {\n-\n-        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n-            + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n \n         List\u003cBlockEntry\u003e blockEntries \u003d\n             blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n \n-        nextBlockCount +\u003d blockEntries.size();\n+        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n+        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n+        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n+\n+        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n+\n+          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n+          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n+          this.blockIdPrefix \u003d \"\";\n+          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+          nextBlockCount +\u003d blockEntries.size();\n+\n+        } else {\n+\n+          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n+          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n+          this.blockIdPrefix \u003d prefix;\n+          nextBlockCount \u003d blockEntries.size();\n+\n+        }\n \n       }\n+\n     } catch (StorageException ex) {\n-      LOG.debug(\"Encountered storage exception during setting next Block Count.\"\n+      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n           + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n       throw new IOException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n\n    try {\n\n      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n\n        List\u003cBlockEntry\u003e blockEntries \u003d\n            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n\n        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n\n        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n\n          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n          this.blockIdPrefix \u003d \"\";\n          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n          nextBlockCount +\u003d blockEntries.size();\n\n        } else {\n\n          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n          this.blockIdPrefix \u003d prefix;\n          nextBlockCount \u003d blockEntries.size();\n\n        }\n\n      }\n\n    } catch (StorageException ex) {\n      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n      throw new IOException(ex);\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
          "extendedDetails": {
            "oldValue": "setBlocksCount",
            "newValue": "setBlocksCountAndBlockIdPrefix"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13354. Update WASB driver to use the latest version (4.2.0) of SDK for Microsoft Azure Storage Clients. Contributed by Sivaguru Sankaridurg.\n",
          "commitDate": "27/07/16 3:50 PM",
          "commitName": "b43de80031d1272e8a08ea5bd31027efe45e9d70",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "18/01/16 9:08 AM",
          "commitNameOld": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 191.24,
          "commitsBetweenForRepo": 1373,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,39 @@\n-  private void setBlocksCount() throws IOException {\n+  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n+\n     try {\n \n-      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT) {\n-\n-        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n-            + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n \n         List\u003cBlockEntry\u003e blockEntries \u003d\n             blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n \n-        nextBlockCount +\u003d blockEntries.size();\n+        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n+        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n+        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n+\n+        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n+\n+          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n+          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n+          this.blockIdPrefix \u003d \"\";\n+          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+          nextBlockCount +\u003d blockEntries.size();\n+\n+        } else {\n+\n+          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n+          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n+          this.blockIdPrefix \u003d prefix;\n+          nextBlockCount \u003d blockEntries.size();\n+\n+        }\n \n       }\n+\n     } catch (StorageException ex) {\n-      LOG.debug(\"Encountered storage exception during setting next Block Count.\"\n+      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n           + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n       throw new IOException(ex);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setBlocksCountAndBlockIdPrefix() throws IOException {\n\n    try {\n\n      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT \u0026\u0026 blockIdPrefix\u003d\u003dnull) {\n\n        List\u003cBlockEntry\u003e blockEntries \u003d\n            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n\n        String blockZeroBlockId \u003d (blockEntries.size() \u003e 0) ? blockEntries.get(0).getId() : \"\";\n        String prefix \u003d UUID.randomUUID().toString() + \"-\";\n        String sampleNewerVersionBlockId \u003d generateNewerVersionBlockId(prefix, 0);\n\n        if (blockEntries.size() \u003e 0 \u0026\u0026 blockZeroBlockId.length() \u003c sampleNewerVersionBlockId.length()) {\n\n          // If blob has already been created with 2.2.0, append subsequent blocks with older version (2.2.0) blockId\n          // compute nextBlockCount, the way it was done before; and don\u0027t use blockIdPrefix\n          this.blockIdPrefix \u003d \"\";\n          nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n              + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n          nextBlockCount +\u003d blockEntries.size();\n\n        } else {\n\n          // If there are no existing blocks, create the first block with newer version (4.2.0) blockId\n          // If blob has already been created with 4.2.0, append subsequent blocks with newer version (4.2.0) blockId\n          this.blockIdPrefix \u003d prefix;\n          nextBlockCount \u003d blockEntries.size();\n\n        }\n\n      }\n\n    } catch (StorageException ex) {\n      LOG.debug(\"Encountered storage exception during setting next Block Count and BlockId prefix.\"\n          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n      throw new IOException(ex);\n    }\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12635. Adding Append API support for WASB. Contributed by Dushyanth.\n",
      "commitDate": "18/01/16 9:08 AM",
      "commitName": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,20 @@\n+  private void setBlocksCount() throws IOException {\n+    try {\n+\n+      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT) {\n+\n+        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n+            + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n+\n+        List\u003cBlockEntry\u003e blockEntries \u003d\n+            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n+\n+        nextBlockCount +\u003d blockEntries.size();\n+\n+      }\n+    } catch (StorageException ex) {\n+      LOG.debug(\"Encountered storage exception during setting next Block Count.\"\n+          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n+      throw new IOException(ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void setBlocksCount() throws IOException {\n    try {\n\n      if (nextBlockCount \u003d\u003d UNSET_BLOCKS_COUNT) {\n\n        nextBlockCount \u003d (long) (sequenceGenerator.nextInt(Integer.MAX_VALUE))\n            + sequenceGenerator.nextInt(Integer.MAX_VALUE - MAX_BLOCK_COUNT);\n\n        List\u003cBlockEntry\u003e blockEntries \u003d\n            blob.downloadBlockList(BlockListingFilter.COMMITTED, new BlobRequestOptions(), opContext);\n\n        nextBlockCount +\u003d blockEntries.size();\n\n      }\n    } catch (StorageException ex) {\n      LOG.debug(\"Encountered storage exception during setting next Block Count.\"\n          + \" StorageException : {} ErrorCode : {}\", ex, ex.getErrorCode());\n      throw new IOException(ex);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/BlockBlobAppendStream.java"
    }
  }
}