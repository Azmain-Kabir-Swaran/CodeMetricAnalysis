{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineV2ClientImpl.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
  "functionStartLine": 449,
  "functionEndLine": 495,
  "numCommitsSeen": 11,
  "timeTaken": 1490,
  "changeHistory": [
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711"
  ],
  "changeHistoryShort": {
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6342. Make TimelineV2Client\u0027s drain timeout after stop configurable (Haibo Chen via Varun Saxena)\n",
      "commitDate": "30/03/17 1:32 PM",
      "commitName": "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "16/02/17 11:41 AM",
      "commitNameOld": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 42.04,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n         public void run() {\n           try {\n             EntitiesHolder entitiesHolder;\n             while (!Thread.currentThread().isInterrupted()) {\n               // Merge all the async calls and make one push, but if its sync\n               // call push immediately\n               try {\n                 entitiesHolder \u003d timelineEntityQueue.take();\n               } catch (InterruptedException ie) {\n                 LOG.info(\"Timeline dispatcher thread was interrupted \");\n                 Thread.currentThread().interrupt();\n                 return;\n               }\n               if (entitiesHolder !\u003d null) {\n                 publishWithoutBlockingOnQueue(entitiesHolder);\n               }\n             }\n           } finally {\n             if (!timelineEntityQueue.isEmpty()) {\n               LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                   + \" timelineEntities, draining them now. \");\n             }\n             // Try to drain the remaining entities to be published @ the max for\n             // 2 seconds\n             long timeTillweDrain \u003d\n-                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n+                System.currentTimeMillis() + drainTimeoutPeriod;\n             while (!timelineEntityQueue.isEmpty()) {\n               publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n               if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                 // time elapsed stop publishing further....\n                 if (!timelineEntityQueue.isEmpty()) {\n                   LOG.warn(\"Time to drain elapsed! Remaining \"\n                       + timelineEntityQueue.size() + \"timelineEntities will not\"\n                       + \" be published\");\n                   // if some entities were not drained then we need interrupt\n                   // the threads which had put sync EntityHolders to the queue.\n                   EntitiesHolder nextEntityInTheQueue \u003d null;\n                   while ((nextEntityInTheQueue \u003d\n                       timelineEntityQueue.poll()) !\u003d null) {\n                     nextEntityInTheQueue.cancel(true);\n                   }\n                 }\n                 break;\n               }\n             }\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void run() {\n          try {\n            EntitiesHolder entitiesHolder;\n            while (!Thread.currentThread().isInterrupted()) {\n              // Merge all the async calls and make one push, but if its sync\n              // call push immediately\n              try {\n                entitiesHolder \u003d timelineEntityQueue.take();\n              } catch (InterruptedException ie) {\n                LOG.info(\"Timeline dispatcher thread was interrupted \");\n                Thread.currentThread().interrupt();\n                return;\n              }\n              if (entitiesHolder !\u003d null) {\n                publishWithoutBlockingOnQueue(entitiesHolder);\n              }\n            }\n          } finally {\n            if (!timelineEntityQueue.isEmpty()) {\n              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                  + \" timelineEntities, draining them now. \");\n            }\n            // Try to drain the remaining entities to be published @ the max for\n            // 2 seconds\n            long timeTillweDrain \u003d\n                System.currentTimeMillis() + drainTimeoutPeriod;\n            while (!timelineEntityQueue.isEmpty()) {\n              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                // time elapsed stop publishing further....\n                if (!timelineEntityQueue.isEmpty()) {\n                  LOG.warn(\"Time to drain elapsed! Remaining \"\n                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n                      + \" be published\");\n                  // if some entities were not drained then we need interrupt\n                  // the threads which had put sync EntityHolders to the queue.\n                  EntitiesHolder nextEntityInTheQueue \u003d null;\n                  while ((nextEntityInTheQueue \u003d\n                      timelineEntityQueue.poll()) !\u003d null) {\n                    nextEntityInTheQueue.cancel(true);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,47 @@\n+        public void run() {\n+          try {\n+            EntitiesHolder entitiesHolder;\n+            while (!Thread.currentThread().isInterrupted()) {\n+              // Merge all the async calls and make one push, but if its sync\n+              // call push immediately\n+              try {\n+                entitiesHolder \u003d timelineEntityQueue.take();\n+              } catch (InterruptedException ie) {\n+                LOG.info(\"Timeline dispatcher thread was interrupted \");\n+                Thread.currentThread().interrupt();\n+                return;\n+              }\n+              if (entitiesHolder !\u003d null) {\n+                publishWithoutBlockingOnQueue(entitiesHolder);\n+              }\n+            }\n+          } finally {\n+            if (!timelineEntityQueue.isEmpty()) {\n+              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n+                  + \" timelineEntities, draining them now. \");\n+            }\n+            // Try to drain the remaining entities to be published @ the max for\n+            // 2 seconds\n+            long timeTillweDrain \u003d\n+                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n+            while (!timelineEntityQueue.isEmpty()) {\n+              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n+              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n+                // time elapsed stop publishing further....\n+                if (!timelineEntityQueue.isEmpty()) {\n+                  LOG.warn(\"Time to drain elapsed! Remaining \"\n+                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n+                      + \" be published\");\n+                  // if some entities were not drained then we need interrupt\n+                  // the threads which had put sync EntityHolders to the queue.\n+                  EntitiesHolder nextEntityInTheQueue \u003d null;\n+                  while ((nextEntityInTheQueue \u003d\n+                      timelineEntityQueue.poll()) !\u003d null) {\n+                    nextEntityInTheQueue.cancel(true);\n+                  }\n+                }\n+                break;\n+              }\n+            }\n+          }\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void run() {\n          try {\n            EntitiesHolder entitiesHolder;\n            while (!Thread.currentThread().isInterrupted()) {\n              // Merge all the async calls and make one push, but if its sync\n              // call push immediately\n              try {\n                entitiesHolder \u003d timelineEntityQueue.take();\n              } catch (InterruptedException ie) {\n                LOG.info(\"Timeline dispatcher thread was interrupted \");\n                Thread.currentThread().interrupt();\n                return;\n              }\n              if (entitiesHolder !\u003d null) {\n                publishWithoutBlockingOnQueue(entitiesHolder);\n              }\n            }\n          } finally {\n            if (!timelineEntityQueue.isEmpty()) {\n              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                  + \" timelineEntities, draining them now. \");\n            }\n            // Try to drain the remaining entities to be published @ the max for\n            // 2 seconds\n            long timeTillweDrain \u003d\n                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n            while (!timelineEntityQueue.isEmpty()) {\n              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                // time elapsed stop publishing further....\n                if (!timelineEntityQueue.isEmpty()) {\n                  LOG.warn(\"Time to drain elapsed! Remaining \"\n                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n                      + \" be published\");\n                  // if some entities were not drained then we need interrupt\n                  // the threads which had put sync EntityHolders to the queue.\n                  EntitiesHolder nextEntityInTheQueue \u003d null;\n                  while ((nextEntityInTheQueue \u003d\n                      timelineEntityQueue.poll()) !\u003d null) {\n                    nextEntityInTheQueue.cancel(true);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java"
    }
  }
}