{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodesListManager.java",
  "functionName": "handleExcludeNodeList",
  "functionId": "handleExcludeNodeList___graceful-boolean__timeout-int",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
  "functionStartLine": 280,
  "functionEndLine": 366,
  "numCommitsSeen": 61,
  "timeTaken": 4212,
  "changeHistory": [
    "27642367ef3409a9ca93747c6c2cc279c087a4c0",
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2",
    "d87a63a9019d74a1c338c724e050952843a153e5",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421"
  ],
  "changeHistoryShort": {
    "27642367ef3409a9ca93747c6c2cc279c087a4c0": "Ybodychange",
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2": "Yparameterchange",
    "d87a63a9019d74a1c338c724e050952843a153e5": "Ybodychange",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": "Yintroduced"
  },
  "changeHistoryDetails": {
    "27642367ef3409a9ca93747c6c2cc279c087a4c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9011. Race condition during decommissioning. Contributed by Peter Bacsko\n",
      "commitDate": "18/11/19 7:29 AM",
      "commitName": "27642367ef3409a9ca93747c6c2cc279c087a4c0",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 247.67,
      "commitsBetweenForRepo": 1751,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,87 @@\n   private void handleExcludeNodeList(boolean graceful, int timeout) {\n     // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n     List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n \n     // Nodes need to be decommissioned (graceful or forceful);\n     List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n \n-    HostDetails hostDetails \u003d hostsReader.getHostDetails();\n+    HostDetails hostDetails;\n+    gracefulDecommissionableNodes.clear();\n+    if (graceful) {\n+      hostDetails \u003d hostsReader.getLazyLoadedHostDetails();\n+    } else {\n+      hostDetails \u003d hostsReader.getHostDetails();\n+    }\n+\n     Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n     Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n \n     for (RMNode n : this.rmContext.getRMNodes().values()) {\n       NodeState s \u003d n.getState();\n       // An invalid node (either due to explicit exclude or not include)\n       // should be excluded.\n       boolean isExcluded \u003d !isValidNode(\n           n.getHostName(), includes, excludes.keySet());\n       String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n       if (!isExcluded) {\n         // Note that no action is needed for DECOMMISSIONED node.\n         if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n           LOG.info(\"Recommission \" + nodeStr);\n           nodesToRecom.add(n);\n         }\n         // Otherwise no-action needed.\n       } else {\n         // exclude is true.\n         if (graceful) {\n           // Use per node timeout if exist otherwise the request timeout.\n           Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n               excludes.get(n.getHostName()) : timeout;\n           if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n               s !\u003d NodeState.DECOMMISSIONING) {\n             LOG.info(\"Gracefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n+            gracefulDecommissionableNodes.add(n);\n           } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                      !Objects.equals(n.getDecommissioningTimeout(),\n                          timeoutToUse)) {\n             LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n             nodesToDecom.add(n);\n+            gracefulDecommissionableNodes.add(n);\n           } else {\n             LOG.info(\"No action for \" + nodeStr);\n           }\n         } else {\n           if (s !\u003d NodeState.DECOMMISSIONED) {\n             LOG.info(\"Forcefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n           }\n         }\n       }\n     }\n \n+    if (graceful) {\n+      hostsReader.finishRefresh();\n+    }\n+\n     for (RMNode n : nodesToRecom) {\n       RMNodeEvent e \u003d new RMNodeEvent(\n           n.getNodeID(), RMNodeEventType.RECOMMISSION);\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     for (RMNode n : nodesToDecom) {\n       RMNodeEvent e;\n       if (graceful) {\n         Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n             excludes.get(n.getHostName()) : timeout;\n         e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n       } else {\n         RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n             RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n         e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     updateInactiveNodes();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleExcludeNodeList(boolean graceful, int timeout) {\n    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n    List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    // Nodes need to be decommissioned (graceful or forceful);\n    List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    HostDetails hostDetails;\n    gracefulDecommissionableNodes.clear();\n    if (graceful) {\n      hostDetails \u003d hostsReader.getLazyLoadedHostDetails();\n    } else {\n      hostDetails \u003d hostsReader.getHostDetails();\n    }\n\n    Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n    Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n\n    for (RMNode n : this.rmContext.getRMNodes().values()) {\n      NodeState s \u003d n.getState();\n      // An invalid node (either due to explicit exclude or not include)\n      // should be excluded.\n      boolean isExcluded \u003d !isValidNode(\n          n.getHostName(), includes, excludes.keySet());\n      String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n      if (!isExcluded) {\n        // Note that no action is needed for DECOMMISSIONED node.\n        if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n          LOG.info(\"Recommission \" + nodeStr);\n          nodesToRecom.add(n);\n        }\n        // Otherwise no-action needed.\n      } else {\n        // exclude is true.\n        if (graceful) {\n          // Use per node timeout if exist otherwise the request timeout.\n          Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n              excludes.get(n.getHostName()) : timeout;\n          if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n              s !\u003d NodeState.DECOMMISSIONING) {\n            LOG.info(\"Gracefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n            gracefulDecommissionableNodes.add(n);\n          } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                     !Objects.equals(n.getDecommissioningTimeout(),\n                         timeoutToUse)) {\n            LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n            nodesToDecom.add(n);\n            gracefulDecommissionableNodes.add(n);\n          } else {\n            LOG.info(\"No action for \" + nodeStr);\n          }\n        } else {\n          if (s !\u003d NodeState.DECOMMISSIONED) {\n            LOG.info(\"Forcefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          }\n        }\n      }\n    }\n\n    if (graceful) {\n      hostsReader.finishRefresh();\n    }\n\n    for (RMNode n : nodesToRecom) {\n      RMNodeEvent e \u003d new RMNodeEvent(\n          n.getNodeID(), RMNodeEventType.RECOMMISSION);\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    for (RMNode n : nodesToDecom) {\n      RMNodeEvent e;\n      if (graceful) {\n        Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n            excludes.get(n.getHostName()) : timeout;\n        e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n      } else {\n        RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n        e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    updateInactiveNodes();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "b46ca7e73b8bac3fdbff0b13afe009308078acf2": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-6483. Add nodes transitioning to DECOMMISSIONING state to the list of updated nodes returned to the AM. (Juan Rodriguez Hortala via asuresh)\n",
      "commitDate": "22/11/17 7:18 PM",
      "commitName": "b46ca7e73b8bac3fdbff0b13afe009308078acf2",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/05/17 7:57 PM",
      "commitNameOld": "d87a63a9019d74a1c338c724e050952843a153e5",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 190.01,
      "commitsBetweenForRepo": 1400,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n-  private void handleExcludeNodeList(boolean graceful, Integer timeout) {\n+  private void handleExcludeNodeList(boolean graceful, int timeout) {\n     // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n     List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n \n     // Nodes need to be decommissioned (graceful or forceful);\n     List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n \n     HostDetails hostDetails \u003d hostsReader.getHostDetails();\n     Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n     Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n \n     for (RMNode n : this.rmContext.getRMNodes().values()) {\n       NodeState s \u003d n.getState();\n       // An invalid node (either due to explicit exclude or not include)\n       // should be excluded.\n       boolean isExcluded \u003d !isValidNode(\n           n.getHostName(), includes, excludes.keySet());\n       String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n       if (!isExcluded) {\n         // Note that no action is needed for DECOMMISSIONED node.\n         if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n           LOG.info(\"Recommission \" + nodeStr);\n           nodesToRecom.add(n);\n         }\n         // Otherwise no-action needed.\n       } else {\n         // exclude is true.\n         if (graceful) {\n           // Use per node timeout if exist otherwise the request timeout.\n           Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n               excludes.get(n.getHostName()) : timeout;\n           if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n               s !\u003d NodeState.DECOMMISSIONING) {\n             LOG.info(\"Gracefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n           } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                      !Objects.equals(n.getDecommissioningTimeout(),\n                          timeoutToUse)) {\n             LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n             nodesToDecom.add(n);\n           } else {\n             LOG.info(\"No action for \" + nodeStr);\n           }\n         } else {\n           if (s !\u003d NodeState.DECOMMISSIONED) {\n             LOG.info(\"Forcefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n           }\n         }\n       }\n     }\n \n     for (RMNode n : nodesToRecom) {\n       RMNodeEvent e \u003d new RMNodeEvent(\n           n.getNodeID(), RMNodeEventType.RECOMMISSION);\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     for (RMNode n : nodesToDecom) {\n       RMNodeEvent e;\n       if (graceful) {\n         Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n             excludes.get(n.getHostName()) : timeout;\n         e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n       } else {\n         RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n             RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n         e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     updateInactiveNodes();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleExcludeNodeList(boolean graceful, int timeout) {\n    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n    List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    // Nodes need to be decommissioned (graceful or forceful);\n    List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    HostDetails hostDetails \u003d hostsReader.getHostDetails();\n    Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n    Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n\n    for (RMNode n : this.rmContext.getRMNodes().values()) {\n      NodeState s \u003d n.getState();\n      // An invalid node (either due to explicit exclude or not include)\n      // should be excluded.\n      boolean isExcluded \u003d !isValidNode(\n          n.getHostName(), includes, excludes.keySet());\n      String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n      if (!isExcluded) {\n        // Note that no action is needed for DECOMMISSIONED node.\n        if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n          LOG.info(\"Recommission \" + nodeStr);\n          nodesToRecom.add(n);\n        }\n        // Otherwise no-action needed.\n      } else {\n        // exclude is true.\n        if (graceful) {\n          // Use per node timeout if exist otherwise the request timeout.\n          Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n              excludes.get(n.getHostName()) : timeout;\n          if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n              s !\u003d NodeState.DECOMMISSIONING) {\n            LOG.info(\"Gracefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                     !Objects.equals(n.getDecommissioningTimeout(),\n                         timeoutToUse)) {\n            LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n            nodesToDecom.add(n);\n          } else {\n            LOG.info(\"No action for \" + nodeStr);\n          }\n        } else {\n          if (s !\u003d NodeState.DECOMMISSIONED) {\n            LOG.info(\"Forcefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          }\n        }\n      }\n    }\n\n    for (RMNode n : nodesToRecom) {\n      RMNodeEvent e \u003d new RMNodeEvent(\n          n.getNodeID(), RMNodeEventType.RECOMMISSION);\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    for (RMNode n : nodesToDecom) {\n      RMNodeEvent e;\n      if (graceful) {\n        Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n            excludes.get(n.getHostName()) : timeout;\n        e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n      } else {\n        RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n        e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    updateInactiveNodes();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {
        "oldValue": "[graceful-boolean, timeout-Integer]",
        "newValue": "[graceful-boolean, timeout-int]"
      }
    },
    "d87a63a9019d74a1c338c724e050952843a153e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14412. HostsFileReader#getHostDetails is very expensive on large clusters. Contributed by Jason Lowe.\n",
      "commitDate": "16/05/17 7:57 PM",
      "commitName": "d87a63a9019d74a1c338c724e050952843a153e5",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "04/11/16 3:20 PM",
      "commitNameOld": "6bb741ff0ef208a8628bc64d6537999d4cd67955",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 193.19,
      "commitsBetweenForRepo": 1086,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   private void handleExcludeNodeList(boolean graceful, Integer timeout) {\n     // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n     List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n \n     // Nodes need to be decommissioned (graceful or forceful);\n     List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n \n-    Set\u003cString\u003e includes \u003d new HashSet\u003cString\u003e();\n-    Map\u003cString, Integer\u003e excludes \u003d new HashMap\u003cString, Integer\u003e();\n-    hostsReader.getHostDetails(includes, excludes);\n+    HostDetails hostDetails \u003d hostsReader.getHostDetails();\n+    Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n+    Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n \n     for (RMNode n : this.rmContext.getRMNodes().values()) {\n       NodeState s \u003d n.getState();\n       // An invalid node (either due to explicit exclude or not include)\n       // should be excluded.\n       boolean isExcluded \u003d !isValidNode(\n           n.getHostName(), includes, excludes.keySet());\n       String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n       if (!isExcluded) {\n         // Note that no action is needed for DECOMMISSIONED node.\n         if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n           LOG.info(\"Recommission \" + nodeStr);\n           nodesToRecom.add(n);\n         }\n         // Otherwise no-action needed.\n       } else {\n         // exclude is true.\n         if (graceful) {\n           // Use per node timeout if exist otherwise the request timeout.\n           Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n               excludes.get(n.getHostName()) : timeout;\n           if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n               s !\u003d NodeState.DECOMMISSIONING) {\n             LOG.info(\"Gracefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n           } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                      !Objects.equals(n.getDecommissioningTimeout(),\n                          timeoutToUse)) {\n             LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n             nodesToDecom.add(n);\n           } else {\n             LOG.info(\"No action for \" + nodeStr);\n           }\n         } else {\n           if (s !\u003d NodeState.DECOMMISSIONED) {\n             LOG.info(\"Forcefully decommission \" + nodeStr);\n             nodesToDecom.add(n);\n           }\n         }\n       }\n     }\n \n     for (RMNode n : nodesToRecom) {\n       RMNodeEvent e \u003d new RMNodeEvent(\n           n.getNodeID(), RMNodeEventType.RECOMMISSION);\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     for (RMNode n : nodesToDecom) {\n       RMNodeEvent e;\n       if (graceful) {\n         Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n             excludes.get(n.getHostName()) : timeout;\n         e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n       } else {\n         RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n             RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n         e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(e);\n     }\n \n     updateInactiveNodes();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleExcludeNodeList(boolean graceful, Integer timeout) {\n    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n    List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    // Nodes need to be decommissioned (graceful or forceful);\n    List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    HostDetails hostDetails \u003d hostsReader.getHostDetails();\n    Set\u003cString\u003e includes \u003d hostDetails.getIncludedHosts();\n    Map\u003cString, Integer\u003e excludes \u003d hostDetails.getExcludedMap();\n\n    for (RMNode n : this.rmContext.getRMNodes().values()) {\n      NodeState s \u003d n.getState();\n      // An invalid node (either due to explicit exclude or not include)\n      // should be excluded.\n      boolean isExcluded \u003d !isValidNode(\n          n.getHostName(), includes, excludes.keySet());\n      String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n      if (!isExcluded) {\n        // Note that no action is needed for DECOMMISSIONED node.\n        if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n          LOG.info(\"Recommission \" + nodeStr);\n          nodesToRecom.add(n);\n        }\n        // Otherwise no-action needed.\n      } else {\n        // exclude is true.\n        if (graceful) {\n          // Use per node timeout if exist otherwise the request timeout.\n          Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n              excludes.get(n.getHostName()) : timeout;\n          if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n              s !\u003d NodeState.DECOMMISSIONING) {\n            LOG.info(\"Gracefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                     !Objects.equals(n.getDecommissioningTimeout(),\n                         timeoutToUse)) {\n            LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n            nodesToDecom.add(n);\n          } else {\n            LOG.info(\"No action for \" + nodeStr);\n          }\n        } else {\n          if (s !\u003d NodeState.DECOMMISSIONED) {\n            LOG.info(\"Forcefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          }\n        }\n      }\n    }\n\n    for (RMNode n : nodesToRecom) {\n      RMNodeEvent e \u003d new RMNodeEvent(\n          n.getNodeID(), RMNodeEventType.RECOMMISSION);\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    for (RMNode n : nodesToDecom) {\n      RMNodeEvent e;\n      if (graceful) {\n        Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n            excludes.get(n.getHostName()) : timeout;\n        e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n      } else {\n        RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n        e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    updateInactiveNodes();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java",
      "extendedDetails": {}
    },
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.\n(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)\n\nConflicts:\n\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java\n",
      "commitDate": "18/08/16 7:27 AM",
      "commitName": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,74 @@\n+  private void handleExcludeNodeList(boolean graceful, Integer timeout) {\n+    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n+    List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n+\n+    // Nodes need to be decommissioned (graceful or forceful);\n+    List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n+\n+    Set\u003cString\u003e includes \u003d new HashSet\u003cString\u003e();\n+    Map\u003cString, Integer\u003e excludes \u003d new HashMap\u003cString, Integer\u003e();\n+    hostsReader.getHostDetails(includes, excludes);\n+\n+    for (RMNode n : this.rmContext.getRMNodes().values()) {\n+      NodeState s \u003d n.getState();\n+      // An invalid node (either due to explicit exclude or not include)\n+      // should be excluded.\n+      boolean isExcluded \u003d !isValidNode(\n+          n.getHostName(), includes, excludes.keySet());\n+      String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n+      if (!isExcluded) {\n+        // Note that no action is needed for DECOMMISSIONED node.\n+        if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n+          LOG.info(\"Recommission \" + nodeStr);\n+          nodesToRecom.add(n);\n+        }\n+        // Otherwise no-action needed.\n+      } else {\n+        // exclude is true.\n+        if (graceful) {\n+          // Use per node timeout if exist otherwise the request timeout.\n+          Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n+              excludes.get(n.getHostName()) : timeout;\n+          if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n+              s !\u003d NodeState.DECOMMISSIONING) {\n+            LOG.info(\"Gracefully decommission \" + nodeStr);\n+            nodesToDecom.add(n);\n+          } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n+                     !Objects.equals(n.getDecommissioningTimeout(),\n+                         timeoutToUse)) {\n+            LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n+            nodesToDecom.add(n);\n+          } else {\n+            LOG.info(\"No action for \" + nodeStr);\n+          }\n+        } else {\n+          if (s !\u003d NodeState.DECOMMISSIONED) {\n+            LOG.info(\"Forcefully decommission \" + nodeStr);\n+            nodesToDecom.add(n);\n+          }\n+        }\n+      }\n+    }\n+\n+    for (RMNode n : nodesToRecom) {\n+      RMNodeEvent e \u003d new RMNodeEvent(\n+          n.getNodeID(), RMNodeEventType.RECOMMISSION);\n+      this.rmContext.getDispatcher().getEventHandler().handle(e);\n+    }\n+\n+    for (RMNode n : nodesToDecom) {\n+      RMNodeEvent e;\n+      if (graceful) {\n+        Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n+            excludes.get(n.getHostName()) : timeout;\n+        e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n+      } else {\n+        RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n+            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n+        e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n+      }\n+      this.rmContext.getDispatcher().getEventHandler().handle(e);\n+    }\n+\n+    updateInactiveNodes();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleExcludeNodeList(boolean graceful, Integer timeout) {\n    // DECOMMISSIONED/DECOMMISSIONING nodes need to be re-commissioned.\n    List\u003cRMNode\u003e nodesToRecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    // Nodes need to be decommissioned (graceful or forceful);\n    List\u003cRMNode\u003e nodesToDecom \u003d new ArrayList\u003cRMNode\u003e();\n\n    Set\u003cString\u003e includes \u003d new HashSet\u003cString\u003e();\n    Map\u003cString, Integer\u003e excludes \u003d new HashMap\u003cString, Integer\u003e();\n    hostsReader.getHostDetails(includes, excludes);\n\n    for (RMNode n : this.rmContext.getRMNodes().values()) {\n      NodeState s \u003d n.getState();\n      // An invalid node (either due to explicit exclude or not include)\n      // should be excluded.\n      boolean isExcluded \u003d !isValidNode(\n          n.getHostName(), includes, excludes.keySet());\n      String nodeStr \u003d \"node \" + n.getNodeID() + \" with state \" + s;\n      if (!isExcluded) {\n        // Note that no action is needed for DECOMMISSIONED node.\n        if (s \u003d\u003d NodeState.DECOMMISSIONING) {\n          LOG.info(\"Recommission \" + nodeStr);\n          nodesToRecom.add(n);\n        }\n        // Otherwise no-action needed.\n      } else {\n        // exclude is true.\n        if (graceful) {\n          // Use per node timeout if exist otherwise the request timeout.\n          Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n              excludes.get(n.getHostName()) : timeout;\n          if (s !\u003d NodeState.DECOMMISSIONED \u0026\u0026\n              s !\u003d NodeState.DECOMMISSIONING) {\n            LOG.info(\"Gracefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          } else if (s \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n                     !Objects.equals(n.getDecommissioningTimeout(),\n                         timeoutToUse)) {\n            LOG.info(\"Update \" + nodeStr + \" timeout to be \" + timeoutToUse);\n            nodesToDecom.add(n);\n          } else {\n            LOG.info(\"No action for \" + nodeStr);\n          }\n        } else {\n          if (s !\u003d NodeState.DECOMMISSIONED) {\n            LOG.info(\"Forcefully decommission \" + nodeStr);\n            nodesToDecom.add(n);\n          }\n        }\n      }\n    }\n\n    for (RMNode n : nodesToRecom) {\n      RMNodeEvent e \u003d new RMNodeEvent(\n          n.getNodeID(), RMNodeEventType.RECOMMISSION);\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    for (RMNode n : nodesToDecom) {\n      RMNodeEvent e;\n      if (graceful) {\n        Integer timeoutToUse \u003d (excludes.get(n.getHostName()) !\u003d null)?\n            excludes.get(n.getHostName()) : timeout;\n        e \u003d new RMNodeDecommissioningEvent(n.getNodeID(), timeoutToUse);\n      } else {\n        RMNodeEventType eventType \u003d isUntrackedNode(n.getHostName())?\n            RMNodeEventType.SHUTDOWN : RMNodeEventType.DECOMMISSION;\n        e \u003d new RMNodeEvent(n.getNodeID(), eventType);\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(e);\n    }\n\n    updateInactiveNodes();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/NodesListManager.java"
    }
  }
}