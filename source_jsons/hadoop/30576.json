{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KeyValueBasedTimelineStore.java",
  "functionName": "put",
  "functionId": "put___data-TimelineEntities",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/KeyValueBasedTimelineStore.java",
  "functionStartLine": 326,
  "functionEndLine": 462,
  "numCommitsSeen": 19,
  "timeTaken": 3276,
  "changeHistory": [
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806",
    "33714d9ad66622f545a030a7d3df94f4b0e73794",
    "84425fb435cb603fd8adcc2f76631c0244175310",
    "e06226126cd89d0cf8b4ef80a88659b248579231",
    "23b2e43f5d678517e33590d15dec73225b9c5682",
    "96578f0e01ba751175d4bcbad48d6f679e662382"
  ],
  "changeHistoryShort": {
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": "Ymultichange(Ymovefromfile,Ybodychange)",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": "Ybodychange",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": "Ymodifierchange",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": "Yfilerename",
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806": "Ybodychange",
    "33714d9ad66622f545a030a7d3df94f4b0e73794": "Ybodychange",
    "84425fb435cb603fd8adcc2f76631c0244175310": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Yparameterchange)",
    "e06226126cd89d0cf8b4ef80a88659b248579231": "Ybodychange",
    "23b2e43f5d678517e33590d15dec73225b9c5682": "Ybodychange",
    "96578f0e01ba751175d4bcbad48d6f679e662382": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-4219. New levelDB cache storage for timeline v1.5. Contributed by\nLi Lu\n",
      "commitDate": "28/01/16 2:24 PM",
      "commitName": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4219. New levelDB cache storage for timeline v1.5. Contributed by\nLi Lu\n",
          "commitDate": "28/01/16 2:24 PM",
          "commitName": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
          "commitAuthor": "Xuan",
          "commitDateOld": "28/01/16 10:59 AM",
          "commitNameOld": "61382ff8fabc76b3a51f227646573cdf367fea1a",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,137 @@\n   public synchronized TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n+    if (getServiceStopped()) {\n+      LOG.info(\"Service stopped, return null for the storage\");\n+      TimelinePutError error \u003d new TimelinePutError();\n+      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+      response.addError(error);\n+      return response;\n+    }\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n+      boolean needsPut \u003d false;\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         if (entity.getDomainId() \u003d\u003d null ||\n             entity.getDomainId().length() \u003d\u003d 0) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_DOMAIN);\n           response.addError(error);\n           continue;\n         }\n         existingEntity.setDomainId(entity.getDomainId());\n-        entities.put(entityId, existingEntity);\n+        // insert a new entity to the storage, update insert time map\n         entityInsertTimes.put(entityId, System.currentTimeMillis());\n+        needsPut \u003d true;\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n+        needsPut \u003d true;\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n           entityInsertTimes.remove(entityId);\n           continue;\n         } else {\n           Long min \u003d Long.MAX_VALUE;\n           for (TimelineEvent e : entity.getEvents()) {\n             if (min \u003e e.getTimestamp()) {\n               min \u003d e.getTimestamp();\n             }\n           }\n           existingEntity.setStartTime(min);\n+          needsPut \u003d true;\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n         }\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n             entity.getPrimaryFilters().entrySet()) {\n           for (Object pfo : pf.getValue()) {\n-            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n+            existingEntity.addPrimaryFilter(pf.getKey(),\n+                KeyValueBasedTimelineStoreUtils.compactNumber(pfo));\n+            needsPut \u003d true;\n           }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n         }\n         for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n           existingEntity.addOtherInfo(info.getKey(),\n-              maybeConvert(info.getValue()));\n+              KeyValueBasedTimelineStoreUtils.compactNumber(info.getValue()));\n+          needsPut \u003d true;\n         }\n       }\n+      if (needsPut) {\n+        entities.put(entityId, existingEntity);\n+      }\n+\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n-      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n+      for (Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             if (relatedEntity.getDomainId().equals(\n                 existingEntity.getDomainId())) {\n               relatedEntity.addRelatedEntity(\n                   existingEntity.getEntityType(), existingEntity.getEntityId());\n+              entities.put(relatedEntityId, relatedEntity);\n             } else {\n               // in this case the entity will be put, but the relation will be\n               // ignored\n               TimelinePutError error \u003d new TimelinePutError();\n               error.setEntityType(existingEntity.getEntityType());\n               error.setEntityId(existingEntity.getEntityId());\n               error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n               response.addError(error);\n             }\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             relatedEntity.setDomainId(existingEntity.getDomainId());\n             entities.put(relatedEntityId, relatedEntity);\n             entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    if (getServiceStopped()) {\n      LOG.info(\"Service stopped, return null for the storage\");\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n      return response;\n    }\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      boolean needsPut \u003d false;\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        if (entity.getDomainId() \u003d\u003d null ||\n            entity.getDomainId().length() \u003d\u003d 0) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          continue;\n        }\n        existingEntity.setDomainId(entity.getDomainId());\n        // insert a new entity to the storage, update insert time map\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n        needsPut \u003d true;\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n        needsPut \u003d true;\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n          needsPut \u003d true;\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(),\n                KeyValueBasedTimelineStoreUtils.compactNumber(pfo));\n            needsPut \u003d true;\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              KeyValueBasedTimelineStoreUtils.compactNumber(info.getValue()));\n          needsPut \u003d true;\n        }\n      }\n      if (needsPut) {\n        entities.put(entityId, existingEntity);\n      }\n\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            if (relatedEntity.getDomainId().equals(\n                existingEntity.getDomainId())) {\n              relatedEntity.addRelatedEntity(\n                  existingEntity.getEntityType(), existingEntity.getEntityId());\n              entities.put(relatedEntityId, relatedEntity);\n            } else {\n              // in this case the entity will be put, but the relation will be\n              // ignored\n              TimelinePutError error \u003d new TimelinePutError();\n              error.setEntityType(existingEntity.getEntityType());\n              error.setEntityId(existingEntity.getEntityId());\n              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n              response.addError(error);\n            }\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            relatedEntity.setDomainId(existingEntity.getDomainId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/KeyValueBasedTimelineStore.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/MemoryTimelineStore.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/KeyValueBasedTimelineStore.java",
            "oldMethodName": "put",
            "newMethodName": "put"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4219. New levelDB cache storage for timeline v1.5. Contributed by\nLi Lu\n",
          "commitDate": "28/01/16 2:24 PM",
          "commitName": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
          "commitAuthor": "Xuan",
          "commitDateOld": "28/01/16 10:59 AM",
          "commitNameOld": "61382ff8fabc76b3a51f227646573cdf367fea1a",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,137 @@\n   public synchronized TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n+    if (getServiceStopped()) {\n+      LOG.info(\"Service stopped, return null for the storage\");\n+      TimelinePutError error \u003d new TimelinePutError();\n+      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+      response.addError(error);\n+      return response;\n+    }\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n+      boolean needsPut \u003d false;\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         if (entity.getDomainId() \u003d\u003d null ||\n             entity.getDomainId().length() \u003d\u003d 0) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_DOMAIN);\n           response.addError(error);\n           continue;\n         }\n         existingEntity.setDomainId(entity.getDomainId());\n-        entities.put(entityId, existingEntity);\n+        // insert a new entity to the storage, update insert time map\n         entityInsertTimes.put(entityId, System.currentTimeMillis());\n+        needsPut \u003d true;\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n+        needsPut \u003d true;\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n           entityInsertTimes.remove(entityId);\n           continue;\n         } else {\n           Long min \u003d Long.MAX_VALUE;\n           for (TimelineEvent e : entity.getEvents()) {\n             if (min \u003e e.getTimestamp()) {\n               min \u003d e.getTimestamp();\n             }\n           }\n           existingEntity.setStartTime(min);\n+          needsPut \u003d true;\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n         }\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n             entity.getPrimaryFilters().entrySet()) {\n           for (Object pfo : pf.getValue()) {\n-            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n+            existingEntity.addPrimaryFilter(pf.getKey(),\n+                KeyValueBasedTimelineStoreUtils.compactNumber(pfo));\n+            needsPut \u003d true;\n           }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n         }\n         for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n           existingEntity.addOtherInfo(info.getKey(),\n-              maybeConvert(info.getValue()));\n+              KeyValueBasedTimelineStoreUtils.compactNumber(info.getValue()));\n+          needsPut \u003d true;\n         }\n       }\n+      if (needsPut) {\n+        entities.put(entityId, existingEntity);\n+      }\n+\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n-      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n+      for (Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             if (relatedEntity.getDomainId().equals(\n                 existingEntity.getDomainId())) {\n               relatedEntity.addRelatedEntity(\n                   existingEntity.getEntityType(), existingEntity.getEntityId());\n+              entities.put(relatedEntityId, relatedEntity);\n             } else {\n               // in this case the entity will be put, but the relation will be\n               // ignored\n               TimelinePutError error \u003d new TimelinePutError();\n               error.setEntityType(existingEntity.getEntityType());\n               error.setEntityId(existingEntity.getEntityId());\n               error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n               response.addError(error);\n             }\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             relatedEntity.setDomainId(existingEntity.getDomainId());\n             entities.put(relatedEntityId, relatedEntity);\n             entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    if (getServiceStopped()) {\n      LOG.info(\"Service stopped, return null for the storage\");\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n      return response;\n    }\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      boolean needsPut \u003d false;\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        if (entity.getDomainId() \u003d\u003d null ||\n            entity.getDomainId().length() \u003d\u003d 0) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          continue;\n        }\n        existingEntity.setDomainId(entity.getDomainId());\n        // insert a new entity to the storage, update insert time map\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n        needsPut \u003d true;\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n        needsPut \u003d true;\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n          needsPut \u003d true;\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(),\n                KeyValueBasedTimelineStoreUtils.compactNumber(pfo));\n            needsPut \u003d true;\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              KeyValueBasedTimelineStoreUtils.compactNumber(info.getValue()));\n          needsPut \u003d true;\n        }\n      }\n      if (needsPut) {\n        entities.put(entityId, existingEntity);\n      }\n\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            if (relatedEntity.getDomainId().equals(\n                existingEntity.getDomainId())) {\n              relatedEntity.addRelatedEntity(\n                  existingEntity.getEntityType(), existingEntity.getEntityId());\n              entities.put(relatedEntityId, relatedEntity);\n            } else {\n              // in this case the entity will be put, but the relation will be\n              // ignored\n              TimelinePutError error \u003d new TimelinePutError();\n              error.setEntityType(existingEntity.getEntityType());\n              error.setEntityId(existingEntity.getEntityId());\n              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n              response.addError(error);\n            }\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            relatedEntity.setDomainId(existingEntity.getDomainId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/KeyValueBasedTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
      "commitDate": "01/10/14 5:52 PM",
      "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/14 11:27 AM",
      "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,118 @@\n   public synchronized TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n+        if (entity.getDomainId() \u003d\u003d null ||\n+            entity.getDomainId().length() \u003d\u003d 0) {\n+          TimelinePutError error \u003d new TimelinePutError();\n+          error.setEntityId(entityId.getId());\n+          error.setEntityType(entityId.getType());\n+          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n+          response.addError(error);\n+          continue;\n+        }\n+        existingEntity.setDomainId(entity.getDomainId());\n         entities.put(entityId, existingEntity);\n         entityInsertTimes.put(entityId, System.currentTimeMillis());\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n           entityInsertTimes.remove(entityId);\n           continue;\n         } else {\n           Long min \u003d Long.MAX_VALUE;\n           for (TimelineEvent e : entity.getEvents()) {\n             if (min \u003e e.getTimestamp()) {\n               min \u003d e.getTimestamp();\n             }\n           }\n           existingEntity.setStartTime(min);\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n         }\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n             entity.getPrimaryFilters().entrySet()) {\n           for (Object pfo : pf.getValue()) {\n             existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n           }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n         }\n         for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n           existingEntity.addOtherInfo(info.getKey(),\n               maybeConvert(info.getValue()));\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n-            relatedEntity.addRelatedEntity(\n-                existingEntity.getEntityType(), existingEntity.getEntityId());\n+            if (relatedEntity.getDomainId().equals(\n+                existingEntity.getDomainId())) {\n+              relatedEntity.addRelatedEntity(\n+                  existingEntity.getEntityType(), existingEntity.getEntityId());\n+            } else {\n+              // in this case the entity will be put, but the relation will be\n+              // ignored\n+              TimelinePutError error \u003d new TimelinePutError();\n+              error.setEntityType(existingEntity.getEntityType());\n+              error.setEntityId(existingEntity.getEntityId());\n+              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n+              response.addError(error);\n+            }\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n+            relatedEntity.setDomainId(existingEntity.getDomainId());\n             entities.put(relatedEntityId, relatedEntity);\n             entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        if (entity.getDomainId() \u003d\u003d null ||\n            entity.getDomainId().length() \u003d\u003d 0) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          continue;\n        }\n        existingEntity.setDomainId(entity.getDomainId());\n        entities.put(entityId, existingEntity);\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              maybeConvert(info.getValue()));\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            if (relatedEntity.getDomainId().equals(\n                existingEntity.getDomainId())) {\n              relatedEntity.addRelatedEntity(\n                  existingEntity.getEntityType(), existingEntity.getEntityId());\n            } else {\n              // in this case the entity will be put, but the relation will be\n              // ignored\n              TimelinePutError error \u003d new TimelinePutError();\n              error.setEntityType(existingEntity.getEntityType());\n              error.setEntityId(existingEntity.getEntityId());\n              error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n              response.addError(error);\n            }\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            relatedEntity.setDomainId(existingEntity.getDomainId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/MemoryTimelineStore.java",
      "extendedDetails": {}
    },
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-2033. Merging generic-history into the Timeline Store (Contributed by Zhijie Shen)\n",
      "commitDate": "11/09/14 7:04 PM",
      "commitName": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthor": "junping_du",
      "commitDateOld": "28/05/14 11:09 AM",
      "commitNameOld": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 106.33,
      "commitsBetweenForRepo": 825,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n-  public TimelinePutResponse put(TimelineEntities data) {\n+  public synchronized TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n         entityInsertTimes.put(entityId, System.currentTimeMillis());\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n           entityInsertTimes.remove(entityId);\n           continue;\n         } else {\n           Long min \u003d Long.MAX_VALUE;\n           for (TimelineEvent e : entity.getEvents()) {\n             if (min \u003e e.getTimestamp()) {\n               min \u003d e.getTimestamp();\n             }\n           }\n           existingEntity.setStartTime(min);\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n         }\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n             entity.getPrimaryFilters().entrySet()) {\n           for (Object pfo : pf.getValue()) {\n             existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n           }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n         }\n         for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n           existingEntity.addOtherInfo(info.getKey(),\n               maybeConvert(info.getValue()));\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n             entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              maybeConvert(info.getValue()));\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/MemoryTimelineStore.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": {
      "type": "Yfilerename",
      "commitMessage": "YARN-2107. Refactored timeline classes into o.a.h.y.s.timeline package. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/14 11:09 AM",
      "commitName": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 10:44 AM",
      "commitNameOld": "cfd8647d0f20c08761f908be1f5b718c1c372498",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              maybeConvert(info.getValue()));\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/MemoryTimelineStore.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/MemoryTimelineStore.java"
      }
    },
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1838. Enhanced timeline service getEntities API to get entities from a given entity ID or insertion timestamp. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580960 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 11:14 AM",
      "commitName": "0f1eda6bbf895a1239b25cdf8b17fabd3759e806",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/03/14 4:20 PM",
      "commitNameOld": "33714d9ad66622f545a030a7d3df94f4b0e73794",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 20.75,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,96 @@\n   public TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n+        entityInsertTimes.put(entityId, System.currentTimeMillis());\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n+          entityInsertTimes.remove(entityId);\n           continue;\n         } else {\n-          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n+          Long min \u003d Long.MAX_VALUE;\n+          for (TimelineEvent e : entity.getEvents()) {\n+            if (min \u003e e.getTimestamp()) {\n+              min \u003d e.getTimestamp();\n+            }\n+          }\n+          existingEntity.setStartTime(min);\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n         }\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n             entity.getPrimaryFilters().entrySet()) {\n           for (Object pfo : pf.getValue()) {\n             existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n           }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n         }\n         for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n           existingEntity.addOtherInfo(info.getKey(),\n               maybeConvert(info.getValue()));\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n+            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n        entityInsertTimes.put(entityId, System.currentTimeMillis());\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          entityInsertTimes.remove(entityId);\n          continue;\n        } else {\n          Long min \u003d Long.MAX_VALUE;\n          for (TimelineEvent e : entity.getEvents()) {\n            if (min \u003e e.getTimestamp()) {\n              min \u003d e.getTimestamp();\n            }\n          }\n          existingEntity.setStartTime(min);\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              maybeConvert(info.getValue()));\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n            entityInsertTimes.put(relatedEntityId, System.currentTimeMillis());\n          }\n        }\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
      "extendedDetails": {}
    },
    "33714d9ad66622f545a030a7d3df94f4b0e73794": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1729. Made TimelineWebServices deserialize the string primary- and secondary-filters param into the JSON-compatible object. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573825 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 4:20 PM",
      "commitName": "33714d9ad66622f545a030a7d3df94f4b0e73794",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "22/02/14 12:55 PM",
      "commitNameOld": "84425fb435cb603fd8adcc2f76631c0244175310",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.14,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,87 @@\n   public TimelinePutResponse put(TimelineEntities data) {\n     TimelinePutResponse response \u003d new TimelinePutResponse();\n     for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(TimelinePutError.NO_START_TIME);\n           response.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n-          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n-        } else {\n-          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n+          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n+        }\n+        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n+            entity.getPrimaryFilters().entrySet()) {\n+          for (Object pfo : pf.getValue()) {\n+            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n+          }\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n-          existingEntity.setOtherInfo(entity.getOtherInfo());\n-        } else {\n-          existingEntity.addOtherInfo(entity.getOtherInfo());\n+          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n+        }\n+        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n+          existingEntity.addOtherInfo(info.getKey(),\n+              maybeConvert(info.getValue()));\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n             relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(new HashMap\u003cString, Set\u003cObject\u003e\u003e());\n        }\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e pf :\n            entity.getPrimaryFilters().entrySet()) {\n          for (Object pfo : pf.getValue()) {\n            existingEntity.addPrimaryFilter(pf.getKey(), maybeConvert(pfo));\n          }\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(new HashMap\u003cString, Object\u003e());\n        }\n        for (Entry\u003cString, Object\u003e info : entity.getOtherInfo().entrySet()) {\n          existingEntity.addOtherInfo(info.getKey(),\n              maybeConvert(info.getValue()));\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
      "extendedDetails": {}
    },
    "84425fb435cb603fd8adcc2f76631c0244175310": {
      "type": "Ymultichange(Yfilerename,Yreturntypechange,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/14 12:55 PM",
      "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/14 12:55 PM",
          "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/02/14 12:46 PM",
          "commitNameOld": "e06226126cd89d0cf8b4ef80a88659b248579231",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  public ATSPutErrors put(ATSEntities data) {\n-    ATSPutErrors errors \u003d new ATSPutErrors();\n-    for (ATSEntity entity : data.getEntities()) {\n+  public TimelinePutResponse put(TimelineEntities data) {\n+    TimelinePutResponse response \u003d new TimelinePutResponse();\n+    for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n-      ATSEntity existingEntity \u003d entities.get(entityId);\n+      TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n-        existingEntity \u003d new ATSEntity();\n+        existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n-          ATSPutError error \u003d new ATSPutError();\n+          TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n-          error.setErrorCode(ATSPutError.NO_START_TIME);\n-          errors.addError(error);\n+          error.setErrorCode(TimelinePutError.NO_START_TIME);\n+          response.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n-          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n+          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n-            relatedEntity \u003d new ATSEntity();\n+            relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n-    return errors;\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/apptimeline/MemoryApplicationTimelineStore.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/14 12:55 PM",
          "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/02/14 12:46 PM",
          "commitNameOld": "e06226126cd89d0cf8b4ef80a88659b248579231",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  public ATSPutErrors put(ATSEntities data) {\n-    ATSPutErrors errors \u003d new ATSPutErrors();\n-    for (ATSEntity entity : data.getEntities()) {\n+  public TimelinePutResponse put(TimelineEntities data) {\n+    TimelinePutResponse response \u003d new TimelinePutResponse();\n+    for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n-      ATSEntity existingEntity \u003d entities.get(entityId);\n+      TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n-        existingEntity \u003d new ATSEntity();\n+        existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n-          ATSPutError error \u003d new ATSPutError();\n+          TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n-          error.setErrorCode(ATSPutError.NO_START_TIME);\n-          errors.addError(error);\n+          error.setErrorCode(TimelinePutError.NO_START_TIME);\n+          response.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n-          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n+          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n-            relatedEntity \u003d new ATSEntity();\n+            relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n-    return errors;\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
          "extendedDetails": {
            "oldValue": "ATSPutErrors",
            "newValue": "TimelinePutResponse"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/14 12:55 PM",
          "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/02/14 12:46 PM",
          "commitNameOld": "e06226126cd89d0cf8b4ef80a88659b248579231",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  public ATSPutErrors put(ATSEntities data) {\n-    ATSPutErrors errors \u003d new ATSPutErrors();\n-    for (ATSEntity entity : data.getEntities()) {\n+  public TimelinePutResponse put(TimelineEntities data) {\n+    TimelinePutResponse response \u003d new TimelinePutResponse();\n+    for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n-      ATSEntity existingEntity \u003d entities.get(entityId);\n+      TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n-        existingEntity \u003d new ATSEntity();\n+        existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n-          ATSPutError error \u003d new ATSPutError();\n+          TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n-          error.setErrorCode(ATSPutError.NO_START_TIME);\n-          errors.addError(error);\n+          error.setErrorCode(TimelinePutError.NO_START_TIME);\n+          response.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n-          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n+          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n-            relatedEntity \u003d new ATSEntity();\n+            relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n-    return errors;\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/14 12:55 PM",
          "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/02/14 12:46 PM",
          "commitNameOld": "e06226126cd89d0cf8b4ef80a88659b248579231",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n-  public ATSPutErrors put(ATSEntities data) {\n-    ATSPutErrors errors \u003d new ATSPutErrors();\n-    for (ATSEntity entity : data.getEntities()) {\n+  public TimelinePutResponse put(TimelineEntities data) {\n+    TimelinePutResponse response \u003d new TimelinePutResponse();\n+    for (TimelineEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n-      ATSEntity existingEntity \u003d entities.get(entityId);\n+      TimelineEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n-        existingEntity \u003d new ATSEntity();\n+        existingEntity \u003d new TimelineEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n-          ATSPutError error \u003d new ATSPutError();\n+          TimelinePutError error \u003d new TimelinePutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n-          error.setErrorCode(ATSPutError.NO_START_TIME);\n-          errors.addError(error);\n+          error.setErrorCode(TimelinePutError.NO_START_TIME);\n+          response.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n-          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n+          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n-            relatedEntity \u003d new ATSEntity();\n+            relatedEntity \u003d new TimelineEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n-    return errors;\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TimelinePutResponse put(TimelineEntities data) {\n    TimelinePutResponse response \u003d new TimelinePutResponse();\n    for (TimelineEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      TimelineEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new TimelineEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(TimelinePutError.NO_START_TIME);\n          response.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          TimelineEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new TimelineEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/MemoryTimelineStore.java",
          "extendedDetails": {
            "oldValue": "[data-ATSEntities]",
            "newValue": "[data-TimelineEntities]"
          }
        }
      ]
    },
    "e06226126cd89d0cf8b4ef80a88659b248579231": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1732. Changed types of related-entities and primary-filters in the timeline-service to be sets instead of maps. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570914 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/14 12:46 PM",
      "commitName": "e06226126cd89d0cf8b4ef80a88659b248579231",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/02/14 6:15 PM",
      "commitNameOld": "23b2e43f5d678517e33590d15dec73225b9c5682",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 14.77,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,81 @@\n   public ATSPutErrors put(ATSEntities data) {\n     ATSPutErrors errors \u003d new ATSPutErrors();\n     for (ATSEntity entity : data.getEntities()) {\n       EntityIdentifier entityId \u003d\n           new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       ATSEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new ATSEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           ATSPutError error \u003d new ATSPutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n           error.setErrorCode(ATSPutError.NO_START_TIME);\n           errors.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n-      for (Map.Entry\u003cString, List\u003cString\u003e\u003e partRelatedEntities : entity\n+      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n           EntityIdentifier relatedEntityId \u003d\n               new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n           } else {\n             relatedEntity \u003d new ATSEntity();\n             relatedEntity.setEntityId(relatedEntityId.getId());\n             relatedEntity.setEntityType(relatedEntityId.getType());\n             relatedEntity.setStartTime(existingEntity.getStartTime());\n             relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                 existingEntity.getEntityId());\n             entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n     return errors;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ATSPutErrors put(ATSEntities data) {\n    ATSPutErrors errors \u003d new ATSPutErrors();\n    for (ATSEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      ATSEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new ATSEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          ATSPutError error \u003d new ATSPutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(ATSPutError.NO_START_TIME);\n          errors.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, Set\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new ATSEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return errors;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/apptimeline/MemoryApplicationTimelineStore.java",
      "extendedDetails": {}
    },
    "23b2e43f5d678517e33590d15dec73225b9c5682": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1635. Implemented a Leveldb based ApplicationTimelineStore. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1565868 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/14 6:15 PM",
      "commitName": "23b2e43f5d678517e33590d15dec73225b9c5682",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "04/02/14 4:32 PM",
      "commitNameOld": "96578f0e01ba751175d4bcbad48d6f679e662382",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,81 @@\n   public ATSPutErrors put(ATSEntities data) {\n     ATSPutErrors errors \u003d new ATSPutErrors();\n     for (ATSEntity entity : data.getEntities()) {\n-      EntityId entityId \u003d\n-          new EntityId(entity.getEntityId(), entity.getEntityType());\n+      EntityIdentifier entityId \u003d\n+          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n       // store entity info in memory\n       ATSEntity existingEntity \u003d entities.get(entityId);\n       if (existingEntity \u003d\u003d null) {\n         existingEntity \u003d new ATSEntity();\n         existingEntity.setEntityId(entity.getEntityId());\n         existingEntity.setEntityType(entity.getEntityType());\n         existingEntity.setStartTime(entity.getStartTime());\n         entities.put(entityId, existingEntity);\n       }\n       if (entity.getEvents() !\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null) {\n           existingEntity.setEvents(entity.getEvents());\n         } else {\n           existingEntity.addEvents(entity.getEvents());\n         }\n         Collections.sort(existingEntity.getEvents());\n       }\n       // check startTime\n       if (existingEntity.getStartTime() \u003d\u003d null) {\n         if (existingEntity.getEvents() \u003d\u003d null\n             || existingEntity.getEvents().isEmpty()) {\n           ATSPutError error \u003d new ATSPutError();\n           error.setEntityId(entityId.getId());\n           error.setEntityType(entityId.getType());\n-          error.setErrorCode(1);\n+          error.setErrorCode(ATSPutError.NO_START_TIME);\n           errors.addError(error);\n           entities.remove(entityId);\n           continue;\n         } else {\n           existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n         }\n       }\n       if (entity.getPrimaryFilters() !\u003d null) {\n         if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n           existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n         } else {\n           existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n         }\n       }\n       if (entity.getOtherInfo() !\u003d null) {\n         if (existingEntity.getOtherInfo() \u003d\u003d null) {\n           existingEntity.setOtherInfo(entity.getOtherInfo());\n         } else {\n           existingEntity.addOtherInfo(entity.getOtherInfo());\n         }\n       }\n       // relate it to other entities\n       if (entity.getRelatedEntities() \u003d\u003d null) {\n         continue;\n       }\n       for (Map.Entry\u003cString, List\u003cString\u003e\u003e partRelatedEntities : entity\n           .getRelatedEntities().entrySet()) {\n         if (partRelatedEntities \u003d\u003d null) {\n           continue;\n         }\n         for (String idStr : partRelatedEntities.getValue()) {\n-          EntityId relatedEntityId \u003d\n-              new EntityId(idStr, partRelatedEntities.getKey());\n+          EntityIdentifier relatedEntityId \u003d\n+              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n           ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n           if (relatedEntity !\u003d null) {\n             relatedEntity.addRelatedEntity(\n                 existingEntity.getEntityType(), existingEntity.getEntityId());\n+          } else {\n+            relatedEntity \u003d new ATSEntity();\n+            relatedEntity.setEntityId(relatedEntityId.getId());\n+            relatedEntity.setEntityType(relatedEntityId.getType());\n+            relatedEntity.setStartTime(existingEntity.getStartTime());\n+            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n+                existingEntity.getEntityId());\n+            entities.put(relatedEntityId, relatedEntity);\n           }\n         }\n       }\n     }\n     return errors;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ATSPutErrors put(ATSEntities data) {\n    ATSPutErrors errors \u003d new ATSPutErrors();\n    for (ATSEntity entity : data.getEntities()) {\n      EntityIdentifier entityId \u003d\n          new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      ATSEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new ATSEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          ATSPutError error \u003d new ATSPutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(ATSPutError.NO_START_TIME);\n          errors.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, List\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityIdentifier relatedEntityId \u003d\n              new EntityIdentifier(idStr, partRelatedEntities.getKey());\n          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          } else {\n            relatedEntity \u003d new ATSEntity();\n            relatedEntity.setEntityId(relatedEntityId.getId());\n            relatedEntity.setEntityType(relatedEntityId.getType());\n            relatedEntity.setStartTime(existingEntity.getStartTime());\n            relatedEntity.addRelatedEntity(existingEntity.getEntityType(),\n                existingEntity.getEntityId());\n            entities.put(relatedEntityId, relatedEntity);\n          }\n        }\n      }\n    }\n    return errors;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/apptimeline/MemoryApplicationTimelineStore.java",
      "extendedDetails": {}
    },
    "96578f0e01ba751175d4bcbad48d6f679e662382": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1634. Added a testable in-memory implementation of ApplicationTimelineStore. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564583 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/02/14 4:32 PM",
      "commitName": "96578f0e01ba751175d4bcbad48d6f679e662382",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,73 @@\n+  public ATSPutErrors put(ATSEntities data) {\n+    ATSPutErrors errors \u003d new ATSPutErrors();\n+    for (ATSEntity entity : data.getEntities()) {\n+      EntityId entityId \u003d\n+          new EntityId(entity.getEntityId(), entity.getEntityType());\n+      // store entity info in memory\n+      ATSEntity existingEntity \u003d entities.get(entityId);\n+      if (existingEntity \u003d\u003d null) {\n+        existingEntity \u003d new ATSEntity();\n+        existingEntity.setEntityId(entity.getEntityId());\n+        existingEntity.setEntityType(entity.getEntityType());\n+        existingEntity.setStartTime(entity.getStartTime());\n+        entities.put(entityId, existingEntity);\n+      }\n+      if (entity.getEvents() !\u003d null) {\n+        if (existingEntity.getEvents() \u003d\u003d null) {\n+          existingEntity.setEvents(entity.getEvents());\n+        } else {\n+          existingEntity.addEvents(entity.getEvents());\n+        }\n+        Collections.sort(existingEntity.getEvents());\n+      }\n+      // check startTime\n+      if (existingEntity.getStartTime() \u003d\u003d null) {\n+        if (existingEntity.getEvents() \u003d\u003d null\n+            || existingEntity.getEvents().isEmpty()) {\n+          ATSPutError error \u003d new ATSPutError();\n+          error.setEntityId(entityId.getId());\n+          error.setEntityType(entityId.getType());\n+          error.setErrorCode(1);\n+          errors.addError(error);\n+          entities.remove(entityId);\n+          continue;\n+        } else {\n+          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n+        }\n+      }\n+      if (entity.getPrimaryFilters() !\u003d null) {\n+        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n+          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n+        } else {\n+          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n+        }\n+      }\n+      if (entity.getOtherInfo() !\u003d null) {\n+        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n+          existingEntity.setOtherInfo(entity.getOtherInfo());\n+        } else {\n+          existingEntity.addOtherInfo(entity.getOtherInfo());\n+        }\n+      }\n+      // relate it to other entities\n+      if (entity.getRelatedEntities() \u003d\u003d null) {\n+        continue;\n+      }\n+      for (Map.Entry\u003cString, List\u003cString\u003e\u003e partRelatedEntities : entity\n+          .getRelatedEntities().entrySet()) {\n+        if (partRelatedEntities \u003d\u003d null) {\n+          continue;\n+        }\n+        for (String idStr : partRelatedEntities.getValue()) {\n+          EntityId relatedEntityId \u003d\n+              new EntityId(idStr, partRelatedEntities.getKey());\n+          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n+          if (relatedEntity !\u003d null) {\n+            relatedEntity.addRelatedEntity(\n+                existingEntity.getEntityType(), existingEntity.getEntityId());\n+          }\n+        }\n+      }\n+    }\n+    return errors;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ATSPutErrors put(ATSEntities data) {\n    ATSPutErrors errors \u003d new ATSPutErrors();\n    for (ATSEntity entity : data.getEntities()) {\n      EntityId entityId \u003d\n          new EntityId(entity.getEntityId(), entity.getEntityType());\n      // store entity info in memory\n      ATSEntity existingEntity \u003d entities.get(entityId);\n      if (existingEntity \u003d\u003d null) {\n        existingEntity \u003d new ATSEntity();\n        existingEntity.setEntityId(entity.getEntityId());\n        existingEntity.setEntityType(entity.getEntityType());\n        existingEntity.setStartTime(entity.getStartTime());\n        entities.put(entityId, existingEntity);\n      }\n      if (entity.getEvents() !\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null) {\n          existingEntity.setEvents(entity.getEvents());\n        } else {\n          existingEntity.addEvents(entity.getEvents());\n        }\n        Collections.sort(existingEntity.getEvents());\n      }\n      // check startTime\n      if (existingEntity.getStartTime() \u003d\u003d null) {\n        if (existingEntity.getEvents() \u003d\u003d null\n            || existingEntity.getEvents().isEmpty()) {\n          ATSPutError error \u003d new ATSPutError();\n          error.setEntityId(entityId.getId());\n          error.setEntityType(entityId.getType());\n          error.setErrorCode(1);\n          errors.addError(error);\n          entities.remove(entityId);\n          continue;\n        } else {\n          existingEntity.setStartTime(entity.getEvents().get(0).getTimestamp());\n        }\n      }\n      if (entity.getPrimaryFilters() !\u003d null) {\n        if (existingEntity.getPrimaryFilters() \u003d\u003d null) {\n          existingEntity.setPrimaryFilters(entity.getPrimaryFilters());\n        } else {\n          existingEntity.addPrimaryFilters(entity.getPrimaryFilters());\n        }\n      }\n      if (entity.getOtherInfo() !\u003d null) {\n        if (existingEntity.getOtherInfo() \u003d\u003d null) {\n          existingEntity.setOtherInfo(entity.getOtherInfo());\n        } else {\n          existingEntity.addOtherInfo(entity.getOtherInfo());\n        }\n      }\n      // relate it to other entities\n      if (entity.getRelatedEntities() \u003d\u003d null) {\n        continue;\n      }\n      for (Map.Entry\u003cString, List\u003cString\u003e\u003e partRelatedEntities : entity\n          .getRelatedEntities().entrySet()) {\n        if (partRelatedEntities \u003d\u003d null) {\n          continue;\n        }\n        for (String idStr : partRelatedEntities.getValue()) {\n          EntityId relatedEntityId \u003d\n              new EntityId(idStr, partRelatedEntities.getKey());\n          ATSEntity relatedEntity \u003d entities.get(relatedEntityId);\n          if (relatedEntity !\u003d null) {\n            relatedEntity.addRelatedEntity(\n                existingEntity.getEntityType(), existingEntity.getEntityId());\n          }\n        }\n      }\n    }\n    return errors;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/apptimeline/MemoryApplicationTimelineStore.java"
    }
  }
}