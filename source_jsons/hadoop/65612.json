{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalMetadataStore.java",
  "functionName": "put",
  "functionId": "put___meta-PathMetadata(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
  "functionStartLine": 267,
  "functionEndLine": 269,
  "numCommitsSeen": 34,
  "timeTaken": 5228,
  "changeHistory": [
    "e02eb24e0a9139418120027b694492e0738df20a",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "e148c3ff094e16d788f0bf9833ced02d27640805",
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40",
    "69aac696d9d4e32a55ba9b6992f41a9ad13424f1",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Ybodychange,Yparametermetachange)",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "e148c3ff094e16d788f0bf9833ced02d27640805": "Ybodychange",
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40": "Ybodychange",
    "69aac696d9d4e32a55ba9b6992f41a9ad13424f1": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,3 @@\n-  public void put(PathMetadata meta) throws IOException {\n-\n-    Preconditions.checkNotNull(meta);\n-    S3AFileStatus status \u003d meta.getFileStatus();\n-    Path path \u003d standardize(status.getPath());\n-    synchronized (this) {\n-\n-      /* Add entry for this file. */\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n-      }\n-      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n-      if(entry \u003d\u003d null){\n-        entry \u003d new LocalMetadataEntry(meta);\n-      } else {\n-        entry.setPathMetadata(meta);\n-      }\n-\n-      /* Directory case:\n-       * We also make sure we have an entry in the dirCache, so subsequent\n-       * listStatus(path) at least see the directory.\n-       *\n-       * If we had a boolean flag argument \"isNew\", we would know whether this\n-       * is an existing directory the client discovered via getFileStatus(),\n-       * or if it is a newly-created directory.  In the latter case, we would\n-       * be able to mark the directory as authoritative (fully-cached),\n-       * saving round trips to underlying store for subsequent listStatus()\n-       */\n-\n-      // only create DirListingMetadata if the entry does not have one\n-      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n-        DirListingMetadata dlm \u003d\n-            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n-        entry.setDirListingMetadata(dlm);\n-      }\n-      localCache.put(path, entry);\n-\n-      /* Update cached parent dir. */\n-      Path parentPath \u003d path.getParent();\n-      if (parentPath !\u003d null) {\n-        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n-\n-        // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n-        if (parentMeta \u003d\u003d null){\n-          parentMeta \u003d new LocalMetadataEntry();\n-          localCache.put(parentPath, parentMeta);\n-        }\n-\n-        // If there is no directory metadata on the parent entry, create\n-        // an empty one\n-        if (!parentMeta.hasDirMeta()) {\n-          DirListingMetadata parentDirMeta \u003d\n-              new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n-                  false);\n-          parentMeta.setDirListingMetadata(parentDirMeta);\n-        }\n-\n-        // Add the child status to the listing\n-        parentMeta.getDirListingMeta().put(status);\n-\n-        // Mark the listing entry as deleted if the meta is set to deleted\n-        if(meta.isDeleted()) {\n-          parentMeta.getDirListingMeta().markDeleted(path);\n-        }\n-      }\n-    }\n+  public void put(final PathMetadata meta) throws IOException {\n+    put(meta, null);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(final PathMetadata meta) throws IOException {\n    put(meta, null);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,3 @@\n-  public void put(PathMetadata meta) throws IOException {\n-\n-    Preconditions.checkNotNull(meta);\n-    S3AFileStatus status \u003d meta.getFileStatus();\n-    Path path \u003d standardize(status.getPath());\n-    synchronized (this) {\n-\n-      /* Add entry for this file. */\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n-      }\n-      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n-      if(entry \u003d\u003d null){\n-        entry \u003d new LocalMetadataEntry(meta);\n-      } else {\n-        entry.setPathMetadata(meta);\n-      }\n-\n-      /* Directory case:\n-       * We also make sure we have an entry in the dirCache, so subsequent\n-       * listStatus(path) at least see the directory.\n-       *\n-       * If we had a boolean flag argument \"isNew\", we would know whether this\n-       * is an existing directory the client discovered via getFileStatus(),\n-       * or if it is a newly-created directory.  In the latter case, we would\n-       * be able to mark the directory as authoritative (fully-cached),\n-       * saving round trips to underlying store for subsequent listStatus()\n-       */\n-\n-      // only create DirListingMetadata if the entry does not have one\n-      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n-        DirListingMetadata dlm \u003d\n-            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n-        entry.setDirListingMetadata(dlm);\n-      }\n-      localCache.put(path, entry);\n-\n-      /* Update cached parent dir. */\n-      Path parentPath \u003d path.getParent();\n-      if (parentPath !\u003d null) {\n-        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n-\n-        // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n-        if (parentMeta \u003d\u003d null){\n-          parentMeta \u003d new LocalMetadataEntry();\n-          localCache.put(parentPath, parentMeta);\n-        }\n-\n-        // If there is no directory metadata on the parent entry, create\n-        // an empty one\n-        if (!parentMeta.hasDirMeta()) {\n-          DirListingMetadata parentDirMeta \u003d\n-              new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n-                  false);\n-          parentMeta.setDirListingMetadata(parentDirMeta);\n-        }\n-\n-        // Add the child status to the listing\n-        parentMeta.getDirListingMeta().put(status);\n-\n-        // Mark the listing entry as deleted if the meta is set to deleted\n-        if(meta.isDeleted()) {\n-          parentMeta.getDirListingMeta().markDeleted(path);\n-        }\n-      }\n-    }\n+  public void put(final PathMetadata meta) throws IOException {\n+    put(meta, null);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(final PathMetadata meta) throws IOException {\n    put(meta, null);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[meta-PathMetadata]",
            "newValue": "[meta-PathMetadata(modifiers-final)]"
          }
        }
      ]
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "28/11/18 9:45 AM",
      "commitNameOld": "e148c3ff094e16d788f0bf9833ced02d27640805",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 172.16,
      "commitsBetweenForRepo": 1174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   public void put(PathMetadata meta) throws IOException {\n \n     Preconditions.checkNotNull(meta);\n-    FileStatus status \u003d meta.getFileStatus();\n+    S3AFileStatus status \u003d meta.getFileStatus();\n     Path path \u003d standardize(status.getPath());\n     synchronized (this) {\n \n       /* Add entry for this file. */\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n       }\n       LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n       if(entry \u003d\u003d null){\n         entry \u003d new LocalMetadataEntry(meta);\n       } else {\n         entry.setPathMetadata(meta);\n       }\n \n       /* Directory case:\n        * We also make sure we have an entry in the dirCache, so subsequent\n        * listStatus(path) at least see the directory.\n        *\n        * If we had a boolean flag argument \"isNew\", we would know whether this\n        * is an existing directory the client discovered via getFileStatus(),\n        * or if it is a newly-created directory.  In the latter case, we would\n        * be able to mark the directory as authoritative (fully-cached),\n        * saving round trips to underlying store for subsequent listStatus()\n        */\n \n       // only create DirListingMetadata if the entry does not have one\n       if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n         DirListingMetadata dlm \u003d\n             new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n         entry.setDirListingMetadata(dlm);\n       }\n       localCache.put(path, entry);\n \n       /* Update cached parent dir. */\n       Path parentPath \u003d path.getParent();\n       if (parentPath !\u003d null) {\n         LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n \n         // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n         if (parentMeta \u003d\u003d null){\n           parentMeta \u003d new LocalMetadataEntry();\n           localCache.put(parentPath, parentMeta);\n         }\n \n         // If there is no directory metadata on the parent entry, create\n         // an empty one\n         if (!parentMeta.hasDirMeta()) {\n           DirListingMetadata parentDirMeta \u003d\n               new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n                   false);\n           parentMeta.setDirListingMetadata(parentDirMeta);\n         }\n \n         // Add the child status to the listing\n         parentMeta.getDirListingMeta().put(status);\n \n         // Mark the listing entry as deleted if the meta is set to deleted\n         if(meta.isDeleted()) {\n           parentMeta.getDirListingMeta().markDeleted(path);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(PathMetadata meta) throws IOException {\n\n    Preconditions.checkNotNull(meta);\n    S3AFileStatus status \u003d meta.getFileStatus();\n    Path path \u003d standardize(status.getPath());\n    synchronized (this) {\n\n      /* Add entry for this file. */\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n      }\n      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n      if(entry \u003d\u003d null){\n        entry \u003d new LocalMetadataEntry(meta);\n      } else {\n        entry.setPathMetadata(meta);\n      }\n\n      /* Directory case:\n       * We also make sure we have an entry in the dirCache, so subsequent\n       * listStatus(path) at least see the directory.\n       *\n       * If we had a boolean flag argument \"isNew\", we would know whether this\n       * is an existing directory the client discovered via getFileStatus(),\n       * or if it is a newly-created directory.  In the latter case, we would\n       * be able to mark the directory as authoritative (fully-cached),\n       * saving round trips to underlying store for subsequent listStatus()\n       */\n\n      // only create DirListingMetadata if the entry does not have one\n      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n        DirListingMetadata dlm \u003d\n            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n        entry.setDirListingMetadata(dlm);\n      }\n      localCache.put(path, entry);\n\n      /* Update cached parent dir. */\n      Path parentPath \u003d path.getParent();\n      if (parentPath !\u003d null) {\n        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n\n        // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n        if (parentMeta \u003d\u003d null){\n          parentMeta \u003d new LocalMetadataEntry();\n          localCache.put(parentPath, parentMeta);\n        }\n\n        // If there is no directory metadata on the parent entry, create\n        // an empty one\n        if (!parentMeta.hasDirMeta()) {\n          DirListingMetadata parentDirMeta \u003d\n              new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n                  false);\n          parentMeta.setDirListingMetadata(parentDirMeta);\n        }\n\n        // Add the child status to the listing\n        parentMeta.getDirListingMeta().put(status);\n\n        // Mark the listing entry as deleted if the meta is set to deleted\n        if(meta.isDeleted()) {\n          parentMeta.getDirListingMeta().markDeleted(path);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "e148c3ff094e16d788f0bf9833ced02d27640805": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15798. LocalMetadataStore put() does not retain isDeleted in parent listing. Contributed by Gabor Bota.\n",
      "commitDate": "28/11/18 9:45 AM",
      "commitName": "e148c3ff094e16d788f0bf9833ced02d27640805",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "07/09/18 10:25 AM",
      "commitNameOld": "36c7c782606c2b863b528ad4eb21bfde02a33cc1",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 82.01,
      "commitsBetweenForRepo": 759,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,67 @@\n   public void put(PathMetadata meta) throws IOException {\n \n     Preconditions.checkNotNull(meta);\n     FileStatus status \u003d meta.getFileStatus();\n     Path path \u003d standardize(status.getPath());\n     synchronized (this) {\n \n       /* Add entry for this file. */\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n       }\n       LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n       if(entry \u003d\u003d null){\n         entry \u003d new LocalMetadataEntry(meta);\n       } else {\n         entry.setPathMetadata(meta);\n       }\n \n       /* Directory case:\n        * We also make sure we have an entry in the dirCache, so subsequent\n        * listStatus(path) at least see the directory.\n        *\n        * If we had a boolean flag argument \"isNew\", we would know whether this\n        * is an existing directory the client discovered via getFileStatus(),\n        * or if it is a newly-created directory.  In the latter case, we would\n        * be able to mark the directory as authoritative (fully-cached),\n        * saving round trips to underlying store for subsequent listStatus()\n        */\n \n       // only create DirListingMetadata if the entry does not have one\n       if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n         DirListingMetadata dlm \u003d\n             new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n         entry.setDirListingMetadata(dlm);\n       }\n       localCache.put(path, entry);\n \n       /* Update cached parent dir. */\n       Path parentPath \u003d path.getParent();\n       if (parentPath !\u003d null) {\n         LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n-        DirListingMetadata parentDirMeta \u003d\n-            new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n-                false);\n-        parentDirMeta.put(status);\n \n-        getDirListingMeta(parentPath);\n-\n+        // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n         if (parentMeta \u003d\u003d null){\n-          localCache.put(parentPath, new LocalMetadataEntry(parentDirMeta));\n-        } else if (!parentMeta.hasDirMeta()) {\n+          parentMeta \u003d new LocalMetadataEntry();\n+          localCache.put(parentPath, parentMeta);\n+        }\n+\n+        // If there is no directory metadata on the parent entry, create\n+        // an empty one\n+        if (!parentMeta.hasDirMeta()) {\n+          DirListingMetadata parentDirMeta \u003d\n+              new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n+                  false);\n           parentMeta.setDirListingMetadata(parentDirMeta);\n-        } else {\n-          parentMeta.getDirListingMeta().put(status);\n+        }\n+\n+        // Add the child status to the listing\n+        parentMeta.getDirListingMeta().put(status);\n+\n+        // Mark the listing entry as deleted if the meta is set to deleted\n+        if(meta.isDeleted()) {\n+          parentMeta.getDirListingMeta().markDeleted(path);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(PathMetadata meta) throws IOException {\n\n    Preconditions.checkNotNull(meta);\n    FileStatus status \u003d meta.getFileStatus();\n    Path path \u003d standardize(status.getPath());\n    synchronized (this) {\n\n      /* Add entry for this file. */\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n      }\n      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n      if(entry \u003d\u003d null){\n        entry \u003d new LocalMetadataEntry(meta);\n      } else {\n        entry.setPathMetadata(meta);\n      }\n\n      /* Directory case:\n       * We also make sure we have an entry in the dirCache, so subsequent\n       * listStatus(path) at least see the directory.\n       *\n       * If we had a boolean flag argument \"isNew\", we would know whether this\n       * is an existing directory the client discovered via getFileStatus(),\n       * or if it is a newly-created directory.  In the latter case, we would\n       * be able to mark the directory as authoritative (fully-cached),\n       * saving round trips to underlying store for subsequent listStatus()\n       */\n\n      // only create DirListingMetadata if the entry does not have one\n      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n        DirListingMetadata dlm \u003d\n            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n        entry.setDirListingMetadata(dlm);\n      }\n      localCache.put(path, entry);\n\n      /* Update cached parent dir. */\n      Path parentPath \u003d path.getParent();\n      if (parentPath !\u003d null) {\n        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n\n        // Create empty parent LocalMetadataEntry if it doesn\u0027t exist\n        if (parentMeta \u003d\u003d null){\n          parentMeta \u003d new LocalMetadataEntry();\n          localCache.put(parentPath, parentMeta);\n        }\n\n        // If there is no directory metadata on the parent entry, create\n        // an empty one\n        if (!parentMeta.hasDirMeta()) {\n          DirListingMetadata parentDirMeta \u003d\n              new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n                  false);\n          parentMeta.setDirListingMetadata(parentDirMeta);\n        }\n\n        // Add the child status to the listing\n        parentMeta.getDirListingMeta().put(status);\n\n        // Mark the listing entry as deleted if the meta is set to deleted\n        if(meta.isDeleted()) {\n          parentMeta.getDirListingMeta().markDeleted(path);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "c687a6617d73293019d8d91ac48bbfd2ccca3b40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15423. Merge fileCache and dirCache into ine single cache in LocalMetadataStore. Contributed by Gabor Bota.\n",
      "commitDate": "25/06/18 1:59 PM",
      "commitName": "c687a6617d73293019d8d91ac48bbfd2ccca3b40",
      "commitAuthor": "Sean Mackrory",
      "commitDateOld": "08/05/18 6:58 PM",
      "commitNameOld": "8981674bbcff0663af820f3e87a3eaea5789968a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 47.79,
      "commitsBetweenForRepo": 363,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,58 @@\n   public void put(PathMetadata meta) throws IOException {\n \n     Preconditions.checkNotNull(meta);\n     FileStatus status \u003d meta.getFileStatus();\n     Path path \u003d standardize(status.getPath());\n     synchronized (this) {\n \n       /* Add entry for this file. */\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n       }\n-      fileCache.put(path, meta);\n+      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n+      if(entry \u003d\u003d null){\n+        entry \u003d new LocalMetadataEntry(meta);\n+      } else {\n+        entry.setPathMetadata(meta);\n+      }\n \n       /* Directory case:\n        * We also make sure we have an entry in the dirCache, so subsequent\n        * listStatus(path) at least see the directory.\n        *\n        * If we had a boolean flag argument \"isNew\", we would know whether this\n        * is an existing directory the client discovered via getFileStatus(),\n        * or if it is a newly-created directory.  In the latter case, we would\n        * be able to mark the directory as authoritative (fully-cached),\n        * saving round trips to underlying store for subsequent listStatus()\n        */\n \n-      if (status.isDirectory()) {\n-        DirListingMetadata dir \u003d dirCache.getIfPresent(path);\n-        if (dir \u003d\u003d null) {\n-          dirCache.put(path, new DirListingMetadata(path, DirListingMetadata\n-              .EMPTY_DIR, false));\n-        }\n+      // only create DirListingMetadata if the entry does not have one\n+      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n+        DirListingMetadata dlm \u003d\n+            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n+        entry.setDirListingMetadata(dlm);\n       }\n+      localCache.put(path, entry);\n \n       /* Update cached parent dir. */\n       Path parentPath \u003d path.getParent();\n       if (parentPath !\u003d null) {\n-        DirListingMetadata parent \u003d dirCache.getIfPresent(parentPath);\n-        if (parent \u003d\u003d null) {\n-        /* Track this new file\u0027s listing in parent.  Parent is not\n-         * authoritative, since there may be other items in it we don\u0027t know\n-         * about. */\n-          parent \u003d new DirListingMetadata(parentPath,\n-              DirListingMetadata.EMPTY_DIR, false);\n-          dirCache.put(parentPath, parent);\n+        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n+        DirListingMetadata parentDirMeta \u003d\n+            new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n+                false);\n+        parentDirMeta.put(status);\n+\n+        getDirListingMeta(parentPath);\n+\n+        if (parentMeta \u003d\u003d null){\n+          localCache.put(parentPath, new LocalMetadataEntry(parentDirMeta));\n+        } else if (!parentMeta.hasDirMeta()) {\n+          parentMeta.setDirListingMetadata(parentDirMeta);\n+        } else {\n+          parentMeta.getDirListingMeta().put(status);\n         }\n-        parent.put(status);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(PathMetadata meta) throws IOException {\n\n    Preconditions.checkNotNull(meta);\n    FileStatus status \u003d meta.getFileStatus();\n    Path path \u003d standardize(status.getPath());\n    synchronized (this) {\n\n      /* Add entry for this file. */\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n      }\n      LocalMetadataEntry entry \u003d localCache.getIfPresent(path);\n      if(entry \u003d\u003d null){\n        entry \u003d new LocalMetadataEntry(meta);\n      } else {\n        entry.setPathMetadata(meta);\n      }\n\n      /* Directory case:\n       * We also make sure we have an entry in the dirCache, so subsequent\n       * listStatus(path) at least see the directory.\n       *\n       * If we had a boolean flag argument \"isNew\", we would know whether this\n       * is an existing directory the client discovered via getFileStatus(),\n       * or if it is a newly-created directory.  In the latter case, we would\n       * be able to mark the directory as authoritative (fully-cached),\n       * saving round trips to underlying store for subsequent listStatus()\n       */\n\n      // only create DirListingMetadata if the entry does not have one\n      if (status.isDirectory() \u0026\u0026 !entry.hasDirMeta()) {\n        DirListingMetadata dlm \u003d\n            new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR, false);\n        entry.setDirListingMetadata(dlm);\n      }\n      localCache.put(path, entry);\n\n      /* Update cached parent dir. */\n      Path parentPath \u003d path.getParent();\n      if (parentPath !\u003d null) {\n        LocalMetadataEntry parentMeta \u003d localCache.getIfPresent(parentPath);\n        DirListingMetadata parentDirMeta \u003d\n            new DirListingMetadata(parentPath, DirListingMetadata.EMPTY_DIR,\n                false);\n        parentDirMeta.put(status);\n\n        getDirListingMeta(parentPath);\n\n        if (parentMeta \u003d\u003d null){\n          localCache.put(parentPath, new LocalMetadataEntry(parentDirMeta));\n        } else if (!parentMeta.hasDirMeta()) {\n          parentMeta.setDirListingMetadata(parentDirMeta);\n        } else {\n          parentMeta.getDirListingMeta().put(status);\n        }\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "69aac696d9d4e32a55ba9b6992f41a9ad13424f1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13649 s3guard: implement time-based (TTL) expiry for LocalMetadataStore (Gabor Bota)\n",
      "commitDate": "08/05/18 3:29 PM",
      "commitName": "69aac696d9d4e32a55ba9b6992f41a9ad13424f1",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "26/04/18 8:41 PM",
      "commitNameOld": "7d8bcf534acce52fb8cfb745a8671f9350d3b5be",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 11.78,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public void put(PathMetadata meta) throws IOException {\n \n     Preconditions.checkNotNull(meta);\n     FileStatus status \u003d meta.getFileStatus();\n     Path path \u003d standardize(status.getPath());\n     synchronized (this) {\n \n       /* Add entry for this file. */\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n       }\n-      fileHash.put(path, meta);\n+      fileCache.put(path, meta);\n \n       /* Directory case:\n-       * We also make sure we have an entry in the dirHash, so subsequent\n+       * We also make sure we have an entry in the dirCache, so subsequent\n        * listStatus(path) at least see the directory.\n        *\n        * If we had a boolean flag argument \"isNew\", we would know whether this\n        * is an existing directory the client discovered via getFileStatus(),\n        * or if it is a newly-created directory.  In the latter case, we would\n        * be able to mark the directory as authoritative (fully-cached),\n        * saving round trips to underlying store for subsequent listStatus()\n        */\n \n       if (status.isDirectory()) {\n-        DirListingMetadata dir \u003d dirHash.mruGet(path);\n+        DirListingMetadata dir \u003d dirCache.getIfPresent(path);\n         if (dir \u003d\u003d null) {\n-          dirHash.put(path, new DirListingMetadata(path, DirListingMetadata\n+          dirCache.put(path, new DirListingMetadata(path, DirListingMetadata\n               .EMPTY_DIR, false));\n         }\n       }\n \n       /* Update cached parent dir. */\n       Path parentPath \u003d path.getParent();\n       if (parentPath !\u003d null) {\n-        DirListingMetadata parent \u003d dirHash.mruGet(parentPath);\n+        DirListingMetadata parent \u003d dirCache.getIfPresent(parentPath);\n         if (parent \u003d\u003d null) {\n         /* Track this new file\u0027s listing in parent.  Parent is not\n          * authoritative, since there may be other items in it we don\u0027t know\n          * about. */\n           parent \u003d new DirListingMetadata(parentPath,\n               DirListingMetadata.EMPTY_DIR, false);\n-          dirHash.put(parentPath, parent);\n+          dirCache.put(parentPath, parent);\n         }\n         parent.put(status);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(PathMetadata meta) throws IOException {\n\n    Preconditions.checkNotNull(meta);\n    FileStatus status \u003d meta.getFileStatus();\n    Path path \u003d standardize(status.getPath());\n    synchronized (this) {\n\n      /* Add entry for this file. */\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n      }\n      fileCache.put(path, meta);\n\n      /* Directory case:\n       * We also make sure we have an entry in the dirCache, so subsequent\n       * listStatus(path) at least see the directory.\n       *\n       * If we had a boolean flag argument \"isNew\", we would know whether this\n       * is an existing directory the client discovered via getFileStatus(),\n       * or if it is a newly-created directory.  In the latter case, we would\n       * be able to mark the directory as authoritative (fully-cached),\n       * saving round trips to underlying store for subsequent listStatus()\n       */\n\n      if (status.isDirectory()) {\n        DirListingMetadata dir \u003d dirCache.getIfPresent(path);\n        if (dir \u003d\u003d null) {\n          dirCache.put(path, new DirListingMetadata(path, DirListingMetadata\n              .EMPTY_DIR, false));\n        }\n      }\n\n      /* Update cached parent dir. */\n      Path parentPath \u003d path.getParent();\n      if (parentPath !\u003d null) {\n        DirListingMetadata parent \u003d dirCache.getIfPresent(parentPath);\n        if (parent \u003d\u003d null) {\n        /* Track this new file\u0027s listing in parent.  Parent is not\n         * authoritative, since there may be other items in it we don\u0027t know\n         * about. */\n          parent \u003d new DirListingMetadata(parentPath,\n              DirListingMetadata.EMPTY_DIR, false);\n          dirCache.put(parentPath, parent);\n        }\n        parent.put(status);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,48 @@\n+  public void put(PathMetadata meta) throws IOException {\n+\n+    Preconditions.checkNotNull(meta);\n+    FileStatus status \u003d meta.getFileStatus();\n+    Path path \u003d standardize(status.getPath());\n+    synchronized (this) {\n+\n+      /* Add entry for this file. */\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n+      }\n+      fileHash.put(path, meta);\n+\n+      /* Directory case:\n+       * We also make sure we have an entry in the dirHash, so subsequent\n+       * listStatus(path) at least see the directory.\n+       *\n+       * If we had a boolean flag argument \"isNew\", we would know whether this\n+       * is an existing directory the client discovered via getFileStatus(),\n+       * or if it is a newly-created directory.  In the latter case, we would\n+       * be able to mark the directory as authoritative (fully-cached),\n+       * saving round trips to underlying store for subsequent listStatus()\n+       */\n+\n+      if (status.isDirectory()) {\n+        DirListingMetadata dir \u003d dirHash.mruGet(path);\n+        if (dir \u003d\u003d null) {\n+          dirHash.put(path, new DirListingMetadata(path, DirListingMetadata\n+              .EMPTY_DIR, false));\n+        }\n+      }\n+\n+      /* Update cached parent dir. */\n+      Path parentPath \u003d path.getParent();\n+      if (parentPath !\u003d null) {\n+        DirListingMetadata parent \u003d dirHash.mruGet(parentPath);\n+        if (parent \u003d\u003d null) {\n+        /* Track this new file\u0027s listing in parent.  Parent is not\n+         * authoritative, since there may be other items in it we don\u0027t know\n+         * about. */\n+          parent \u003d new DirListingMetadata(parentPath,\n+              DirListingMetadata.EMPTY_DIR, false);\n+          dirHash.put(parentPath, parent);\n+        }\n+        parent.put(status);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(PathMetadata meta) throws IOException {\n\n    Preconditions.checkNotNull(meta);\n    FileStatus status \u003d meta.getFileStatus();\n    Path path \u003d standardize(status.getPath());\n    synchronized (this) {\n\n      /* Add entry for this file. */\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"put {} -\u003e {}\", path, meta.prettyPrint());\n      }\n      fileHash.put(path, meta);\n\n      /* Directory case:\n       * We also make sure we have an entry in the dirHash, so subsequent\n       * listStatus(path) at least see the directory.\n       *\n       * If we had a boolean flag argument \"isNew\", we would know whether this\n       * is an existing directory the client discovered via getFileStatus(),\n       * or if it is a newly-created directory.  In the latter case, we would\n       * be able to mark the directory as authoritative (fully-cached),\n       * saving round trips to underlying store for subsequent listStatus()\n       */\n\n      if (status.isDirectory()) {\n        DirListingMetadata dir \u003d dirHash.mruGet(path);\n        if (dir \u003d\u003d null) {\n          dirHash.put(path, new DirListingMetadata(path, DirListingMetadata\n              .EMPTY_DIR, false));\n        }\n      }\n\n      /* Update cached parent dir. */\n      Path parentPath \u003d path.getParent();\n      if (parentPath !\u003d null) {\n        DirListingMetadata parent \u003d dirHash.mruGet(parentPath);\n        if (parent \u003d\u003d null) {\n        /* Track this new file\u0027s listing in parent.  Parent is not\n         * authoritative, since there may be other items in it we don\u0027t know\n         * about. */\n          parent \u003d new DirListingMetadata(parentPath,\n              DirListingMetadata.EMPTY_DIR, false);\n          dirHash.put(parentPath, parent);\n        }\n        parent.put(status);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java"
    }
  }
}