{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAuthenticationFilterInitializer.java",
  "functionName": "createFilterConfig",
  "functionId": "createFilterConfig___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java",
  "functionStartLine": 41,
  "functionEndLine": 59,
  "numCommitsSeen": 6,
  "timeTaken": 1863,
  "changeHistory": [
    "ee2ce923a922bfc3e89ad6f0f6a25e776fe91ffb",
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9",
    "c0e034336c85296be6f549d88d137fb2b2b79a15",
    "1220bb72d452521c6f09cebe1dd77341054ee9dd",
    "d6532d3a77abe5a9b1760c1e26a899d49aa661dc"
  ],
  "changeHistoryShort": {
    "ee2ce923a922bfc3e89ad6f0f6a25e776fe91ffb": "Ybodychange",
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9": "Ybodychange",
    "c0e034336c85296be6f549d88d137fb2b2b79a15": "Ybodychange",
    "1220bb72d452521c6f09cebe1dd77341054ee9dd": "Ybodychange",
    "d6532d3a77abe5a9b1760c1e26a899d49aa661dc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ee2ce923a922bfc3e89ad6f0f6a25e776fe91ffb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8217. RmAuthenticationFilterInitializer and TimelineAuthenticationFilterInitializer should use Configuration.getPropsWithPrefix instead of iterator. Contributed by Suma Shivaprasad.\n",
      "commitDate": "03/05/18 2:13 AM",
      "commitName": "ee2ce923a922bfc3e89ad6f0f6a25e776fe91ffb",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "25/03/15 11:12 AM",
      "commitNameOld": "e4b8d9e72d54d4725bf2a902452459b6b243b2e9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1134.63,
      "commitsBetweenForRepo": 8570,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,19 @@\n   protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n-    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n-\n-    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n-    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n+    Map\u003cString, String\u003e filterConfig \u003d AuthenticationFilterInitializer\n+        .getFilterConfigMap(conf, configPrefix);\n \n     // Before conf object is passed in, RM has already processed it and used RM\n     // specific configs to overwrite hadoop common ones. Hence we just need to\n     // source hadoop.proxyuser configs here.\n-    for (Map.Entry\u003cString, String\u003e entry : conf) {\n-      String propName \u003d entry.getKey();\n-      if (propName.startsWith(configPrefix)) {\n-        String value \u003d conf.get(propName);\n-        String name \u003d propName.substring(configPrefix.length());\n-        filterConfig.put(name, value);\n-      } else if (propName.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n-        String value \u003d conf.get(propName);\n-        String name \u003d propName.substring(\"hadoop.\".length());\n-        filterConfig.put(name, value);\n-      }\n-    }\n \n-    // Resolve _HOST into bind address\n-    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n-    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n-    if (principal !\u003d null) {\n-      try {\n-        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n-      } catch (IOException ex) {\n-        throw new RuntimeException(\n-          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n-      }\n-      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n+    //Add proxy user configs\n+    for (Map.Entry\u003cString, String\u003e entry : conf.\n+        getPropsWithPrefix(ProxyUsers.CONF_HADOOP_PROXYUSER).entrySet()) {\n+      filterConfig.put(\"proxyuser\" + entry.getKey(), entry.getValue());\n     }\n \n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         RMDelegationTokenIdentifier.KIND_NAME.toString());\n \n     return filterConfig;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d AuthenticationFilterInitializer\n        .getFilterConfigMap(conf, configPrefix);\n\n    // Before conf object is passed in, RM has already processed it and used RM\n    // specific configs to overwrite hadoop common ones. Hence we just need to\n    // source hadoop.proxyuser configs here.\n\n    //Add proxy user configs\n    for (Map.Entry\u003cString, String\u003e entry : conf.\n        getPropsWithPrefix(ProxyUsers.CONF_HADOOP_PROXYUSER).entrySet()) {\n      filterConfig.put(\"proxyuser\" + entry.getKey(), entry.getValue());\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        RMDelegationTokenIdentifier.KIND_NAME.toString());\n\n    return filterConfig;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10670. Allow AuthenticationFilters to load secret from signature secret files. Contributed by Kai Zheng.\n",
      "commitDate": "25/03/15 11:12 AM",
      "commitName": "e4b8d9e72d54d4725bf2a902452459b6b243b2e9",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "21/10/14 8:09 PM",
      "commitNameOld": "c0e034336c85296be6f549d88d137fb2b2b79a15",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 154.63,
      "commitsBetweenForRepo": 1258,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,40 @@\n   protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n     Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n \n     // Before conf object is passed in, RM has already processed it and used RM\n     // specific configs to overwrite hadoop common ones. Hence we just need to\n     // source hadoop.proxyuser configs here.\n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String propName \u003d entry.getKey();\n       if (propName.startsWith(configPrefix)) {\n         String value \u003d conf.get(propName);\n         String name \u003d propName.substring(configPrefix.length());\n         filterConfig.put(name, value);\n       } else if (propName.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n         String value \u003d conf.get(propName);\n         String name \u003d propName.substring(\"hadoop.\".length());\n         filterConfig.put(name, value);\n       }\n     }\n \n-    String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n-    if (signatureSecretFile !\u003d null) {\n-      Reader reader \u003d null;\n-      try {\n-        StringBuilder secret \u003d new StringBuilder();\n-        reader \u003d\n-            new InputStreamReader(new FileInputStream(signatureSecretFile),\n-              \"UTF-8\");\n-        int c \u003d reader.read();\n-        while (c \u003e -1) {\n-          secret.append((char) c);\n-          c \u003d reader.read();\n-        }\n-        filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n-          secret.toString());\n-      } catch (IOException ex) {\n-        // if running in non-secure mode, this filter only gets added\n-        // because the user has not setup his own filter so just generate\n-        // a random secret. in secure mode, the user needs to setup security\n-        if (UserGroupInformation.isSecurityEnabled()) {\n-          throw new RuntimeException(\n-            \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n-        }\n-      } finally {\n-        IOUtils.closeQuietly(reader);\n-      }\n-    }\n-\n     // Resolve _HOST into bind address\n     String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n     String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n     if (principal !\u003d null) {\n       try {\n         principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n       } catch (IOException ex) {\n         throw new RuntimeException(\n           \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n       }\n       filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n     }\n \n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         RMDelegationTokenIdentifier.KIND_NAME.toString());\n \n     return filterConfig;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n\n    // Before conf object is passed in, RM has already processed it and used RM\n    // specific configs to overwrite hadoop common ones. Hence we just need to\n    // source hadoop.proxyuser configs here.\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String propName \u003d entry.getKey();\n      if (propName.startsWith(configPrefix)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(configPrefix.length());\n        filterConfig.put(name, value);\n      } else if (propName.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        RMDelegationTokenIdentifier.KIND_NAME.toString());\n\n    return filterConfig;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "c0e034336c85296be6f549d88d137fb2b2b79a15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2715. Fixed ResourceManager to respect common configurations for proxy users/groups beyond just the YARN level config. Contributed by Zhijie Shen.\n",
      "commitDate": "21/10/14 8:09 PM",
      "commitName": "c0e034336c85296be6f549d88d137fb2b2b79a15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/10/14 9:50 PM",
      "commitNameOld": "1220bb72d452521c6f09cebe1dd77341054ee9dd",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,68 @@\n   protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n     Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n \n+    // Before conf object is passed in, RM has already processed it and used RM\n+    // specific configs to overwrite hadoop common ones. Hence we just need to\n+    // source hadoop.proxyuser configs here.\n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String propName \u003d entry.getKey();\n       if (propName.startsWith(configPrefix)) {\n         String value \u003d conf.get(propName);\n         String name \u003d propName.substring(configPrefix.length());\n         filterConfig.put(name, value);\n-      } else if (propName.startsWith(proxyPrefix)) {\n+      } else if (propName.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n         String value \u003d conf.get(propName);\n-        String name \u003d propName.substring(\"yarn.resourcemanager.webapp.\".length());\n+        String name \u003d propName.substring(\"hadoop.\".length());\n         filterConfig.put(name, value);\n       }\n     }\n \n     String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n     if (signatureSecretFile !\u003d null) {\n       Reader reader \u003d null;\n       try {\n         StringBuilder secret \u003d new StringBuilder();\n         reader \u003d\n             new InputStreamReader(new FileInputStream(signatureSecretFile),\n               \"UTF-8\");\n         int c \u003d reader.read();\n         while (c \u003e -1) {\n           secret.append((char) c);\n           c \u003d reader.read();\n         }\n         filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n           secret.toString());\n       } catch (IOException ex) {\n         // if running in non-secure mode, this filter only gets added\n         // because the user has not setup his own filter so just generate\n         // a random secret. in secure mode, the user needs to setup security\n         if (UserGroupInformation.isSecurityEnabled()) {\n           throw new RuntimeException(\n             \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n         }\n       } finally {\n         IOUtils.closeQuietly(reader);\n       }\n     }\n \n     // Resolve _HOST into bind address\n     String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n     String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n     if (principal !\u003d null) {\n       try {\n         principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n       } catch (IOException ex) {\n         throw new RuntimeException(\n           \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n       }\n       filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n     }\n \n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         RMDelegationTokenIdentifier.KIND_NAME.toString());\n \n     return filterConfig;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n\n    // Before conf object is passed in, RM has already processed it and used RM\n    // specific configs to overwrite hadoop common ones. Hence we just need to\n    // source hadoop.proxyuser configs here.\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String propName \u003d entry.getKey();\n      if (propName.startsWith(configPrefix)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(configPrefix.length());\n        filterConfig.put(name, value);\n      } else if (propName.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d\n            new InputStreamReader(new FileInputStream(signatureSecretFile),\n              \"UTF-8\");\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n          secret.toString());\n      } catch (IOException ex) {\n        // if running in non-secure mode, this filter only gets added\n        // because the user has not setup his own filter so just generate\n        // a random secret. in secure mode, the user needs to setup security\n        if (UserGroupInformation.isSecurityEnabled()) {\n          throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n        }\n      } finally {\n        IOUtils.closeQuietly(reader);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        RMDelegationTokenIdentifier.KIND_NAME.toString());\n\n    return filterConfig;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "1220bb72d452521c6f09cebe1dd77341054ee9dd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2656. Made RM web services authentication filter support proxy user. Contributed by Varun Vasudev and Zhijie Shen.\n",
      "commitDate": "14/10/14 9:50 PM",
      "commitName": "1220bb72d452521c6f09cebe1dd77341054ee9dd",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "14/08/14 2:17 PM",
      "commitNameOld": "a9023c2736fb8a95dbba90d3f61c9eca33126af4",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 61.31,
      "commitsBetweenForRepo": 612,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,65 @@\n   protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n     Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n \n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n-      String name \u003d entry.getKey();\n-      if (name.startsWith(configPrefix)) {\n-        String value \u003d conf.get(name);\n-        name \u003d name.substring(configPrefix.length());\n+      String propName \u003d entry.getKey();\n+      if (propName.startsWith(configPrefix)) {\n+        String value \u003d conf.get(propName);\n+        String name \u003d propName.substring(configPrefix.length());\n+        filterConfig.put(name, value);\n+      } else if (propName.startsWith(proxyPrefix)) {\n+        String value \u003d conf.get(propName);\n+        String name \u003d propName.substring(\"yarn.resourcemanager.webapp.\".length());\n         filterConfig.put(name, value);\n       }\n     }\n \n     String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n     if (signatureSecretFile !\u003d null) {\n       Reader reader \u003d null;\n       try {\n         StringBuilder secret \u003d new StringBuilder();\n         reader \u003d\n             new InputStreamReader(new FileInputStream(signatureSecretFile),\n               \"UTF-8\");\n         int c \u003d reader.read();\n         while (c \u003e -1) {\n           secret.append((char) c);\n           c \u003d reader.read();\n         }\n         filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n           secret.toString());\n       } catch (IOException ex) {\n         // if running in non-secure mode, this filter only gets added\n         // because the user has not setup his own filter so just generate\n         // a random secret. in secure mode, the user needs to setup security\n         if (UserGroupInformation.isSecurityEnabled()) {\n           throw new RuntimeException(\n             \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n         }\n       } finally {\n         IOUtils.closeQuietly(reader);\n       }\n     }\n \n     // Resolve _HOST into bind address\n     String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n     String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n     if (principal !\u003d null) {\n       try {\n         principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n       } catch (IOException ex) {\n         throw new RuntimeException(\n           \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n       }\n       filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n     }\n+\n+    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n+        RMDelegationTokenIdentifier.KIND_NAME.toString());\n+\n     return filterConfig;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String propName \u003d entry.getKey();\n      if (propName.startsWith(configPrefix)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(configPrefix.length());\n        filterConfig.put(name, value);\n      } else if (propName.startsWith(proxyPrefix)) {\n        String value \u003d conf.get(propName);\n        String name \u003d propName.substring(\"yarn.resourcemanager.webapp.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d\n            new InputStreamReader(new FileInputStream(signatureSecretFile),\n              \"UTF-8\");\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n          secret.toString());\n      } catch (IOException ex) {\n        // if running in non-secure mode, this filter only gets added\n        // because the user has not setup his own filter so just generate\n        // a random secret. in secure mode, the user needs to setup security\n        if (UserGroupInformation.isSecurityEnabled()) {\n          throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n        }\n      } finally {\n        IOUtils.closeQuietly(reader);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        RMDelegationTokenIdentifier.KIND_NAME.toString());\n\n    return filterConfig;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "d6532d3a77abe5a9b1760c1e26a899d49aa661dc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2247. Made RM web services authenticate users via kerberos and delegation token. Contributed by Varun Vasudev.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1613821 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/14 10:55 AM",
      "commitName": "d6532d3a77abe5a9b1760c1e26a899d49aa661dc",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,57 @@\n+  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n+    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n+\n+    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n+    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n+\n+    for (Map.Entry\u003cString, String\u003e entry : conf) {\n+      String name \u003d entry.getKey();\n+      if (name.startsWith(configPrefix)) {\n+        String value \u003d conf.get(name);\n+        name \u003d name.substring(configPrefix.length());\n+        filterConfig.put(name, value);\n+      }\n+    }\n+\n+    String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n+    if (signatureSecretFile !\u003d null) {\n+      Reader reader \u003d null;\n+      try {\n+        StringBuilder secret \u003d new StringBuilder();\n+        reader \u003d\n+            new InputStreamReader(new FileInputStream(signatureSecretFile),\n+              \"UTF-8\");\n+        int c \u003d reader.read();\n+        while (c \u003e -1) {\n+          secret.append((char) c);\n+          c \u003d reader.read();\n+        }\n+        filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n+          secret.toString());\n+      } catch (IOException ex) {\n+        // if running in non-secure mode, this filter only gets added\n+        // because the user has not setup his own filter so just generate\n+        // a random secret. in secure mode, the user needs to setup security\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          throw new RuntimeException(\n+            \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n+        }\n+      } finally {\n+        IOUtils.closeQuietly(reader);\n+      }\n+    }\n+\n+    // Resolve _HOST into bind address\n+    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n+    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n+    if (principal !\u003d null) {\n+      try {\n+        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n+      } catch (IOException ex) {\n+        throw new RuntimeException(\n+          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n+      }\n+      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n+    }\n+    return filterConfig;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected Map\u003cString, String\u003e createFilterConfig(Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(AuthenticationFilter.COOKIE_PATH, cookiePath);\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(configPrefix)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(configPrefix.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(signatureSecretFileProperty);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d\n            new InputStreamReader(new FileInputStream(signatureSecretFile),\n              \"UTF-8\");\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig.put(AuthenticationFilter.SIGNATURE_SECRET,\n          secret.toString());\n      } catch (IOException ex) {\n        // if running in non-secure mode, this filter only gets added\n        // because the user has not setup his own filter so just generate\n        // a random secret. in secure mode, the user needs to setup security\n        if (UserGroupInformation.isSecurityEnabled()) {\n          throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \" + signatureSecretFile);\n        }\n      } finally {\n        IOUtils.closeQuietly(reader);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d filterConfig.get(kerberosPrincipalProperty);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n          \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL, principal);\n    }\n    return filterConfig;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/security/http/RMAuthenticationFilterInitializer.java"
    }
  }
}