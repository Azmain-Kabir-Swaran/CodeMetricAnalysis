{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Configuration.java",
  "functionName": "findSubVariable",
  "functionId": "findSubVariable___eval-String",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
  "functionStartLine": 1052,
  "functionEndLine": 1098,
  "numCommitsSeen": 132,
  "timeTaken": 2793,
  "changeHistory": [
    "644548f201743408904dfe24b9f5b515b2c96713"
  ],
  "changeHistoryShort": {
    "644548f201743408904dfe24b9f5b515b2c96713": "Yintroduced"
  },
  "changeHistoryDetails": {
    "644548f201743408904dfe24b9f5b515b2c96713": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-11506. Configuration variable expansion regex expensive for long values. (Gera Shegalov via gera)\n",
      "commitDate": "06/02/15 12:27 AM",
      "commitName": "644548f201743408904dfe24b9f5b515b2c96713",
      "commitAuthor": "Gera Shegalov",
      "diff": "@@ -0,0 +1,47 @@\n+  private static int[] findSubVariable(String eval) {\n+    int[] result \u003d {-1, -1};\n+\n+    int matchStart;\n+    int leftBrace;\n+\n+    // scanning for a brace first because it\u0027s less frequent than $\n+    // that can occur in nested class names\n+    //\n+    match_loop:\n+    for (matchStart \u003d 1, leftBrace \u003d eval.indexOf(\u0027{\u0027, matchStart);\n+         // minimum left brace position (follows \u0027$\u0027)\n+         leftBrace \u003e 0\n+         // right brace of a smallest valid expression \"${c}\"\n+         \u0026\u0026 leftBrace + \"{c\".length() \u003c eval.length();\n+         leftBrace \u003d eval.indexOf(\u0027{\u0027, matchStart)) {\n+      int matchedLen \u003d 0;\n+      if (eval.charAt(leftBrace - 1) \u003d\u003d \u0027$\u0027) {\n+        int subStart \u003d leftBrace + 1; // after \u0027{\u0027\n+        for (int i \u003d subStart; i \u003c eval.length(); i++) {\n+          switch (eval.charAt(i)) {\n+            case \u0027}\u0027:\n+              if (matchedLen \u003e 0) { // match\n+                result[SUB_START_IDX] \u003d subStart;\n+                result[SUB_END_IDX] \u003d subStart + matchedLen;\n+                break match_loop;\n+              }\n+              // fall through to skip 1 char\n+            case \u0027 \u0027:\n+            case \u0027$\u0027:\n+              matchStart \u003d i + 1;\n+              continue match_loop;\n+            default:\n+              matchedLen++;\n+          }\n+        }\n+        // scanned from \"${\"  to the end of eval, and no reset via \u0027 \u0027, \u0027$\u0027:\n+        //    no match!\n+        break match_loop;\n+      } else {\n+        // not a start of a variable\n+        //\n+        matchStart \u003d leftBrace + 1;\n+      }\n+    }\n+    return result;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static int[] findSubVariable(String eval) {\n    int[] result \u003d {-1, -1};\n\n    int matchStart;\n    int leftBrace;\n\n    // scanning for a brace first because it\u0027s less frequent than $\n    // that can occur in nested class names\n    //\n    match_loop:\n    for (matchStart \u003d 1, leftBrace \u003d eval.indexOf(\u0027{\u0027, matchStart);\n         // minimum left brace position (follows \u0027$\u0027)\n         leftBrace \u003e 0\n         // right brace of a smallest valid expression \"${c}\"\n         \u0026\u0026 leftBrace + \"{c\".length() \u003c eval.length();\n         leftBrace \u003d eval.indexOf(\u0027{\u0027, matchStart)) {\n      int matchedLen \u003d 0;\n      if (eval.charAt(leftBrace - 1) \u003d\u003d \u0027$\u0027) {\n        int subStart \u003d leftBrace + 1; // after \u0027{\u0027\n        for (int i \u003d subStart; i \u003c eval.length(); i++) {\n          switch (eval.charAt(i)) {\n            case \u0027}\u0027:\n              if (matchedLen \u003e 0) { // match\n                result[SUB_START_IDX] \u003d subStart;\n                result[SUB_END_IDX] \u003d subStart + matchedLen;\n                break match_loop;\n              }\n              // fall through to skip 1 char\n            case \u0027 \u0027:\n            case \u0027$\u0027:\n              matchStart \u003d i + 1;\n              continue match_loop;\n            default:\n              matchedLen++;\n          }\n        }\n        // scanned from \"${\"  to the end of eval, and no reset via \u0027 \u0027, \u0027$\u0027:\n        //    no match!\n        break match_loop;\n      } else {\n        // not a start of a variable\n        //\n        matchStart \u003d leftBrace + 1;\n      }\n    }\n    return result;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
    }
  }
}