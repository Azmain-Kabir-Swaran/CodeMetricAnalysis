{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMContainerAllocator.java",
  "functionName": "preemptReducesIfNeeded",
  "functionId": "preemptReducesIfNeeded",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
  "functionStartLine": 541,
  "functionEndLine": 585,
  "numCommitsSeen": 83,
  "timeTaken": 9620,
  "changeHistory": [
    "060558c6f221ded0b014189d5b82eee4cc7b576b",
    "c9bb96fa81fc925e33ccc0b02c98cc2d929df120",
    "4aa9b3e75ca86917125e56e1b438668273a5d87f",
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
    "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698",
    "9ca394d54dd24e67867c845a58150f6b51761512",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "060558c6f221ded0b014189d5b82eee4cc7b576b": "Ybodychange",
    "c9bb96fa81fc925e33ccc0b02c98cc2d929df120": "Ymultichange(Yreturntypechange,Ybodychange)",
    "4aa9b3e75ca86917125e56e1b438668273a5d87f": "Ybodychange",
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7": "Ybodychange",
    "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698": "Ymultichange(Ymodifierchange,Ybodychange)",
    "9ca394d54dd24e67867c845a58150f6b51761512": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "060558c6f221ded0b014189d5b82eee4cc7b576b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6541. Exclude scheduled reducer memory when calculating available mapper slots from headroom to avoid deadlock. Contributed by Varun Saxena\n",
      "commitDate": "27/10/16 5:33 AM",
      "commitName": "060558c6f221ded0b014189d5b82eee4cc7b576b",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "29/09/16 8:27 AM",
      "commitNameOld": "a1b8251bf7a7e9b776c4483fa01f7d453420eba4",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 27.88,
      "commitsBetweenForRepo": 223,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,45 @@\n   boolean preemptReducesIfNeeded() {\n     if (reduceResourceRequest.equals(Resources.none())) {\n       return false; // no reduces\n     }\n \n     if (assignedRequests.maps.size() \u003e 0) {\n       // there are assigned mappers\n       return false;\n     }\n \n     if (scheduledRequests.maps.size() \u003c\u003d 0) {\n       // there are no pending requests for mappers\n       return false;\n     }\n \n     // At this point:\n     // we have pending mappers and all assigned resources are taken by reducers\n     if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n       // Unconditional preemption is enabled.\n       // If mappers are pending for longer than the configured threshold,\n       // preempt reducers irrespective of what the headroom is.\n       if (preemptReducersForHangingMapRequests(\n           reducerUnconditionalPreemptionDelayMs)) {\n         return true;\n       }\n     }\n \n     // The pending mappers haven\u0027t been waiting for too long. Let us see if\n-    // the headroom can fit a mapper.\n-    Resource availableResourceForMap \u003d getAvailableResources();\n+    // there are enough resources for a mapper to run. This is calculated by\n+    // excluding scheduled reducers from headroom and comparing it against\n+    // resources required to run one mapper.\n+    Resource scheduledReducesResource \u003d Resources.multiply(\n+         reduceResourceRequest, scheduledRequests.reduces.size());\n+    Resource availableResourceForMap \u003d\n+         Resources.subtract(getAvailableResources(), scheduledReducesResource);\n     if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n         mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n-      // the available headroom is enough to run a mapper\n+       // Enough room to run a mapper\n       return false;\n     }\n \n-    // Available headroom is not enough to run mapper. See if we should hold\n+    // Available resources are not enough to run mapper. See if we should hold\n     // off before preempting reducers and preempt if okay.\n     return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean preemptReducesIfNeeded() {\n    if (reduceResourceRequest.equals(Resources.none())) {\n      return false; // no reduces\n    }\n\n    if (assignedRequests.maps.size() \u003e 0) {\n      // there are assigned mappers\n      return false;\n    }\n\n    if (scheduledRequests.maps.size() \u003c\u003d 0) {\n      // there are no pending requests for mappers\n      return false;\n    }\n\n    // At this point:\n    // we have pending mappers and all assigned resources are taken by reducers\n    if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n      // Unconditional preemption is enabled.\n      // If mappers are pending for longer than the configured threshold,\n      // preempt reducers irrespective of what the headroom is.\n      if (preemptReducersForHangingMapRequests(\n          reducerUnconditionalPreemptionDelayMs)) {\n        return true;\n      }\n    }\n\n    // The pending mappers haven\u0027t been waiting for too long. Let us see if\n    // there are enough resources for a mapper to run. This is calculated by\n    // excluding scheduled reducers from headroom and comparing it against\n    // resources required to run one mapper.\n    Resource scheduledReducesResource \u003d Resources.multiply(\n         reduceResourceRequest, scheduledRequests.reduces.size());\n    Resource availableResourceForMap \u003d\n         Resources.subtract(getAvailableResources(), scheduledReducesResource);\n    if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n        mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n       // Enough room to run a mapper\n      return false;\n    }\n\n    // Available resources are not enough to run mapper. See if we should hold\n    // off before preempting reducers and preempt if okay.\n    return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "c9bb96fa81fc925e33ccc0b02c98cc2d929df120": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6689. MapReduce job can infinitely increase number of reducer resource requests. Contributed by Wangda Tan\n",
      "commitDate": "06/05/16 3:25 PM",
      "commitName": "c9bb96fa81fc925e33ccc0b02c98cc2d929df120",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-6689. MapReduce job can infinitely increase number of reducer resource requests. Contributed by Wangda Tan\n",
          "commitDate": "06/05/16 3:25 PM",
          "commitName": "c9bb96fa81fc925e33ccc0b02c98cc2d929df120",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "05/05/16 7:03 PM",
          "commitNameOld": "8d48266720dcf0e71cfd87fef18b60a53aa1bef9",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  void preemptReducesIfNeeded() {\n+  boolean preemptReducesIfNeeded() {\n     if (reduceResourceRequest.equals(Resources.none())) {\n-      return; // no reduces\n+      return false; // no reduces\n     }\n \n     if (assignedRequests.maps.size() \u003e 0) {\n       // there are assigned mappers\n-      return;\n+      return false;\n     }\n \n     if (scheduledRequests.maps.size() \u003c\u003d 0) {\n       // there are no pending requests for mappers\n-      return;\n+      return false;\n     }\n+\n     // At this point:\n     // we have pending mappers and all assigned resources are taken by reducers\n-\n     if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n       // Unconditional preemption is enabled.\n       // If mappers are pending for longer than the configured threshold,\n       // preempt reducers irrespective of what the headroom is.\n       if (preemptReducersForHangingMapRequests(\n           reducerUnconditionalPreemptionDelayMs)) {\n-        return;\n+        return true;\n       }\n     }\n \n     // The pending mappers haven\u0027t been waiting for too long. Let us see if\n     // the headroom can fit a mapper.\n     Resource availableResourceForMap \u003d getAvailableResources();\n     if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n         mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n       // the available headroom is enough to run a mapper\n-      return;\n+      return false;\n     }\n \n     // Available headroom is not enough to run mapper. See if we should hold\n     // off before preempting reducers and preempt if okay.\n-    preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n+    return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean preemptReducesIfNeeded() {\n    if (reduceResourceRequest.equals(Resources.none())) {\n      return false; // no reduces\n    }\n\n    if (assignedRequests.maps.size() \u003e 0) {\n      // there are assigned mappers\n      return false;\n    }\n\n    if (scheduledRequests.maps.size() \u003c\u003d 0) {\n      // there are no pending requests for mappers\n      return false;\n    }\n\n    // At this point:\n    // we have pending mappers and all assigned resources are taken by reducers\n    if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n      // Unconditional preemption is enabled.\n      // If mappers are pending for longer than the configured threshold,\n      // preempt reducers irrespective of what the headroom is.\n      if (preemptReducersForHangingMapRequests(\n          reducerUnconditionalPreemptionDelayMs)) {\n        return true;\n      }\n    }\n\n    // The pending mappers haven\u0027t been waiting for too long. Let us see if\n    // the headroom can fit a mapper.\n    Resource availableResourceForMap \u003d getAvailableResources();\n    if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n        mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n      // the available headroom is enough to run a mapper\n      return false;\n    }\n\n    // Available headroom is not enough to run mapper. See if we should hold\n    // off before preempting reducers and preempt if okay.\n    return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6689. MapReduce job can infinitely increase number of reducer resource requests. Contributed by Wangda Tan\n",
          "commitDate": "06/05/16 3:25 PM",
          "commitName": "c9bb96fa81fc925e33ccc0b02c98cc2d929df120",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "05/05/16 7:03 PM",
          "commitNameOld": "8d48266720dcf0e71cfd87fef18b60a53aa1bef9",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  void preemptReducesIfNeeded() {\n+  boolean preemptReducesIfNeeded() {\n     if (reduceResourceRequest.equals(Resources.none())) {\n-      return; // no reduces\n+      return false; // no reduces\n     }\n \n     if (assignedRequests.maps.size() \u003e 0) {\n       // there are assigned mappers\n-      return;\n+      return false;\n     }\n \n     if (scheduledRequests.maps.size() \u003c\u003d 0) {\n       // there are no pending requests for mappers\n-      return;\n+      return false;\n     }\n+\n     // At this point:\n     // we have pending mappers and all assigned resources are taken by reducers\n-\n     if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n       // Unconditional preemption is enabled.\n       // If mappers are pending for longer than the configured threshold,\n       // preempt reducers irrespective of what the headroom is.\n       if (preemptReducersForHangingMapRequests(\n           reducerUnconditionalPreemptionDelayMs)) {\n-        return;\n+        return true;\n       }\n     }\n \n     // The pending mappers haven\u0027t been waiting for too long. Let us see if\n     // the headroom can fit a mapper.\n     Resource availableResourceForMap \u003d getAvailableResources();\n     if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n         mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n       // the available headroom is enough to run a mapper\n-      return;\n+      return false;\n     }\n \n     // Available headroom is not enough to run mapper. See if we should hold\n     // off before preempting reducers and preempt if okay.\n-    preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n+    return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean preemptReducesIfNeeded() {\n    if (reduceResourceRequest.equals(Resources.none())) {\n      return false; // no reduces\n    }\n\n    if (assignedRequests.maps.size() \u003e 0) {\n      // there are assigned mappers\n      return false;\n    }\n\n    if (scheduledRequests.maps.size() \u003c\u003d 0) {\n      // there are no pending requests for mappers\n      return false;\n    }\n\n    // At this point:\n    // we have pending mappers and all assigned resources are taken by reducers\n    if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n      // Unconditional preemption is enabled.\n      // If mappers are pending for longer than the configured threshold,\n      // preempt reducers irrespective of what the headroom is.\n      if (preemptReducersForHangingMapRequests(\n          reducerUnconditionalPreemptionDelayMs)) {\n        return true;\n      }\n    }\n\n    // The pending mappers haven\u0027t been waiting for too long. Let us see if\n    // the headroom can fit a mapper.\n    Resource availableResourceForMap \u003d getAvailableResources();\n    if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n        mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n      // the available headroom is enough to run a mapper\n      return false;\n    }\n\n    // Available headroom is not enough to run mapper. See if we should hold\n    // off before preempting reducers and preempt if okay.\n    return preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "4aa9b3e75ca86917125e56e1b438668273a5d87f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6302. Incorrect headroom can lead to a deadlock between map and reduce allocations. (kasha)\n",
      "commitDate": "09/10/15 7:37 AM",
      "commitName": "4aa9b3e75ca86917125e56e1b438668273a5d87f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/09/15 8:54 PM",
      "commitNameOld": "dfd807afab0fae3839c9cc5d552aa0304444f956",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 17.45,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,40 @@\n   void preemptReducesIfNeeded() {\n     if (reduceResourceRequest.equals(Resources.none())) {\n       return; // no reduces\n     }\n-    //check if reduces have taken over the whole cluster and there are \n-    //unassigned maps\n-    if (scheduledRequests.maps.size() \u003e 0) {\n-      Resource resourceLimit \u003d getResourceLimit();\n-      Resource availableResourceForMap \u003d\n-          Resources.subtract(\n-            resourceLimit,\n-            Resources.multiply(reduceResourceRequest,\n-              assignedRequests.reduces.size()\n-                  - assignedRequests.preemptionWaitingReduces.size()));\n-      // availableMemForMap must be sufficient to run at least 1 map\n-      if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n-        mapResourceRequest, getSchedulerResourceTypes()) \u003c\u003d 0) {\n-        // to make sure new containers are given to maps and not reduces\n-        // ramp down all scheduled reduces if any\n-        // (since reduces are scheduled at higher priority than maps)\n-        LOG.info(\"Ramping down all scheduled reduces:\"\n-            + scheduledRequests.reduces.size());\n-        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n-          pendingReduces.add(req);\n-        }\n-        scheduledRequests.reduces.clear();\n \n-        //do further checking to find the number of map requests that were\n-        //hanging around for a while\n-        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n-        if (hangingMapRequests \u003e 0) {\n-          // preempt for making space for at least one map\n-          int preemptionReduceNumForOneMap \u003d\n-              ResourceCalculatorUtils.divideAndCeilContainers(mapResourceRequest,\n-                reduceResourceRequest, getSchedulerResourceTypes());\n-          int preemptionReduceNumForPreemptionLimit \u003d\n-              ResourceCalculatorUtils.divideAndCeilContainers(\n-                Resources.multiply(resourceLimit, maxReducePreemptionLimit),\n-                reduceResourceRequest, getSchedulerResourceTypes());\n-          int preemptionReduceNumForAllMaps \u003d\n-              ResourceCalculatorUtils.divideAndCeilContainers(\n-                Resources.multiply(mapResourceRequest, hangingMapRequests),\n-                reduceResourceRequest, getSchedulerResourceTypes());\n-          int toPreempt \u003d\n-              Math.min(Math.max(preemptionReduceNumForOneMap,\n-                preemptionReduceNumForPreemptionLimit),\n-                preemptionReduceNumForAllMaps);\n+    if (assignedRequests.maps.size() \u003e 0) {\n+      // there are assigned mappers\n+      return;\n+    }\n \n-          LOG.info(\"Going to preempt \" + toPreempt\n-              + \" due to lack of space for maps\");\n-          assignedRequests.preemptReduce(toPreempt);\n-        }\n+    if (scheduledRequests.maps.size() \u003c\u003d 0) {\n+      // there are no pending requests for mappers\n+      return;\n+    }\n+    // At this point:\n+    // we have pending mappers and all assigned resources are taken by reducers\n+\n+    if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n+      // Unconditional preemption is enabled.\n+      // If mappers are pending for longer than the configured threshold,\n+      // preempt reducers irrespective of what the headroom is.\n+      if (preemptReducersForHangingMapRequests(\n+          reducerUnconditionalPreemptionDelayMs)) {\n+        return;\n       }\n     }\n+\n+    // The pending mappers haven\u0027t been waiting for too long. Let us see if\n+    // the headroom can fit a mapper.\n+    Resource availableResourceForMap \u003d getAvailableResources();\n+    if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n+        mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n+      // the available headroom is enough to run a mapper\n+      return;\n+    }\n+\n+    // Available headroom is not enough to run mapper. See if we should hold\n+    // off before preempting reducers and preempt if okay.\n+    preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void preemptReducesIfNeeded() {\n    if (reduceResourceRequest.equals(Resources.none())) {\n      return; // no reduces\n    }\n\n    if (assignedRequests.maps.size() \u003e 0) {\n      // there are assigned mappers\n      return;\n    }\n\n    if (scheduledRequests.maps.size() \u003c\u003d 0) {\n      // there are no pending requests for mappers\n      return;\n    }\n    // At this point:\n    // we have pending mappers and all assigned resources are taken by reducers\n\n    if (reducerUnconditionalPreemptionDelayMs \u003e\u003d 0) {\n      // Unconditional preemption is enabled.\n      // If mappers are pending for longer than the configured threshold,\n      // preempt reducers irrespective of what the headroom is.\n      if (preemptReducersForHangingMapRequests(\n          reducerUnconditionalPreemptionDelayMs)) {\n        return;\n      }\n    }\n\n    // The pending mappers haven\u0027t been waiting for too long. Let us see if\n    // the headroom can fit a mapper.\n    Resource availableResourceForMap \u003d getAvailableResources();\n    if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n        mapResourceRequest, getSchedulerResourceTypes()) \u003e 0) {\n      // the available headroom is enough to run a mapper\n      return;\n    }\n\n    // Available headroom is not enough to run mapper. See if we should hold\n    // off before preempting reducers and preempt if okay.\n    preemptReducersForHangingMapRequests(reducerNoHeadroomPreemptionDelayMs);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "376233cdd4a4ddbde5a92a0627f78338cb4c38b7": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5279. Made MR headroom calculation honor cpu dimension when YARN scheduler resource type is memory plus cpu. Contributed by Peng Zhang and Varun Vasudev.\n",
      "commitDate": "22/09/14 9:28 AM",
      "commitName": "376233cdd4a4ddbde5a92a0627f78338cb4c38b7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "08/08/14 2:38 PM",
      "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthorOld": "Xuan Gong",
      "daysBetweenCommits": 44.78,
      "commitsBetweenForRepo": 414,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,55 @@\n   void preemptReducesIfNeeded() {\n-    if (reduceResourceRequest \u003d\u003d 0) {\n-      return; //no reduces\n+    if (reduceResourceRequest.equals(Resources.none())) {\n+      return; // no reduces\n     }\n     //check if reduces have taken over the whole cluster and there are \n     //unassigned maps\n     if (scheduledRequests.maps.size() \u003e 0) {\n-      int memLimit \u003d getMemLimit();\n-      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n-          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceRequest);\n-      //availableMemForMap must be sufficient to run atleast 1 map\n-      if (availableMemForMap \u003c mapResourceRequest) {\n-        //to make sure new containers are given to maps and not reduces\n-        //ramp down all scheduled reduces if any\n-        //(since reduces are scheduled at higher priority than maps)\n-        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n+      Resource resourceLimit \u003d getResourceLimit();\n+      Resource availableResourceForMap \u003d\n+          Resources.subtract(\n+            resourceLimit,\n+            Resources.multiply(reduceResourceRequest,\n+              assignedRequests.reduces.size()\n+                  - assignedRequests.preemptionWaitingReduces.size()));\n+      // availableMemForMap must be sufficient to run at least 1 map\n+      if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n+        mapResourceRequest, getSchedulerResourceTypes()) \u003c\u003d 0) {\n+        // to make sure new containers are given to maps and not reduces\n+        // ramp down all scheduled reduces if any\n+        // (since reduces are scheduled at higher priority than maps)\n+        LOG.info(\"Ramping down all scheduled reduces:\"\n+            + scheduledRequests.reduces.size());\n         for (ContainerRequest req : scheduledRequests.reduces.values()) {\n           pendingReduces.add(req);\n         }\n         scheduledRequests.reduces.clear();\n \n         //do further checking to find the number of map requests that were\n         //hanging around for a while\n         int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n         if (hangingMapRequests \u003e 0) {\n-          //preempt for making space for at least one map\n-          int premeptionLimit \u003d Math.max(mapResourceRequest,\n-              (int) (maxReducePreemptionLimit * memLimit));\n+          // preempt for making space for at least one map\n+          int preemptionReduceNumForOneMap \u003d\n+              ResourceCalculatorUtils.divideAndCeilContainers(mapResourceRequest,\n+                reduceResourceRequest, getSchedulerResourceTypes());\n+          int preemptionReduceNumForPreemptionLimit \u003d\n+              ResourceCalculatorUtils.divideAndCeilContainers(\n+                Resources.multiply(resourceLimit, maxReducePreemptionLimit),\n+                reduceResourceRequest, getSchedulerResourceTypes());\n+          int preemptionReduceNumForAllMaps \u003d\n+              ResourceCalculatorUtils.divideAndCeilContainers(\n+                Resources.multiply(mapResourceRequest, hangingMapRequests),\n+                reduceResourceRequest, getSchedulerResourceTypes());\n+          int toPreempt \u003d\n+              Math.min(Math.max(preemptionReduceNumForOneMap,\n+                preemptionReduceNumForPreemptionLimit),\n+                preemptionReduceNumForAllMaps);\n \n-          int preemptMem \u003d Math.min(hangingMapRequests * mapResourceRequest,\n-              premeptionLimit);\n-\n-          int toPreempt \u003d (int) Math.ceil((float) preemptMem / reduceResourceRequest);\n-          toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n-\n-          LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n+          LOG.info(\"Going to preempt \" + toPreempt\n+              + \" due to lack of space for maps\");\n           assignedRequests.preemptReduce(toPreempt);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void preemptReducesIfNeeded() {\n    if (reduceResourceRequest.equals(Resources.none())) {\n      return; // no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      Resource resourceLimit \u003d getResourceLimit();\n      Resource availableResourceForMap \u003d\n          Resources.subtract(\n            resourceLimit,\n            Resources.multiply(reduceResourceRequest,\n              assignedRequests.reduces.size()\n                  - assignedRequests.preemptionWaitingReduces.size()));\n      // availableMemForMap must be sufficient to run at least 1 map\n      if (ResourceCalculatorUtils.computeAvailableContainers(availableResourceForMap,\n        mapResourceRequest, getSchedulerResourceTypes()) \u003c\u003d 0) {\n        // to make sure new containers are given to maps and not reduces\n        // ramp down all scheduled reduces if any\n        // (since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\"\n            + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n\n        //do further checking to find the number of map requests that were\n        //hanging around for a while\n        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n        if (hangingMapRequests \u003e 0) {\n          // preempt for making space for at least one map\n          int preemptionReduceNumForOneMap \u003d\n              ResourceCalculatorUtils.divideAndCeilContainers(mapResourceRequest,\n                reduceResourceRequest, getSchedulerResourceTypes());\n          int preemptionReduceNumForPreemptionLimit \u003d\n              ResourceCalculatorUtils.divideAndCeilContainers(\n                Resources.multiply(resourceLimit, maxReducePreemptionLimit),\n                reduceResourceRequest, getSchedulerResourceTypes());\n          int preemptionReduceNumForAllMaps \u003d\n              ResourceCalculatorUtils.divideAndCeilContainers(\n                Resources.multiply(mapResourceRequest, hangingMapRequests),\n                reduceResourceRequest, getSchedulerResourceTypes());\n          int toPreempt \u003d\n              Math.min(Math.max(preemptionReduceNumForOneMap,\n                preemptionReduceNumForPreemptionLimit),\n                preemptionReduceNumForAllMaps);\n\n          LOG.info(\"Going to preempt \" + toPreempt\n              + \" due to lack of space for maps\");\n          assignedRequests.preemptReduce(toPreempt);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5844. Add a configurable delay to reducer-preemption. (Maysam Yabandeh via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603957 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/14 10:22 AM",
      "commitName": "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-5844. Add a configurable delay to reducer-preemption. (Maysam Yabandeh via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603957 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/06/14 10:22 AM",
          "commitName": "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "22/04/14 11:44 AM",
          "commitNameOld": "4a91b876db768e7997e740d754aeea66c3b7a36c",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 57.94,
          "commitsBetweenForRepo": 333,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,41 @@\n-  private void preemptReducesIfNeeded() {\n-    if (reduceResourceReqt \u003d\u003d 0) {\n+  void preemptReducesIfNeeded() {\n+    if (reduceResourceRequest \u003d\u003d 0) {\n       return; //no reduces\n     }\n     //check if reduces have taken over the whole cluster and there are \n     //unassigned maps\n     if (scheduledRequests.maps.size() \u003e 0) {\n       int memLimit \u003d getMemLimit();\n       int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n-          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n+          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceRequest);\n       //availableMemForMap must be sufficient to run atleast 1 map\n-      if (availableMemForMap \u003c mapResourceReqt) {\n+      if (availableMemForMap \u003c mapResourceRequest) {\n         //to make sure new containers are given to maps and not reduces\n         //ramp down all scheduled reduces if any\n         //(since reduces are scheduled at higher priority than maps)\n         LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n         for (ContainerRequest req : scheduledRequests.reduces.values()) {\n           pendingReduces.add(req);\n         }\n         scheduledRequests.reduces.clear();\n-        \n-        //preempt for making space for at least one map\n-        int premeptionLimit \u003d Math.max(mapResourceReqt, \n-            (int) (maxReducePreemptionLimit * memLimit));\n-        \n-        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n-            premeptionLimit);\n-        \n-        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n-        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n-        \n-        LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n-        assignedRequests.preemptReduce(toPreempt);\n+\n+        //do further checking to find the number of map requests that were\n+        //hanging around for a while\n+        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n+        if (hangingMapRequests \u003e 0) {\n+          //preempt for making space for at least one map\n+          int premeptionLimit \u003d Math.max(mapResourceRequest,\n+              (int) (maxReducePreemptionLimit * memLimit));\n+\n+          int preemptMem \u003d Math.min(hangingMapRequests * mapResourceRequest,\n+              premeptionLimit);\n+\n+          int toPreempt \u003d (int) Math.ceil((float) preemptMem / reduceResourceRequest);\n+          toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n+\n+          LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n+          assignedRequests.preemptReduce(toPreempt);\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void preemptReducesIfNeeded() {\n    if (reduceResourceRequest \u003d\u003d 0) {\n      return; //no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      int memLimit \u003d getMemLimit();\n      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceRequest);\n      //availableMemForMap must be sufficient to run atleast 1 map\n      if (availableMemForMap \u003c mapResourceRequest) {\n        //to make sure new containers are given to maps and not reduces\n        //ramp down all scheduled reduces if any\n        //(since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n\n        //do further checking to find the number of map requests that were\n        //hanging around for a while\n        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n        if (hangingMapRequests \u003e 0) {\n          //preempt for making space for at least one map\n          int premeptionLimit \u003d Math.max(mapResourceRequest,\n              (int) (maxReducePreemptionLimit * memLimit));\n\n          int preemptMem \u003d Math.min(hangingMapRequests * mapResourceRequest,\n              premeptionLimit);\n\n          int toPreempt \u003d (int) Math.ceil((float) preemptMem / reduceResourceRequest);\n          toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n\n          LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n          assignedRequests.preemptReduce(toPreempt);\n        }\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5844. Add a configurable delay to reducer-preemption. (Maysam Yabandeh via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603957 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/06/14 10:22 AM",
          "commitName": "7b9c074b7635e3dcdc38d4e7fb1afbff7145e698",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "22/04/14 11:44 AM",
          "commitNameOld": "4a91b876db768e7997e740d754aeea66c3b7a36c",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 57.94,
          "commitsBetweenForRepo": 333,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,41 @@\n-  private void preemptReducesIfNeeded() {\n-    if (reduceResourceReqt \u003d\u003d 0) {\n+  void preemptReducesIfNeeded() {\n+    if (reduceResourceRequest \u003d\u003d 0) {\n       return; //no reduces\n     }\n     //check if reduces have taken over the whole cluster and there are \n     //unassigned maps\n     if (scheduledRequests.maps.size() \u003e 0) {\n       int memLimit \u003d getMemLimit();\n       int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n-          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n+          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceRequest);\n       //availableMemForMap must be sufficient to run atleast 1 map\n-      if (availableMemForMap \u003c mapResourceReqt) {\n+      if (availableMemForMap \u003c mapResourceRequest) {\n         //to make sure new containers are given to maps and not reduces\n         //ramp down all scheduled reduces if any\n         //(since reduces are scheduled at higher priority than maps)\n         LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n         for (ContainerRequest req : scheduledRequests.reduces.values()) {\n           pendingReduces.add(req);\n         }\n         scheduledRequests.reduces.clear();\n-        \n-        //preempt for making space for at least one map\n-        int premeptionLimit \u003d Math.max(mapResourceReqt, \n-            (int) (maxReducePreemptionLimit * memLimit));\n-        \n-        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n-            premeptionLimit);\n-        \n-        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n-        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n-        \n-        LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n-        assignedRequests.preemptReduce(toPreempt);\n+\n+        //do further checking to find the number of map requests that were\n+        //hanging around for a while\n+        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n+        if (hangingMapRequests \u003e 0) {\n+          //preempt for making space for at least one map\n+          int premeptionLimit \u003d Math.max(mapResourceRequest,\n+              (int) (maxReducePreemptionLimit * memLimit));\n+\n+          int preemptMem \u003d Math.min(hangingMapRequests * mapResourceRequest,\n+              premeptionLimit);\n+\n+          int toPreempt \u003d (int) Math.ceil((float) preemptMem / reduceResourceRequest);\n+          toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n+\n+          LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n+          assignedRequests.preemptReduce(toPreempt);\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void preemptReducesIfNeeded() {\n    if (reduceResourceRequest \u003d\u003d 0) {\n      return; //no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      int memLimit \u003d getMemLimit();\n      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceRequest);\n      //availableMemForMap must be sufficient to run atleast 1 map\n      if (availableMemForMap \u003c mapResourceRequest) {\n        //to make sure new containers are given to maps and not reduces\n        //ramp down all scheduled reduces if any\n        //(since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n\n        //do further checking to find the number of map requests that were\n        //hanging around for a while\n        int hangingMapRequests \u003d getNumOfHangingRequests(scheduledRequests.maps);\n        if (hangingMapRequests \u003e 0) {\n          //preempt for making space for at least one map\n          int premeptionLimit \u003d Math.max(mapResourceRequest,\n              (int) (maxReducePreemptionLimit * memLimit));\n\n          int preemptMem \u003d Math.min(hangingMapRequests * mapResourceRequest,\n              premeptionLimit);\n\n          int toPreempt \u003d (int) Math.ceil((float) preemptMem / reduceResourceRequest);\n          toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n\n          LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n          assignedRequests.preemptReduce(toPreempt);\n        }\n      }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "9ca394d54dd24e67867c845a58150f6b51761512": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5189. Add policies and wiring to respond to preemption requests\nfrom YARN. Contributed by Carlo Curino.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/13 2:54 PM",
      "commitName": "9ca394d54dd24e67867c845a58150f6b51761512",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "18/07/13 5:57 PM",
      "commitNameOld": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 151.91,
      "commitsBetweenForRepo": 987,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private void preemptReducesIfNeeded() {\n     if (reduceResourceReqt \u003d\u003d 0) {\n       return; //no reduces\n     }\n     //check if reduces have taken over the whole cluster and there are \n     //unassigned maps\n     if (scheduledRequests.maps.size() \u003e 0) {\n       int memLimit \u003d getMemLimit();\n       int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n           assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n       //availableMemForMap must be sufficient to run atleast 1 map\n       if (availableMemForMap \u003c mapResourceReqt) {\n         //to make sure new containers are given to maps and not reduces\n         //ramp down all scheduled reduces if any\n         //(since reduces are scheduled at higher priority than maps)\n         LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n         for (ContainerRequest req : scheduledRequests.reduces.values()) {\n           pendingReduces.add(req);\n         }\n         scheduledRequests.reduces.clear();\n         \n-        //preempt for making space for atleast one map\n+        //preempt for making space for at least one map\n         int premeptionLimit \u003d Math.max(mapResourceReqt, \n             (int) (maxReducePreemptionLimit * memLimit));\n         \n         int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n             premeptionLimit);\n         \n         int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n         toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n         \n-        LOG.info(\"Going to preempt \" + toPreempt);\n+        LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n         assignedRequests.preemptReduce(toPreempt);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptReducesIfNeeded() {\n    if (reduceResourceReqt \u003d\u003d 0) {\n      return; //no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      int memLimit \u003d getMemLimit();\n      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n      //availableMemForMap must be sufficient to run atleast 1 map\n      if (availableMemForMap \u003c mapResourceReqt) {\n        //to make sure new containers are given to maps and not reduces\n        //ramp down all scheduled reduces if any\n        //(since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n        \n        //preempt for making space for at least one map\n        int premeptionLimit \u003d Math.max(mapResourceReqt, \n            (int) (maxReducePreemptionLimit * memLimit));\n        \n        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n            premeptionLimit);\n        \n        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n        \n        LOG.info(\"Going to preempt \" + toPreempt + \" due to lack of space for maps\");\n        assignedRequests.preemptReduce(toPreempt);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void preemptReducesIfNeeded() {\n    if (reduceResourceReqt \u003d\u003d 0) {\n      return; //no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      int memLimit \u003d getMemLimit();\n      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n      //availableMemForMap must be sufficient to run atleast 1 map\n      if (availableMemForMap \u003c mapResourceReqt) {\n        //to make sure new containers are given to maps and not reduces\n        //ramp down all scheduled reduces if any\n        //(since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n        \n        //preempt for making space for atleast one map\n        int premeptionLimit \u003d Math.max(mapResourceReqt, \n            (int) (maxReducePreemptionLimit * memLimit));\n        \n        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n            premeptionLimit);\n        \n        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n        \n        LOG.info(\"Going to preempt \" + toPreempt);\n        assignedRequests.preemptReduce(toPreempt);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,36 @@\n+  private void preemptReducesIfNeeded() {\n+    if (reduceResourceReqt \u003d\u003d 0) {\n+      return; //no reduces\n+    }\n+    //check if reduces have taken over the whole cluster and there are \n+    //unassigned maps\n+    if (scheduledRequests.maps.size() \u003e 0) {\n+      int memLimit \u003d getMemLimit();\n+      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n+          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n+      //availableMemForMap must be sufficient to run atleast 1 map\n+      if (availableMemForMap \u003c mapResourceReqt) {\n+        //to make sure new containers are given to maps and not reduces\n+        //ramp down all scheduled reduces if any\n+        //(since reduces are scheduled at higher priority than maps)\n+        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n+        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n+          pendingReduces.add(req);\n+        }\n+        scheduledRequests.reduces.clear();\n+        \n+        //preempt for making space for atleast one map\n+        int premeptionLimit \u003d Math.max(mapResourceReqt, \n+            (int) (maxReducePreemptionLimit * memLimit));\n+        \n+        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n+            premeptionLimit);\n+        \n+        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n+        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n+        \n+        LOG.info(\"Going to preempt \" + toPreempt);\n+        assignedRequests.preemptReduce(toPreempt);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void preemptReducesIfNeeded() {\n    if (reduceResourceReqt \u003d\u003d 0) {\n      return; //no reduces\n    }\n    //check if reduces have taken over the whole cluster and there are \n    //unassigned maps\n    if (scheduledRequests.maps.size() \u003e 0) {\n      int memLimit \u003d getMemLimit();\n      int availableMemForMap \u003d memLimit - ((assignedRequests.reduces.size() -\n          assignedRequests.preemptionWaitingReduces.size()) * reduceResourceReqt);\n      //availableMemForMap must be sufficient to run atleast 1 map\n      if (availableMemForMap \u003c mapResourceReqt) {\n        //to make sure new containers are given to maps and not reduces\n        //ramp down all scheduled reduces if any\n        //(since reduces are scheduled at higher priority than maps)\n        LOG.info(\"Ramping down all scheduled reduces:\" + scheduledRequests.reduces.size());\n        for (ContainerRequest req : scheduledRequests.reduces.values()) {\n          pendingReduces.add(req);\n        }\n        scheduledRequests.reduces.clear();\n        \n        //preempt for making space for atleast one map\n        int premeptionLimit \u003d Math.max(mapResourceReqt, \n            (int) (maxReducePreemptionLimit * memLimit));\n        \n        int preemptMem \u003d Math.min(scheduledRequests.maps.size() * mapResourceReqt, \n            premeptionLimit);\n        \n        int toPreempt \u003d (int) Math.ceil((float) preemptMem/reduceResourceReqt);\n        toPreempt \u003d Math.min(toPreempt, assignedRequests.reduces.size());\n        \n        LOG.info(\"Going to preempt \" + toPreempt);\n        assignedRequests.preemptReduce(toPreempt);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerAllocator.java"
    }
  }
}