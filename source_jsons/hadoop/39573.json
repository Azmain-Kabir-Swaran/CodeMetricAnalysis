{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ParentQueue.java",
  "functionName": "getResourceLimitsOfChild",
  "functionId": "getResourceLimitsOfChild___child-CSQueue__clusterResource-Resource__parentLimits-Resource__nodePartition-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
  "functionStartLine": 748,
  "functionEndLine": 779,
  "numCommitsSeen": 264,
  "timeTaken": 8138,
  "changeHistory": [
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15",
    "14dd647c556016d351f425ee956ccf800ccb9ce2"
  ],
  "changeHistoryShort": {
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0": "Ymultichange(Yparameterchange,Ybodychange)",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ymultichange(Yparameterchange,Ybodychange)",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ymultichange(Yparameterchange,Ybodychange)",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ymultichange(Yparameterchange,Ybodychange)",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": "Ymultichange(Yparameterchange,Ybodychange)",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7538. Fix performance regression introduced by Capacity Scheduler absolute min/max resource refactoring. (Sunil G via wangda)\n\nChange-Id: Ic9bd7e599c56970fe01cb0e1bba6df7d1f77eb29\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "b7b8cd53242da8d47ba4a6d99d906bdb2a1a3494",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "e65ca92fb6897a3004a235d7b69e308399189aae",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n       Resource clusterResource, Resource parentLimits,\n       String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n     Resource parentMaxAvailableResource \u003d Resources.subtract(\n         parentLimits, queueUsage.getUsed(nodePartition));\n     // Deduct killable from used\n     Resources.addTo(parentMaxAvailableResource,\n         getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n         child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d getEffectiveMaxCapacityDown(\n-        nodePartition, minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d child\n+        .getEffectiveMaxCapacityDown(nodePartition, minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, Resource parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits, queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d child\n        .getEffectiveMaxCapacityDown(nodePartition, minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,32 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n       Resource clusterResource, Resource parentLimits,\n       String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n     Resource parentMaxAvailableResource \u003d Resources.subtract(\n         parentLimits, queueUsage.getUsed(nodePartition));\n     // Deduct killable from used\n     Resources.addTo(parentMaxAvailableResource,\n         getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n         child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n-        resourceCalculator,\n-        labelManager.getResourceByLabel(nodePartition, clusterResource),\n-        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n-        minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d getEffectiveMaxCapacityDown(\n+        nodePartition, minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, Resource parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits, queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d getEffectiveMaxCapacityDown(\n        nodePartition, minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
      "extendedDetails": {}
    },
    "4d92aefd35d4517d9435d81bafdec0d77905a7a0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4280. CapacityScheduler reservations may not prevent indefinite postponement on a busy cluster. Contributed by Kuhu Shukla\n",
      "commitDate": "03/08/16 11:53 AM",
      "commitName": "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4280. CapacityScheduler reservations may not prevent indefinite postponement on a busy cluster. Contributed by Kuhu Shukla\n",
          "commitDate": "03/08/16 11:53 AM",
          "commitName": "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "16/03/16 5:02 PM",
          "commitNameOld": "ae14e5d07f1b6702a5160637438028bb03d9387e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 139.79,
          "commitsBetweenForRepo": 1021,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits,\n+      Resource clusterResource, Resource parentLimits,\n       String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n     Resource parentMaxAvailableResource \u003d Resources.subtract(\n-        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+        parentLimits, queueUsage.getUsed(nodePartition));\n     // Deduct killable from used\n     Resources.addTo(parentMaxAvailableResource,\n         getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n         child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n     Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n         resourceCalculator,\n         labelManager.getResourceByLabel(nodePartition, clusterResource),\n         child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n         minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, Resource parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits, queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits, nodePartition-String]",
            "newValue": "[child-CSQueue, clusterResource-Resource, parentLimits-Resource, nodePartition-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4280. CapacityScheduler reservations may not prevent indefinite postponement on a busy cluster. Contributed by Kuhu Shukla\n",
          "commitDate": "03/08/16 11:53 AM",
          "commitName": "4d92aefd35d4517d9435d81bafdec0d77905a7a0",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "16/03/16 5:02 PM",
          "commitNameOld": "ae14e5d07f1b6702a5160637438028bb03d9387e",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 139.79,
          "commitsBetweenForRepo": 1021,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits,\n+      Resource clusterResource, Resource parentLimits,\n       String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n     Resource parentMaxAvailableResource \u003d Resources.subtract(\n-        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+        parentLimits, queueUsage.getUsed(nodePartition));\n     // Deduct killable from used\n     Resources.addTo(parentMaxAvailableResource,\n         getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n         child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n     Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n         resourceCalculator,\n         labelManager.getResourceByLabel(nodePartition, clusterResource),\n         child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n         minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, Resource parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits, queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
          "commitDate": "16/03/16 5:02 PM",
          "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/03/16 5:02 PM",
          "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits) {\n+      Resource clusterResource, ResourceLimits parentLimits,\n+      String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d\n-        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+    Resource parentMaxAvailableResource \u003d Resources.subtract(\n+        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+    // Deduct killable from used\n+    Resources.addTo(parentMaxAvailableResource,\n+        getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d\n-        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n+        child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n-            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n-            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n+        resourceCalculator,\n+        labelManager.getResourceByLabel(nodePartition, clusterResource),\n+        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n+        minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits]",
            "newValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits, nodePartition-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
          "commitDate": "16/03/16 5:02 PM",
          "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/03/16 5:02 PM",
          "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits) {\n+      Resource clusterResource, ResourceLimits parentLimits,\n+      String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d\n-        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+    Resource parentMaxAvailableResource \u003d Resources.subtract(\n+        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+    // Deduct killable from used\n+    Resources.addTo(parentMaxAvailableResource,\n+        getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d\n-        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n+        child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n-            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n-            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n+        resourceCalculator,\n+        labelManager.getResourceByLabel(nodePartition, clusterResource),\n+        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n+        minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
          "commitDate": "16/03/16 5:02 PM",
          "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/03/16 4:59 PM",
          "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,30 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits,\n-      String nodePartition) {\n+      Resource clusterResource, ResourceLimits parentLimits) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d Resources.subtract(\n-        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n-    // Deduct killable from used\n-    Resources.addTo(parentMaxAvailableResource,\n-        getTotalKillableResource(nodePartition));\n+    Resource parentMaxAvailableResource \u003d\n+        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n-        child.getQueueResourceUsage().getUsed(nodePartition));\n+    Resource childLimit \u003d\n+        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n-        resourceCalculator,\n-        labelManager.getResourceByLabel(nodePartition, clusterResource),\n-        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n-        minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n+            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d\n        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d\n        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits, nodePartition-String]",
            "newValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
          "commitDate": "16/03/16 5:02 PM",
          "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/03/16 4:59 PM",
          "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,30 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits,\n-      String nodePartition) {\n+      Resource clusterResource, ResourceLimits parentLimits) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d Resources.subtract(\n-        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n-    // Deduct killable from used\n-    Resources.addTo(parentMaxAvailableResource,\n-        getTotalKillableResource(nodePartition));\n+    Resource parentMaxAvailableResource \u003d\n+        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n-        child.getQueueResourceUsage().getUsed(nodePartition));\n+    Resource childLimit \u003d\n+        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n-        resourceCalculator,\n-        labelManager.getResourceByLabel(nodePartition, clusterResource),\n-        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n-        minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n+            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d\n        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d\n        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
          "commitDate": "16/03/16 4:59 PM",
          "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "28/02/16 9:35 AM",
          "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 17.27,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits) {\n+      Resource clusterResource, ResourceLimits parentLimits,\n+      String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d\n-        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+    Resource parentMaxAvailableResource \u003d Resources.subtract(\n+        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+    // Deduct killable from used\n+    Resources.addTo(parentMaxAvailableResource,\n+        getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d\n-        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n+        child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n-            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n-            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n+        resourceCalculator,\n+        labelManager.getResourceByLabel(nodePartition, clusterResource),\n+        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n+        minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits]",
            "newValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits, nodePartition-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
          "commitDate": "16/03/16 4:59 PM",
          "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "28/02/16 9:35 AM",
          "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 17.27,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,35 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits parentLimits) {\n+      Resource clusterResource, ResourceLimits parentLimits,\n+      String nodePartition) {\n     // Set resource-limit of a given child, child.limit \u003d\n     // min(my.limit - my.used + child.used, child.max)\n \n     // Parent available resource \u003d parent-limit - parent-used-resource\n-    Resource parentMaxAvailableResource \u003d\n-        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+    Resource parentMaxAvailableResource \u003d Resources.subtract(\n+        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n+    // Deduct killable from used\n+    Resources.addTo(parentMaxAvailableResource,\n+        getTotalKillableResource(nodePartition));\n \n     // Child\u0027s limit \u003d parent-available-resource + child-used\n-    Resource childLimit \u003d\n-        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n+        child.getQueueResourceUsage().getUsed(nodePartition));\n \n     // Get child\u0027s max resource\n-    Resource childConfiguredMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n-            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n-            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n+        resourceCalculator,\n+        labelManager.getResourceByLabel(nodePartition, clusterResource),\n+        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n+        minimumAllocation);\n \n     // Child\u0027s limit should be capped by child configured max resource\n     childLimit \u003d\n         Resources.min(resourceCalculator, clusterResource, childLimit,\n             childConfiguredMaxResource);\n \n     // Normalize before return\n     childLimit \u003d\n         Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n \n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits,\n      String nodePartition) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d Resources.subtract(\n        parentLimits.getLimit(), queueUsage.getUsed(nodePartition));\n    // Deduct killable from used\n    Resources.addTo(parentMaxAvailableResource,\n        getTotalKillableResource(nodePartition));\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d Resources.add(parentMaxAvailableResource,\n        child.getQueueResourceUsage().getUsed(nodePartition));\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d Resources.multiplyAndNormalizeDown(\n        resourceCalculator,\n        labelManager.getResourceByLabel(nodePartition, clusterResource),\n        child.getQueueCapacities().getAbsoluteMaximumCapacity(nodePartition),\n        minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/15 10:24 AM",
      "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,30 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits myLimits) {\n-    /*\n-     * Set head-room of a given child, limit \u003d\n-     * min(minimum-of-limit-of-this-queue-and-ancestors, this.max) - this.used\n-     * + child.used. To avoid any of this queue\u0027s and its ancestors\u0027 limit\n-     * being violated\n-     */\n-    Resource myCurrentLimit \u003d\n-        getCurrentResourceLimit(clusterResource, myLimits);\n-    // My available resource \u003d my-current-limit - my-used-resource\n-    Resource myMaxAvailableResource \u003d Resources.subtract(myCurrentLimit,\n-        getUsedResources());\n-    // Child\u0027s limit \u003d my-available-resource + resource-already-used-by-child\n+      Resource clusterResource, ResourceLimits parentLimits) {\n+    // Set resource-limit of a given child, child.limit \u003d\n+    // min(my.limit - my.used + child.used, child.max)\n+\n+    // Parent available resource \u003d parent-limit - parent-used-resource\n+    Resource parentMaxAvailableResource \u003d\n+        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+\n+    // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d\n-        Resources.add(myMaxAvailableResource, child.getUsedResources());\n-    \n+        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+\n+    // Get child\u0027s max resource\n+    Resource childConfiguredMaxResource \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n+            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+\n+    // Child\u0027s limit should be capped by child configured max resource\n+    childLimit \u003d\n+        Resources.min(resourceCalculator, clusterResource, childLimit,\n+            childConfiguredMaxResource);\n+\n+    // Normalize before return\n+    childLimit \u003d\n+        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n+\n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d\n        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d\n        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {
            "oldValue": "[child-CSQueue, clusterResource-Resource, myLimits-ResourceLimits]",
            "newValue": "[child-CSQueue, clusterResource-Resource, parentLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,30 @@\n   private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n-      Resource clusterResource, ResourceLimits myLimits) {\n-    /*\n-     * Set head-room of a given child, limit \u003d\n-     * min(minimum-of-limit-of-this-queue-and-ancestors, this.max) - this.used\n-     * + child.used. To avoid any of this queue\u0027s and its ancestors\u0027 limit\n-     * being violated\n-     */\n-    Resource myCurrentLimit \u003d\n-        getCurrentResourceLimit(clusterResource, myLimits);\n-    // My available resource \u003d my-current-limit - my-used-resource\n-    Resource myMaxAvailableResource \u003d Resources.subtract(myCurrentLimit,\n-        getUsedResources());\n-    // Child\u0027s limit \u003d my-available-resource + resource-already-used-by-child\n+      Resource clusterResource, ResourceLimits parentLimits) {\n+    // Set resource-limit of a given child, child.limit \u003d\n+    // min(my.limit - my.used + child.used, child.max)\n+\n+    // Parent available resource \u003d parent-limit - parent-used-resource\n+    Resource parentMaxAvailableResource \u003d\n+        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n+\n+    // Child\u0027s limit \u003d parent-available-resource + child-used\n     Resource childLimit \u003d\n-        Resources.add(myMaxAvailableResource, child.getUsedResources());\n-    \n+        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n+\n+    // Get child\u0027s max resource\n+    Resource childConfiguredMaxResource \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n+            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n+\n+    // Child\u0027s limit should be capped by child configured max resource\n+    childLimit \u003d\n+        Resources.min(resourceCalculator, clusterResource, childLimit,\n+            childConfiguredMaxResource);\n+\n+    // Normalize before return\n+    childLimit \u003d\n+        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n+\n     return new ResourceLimits(childLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits parentLimits) {\n    // Set resource-limit of a given child, child.limit \u003d\n    // min(my.limit - my.used + child.used, child.max)\n\n    // Parent available resource \u003d parent-limit - parent-used-resource\n    Resource parentMaxAvailableResource \u003d\n        Resources.subtract(parentLimits.getLimit(), getUsedResources());\n\n    // Child\u0027s limit \u003d parent-available-resource + child-used\n    Resource childLimit \u003d\n        Resources.add(parentMaxAvailableResource, child.getUsedResources());\n\n    // Get child\u0027s max resource\n    Resource childConfiguredMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator, labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL, clusterResource),\n            child.getAbsoluteMaximumCapacity(), minimumAllocation);\n\n    // Child\u0027s limit should be capped by child configured max resource\n    childLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, childLimit,\n            childConfiguredMaxResource);\n\n    // Normalize before return\n    childLimit \u003d\n        Resources.roundDown(resourceCalculator, childLimit, minimumAllocation);\n\n    return new ResourceLimits(childLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,19 @@\n+  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n+      Resource clusterResource, ResourceLimits myLimits) {\n+    /*\n+     * Set head-room of a given child, limit \u003d\n+     * min(minimum-of-limit-of-this-queue-and-ancestors, this.max) - this.used\n+     * + child.used. To avoid any of this queue\u0027s and its ancestors\u0027 limit\n+     * being violated\n+     */\n+    Resource myCurrentLimit \u003d\n+        getCurrentResourceLimit(clusterResource, myLimits);\n+    // My available resource \u003d my-current-limit - my-used-resource\n+    Resource myMaxAvailableResource \u003d Resources.subtract(myCurrentLimit,\n+        getUsedResources());\n+    // Child\u0027s limit \u003d my-available-resource + resource-already-used-by-child\n+    Resource childLimit \u003d\n+        Resources.add(myMaxAvailableResource, child.getUsedResources());\n+    \n+    return new ResourceLimits(childLimit);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ResourceLimits getResourceLimitsOfChild(CSQueue child,\n      Resource clusterResource, ResourceLimits myLimits) {\n    /*\n     * Set head-room of a given child, limit \u003d\n     * min(minimum-of-limit-of-this-queue-and-ancestors, this.max) - this.used\n     * + child.used. To avoid any of this queue\u0027s and its ancestors\u0027 limit\n     * being violated\n     */\n    Resource myCurrentLimit \u003d\n        getCurrentResourceLimit(clusterResource, myLimits);\n    // My available resource \u003d my-current-limit - my-used-resource\n    Resource myMaxAvailableResource \u003d Resources.subtract(myCurrentLimit,\n        getUsedResources());\n    // Child\u0027s limit \u003d my-available-resource + resource-already-used-by-child\n    Resource childLimit \u003d\n        Resources.add(myMaxAvailableResource, child.getUsedResources());\n    \n    return new ResourceLimits(childLimit);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ParentQueue.java"
    }
  }
}