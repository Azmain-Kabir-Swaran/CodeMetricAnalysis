{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSInputStream.java",
  "functionName": "actualGetFromOneDataNode",
  "functionId": "actualGetFromOneDataNode___datanode-DNAddrPair(modifiers-final)__startInBlk-long(modifiers-final)__endInBlk-long(modifiers-final)__buf-ByteBuffer__corruptedBlocks-CorruptedBlocks",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
  "functionStartLine": 1182,
  "functionEndLine": 1266,
  "numCommitsSeen": 101,
  "timeTaken": 6133,
  "changeHistory": [
    "b3119b9ab60a19d624db476c4e1c53410870c7a6",
    "6d5e87aec2f615ed265dc495873bf53ee7d2ace2",
    "70fc6746b326b9a913e8bebca5f5afaf01ab9e11",
    "1b5cceaffbdde50a87ede81552dc380832db8e79",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
    "401db4fc65140979fe7665983e36905e886df971",
    "793447f79924c97c2b562d5e41fa85adf19673fe",
    "be34e85e682880f46eee0310bf00ecc7d39cd5bd",
    "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
    "8808779db351fe444388d4acb3094766b5980718"
  ],
  "changeHistoryShort": {
    "b3119b9ab60a19d624db476c4e1c53410870c7a6": "Ybodychange",
    "6d5e87aec2f615ed265dc495873bf53ee7d2ace2": "Ybodychange",
    "70fc6746b326b9a913e8bebca5f5afaf01ab9e11": "Ymultichange(Yparameterchange,Ybodychange)",
    "1b5cceaffbdde50a87ede81552dc380832db8e79": "Ybodychange",
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": "Ybodychange",
    "401db4fc65140979fe7665983e36905e886df971": "Ymultichange(Yparameterchange,Ybodychange)",
    "793447f79924c97c2b562d5e41fa85adf19673fe": "Ybodychange",
    "be34e85e682880f46eee0310bf00ecc7d39cd5bd": "Ybodychange",
    "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b": "Ybodychange",
    "8808779db351fe444388d4acb3094766b5980718": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "b3119b9ab60a19d624db476c4e1c53410870c7a6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14648. Implement DeadNodeDetector basic model. Contributed by Lisheng Sun.\n",
      "commitDate": "15/11/19 7:32 PM",
      "commitName": "b3119b9ab60a19d624db476c4e1c53410870c7a6",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "06/11/19 5:58 AM",
      "commitNameOld": "c36014165c212b26d75268ee3659aa2cadcff349",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 9.57,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,85 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n       final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n     LocatedBlock block \u003d datanode.block;\n     while (true) {\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (readStatistics.getBlockType() \u003d\u003d BlockType.STRIPED) {\n           dfsClient.updateFileSystemECReadStats(nread);\n         }\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n-        addToDeadNodes(datanode.info);\n+        addToLocalDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n-          addToDeadNodes(datanode.info);\n+          addToLocalDeadNodes(datanode.info);\n+          dfsClient.addNodeToDeadNodeDetector(this, datanode.info);\n           throw new IOException(msg);\n         }\n         // Refresh the block for updated tokens in case of token failures or\n         // encryption key failures.\n         block \u003d refreshLocatedBlock(block);\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n    LocatedBlock block \u003d datanode.block;\n    while (true) {\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (readStatistics.getBlockType() \u003d\u003d BlockType.STRIPED) {\n          dfsClient.updateFileSystemECReadStats(nread);\n        }\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToLocalDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToLocalDeadNodes(datanode.info);\n          dfsClient.addNodeToDeadNodeDetector(this, datanode.info);\n          throw new IOException(msg);\n        }\n        // Refresh the block for updated tokens in case of token failures or\n        // encryption key failures.\n        block \u003d refreshLocatedBlock(block);\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "6d5e87aec2f615ed265dc495873bf53ee7d2ace2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15507. Add MapReduce counters about EC bytes read.\n",
      "commitDate": "04/06/18 9:13 PM",
      "commitName": "6d5e87aec2f615ed265dc495873bf53ee7d2ace2",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "31/05/18 3:20 PM",
      "commitNameOld": "c95b9b5c077c5b95649d195bd7385a76604863c1",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 4.25,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,84 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n       final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n     LocatedBlock block \u003d datanode.block;\n     while (true) {\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n+        if (readStatistics.getBlockType() \u003d\u003d BlockType.STRIPED) {\n+          dfsClient.updateFileSystemECReadStats(nread);\n+        }\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n         // Refresh the block for updated tokens in case of token failures or\n         // encryption key failures.\n         block \u003d refreshLocatedBlock(block);\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n    LocatedBlock block \u003d datanode.block;\n    while (true) {\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (readStatistics.getBlockType() \u003d\u003d BlockType.STRIPED) {\n          dfsClient.updateFileSystemECReadStats(nread);\n        }\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n        // Refresh the block for updated tokens in case of token failures or\n        // encryption key failures.\n        block \u003d refreshLocatedBlock(block);\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "70fc6746b326b9a913e8bebca5f5afaf01ab9e11": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11708. Positional read will fail if replicas moved to different DNs after stream is opened. Contributed by Vinayakumar B.\n",
      "commitDate": "06/06/17 10:25 PM",
      "commitName": "70fc6746b326b9a913e8bebca5f5afaf01ab9e11",
      "commitAuthor": "Vinayakumar B",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11708. Positional read will fail if replicas moved to different DNs after stream is opened. Contributed by Vinayakumar B.\n",
          "commitDate": "06/06/17 10:25 PM",
          "commitName": "70fc6746b326b9a913e8bebca5f5afaf01ab9e11",
          "commitAuthor": "Vinayakumar B",
          "commitDateOld": "03/04/17 8:13 PM",
          "commitNameOld": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 64.09,
          "commitsBetweenForRepo": 349,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,81 @@\n-  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n-      final long startInBlk, final long endInBlk, ByteBuffer buf,\n-                                CorruptedBlocks corruptedBlocks)\n+  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n+      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n-\n+    LocatedBlock block \u003d datanode.block;\n     while (true) {\n-      // cached block locations may have been updated by chooseDataNode()\n-      // or fetchBlockAt(). Always get the latest list of locations at the\n-      // start of the loop.\n-      block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n+        // Refresh the block for updated tokens in case of token failures or\n+        // encryption key failures.\n+        block \u003d refreshLocatedBlock(block);\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n    LocatedBlock block \u003d datanode.block;\n    while (true) {\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n        // Refresh the block for updated tokens in case of token failures or\n        // encryption key failures.\n        block \u003d refreshLocatedBlock(block);\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {
            "oldValue": "[datanode-DNAddrPair(modifiers-final), block-LocatedBlock, startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-ByteBuffer, corruptedBlocks-CorruptedBlocks]",
            "newValue": "[datanode-DNAddrPair(modifiers-final), startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-ByteBuffer, corruptedBlocks-CorruptedBlocks]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11708. Positional read will fail if replicas moved to different DNs after stream is opened. Contributed by Vinayakumar B.\n",
          "commitDate": "06/06/17 10:25 PM",
          "commitName": "70fc6746b326b9a913e8bebca5f5afaf01ab9e11",
          "commitAuthor": "Vinayakumar B",
          "commitDateOld": "03/04/17 8:13 PM",
          "commitNameOld": "6eba79232f36b36e0196163adc8fe4219a6b6bf9",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 64.09,
          "commitsBetweenForRepo": 349,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,81 @@\n-  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n-      final long startInBlk, final long endInBlk, ByteBuffer buf,\n-                                CorruptedBlocks corruptedBlocks)\n+  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n+      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n-\n+    LocatedBlock block \u003d datanode.block;\n     while (true) {\n-      // cached block locations may have been updated by chooseDataNode()\n-      // or fetchBlockAt(). Always get the latest list of locations at the\n-      // start of the loop.\n-      block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n+        // Refresh the block for updated tokens in case of token failures or\n+        // encryption key failures.\n+        block \u003d refreshLocatedBlock(block);\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, final long startInBlk,\n      final long endInBlk, ByteBuffer buf, CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n    LocatedBlock block \u003d datanode.block;\n    while (true) {\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n        // Refresh the block for updated tokens in case of token failures or\n        // encryption key failures.\n        block \u003d refreshLocatedBlock(block);\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "1b5cceaffbdde50a87ede81552dc380832db8e79": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\"\n\nThis reverts commit b9522e86a55564c2ccb5ca3f1ca871965cbe74de.\n",
      "commitDate": "05/12/16 10:54 AM",
      "commitName": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "05/12/16 10:48 AM",
      "commitNameOld": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n-              \"expected \" + len + \", got \" + nread);\n+              \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "b9522e86a55564c2ccb5ca3f1ca871965cbe74de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11201. Spelling errors in the logging, help, assertions and exception messages. Contributed by Grant Sohn.\n",
      "commitDate": "05/12/16 10:48 AM",
      "commitName": "b9522e86a55564c2ccb5ca3f1ca871965cbe74de",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "15/10/16 6:14 AM",
      "commitNameOld": "5ad037df25ab3206509083276b7ef4ef001be48b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 51.23,
      "commitsBetweenForRepo": 403,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n \n         //Behave exactly as the readAll() call\n         ByteBuffer tmp \u003d buf.duplicate();\n         tmp.limit(tmp.position() + len);\n         tmp \u003d tmp.slice();\n         int nread \u003d 0;\n         int ret;\n         while (true) {\n           ret \u003d reader.read(tmp);\n           if (ret \u003c\u003d 0) {\n             break;\n           }\n           nread +\u003d ret;\n         }\n         buf.position(buf.position() + nread);\n \n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n-              \"excpected \" + len + \", got \" + nread);\n+              \"expected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"expected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "401db4fc65140979fe7665983e36905e886df971": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
      "commitDate": "08/09/16 11:54 AM",
      "commitName": "401db4fc65140979fe7665983e36905e886df971",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
          "commitDate": "08/09/16 11:54 AM",
          "commitName": "401db4fc65140979fe7665983e36905e886df971",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "24/08/16 6:57 AM",
          "commitNameOld": "793447f79924c97c2b562d5e41fa85adf19673fe",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 15.21,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,83 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n-      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n+      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n-        int nread \u003d reader.readAll(buf, offset, len);\n+\n+        //Behave exactly as the readAll() call\n+        ByteBuffer tmp \u003d buf.duplicate();\n+        tmp.limit(tmp.position() + len);\n+        tmp \u003d tmp.slice();\n+        int nread \u003d 0;\n+        int ret;\n+        while (true) {\n+          ret \u003d reader.read(tmp);\n+          if (ret \u003c\u003d 0) {\n+            break;\n+          }\n+          nread +\u003d ret;\n+        }\n+        buf.position(buf.position() + nread);\n+\n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {
            "oldValue": "[datanode-DNAddrPair(modifiers-final), block-LocatedBlock, startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-byte[], offset-int, corruptedBlocks-CorruptedBlocks]",
            "newValue": "[datanode-DNAddrPair(modifiers-final), block-LocatedBlock, startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-ByteBuffer, corruptedBlocks-CorruptedBlocks]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8901. Use ByteBuffer in striping positional read. Contributed by Sammi Chen and Kai Zheng.\n",
          "commitDate": "08/09/16 11:54 AM",
          "commitName": "401db4fc65140979fe7665983e36905e886df971",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "24/08/16 6:57 AM",
          "commitNameOld": "793447f79924c97c2b562d5e41fa85adf19673fe",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 15.21,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,83 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n-      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n+      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n-        int nread \u003d reader.readAll(buf, offset, len);\n+\n+        //Behave exactly as the readAll() call\n+        ByteBuffer tmp \u003d buf.duplicate();\n+        tmp.limit(tmp.position() + len);\n+        tmp \u003d tmp.slice();\n+        int nread \u003d 0;\n+        int ret;\n+        while (true) {\n+          ret \u003d reader.read(tmp);\n+          if (ret \u003c\u003d 0) {\n+            break;\n+          }\n+          nread +\u003d ret;\n+        }\n+        buf.position(buf.position() + nread);\n+\n         IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, ByteBuffer buf,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n\n        //Behave exactly as the readAll() call\n        ByteBuffer tmp \u003d buf.duplicate();\n        tmp.limit(tmp.position() + len);\n        tmp \u003d tmp.slice();\n        int nread \u003d 0;\n        int ret;\n        while (true) {\n          ret \u003d reader.read(tmp);\n          if (ret \u003c\u003d 0) {\n            break;\n          }\n          nread +\u003d ret;\n        }\n        buf.position(buf.position() + nread);\n\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {}
        }
      ]
    },
    "793447f79924c97c2b562d5e41fa85adf19673fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8905. Refactor DFSInputStream#ReaderStrategy. Contributed by Kai Zheng and Sammi Chen\n",
      "commitDate": "24/08/16 6:57 AM",
      "commitName": "793447f79924c97c2b562d5e41fa85adf19673fe",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "08/06/16 10:52 PM",
      "commitNameOld": "8ea9bbce2614e8eb499af73589f021ed1789e78f",
      "commitAuthorOld": "Masatake Iwasaki",
      "daysBetweenCommits": 76.34,
      "commitsBetweenForRepo": 637,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n         int nread \u003d reader.readAll(buf, offset, len);\n-        updateReadStatistics(readStatistics, nread, reader);\n+        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n        int nread \u003d reader.readAll(buf, offset, len);\n        IOUtilsClient.updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "be34e85e682880f46eee0310bf00ecc7d39cd5bd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10468. HDFS read ends up ignoring an interrupt. Contributed by Jing Zhao\n",
      "commitDate": "07/06/16 10:48 AM",
      "commitName": "be34e85e682880f46eee0310bf00ecc7d39cd5bd",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/04/16 12:01 PM",
      "commitNameOld": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 42.95,
      "commitsBetweenForRepo": 291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n         int nread \u003d reader.readAll(buf, offset, len);\n         updateReadStatistics(readStatistics, nread, reader);\n         dfsClient.updateFileSystemReadStats(\n             reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n+        checkInterrupted(e);\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n        int nread \u003d reader.readAll(buf, offset, len);\n        updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        checkInterrupted(e);\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9579. Provide bytes-read-by-network-distance metrics at FileSystem.Statistics level (Ming Ma via sjlee)\n",
      "commitDate": "19/03/16 2:02 PM",
      "commitName": "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "25/02/16 9:55 AM",
      "commitNameOld": "8808779db351fe444388d4acb3094766b5980718",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 23.13,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                 CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n         int nread \u003d reader.readAll(buf, offset, len);\n         updateReadStatistics(readStatistics, nread, reader);\n+        dfsClient.updateFileSystemReadStats(\n+            reader.getNetworkDistance(), nread);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n         corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n        int nread \u003d reader.readAll(buf, offset, len);\n        updateReadStatistics(readStatistics, nread, reader);\n        dfsClient.updateFileSystemReadStats(\n            reader.getNetworkDistance(), nread);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
      "extendedDetails": {}
    },
    "8808779db351fe444388d4acb3094766b5980718": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9734. Refactoring of checksum failure report related codes. Contributed by Kai Zheng.\n\nChange-Id: Ie69a77e3498a360959f8e213c51fb2b17c28b64a\n",
      "commitDate": "25/02/16 9:55 AM",
      "commitName": "8808779db351fe444388d4acb3094766b5980718",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9734. Refactoring of checksum failure report related codes. Contributed by Kai Zheng.\n\nChange-Id: Ie69a77e3498a360959f8e213c51fb2b17c28b64a\n",
          "commitDate": "25/02/16 9:55 AM",
          "commitName": "8808779db351fe444388d4acb3094766b5980718",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "22/01/16 9:46 AM",
          "commitNameOld": "95363bcc7dae28ba9ae2cd7ee9a258fcb58cd932",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 34.01,
          "commitsBetweenForRepo": 234,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,65 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, byte[] buf, int offset,\n-      Map\u003cExtendedBlock, Set\u003cDatanodeInfo\u003e\u003e corruptedBlockMap)\n+                                CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n         int nread \u003d reader.readAll(buf, offset, len);\n         updateReadStatistics(readStatistics, nread, reader);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n-        addIntoCorruptedBlockMap(block.getBlock(), datanode.info,\n-            corruptedBlockMap);\n+        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n        int nread \u003d reader.readAll(buf, offset, len);\n        updateReadStatistics(readStatistics, nread, reader);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {
            "oldValue": "[datanode-DNAddrPair(modifiers-final), block-LocatedBlock, startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-byte[], offset-int, corruptedBlockMap-Map\u003cExtendedBlock,Set\u003cDatanodeInfo\u003e\u003e]",
            "newValue": "[datanode-DNAddrPair(modifiers-final), block-LocatedBlock, startInBlk-long(modifiers-final), endInBlk-long(modifiers-final), buf-byte[], offset-int, corruptedBlocks-CorruptedBlocks]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9734. Refactoring of checksum failure report related codes. Contributed by Kai Zheng.\n\nChange-Id: Ie69a77e3498a360959f8e213c51fb2b17c28b64a\n",
          "commitDate": "25/02/16 9:55 AM",
          "commitName": "8808779db351fe444388d4acb3094766b5980718",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "22/01/16 9:46 AM",
          "commitNameOld": "95363bcc7dae28ba9ae2cd7ee9a258fcb58cd932",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 34.01,
          "commitsBetweenForRepo": 234,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,65 @@\n   void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n       final long startInBlk, final long endInBlk, byte[] buf, int offset,\n-      Map\u003cExtendedBlock, Set\u003cDatanodeInfo\u003e\u003e corruptedBlockMap)\n+                                CorruptedBlocks corruptedBlocks)\n       throws IOException {\n     DFSClientFaultInjector.get().startFetchFromDatanode();\n     int refetchToken \u003d 1; // only need to get a new access token once\n     int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n     final int len \u003d (int) (endInBlk - startInBlk + 1);\n \n     while (true) {\n       // cached block locations may have been updated by chooseDataNode()\n       // or fetchBlockAt(). Always get the latest list of locations at the\n       // start of the loop.\n       block \u003d refreshLocatedBlock(block);\n       BlockReader reader \u003d null;\n       try {\n         DFSClientFaultInjector.get().fetchFromDatanodeException();\n         reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n             datanode.storageType, datanode.info);\n         int nread \u003d reader.readAll(buf, offset, len);\n         updateReadStatistics(readStatistics, nread, reader);\n         if (nread !\u003d len) {\n           throw new IOException(\"truncated return from reader.read(): \" +\n               \"excpected \" + len + \", got \" + nread);\n         }\n         DFSClientFaultInjector.get().readFromDatanodeDelay();\n         return;\n       } catch (ChecksumException e) {\n         String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n             + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n             + datanode.info;\n         DFSClient.LOG.warn(msg);\n         // we want to remember what we have tried\n-        addIntoCorruptedBlockMap(block.getBlock(), datanode.info,\n-            corruptedBlockMap);\n+        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n         addToDeadNodes(datanode.info);\n         throw new IOException(msg);\n       } catch (IOException e) {\n         if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n           DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n               + \"encryption key was invalid when connecting to \" + datanode.addr\n               + \" : \" + e);\n           // The encryption key used is invalid.\n           refetchEncryptionKey--;\n           dfsClient.clearDataEncryptionKey();\n         } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n           refetchToken--;\n           try {\n             fetchBlockAt(block.getStartOffset());\n           } catch (IOException fbae) {\n             // ignore IOE, since we can retry it later in a loop\n           }\n         } else {\n           String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n               + src + \" for block \" + block.getBlock() + \":\" + e;\n           DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n           addToDeadNodes(datanode.info);\n           throw new IOException(msg);\n         }\n       } finally {\n         if (reader !\u003d null) {\n           reader.close();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void actualGetFromOneDataNode(final DNAddrPair datanode, LocatedBlock block,\n      final long startInBlk, final long endInBlk, byte[] buf, int offset,\n                                CorruptedBlocks corruptedBlocks)\n      throws IOException {\n    DFSClientFaultInjector.get().startFetchFromDatanode();\n    int refetchToken \u003d 1; // only need to get a new access token once\n    int refetchEncryptionKey \u003d 1; // only need to get a new encryption key once\n    final int len \u003d (int) (endInBlk - startInBlk + 1);\n\n    while (true) {\n      // cached block locations may have been updated by chooseDataNode()\n      // or fetchBlockAt(). Always get the latest list of locations at the\n      // start of the loop.\n      block \u003d refreshLocatedBlock(block);\n      BlockReader reader \u003d null;\n      try {\n        DFSClientFaultInjector.get().fetchFromDatanodeException();\n        reader \u003d getBlockReader(block, startInBlk, len, datanode.addr,\n            datanode.storageType, datanode.info);\n        int nread \u003d reader.readAll(buf, offset, len);\n        updateReadStatistics(readStatistics, nread, reader);\n        if (nread !\u003d len) {\n          throw new IOException(\"truncated return from reader.read(): \" +\n              \"excpected \" + len + \", got \" + nread);\n        }\n        DFSClientFaultInjector.get().readFromDatanodeDelay();\n        return;\n      } catch (ChecksumException e) {\n        String msg \u003d \"fetchBlockByteRange(). Got a checksum exception for \"\n            + src + \" at \" + block.getBlock() + \":\" + e.getPos() + \" from \"\n            + datanode.info;\n        DFSClient.LOG.warn(msg);\n        // we want to remember what we have tried\n        corruptedBlocks.addCorruptedBlock(block.getBlock(), datanode.info);\n        addToDeadNodes(datanode.info);\n        throw new IOException(msg);\n      } catch (IOException e) {\n        if (e instanceof InvalidEncryptionKeyException \u0026\u0026 refetchEncryptionKey \u003e 0) {\n          DFSClient.LOG.info(\"Will fetch a new encryption key and retry, \"\n              + \"encryption key was invalid when connecting to \" + datanode.addr\n              + \" : \" + e);\n          // The encryption key used is invalid.\n          refetchEncryptionKey--;\n          dfsClient.clearDataEncryptionKey();\n        } else if (refetchToken \u003e 0 \u0026\u0026 tokenRefetchNeeded(e, datanode.addr)) {\n          refetchToken--;\n          try {\n            fetchBlockAt(block.getStartOffset());\n          } catch (IOException fbae) {\n            // ignore IOE, since we can retry it later in a loop\n          }\n        } else {\n          String msg \u003d \"Failed to connect to \" + datanode.addr + \" for file \"\n              + src + \" for block \" + block.getBlock() + \":\" + e;\n          DFSClient.LOG.warn(\"Connection failure: \" + msg, e);\n          addToDeadNodes(datanode.info);\n          throw new IOException(msg);\n        }\n      } finally {\n        if (reader !\u003d null) {\n          reader.close();\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSInputStream.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}