{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DirectoryWithSnapshotFeature.java",
  "functionName": "cleanDirectory",
  "functionId": "cleanDirectory___reclaimContext-INode.ReclaimContext__currentINode-INodeDirectory(modifiers-final)__snapshot-int(modifiers-final)__prior-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
  "functionStartLine": 700,
  "functionEndLine": 785,
  "numCommitsSeen": 93,
  "timeTaken": 10488,
  "changeHistory": [
    "82343790eebc3ebe7ef81f6b89260e5bbf121d83",
    "fdd96e46d1f89f0ecdb9b1836dc7fca9fbb954fd",
    "ce8eb1283acbebb990a4f1e40848d78700309222",
    "62445021d5d57b0d49adcb1bd4365c13532328fc",
    "0a85af959ce505f0659e5c69d0ca83a5dce0a7c2",
    "ba0da2785d251745969f88a50d33ce61876d91aa",
    "b2c85db86c9a62b0a03ee87547265077f664970a",
    "4536399d47f6c061e149e2504600804a0f1e093d",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
    "6b441d227a8806e87224106a81361bd61f0b3d0b",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823"
  ],
  "changeHistoryShort": {
    "82343790eebc3ebe7ef81f6b89260e5bbf121d83": "Ybodychange",
    "fdd96e46d1f89f0ecdb9b1836dc7fca9fbb954fd": "Ybodychange",
    "ce8eb1283acbebb990a4f1e40848d78700309222": "Ybodychange",
    "62445021d5d57b0d49adcb1bd4365c13532328fc": "Ybodychange",
    "0a85af959ce505f0659e5c69d0ca83a5dce0a7c2": "Ybodychange",
    "ba0da2785d251745969f88a50d33ce61876d91aa": "Ybodychange",
    "b2c85db86c9a62b0a03ee87547265077f664970a": "Ymultichange(Yreturntypechange,Ybodychange)",
    "4536399d47f6c061e149e2504600804a0f1e093d": "Ymultichange(Yparameterchange,Ybodychange)",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": "Ymultichange(Yparameterchange,Ybodychange)",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "6b441d227a8806e87224106a81361bd61f0b3d0b": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ymultichange(Yparameterchange,Ybodychange)",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Yintroduced"
  },
  "changeHistoryDetails": {
    "82343790eebc3ebe7ef81f6b89260e5bbf121d83": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15313. Ensure inodes in active filesytem are not deleted during snapshot delete. Contributed by Shashikant Banerjee.\n",
      "commitDate": "30/04/20 11:46 PM",
      "commitName": "82343790eebc3ebe7ef81f6b89260e5bbf121d83",
      "commitAuthor": "Shashikant Banerjee",
      "commitDateOld": "18/12/19 9:20 AM",
      "commitNameOld": "fdd96e46d1f89f0ecdb9b1836dc7fca9fbb954fd",
      "commitAuthorOld": "Shashikant Banerjee",
      "daysBetweenCommits": 134.56,
      "commitsBetweenForRepo": 440,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,86 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n           priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n-            if (currentINode.isLastReference() \u0026\u0026\n-                    currentINode.getDiffs().getLastSnapshotId() \u003d\u003d prior) {\n-              // If this is the last reference of the directory inode and it\n-              // can not be accessed in any of the subsequent snapshots i.e,\n-              // this is the latest snapshot diff and if this is the last\n-              // reference, the created list can be\n-              // destroyed.\n-              priorDiff.getChildrenDiff().destroyCreatedList(\n-                  reclaimContext, currentINode);\n-            } else {\n-              // we only check the node originally in prior\u0027s created list\n-              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n-                if (priorCreated.containsKey(cNode)) {\n+            // The nodes in priorCreated must be destroyed if\n+            //   (1) this is the last reference, and\n+            //   (2) prior is the last snapshot, and\n+            //   (3) currentINode is not in the current state.\n+            final boolean destroy \u003d currentINode.isLastReference()\n+                \u0026\u0026 currentINode.getDiffs().getLastSnapshotId() \u003d\u003d prior\n+                \u0026\u0026 !currentINode.isInCurrentState();\n+            // we only check the node originally in prior\u0027s created list\n+            for (INode cNode : new ArrayList\u003c\u003e(priorDiff.\n+                    diff.getCreatedUnmodifiable())) {\n+              if (priorCreated.containsKey(cNode)) {\n+                if (destroy) {\n+                  cNode.destroyAndCollectBlocks(reclaimContext);\n+                  currentINode.removeChild(cNode);\n+                  priorDiff.diff.removeCreated(cNode);\n+                } else {\n                   cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                 }\n               }\n             }\n           }\n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // The nodes in priorCreated must be destroyed if\n            //   (1) this is the last reference, and\n            //   (2) prior is the last snapshot, and\n            //   (3) currentINode is not in the current state.\n            final boolean destroy \u003d currentINode.isLastReference()\n                \u0026\u0026 currentINode.getDiffs().getLastSnapshotId() \u003d\u003d prior\n                \u0026\u0026 !currentINode.isInCurrentState();\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : new ArrayList\u003c\u003e(priorDiff.\n                    diff.getCreatedUnmodifiable())) {\n              if (priorCreated.containsKey(cNode)) {\n                if (destroy) {\n                  cNode.destroyAndCollectBlocks(reclaimContext);\n                  currentINode.removeChild(cNode);\n                  priorDiff.diff.removeCreated(cNode);\n                } else {\n                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                }\n              }\n            }\n          }\n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "fdd96e46d1f89f0ecdb9b1836dc7fca9fbb954fd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15012. NN fails to parse Edit logs after applying HDFS-13101. Contributed by Shashikant Banerjee.\n",
      "commitDate": "18/12/19 9:20 AM",
      "commitName": "fdd96e46d1f89f0ecdb9b1836dc7fca9fbb954fd",
      "commitAuthor": "Shashikant Banerjee",
      "commitDateOld": "27/08/19 10:53 AM",
      "commitNameOld": "ce8eb1283acbebb990a4f1e40848d78700309222",
      "commitAuthorOld": "Shashikant Banerjee",
      "daysBetweenCommits": 112.98,
      "commitsBetweenForRepo": 644,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,83 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n           priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n-            if (currentINode.isLastReference()) {\n-              // if this is the last reference, the created list can be\n+            if (currentINode.isLastReference() \u0026\u0026\n+                    currentINode.getDiffs().getLastSnapshotId() \u003d\u003d prior) {\n+              // If this is the last reference of the directory inode and it\n+              // can not be accessed in any of the subsequent snapshots i.e,\n+              // this is the latest snapshot diff and if this is the last\n+              // reference, the created list can be\n               // destroyed.\n               priorDiff.getChildrenDiff().destroyCreatedList(\n                   reclaimContext, currentINode);\n             } else {\n               // we only check the node originally in prior\u0027s created list\n               for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                 if (priorCreated.containsKey(cNode)) {\n                   cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                 }\n               }\n             }\n           }\n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            if (currentINode.isLastReference() \u0026\u0026\n                    currentINode.getDiffs().getLastSnapshotId() \u003d\u003d prior) {\n              // If this is the last reference of the directory inode and it\n              // can not be accessed in any of the subsequent snapshots i.e,\n              // this is the latest snapshot diff and if this is the last\n              // reference, the created list can be\n              // destroyed.\n              priorDiff.getChildrenDiff().destroyCreatedList(\n                  reclaimContext, currentINode);\n            } else {\n              // we only check the node originally in prior\u0027s created list\n              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                if (priorCreated.containsKey(cNode)) {\n                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                }\n              }\n            }\n          }\n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "ce8eb1283acbebb990a4f1e40848d78700309222": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDDS-1610. applyTransaction failure should not be lost on restart. Contributed by Shashikant Banerjee.\"\n\nThis reverts commit 62445021d5d57b0d49adcb1bd4365c13532328fc as it has unintended changes in DirectoryWithSnapshotFeature class..\n",
      "commitDate": "27/08/19 10:53 AM",
      "commitName": "ce8eb1283acbebb990a4f1e40848d78700309222",
      "commitAuthor": "Shashikant Banerjee",
      "commitDateOld": "20/08/19 2:07 AM",
      "commitNameOld": "62445021d5d57b0d49adcb1bd4365c13532328fc",
      "commitAuthorOld": "Shashikant Banerjee",
      "daysBetweenCommits": 7.37,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n           priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             if (currentINode.isLastReference()) {\n               // if this is the last reference, the created list can be\n               // destroyed.\n-         //     priorDiff.getChildrenDiff().destroyCreatedList(\n-         //         reclaimContext, currentINode);\n+              priorDiff.getChildrenDiff().destroyCreatedList(\n+                  reclaimContext, currentINode);\n             } else {\n               // we only check the node originally in prior\u0027s created list\n               for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                 if (priorCreated.containsKey(cNode)) {\n                   cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                 }\n               }\n             }\n           }\n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            if (currentINode.isLastReference()) {\n              // if this is the last reference, the created list can be\n              // destroyed.\n              priorDiff.getChildrenDiff().destroyCreatedList(\n                  reclaimContext, currentINode);\n            } else {\n              // we only check the node originally in prior\u0027s created list\n              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                if (priorCreated.containsKey(cNode)) {\n                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                }\n              }\n            }\n          }\n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "62445021d5d57b0d49adcb1bd4365c13532328fc": {
      "type": "Ybodychange",
      "commitMessage": "HDDS-1610. applyTransaction failure should not be lost on restart. Contributed by Shashikant Banerjee.\n",
      "commitDate": "20/08/19 2:07 AM",
      "commitName": "62445021d5d57b0d49adcb1bd4365c13532328fc",
      "commitAuthor": "Shashikant Banerjee",
      "commitDateOld": "14/08/19 9:46 PM",
      "commitNameOld": "0a85af959ce505f0659e5c69d0ca83a5dce0a7c2",
      "commitAuthorOld": "Shashikant Banerjee",
      "daysBetweenCommits": 5.18,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n           priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             if (currentINode.isLastReference()) {\n               // if this is the last reference, the created list can be\n               // destroyed.\n-              priorDiff.getChildrenDiff().destroyCreatedList(\n-                  reclaimContext, currentINode);\n+         //     priorDiff.getChildrenDiff().destroyCreatedList(\n+         //         reclaimContext, currentINode);\n             } else {\n               // we only check the node originally in prior\u0027s created list\n               for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                 if (priorCreated.containsKey(cNode)) {\n                   cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                 }\n               }\n             }\n           }\n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            if (currentINode.isLastReference()) {\n              // if this is the last reference, the created list can be\n              // destroyed.\n         //     priorDiff.getChildrenDiff().destroyCreatedList(\n         //         reclaimContext, currentINode);\n            } else {\n              // we only check the node originally in prior\u0027s created list\n              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                if (priorCreated.containsKey(cNode)) {\n                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                }\n              }\n            }\n          }\n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "0a85af959ce505f0659e5c69d0ca83a5dce0a7c2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13101. Yet another fsimage corruption related to snapshot. Contributed by Shashikant Banerjee.\n",
      "commitDate": "14/08/19 9:46 PM",
      "commitName": "0a85af959ce505f0659e5c69d0ca83a5dce0a7c2",
      "commitAuthor": "Shashikant Banerjee",
      "commitDateOld": "14/03/18 9:42 AM",
      "commitNameOld": "4c57fb0cd9344290a9f4f6422c1457d69465eec7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 518.5,
      "commitsBetweenForRepo": 4558,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,79 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n           priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n-            // we only check the node originally in prior\u0027s created list\n-            for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n-              if (priorCreated.containsKey(cNode)) {\n-                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n+            if (currentINode.isLastReference()) {\n+              // if this is the last reference, the created list can be\n+              // destroyed.\n+              priorDiff.getChildrenDiff().destroyCreatedList(\n+                  reclaimContext, currentINode);\n+            } else {\n+              // we only check the node originally in prior\u0027s created list\n+              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n+                if (priorCreated.containsKey(cNode)) {\n+                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n+                }\n               }\n             }\n           }\n-          \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            if (currentINode.isLastReference()) {\n              // if this is the last reference, the created list can be\n              // destroyed.\n              priorDiff.getChildrenDiff().destroyCreatedList(\n                  reclaimContext, currentINode);\n            } else {\n              // we only check the node originally in prior\u0027s created list\n              for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n                if (priorCreated.containsKey(cNode)) {\n                  cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n                }\n              }\n            }\n          }\n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "ba0da2785d251745969f88a50d33ce61876d91aa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13252. Code refactoring: Remove Diff.ListType.\n",
      "commitDate": "09/03/18 3:50 PM",
      "commitName": "ba0da2785d251745969f88a50d33ce61876d91aa",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/03/18 1:35 PM",
      "commitNameOld": "346caa209571dedf1331b2658d5702b45dd40bfe",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.09,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,73 @@\n   public void cleanDirectory(INode.ReclaimContext reclaimContext,\n       final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n-          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n-          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n-          priorCreated \u003d cloneDiffList(cList);\n-          priorDeleted \u003d cloneDiffList(dList);\n+          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n+          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n         }\n       }\n \n       getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n           currentINode);\n       currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n           priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n-            for (INode cNode : priorDiff.getChildrenDiff().getList(\n-                ListType.CREATED)) {\n+            for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n               if (priorCreated.containsKey(cNode)) {\n                 cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n-          for (INode dNode : priorDiff.getChildrenDiff().getList(\n-              ListType.DELETED)) {\n+          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n     QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n     current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n       reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          priorCreated \u003d cloneDiffList(priorDiff.diff.getCreatedUnmodifiable());\n          priorDeleted \u003d cloneDiffList(priorDiff.diff.getDeletedUnmodifiable());\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.diff.getCreatedUnmodifiable()) {\n              if (priorCreated.containsKey(cNode)) {\n                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.diff.getDeletedUnmodifiable()) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "b2c85db86c9a62b0a03ee87547265077f664970a": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
      "commitDate": "13/05/15 9:50 PM",
      "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,77 @@\n-  public QuotaCounts cleanDirectory(\n-      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n-      final int snapshot, int prior) {\n-    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n+  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n+      final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n+    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n-            currentINode));\n+        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n-          snapshot, prior, priorDeleted));\n+      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n+          null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n-      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+      if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n-      \n-      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n-          currentINode));\n-      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n-          snapshot, prior, priorDeleted));\n+\n+      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n+          currentINode);\n+      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n+          priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n-      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+      if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(reclaimContext,\n-                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n+                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(reclaimContext,\n-                  dNode, snapshot, prior));\n+              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n+    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n+    current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n-      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n-          counts.negation());\n+      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n-    return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "QuotaCounts",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,77 @@\n-  public QuotaCounts cleanDirectory(\n-      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n-      final int snapshot, int prior) {\n-    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n+  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n+      final INodeDirectory currentINode, final int snapshot, int prior) {\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n+    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n-            currentINode));\n+        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n-          snapshot, prior, priorDeleted));\n+      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n+          null);\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n-      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+      if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n-      \n-      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n-          currentINode));\n-      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n-          snapshot, prior, priorDeleted));\n+\n+      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n+          currentINode);\n+      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n+          priorDeleted);\n \n       // check priorDiff again since it may be created during the diff deletion\n-      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+      if (prior !\u003d NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(reclaimContext,\n-                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n+                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(reclaimContext,\n-                  dNode, snapshot, prior));\n+              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n             }\n           }\n         }\n       }\n     }\n \n+    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n+    current.subtract(old);\n     if (currentINode.isQuotaSet()) {\n-      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n-          counts.negation());\n+      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n     }\n-    return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void cleanDirectory(INode.ReclaimContext reclaimContext,\n      final INodeDirectory currentINode, final int snapshot, int prior) {\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    QuotaCounts old \u003d reclaimContext.quotaDelta().getCountsCopy();\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        lastDiff.diff.destroyCreatedList(reclaimContext, currentINode);\n      }\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          null);\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n\n      getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode);\n      currentINode.cleanSubtreeRecursively(reclaimContext, snapshot, prior,\n          priorDeleted);\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                cNode.cleanSubtree(reclaimContext, snapshot, NO_SNAPSHOT_ID);\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              cleanDeletedINode(reclaimContext, dNode, snapshot, prior);\n            }\n          }\n        }\n      }\n    }\n\n    QuotaCounts current \u003d reclaimContext.quotaDelta().getCountsCopy();\n    current.subtract(old);\n    if (currentINode.isQuotaSet()) {\n      reclaimContext.quotaDelta().addQuotaDirUpdate(currentINode, current);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "4536399d47f6c061e149e2504600804a0f1e093d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8357. Consolidate parameters of INode.CleanSubtree() into a parameter objects. Contributed by Li Lu.\n",
      "commitDate": "09/05/15 10:51 PM",
      "commitName": "4536399d47f6c061e149e2504600804a0f1e093d",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8357. Consolidate parameters of INode.CleanSubtree() into a parameter objects. Contributed by Li Lu.\n",
          "commitDate": "09/05/15 10:51 PM",
          "commitName": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.99,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,81 @@\n   public QuotaCounts cleanDirectory(\n-      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n-      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n+      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n+      final int snapshot, int prior) {\n     QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n-            collectedBlocks, removedINodes, removedUCFiles));\n+        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n+            currentINode));\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n+      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n+          snapshot, prior, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n-          currentINode, collectedBlocks, removedINodes));\n-      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n+      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n+          currentINode));\n+      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n+          snapshot, prior, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes, removedUCFiles));\n+                counts.add(cNode.cleanSubtree(reclaimContext,\n+                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes, removedUCFiles));\n+              counts.add(cleanDeletedINode(reclaimContext,\n+                  dNode, snapshot, prior));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(\n      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n      final int snapshot, int prior) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n            currentINode));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n          snapshot, prior, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode));\n      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n          snapshot, prior, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(reclaimContext,\n                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(reclaimContext,\n                  dNode, snapshot, prior));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[bsps-BlockStoragePolicySuite(modifiers-final), currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final), removedUCFiles-List\u003cLong\u003e]",
            "newValue": "[reclaimContext-INode.ReclaimContext, currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8357. Consolidate parameters of INode.CleanSubtree() into a parameter objects. Contributed by Li Lu.\n",
          "commitDate": "09/05/15 10:51 PM",
          "commitName": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "08/05/15 11:04 PM",
          "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.99,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,81 @@\n   public QuotaCounts cleanDirectory(\n-      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n-      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n+      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n+      final int snapshot, int prior) {\n     QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n-            collectedBlocks, removedINodes, removedUCFiles));\n+        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n+            currentINode));\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n+      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n+          snapshot, prior, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n-          currentINode, collectedBlocks, removedINodes));\n-      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n+      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n+          currentINode));\n+      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n+          snapshot, prior, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes, removedUCFiles));\n+                counts.add(cNode.cleanSubtree(reclaimContext,\n+                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes, removedUCFiles));\n+              counts.add(cleanDeletedINode(reclaimContext,\n+                  dNode, snapshot, prior));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(\n      INode.ReclaimContext reclaimContext, final INodeDirectory currentINode,\n      final int snapshot, int prior) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(reclaimContext,\n            currentINode));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n          snapshot, prior, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(reclaimContext, snapshot, prior,\n          currentINode));\n      counts.add(currentINode.cleanSubtreeRecursively(reclaimContext,\n          snapshot, prior, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(reclaimContext,\n                    snapshot, Snapshot.NO_SNAPSHOT_ID));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(reclaimContext,\n                  dNode, snapshot, prior));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:04 PM",
      "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:04 PM",
          "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "02/04/15 9:20 PM",
          "commitNameOld": "72f6bd4893dcf10d6dad24753f9be99505a87a1f",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 36.07,
          "commitsBetweenForRepo": 375,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,82 @@\n-  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n-      final int snapshot, int prior,\n-      final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes) {\n+  public QuotaCounts cleanDirectory(\n+      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n+      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n+      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n     QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n-            collectedBlocks, removedINodes));\n+            collectedBlocks, removedINodes, removedUCFiles));\n       }\n       counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted));\n+          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n           currentINode, collectedBlocks, removedINodes));\n       counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted));\n+          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes));\n+                    collectedBlocks, removedINodes, removedUCFiles));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes));\n+                  collectedBlocks, removedINodes, removedUCFiles));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(\n      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n            collectedBlocks, removedINodes, removedUCFiles));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes, removedUCFiles));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, removedUCFiles));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[bsps-BlockStoragePolicySuite(modifiers-final), currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final)]",
            "newValue": "[bsps-BlockStoragePolicySuite(modifiers-final), currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final), removedUCFiles-List\u003cLong\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
          "commitDate": "08/05/15 11:04 PM",
          "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "02/04/15 9:20 PM",
          "commitNameOld": "72f6bd4893dcf10d6dad24753f9be99505a87a1f",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 36.07,
          "commitsBetweenForRepo": 375,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,82 @@\n-  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n-      final int snapshot, int prior,\n-      final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes) {\n+  public QuotaCounts cleanDirectory(\n+      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n+      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n+      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n     QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n-            collectedBlocks, removedINodes));\n+            collectedBlocks, removedINodes, removedUCFiles));\n       }\n       counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted));\n+          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n           currentINode, collectedBlocks, removedINodes));\n       counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted));\n+          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes));\n+                    collectedBlocks, removedINodes, removedUCFiles));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes));\n+                  collectedBlocks, removedINodes, removedUCFiles));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(\n      final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n      final int snapshot, int prior, final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, List\u003cLong\u003e removedUCFiles) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n            collectedBlocks, removedINodes, removedUCFiles));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, removedUCFiles, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes, removedUCFiles));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, removedUCFiles));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
          "commitDate": "11/02/15 10:41 AM",
          "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "02/02/15 4:32 PM",
          "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 8.76,
          "commitsBetweenForRepo": 109,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,82 @@\n-  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n+  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes) {\n-    Quota.Counts counts \u003d Quota.Counts.newInstance();\n+    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n+        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n             collectedBlocks, removedINodes));\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n+      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n           currentINode, collectedBlocks, removedINodes));\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n+                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                     collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n+              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                   collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n-          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n+          counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final)]",
            "newValue": "[bsps-BlockStoragePolicySuite(modifiers-final), currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
          "commitDate": "11/02/15 10:41 AM",
          "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "02/02/15 4:32 PM",
          "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 8.76,
          "commitsBetweenForRepo": 109,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,82 @@\n-  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n+  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes) {\n-    Quota.Counts counts \u003d Quota.Counts.newInstance();\n+    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n+        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n             collectedBlocks, removedINodes));\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n+      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n           currentINode, collectedBlocks, removedINodes));\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n+                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                     collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n+              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                   collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n-          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n+          counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "Quota.Counts",
            "newValue": "QuotaCounts"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
          "commitDate": "11/02/15 10:41 AM",
          "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "02/02/15 4:32 PM",
          "commitNameOld": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 8.76,
          "commitsBetweenForRepo": 109,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,82 +1,82 @@\n-  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n+  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes) {\n-    Quota.Counts counts \u003d Quota.Counts.newInstance();\n+    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n-        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n+        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n             collectedBlocks, removedINodes));\n       }\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n+      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n           currentINode, collectedBlocks, removedINodes));\n-      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n           collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n+                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                     collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n-              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n+              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                   collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n-          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n+          counts.negation());\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public QuotaCounts cleanDirectory(final BlockStoragePolicySuite bsps, final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    QuotaCounts counts \u003d new QuotaCounts.Builder().build();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(bsps, currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(bsps, snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(bsps, snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(bsps, snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(bsps, dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          counts.negation());\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
      "commitDate": "02/02/15 4:32 PM",
      "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
          "commitDate": "02/02/15 4:32 PM",
          "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "22/12/14 11:05 PM",
          "commitNameOld": "50ae1a6664a92619aa683d2a864d0da9fb4af026",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 41.73,
          "commitsBetweenForRepo": 229,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,82 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n-      throws QuotaExceededException {\n+      final List\u003cINode\u003e removedINodes) {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n-          currentINode, collectedBlocks, removedINodes, countDiffChange));\n+          currentINode, collectedBlocks, removedINodes));\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes, countDiffChange));\n+                    collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes, countDiffChange));\n+                  collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final), countDiffChange-boolean(modifiers-final)]",
            "newValue": "[currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
          "commitDate": "02/02/15 4:32 PM",
          "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "22/12/14 11:05 PM",
          "commitNameOld": "50ae1a6664a92619aa683d2a864d0da9fb4af026",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 41.73,
          "commitsBetweenForRepo": 229,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,82 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n-      throws QuotaExceededException {\n+      final List\u003cINode\u003e removedINodes) {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n-          currentINode, collectedBlocks, removedINodes, countDiffChange));\n+          currentINode, collectedBlocks, removedINodes));\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes, countDiffChange));\n+                    collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes, countDiffChange));\n+                  collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[QuotaExceededException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6651. Deletion failure can leak inodes permanently. Contributed by Jing Zhao.\n",
          "commitDate": "02/02/15 4:32 PM",
          "commitName": "8cb473124c1cf1c6f68ead7bde06558ebf7ce47e",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "22/12/14 11:05 PM",
          "commitNameOld": "50ae1a6664a92619aa683d2a864d0da9fb4af026",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 41.73,
          "commitsBetweenForRepo": 229,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,82 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n-      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n-      throws QuotaExceededException {\n+      final List\u003cINode\u003e removedINodes) {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n-          currentINode, collectedBlocks, removedINodes, countDiffChange));\n+          currentINode, collectedBlocks, removedINodes));\n       counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+          collectedBlocks, removedINodes, priorDeleted));\n \n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n-                    collectedBlocks, removedINodes, countDiffChange));\n+                    collectedBlocks, removedINodes));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n-                  collectedBlocks, removedINodes, countDiffChange));\n+                  collectedBlocks, removedINodes));\n             }\n           }\n         }\n       }\n     }\n \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes) {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes));\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "6b441d227a8806e87224106a81361bd61f0b3d0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6908. Incorrect snapshot directory diff generated by snapshot deletion. Contributed by Juan Yu and Jing Zhao.\n",
      "commitDate": "27/08/14 10:26 AM",
      "commitName": "6b441d227a8806e87224106a81361bd61f0b3d0b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/07/14 5:08 PM",
      "commitNameOld": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 50.72,
      "commitsBetweenForRepo": 416,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,83 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n       final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n       throws QuotaExceededException {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n     if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n+      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n       counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n           currentINode, collectedBlocks, removedINodes, countDiffChange));\n-      \n+      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+\n       // check priorDiff again since it may be created during the diff deletion\n       if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n         DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n         if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n                 counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                     collectedBlocks, removedINodes, countDiffChange));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                   collectedBlocks, removedINodes, countDiffChange));\n             }\n           }\n         }\n       }\n     }\n-    counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n-        collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n-    \n+\n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n      throws QuotaExceededException {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes, countDiffChange));\n      counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n          collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n\n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes, countDiffChange));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, countDiffChange));\n            }\n          }\n        }\n      }\n    }\n\n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/01/14 12:52 PM",
          "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "14/12/13 2:13 AM",
          "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 24.44,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n-      final Snapshot snapshot, Snapshot prior,\n+      final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n       throws QuotaExceededException {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n-    if (snapshot \u003d\u003d null) { // delete the current directory\n+    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n-      if (prior !\u003d null) {\n-        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n-        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior, currentINode, \n-          collectedBlocks, removedINodes, countDiffChange));\n+      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n+          currentINode, collectedBlocks, removedINodes, countDiffChange));\n       \n       // check priorDiff again since it may be created during the diff deletion\n-      if (prior !\u003d null) {\n-        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n-        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,\n-                    removedINodes, countDiffChange));\n+                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n+                    collectedBlocks, removedINodes, countDiffChange));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                   collectedBlocks, removedINodes, countDiffChange));\n             }\n           }\n         }\n       }\n     }\n     counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n         collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n     \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n      throws QuotaExceededException {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes, countDiffChange));\n      \n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes, countDiffChange));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, countDiffChange));\n            }\n          }\n        }\n      }\n    }\n    counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n        collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n    \n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {
            "oldValue": "[currentINode-INodeDirectory(modifiers-final), snapshot-Snapshot(modifiers-final), prior-Snapshot, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final), countDiffChange-boolean(modifiers-final)]",
            "newValue": "[currentINode-INodeDirectory(modifiers-final), snapshot-int(modifiers-final), prior-int, collectedBlocks-BlocksMapUpdateInfo(modifiers-final), removedINodes-List\u003cINode\u003e(modifiers-final), countDiffChange-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/01/14 12:52 PM",
          "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "14/12/13 2:13 AM",
          "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 24.44,
          "commitsBetweenForRepo": 98,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,81 +1,81 @@\n   public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n-      final Snapshot snapshot, Snapshot prior,\n+      final int snapshot, int prior,\n       final BlocksMapUpdateInfo collectedBlocks,\n       final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n       throws QuotaExceededException {\n     Quota.Counts counts \u003d Quota.Counts.newInstance();\n     Map\u003cINode, INode\u003e priorCreated \u003d null;\n     Map\u003cINode, INode\u003e priorDeleted \u003d null;\n-    if (snapshot \u003d\u003d null) { // delete the current directory\n+    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n       currentINode.recordModification(prior);\n       // delete everything in created list\n       DirectoryDiff lastDiff \u003d diffs.getLast();\n       if (lastDiff !\u003d null) {\n         counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n             collectedBlocks, removedINodes));\n       }\n     } else {\n       // update prior\n       prior \u003d getDiffs().updatePrior(snapshot, prior);\n       // if there is a snapshot diff associated with prior, we need to record\n       // its original created and deleted list before deleting post\n-      if (prior !\u003d null) {\n-        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n-        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n           List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n           priorCreated \u003d cloneDiffList(cList);\n           priorDeleted \u003d cloneDiffList(dList);\n         }\n       }\n       \n-      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior, currentINode, \n-          collectedBlocks, removedINodes, countDiffChange));\n+      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n+          currentINode, collectedBlocks, removedINodes, countDiffChange));\n       \n       // check priorDiff again since it may be created during the diff deletion\n-      if (prior !\u003d null) {\n-        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n-        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n           // For files/directories created between \"prior\" and \"snapshot\", \n           // we need to clear snapshot copies for \"snapshot\". Note that we must\n           // use null as prior in the cleanSubtree call. Files/directories that\n           // were created before \"prior\" will be covered by the later \n           // cleanSubtreeRecursively call.\n           if (priorCreated !\u003d null) {\n             // we only check the node originally in prior\u0027s created list\n             for (INode cNode : priorDiff.getChildrenDiff().getList(\n                 ListType.CREATED)) {\n               if (priorCreated.containsKey(cNode)) {\n-                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,\n-                    removedINodes, countDiffChange));\n+                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n+                    collectedBlocks, removedINodes, countDiffChange));\n               }\n             }\n           }\n           \n           // When a directory is moved from the deleted list of the posterior\n           // diff to the deleted list of this diff, we need to destroy its\n           // descendants that were 1) created after taking this diff and 2)\n           // deleted after taking posterior diff.\n \n           // For files moved from posterior\u0027s deleted list, we also need to\n           // delete its snapshot copy associated with the posterior snapshot.\n           \n           for (INode dNode : priorDiff.getChildrenDiff().getList(\n               ListType.DELETED)) {\n             if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n               counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                   collectedBlocks, removedINodes, countDiffChange));\n             }\n           }\n         }\n       }\n     }\n     counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n         collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n     \n     if (currentINode.isQuotaSet()) {\n       currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n           -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n     }\n     return counts;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final int snapshot, int prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n      throws QuotaExceededException {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d Snapshot.CURRENT_STATE_ID) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior,\n          currentINode, collectedBlocks, removedINodes, countDiffChange));\n      \n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d Snapshot.NO_SNAPSHOT_ID) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiffById(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshotId() \u003d\u003d prior) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, Snapshot.NO_SNAPSHOT_ID,\n                    collectedBlocks, removedINodes, countDiffChange));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, countDiffChange));\n            }\n          }\n        }\n      }\n    }\n    counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n        collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n    \n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java",
          "extendedDetails": {}
        }
      ]
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,81 @@\n+  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n+      final Snapshot snapshot, Snapshot prior,\n+      final BlocksMapUpdateInfo collectedBlocks,\n+      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n+      throws QuotaExceededException {\n+    Quota.Counts counts \u003d Quota.Counts.newInstance();\n+    Map\u003cINode, INode\u003e priorCreated \u003d null;\n+    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n+    if (snapshot \u003d\u003d null) { // delete the current directory\n+      currentINode.recordModification(prior);\n+      // delete everything in created list\n+      DirectoryDiff lastDiff \u003d diffs.getLast();\n+      if (lastDiff !\u003d null) {\n+        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n+            collectedBlocks, removedINodes));\n+      }\n+    } else {\n+      // update prior\n+      prior \u003d getDiffs().updatePrior(snapshot, prior);\n+      // if there is a snapshot diff associated with prior, we need to record\n+      // its original created and deleted list before deleting post\n+      if (prior !\u003d null) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n+          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n+          priorCreated \u003d cloneDiffList(cList);\n+          priorDeleted \u003d cloneDiffList(dList);\n+        }\n+      }\n+      \n+      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior, currentINode, \n+          collectedBlocks, removedINodes, countDiffChange));\n+      \n+      // check priorDiff again since it may be created during the diff deletion\n+      if (prior !\u003d null) {\n+        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n+        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n+          // For files/directories created between \"prior\" and \"snapshot\", \n+          // we need to clear snapshot copies for \"snapshot\". Note that we must\n+          // use null as prior in the cleanSubtree call. Files/directories that\n+          // were created before \"prior\" will be covered by the later \n+          // cleanSubtreeRecursively call.\n+          if (priorCreated !\u003d null) {\n+            // we only check the node originally in prior\u0027s created list\n+            for (INode cNode : priorDiff.getChildrenDiff().getList(\n+                ListType.CREATED)) {\n+              if (priorCreated.containsKey(cNode)) {\n+                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,\n+                    removedINodes, countDiffChange));\n+              }\n+            }\n+          }\n+          \n+          // When a directory is moved from the deleted list of the posterior\n+          // diff to the deleted list of this diff, we need to destroy its\n+          // descendants that were 1) created after taking this diff and 2)\n+          // deleted after taking posterior diff.\n+\n+          // For files moved from posterior\u0027s deleted list, we also need to\n+          // delete its snapshot copy associated with the posterior snapshot.\n+          \n+          for (INode dNode : priorDiff.getChildrenDiff().getList(\n+              ListType.DELETED)) {\n+            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n+              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n+                  collectedBlocks, removedINodes, countDiffChange));\n+            }\n+          }\n+        }\n+      }\n+    }\n+    counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n+        collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n+    \n+    if (currentINode.isQuotaSet()) {\n+      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n+          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n+    }\n+    return counts;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Quota.Counts cleanDirectory(final INodeDirectory currentINode,\n      final Snapshot snapshot, Snapshot prior,\n      final BlocksMapUpdateInfo collectedBlocks,\n      final List\u003cINode\u003e removedINodes, final boolean countDiffChange)\n      throws QuotaExceededException {\n    Quota.Counts counts \u003d Quota.Counts.newInstance();\n    Map\u003cINode, INode\u003e priorCreated \u003d null;\n    Map\u003cINode, INode\u003e priorDeleted \u003d null;\n    if (snapshot \u003d\u003d null) { // delete the current directory\n      currentINode.recordModification(prior);\n      // delete everything in created list\n      DirectoryDiff lastDiff \u003d diffs.getLast();\n      if (lastDiff !\u003d null) {\n        counts.add(lastDiff.diff.destroyCreatedList(currentINode,\n            collectedBlocks, removedINodes));\n      }\n    } else {\n      // update prior\n      prior \u003d getDiffs().updatePrior(snapshot, prior);\n      // if there is a snapshot diff associated with prior, we need to record\n      // its original created and deleted list before deleting post\n      if (prior !\u003d null) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n          List\u003cINode\u003e cList \u003d priorDiff.diff.getList(ListType.CREATED);\n          List\u003cINode\u003e dList \u003d priorDiff.diff.getList(ListType.DELETED);\n          priorCreated \u003d cloneDiffList(cList);\n          priorDeleted \u003d cloneDiffList(dList);\n        }\n      }\n      \n      counts.add(getDiffs().deleteSnapshotDiff(snapshot, prior, currentINode, \n          collectedBlocks, removedINodes, countDiffChange));\n      \n      // check priorDiff again since it may be created during the diff deletion\n      if (prior !\u003d null) {\n        DirectoryDiff priorDiff \u003d this.getDiffs().getDiff(prior);\n        if (priorDiff !\u003d null \u0026\u0026 priorDiff.getSnapshot().equals(prior)) {\n          // For files/directories created between \"prior\" and \"snapshot\", \n          // we need to clear snapshot copies for \"snapshot\". Note that we must\n          // use null as prior in the cleanSubtree call. Files/directories that\n          // were created before \"prior\" will be covered by the later \n          // cleanSubtreeRecursively call.\n          if (priorCreated !\u003d null) {\n            // we only check the node originally in prior\u0027s created list\n            for (INode cNode : priorDiff.getChildrenDiff().getList(\n                ListType.CREATED)) {\n              if (priorCreated.containsKey(cNode)) {\n                counts.add(cNode.cleanSubtree(snapshot, null, collectedBlocks,\n                    removedINodes, countDiffChange));\n              }\n            }\n          }\n          \n          // When a directory is moved from the deleted list of the posterior\n          // diff to the deleted list of this diff, we need to destroy its\n          // descendants that were 1) created after taking this diff and 2)\n          // deleted after taking posterior diff.\n\n          // For files moved from posterior\u0027s deleted list, we also need to\n          // delete its snapshot copy associated with the posterior snapshot.\n          \n          for (INode dNode : priorDiff.getChildrenDiff().getList(\n              ListType.DELETED)) {\n            if (priorDeleted \u003d\u003d null || !priorDeleted.containsKey(dNode)) {\n              counts.add(cleanDeletedINode(dNode, snapshot, prior,\n                  collectedBlocks, removedINodes, countDiffChange));\n            }\n          }\n        }\n      }\n    }\n    counts.add(currentINode.cleanSubtreeRecursively(snapshot, prior,\n        collectedBlocks, removedINodes, priorDeleted, countDiffChange));\n    \n    if (currentINode.isQuotaSet()) {\n      currentINode.getDirectoryWithQuotaFeature().addSpaceConsumed2Cache(\n          -counts.get(Quota.NAMESPACE), -counts.get(Quota.DISKSPACE));\n    }\n    return counts;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/DirectoryWithSnapshotFeature.java"
    }
  }
}