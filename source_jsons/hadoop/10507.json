{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataStorage.java",
  "functionName": "linkBlocksHelper",
  "functionId": "linkBlocksHelper___from-File__to-File__oldLV-int__hl-HardLink__upgradeToIdBasedLayout-boolean__blockRoot-File__idBasedLayoutSingleLinks-List__LinkArgs__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
  "functionStartLine": 1299,
  "functionEndLine": 1369,
  "numCommitsSeen": 108,
  "timeTaken": 8203,
  "changeHistory": [
    "2e43c28e01fe006210e71aab179527669f6412ed",
    "441378e7e4609d89b7181dacc8ba92b253a962df",
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
    "1403b84b122fb76ef2b085a728b5402c32499c1f",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89",
    "1ba3f8971433cdbc3e43fd3605065d811dab5b16",
    "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
    "64641c28b5ea8538033060452b0c45b7f2eeb60c",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "2e43c28e01fe006210e71aab179527669f6412ed": "Ybodychange",
    "441378e7e4609d89b7181dacc8ba92b253a962df": "Ybodychange",
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a": "Ybodychange",
    "1403b84b122fb76ef2b085a728b5402c32499c1f": "Ybodychange",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": "Ybodychange",
    "1ba3f8971433cdbc3e43fd3605065d811dab5b16": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9": "Ybodychange",
    "64641c28b5ea8538033060452b0c45b7f2eeb60c": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2e43c28e01fe006210e71aab179527669f6412ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\n",
      "commitDate": "15/08/17 1:48 AM",
      "commitName": "2e43c28e01fe006210e71aab179527669f6412ed",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/06/17 1:54 PM",
      "commitNameOld": "441378e7e4609d89b7181dacc8ba92b253a962df",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 46.5,
      "commitsBetweenForRepo": 302,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n   static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n   boolean upgradeToIdBasedLayout, File blockRoot,\n       List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       HardLink.createHardLink(from, to);\n       hl.linkStats.countSingleLinks++;\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(Block.BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n     // any subdirs from the source that contain blocks, since we have a new\n     // directory structure\n     if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n         BLOCK_SUBDIR_PREFIX)) {\n       if (!to.mkdirs())\n         throw new IOException(\"Cannot create directory \" + to);\n     }\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       if (upgradeToIdBasedLayout) {\n         for (String blockName : blockNames) {\n           long blockId \u003d Block.getBlockId(blockName);\n           File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n           if (!blockLocation.exists()) {\n             if (!blockLocation.mkdirs()) {\n               throw new IOException(\"Failed to mkdirs \" + blockLocation);\n             }\n           }\n           idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n               new File(blockLocation, blockName)));\n           hl.linkStats.countSingleLinks++;\n         }\n       } else {\n         HardLink.createHardLinkMult(from, blockNames, to);\n         hl.linkStats.countMultLinks++;\n         hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n       }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX);\n         }\n       });\n-    for(int i \u003d 0; i \u003c otherNames.length; i++)\n-      linkBlocksHelper(new File(from, otherNames[i]),\n-          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n-          blockRoot, idBasedLayoutSingleLinks);\n+\n+    if (otherNames !\u003d null) {\n+      for (int i \u003d 0; i \u003c otherNames.length; i++) {\n+        linkBlocksHelper(new File(from, otherNames[i]),\n+            new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+            blockRoot, idBasedLayoutSingleLinks);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      HardLink.createHardLink(from, to);\n      hl.linkStats.countSingleLinks++;\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX);\n        }\n      });\n\n    if (otherNames !\u003d null) {\n      for (int i \u003d 0; i \u003c otherNames.length; i++) {\n        linkBlocksHelper(new File(from, otherNames[i]),\n            new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n            blockRoot, idBasedLayoutSingleLinks);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "441378e7e4609d89b7181dacc8ba92b253a962df": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\"\n\nThis reverts commit 89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a.\n\n Conflicts:\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java\n",
      "commitDate": "29/06/17 1:54 PM",
      "commitName": "441378e7e4609d89b7181dacc8ba92b253a962df",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "16/05/17 9:41 AM",
      "commitNameOld": "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 44.18,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,67 @@\n   static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n   boolean upgradeToIdBasedLayout, File blockRoot,\n       List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       HardLink.createHardLink(from, to);\n       hl.linkStats.countSingleLinks++;\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(Block.BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n     // any subdirs from the source that contain blocks, since we have a new\n     // directory structure\n     if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n         BLOCK_SUBDIR_PREFIX)) {\n       if (!to.mkdirs())\n         throw new IOException(\"Cannot create directory \" + to);\n     }\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       if (upgradeToIdBasedLayout) {\n         for (String blockName : blockNames) {\n           long blockId \u003d Block.getBlockId(blockName);\n           File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n           if (!blockLocation.exists()) {\n             if (!blockLocation.mkdirs()) {\n               throw new IOException(\"Failed to mkdirs \" + blockLocation);\n             }\n           }\n           idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n               new File(blockLocation, blockName)));\n           hl.linkStats.countSingleLinks++;\n         }\n       } else {\n         HardLink.createHardLinkMult(from, blockNames, to);\n         hl.linkStats.countMultLinks++;\n         hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n       }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX);\n         }\n       });\n-\n-    if (otherNames !\u003d null) {\n-      for (int i \u003d 0; i \u003c otherNames.length; i++) {\n-        linkBlocksHelper(new File(from, otherNames[i]),\n-            new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n-            blockRoot, idBasedLayoutSingleLinks);\n-      }\n-    }\n+    for(int i \u003d 0; i \u003c otherNames.length; i++)\n+      linkBlocksHelper(new File(from, otherNames[i]),\n+          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+          blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      HardLink.createHardLink(from, to);\n      hl.linkStats.countSingleLinks++;\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\n",
      "commitDate": "16/05/17 9:41 AM",
      "commitName": "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "09/05/17 9:22 AM",
      "commitNameOld": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 7.01,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n   static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n   boolean upgradeToIdBasedLayout, File blockRoot,\n       List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       HardLink.createHardLink(from, to);\n       hl.linkStats.countSingleLinks++;\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(Block.BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n     // any subdirs from the source that contain blocks, since we have a new\n     // directory structure\n     if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n         BLOCK_SUBDIR_PREFIX)) {\n       if (!to.mkdirs())\n         throw new IOException(\"Cannot create directory \" + to);\n     }\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       if (upgradeToIdBasedLayout) {\n         for (String blockName : blockNames) {\n           long blockId \u003d Block.getBlockId(blockName);\n           File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n           if (!blockLocation.exists()) {\n             if (!blockLocation.mkdirs()) {\n               throw new IOException(\"Failed to mkdirs \" + blockLocation);\n             }\n           }\n           idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n               new File(blockLocation, blockName)));\n           hl.linkStats.countSingleLinks++;\n         }\n       } else {\n         HardLink.createHardLinkMult(from, blockNames, to);\n         hl.linkStats.countMultLinks++;\n         hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n       }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX);\n         }\n       });\n-    for(int i \u003d 0; i \u003c otherNames.length; i++)\n-      linkBlocksHelper(new File(from, otherNames[i]),\n-          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n-          blockRoot, idBasedLayoutSingleLinks);\n+\n+    if (otherNames !\u003d null) {\n+      for (int i \u003d 0; i \u003c otherNames.length; i++) {\n+        linkBlocksHelper(new File(from, otherNames[i]),\n+            new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+            blockRoot, idBasedLayoutSingleLinks);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      HardLink.createHardLink(from, to);\n      hl.linkStats.countSingleLinks++;\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX);\n        }\n      });\n\n    if (otherNames !\u003d null) {\n      for (int i \u003d 0; i \u003c otherNames.length; i++) {\n        linkBlocksHelper(new File(from, otherNames[i]),\n            new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n            blockRoot, idBasedLayoutSingleLinks);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "1403b84b122fb76ef2b085a728b5402c32499c1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8546. Use try with resources in DataStorage and Storage.\n",
      "commitDate": "25/06/15 5:50 PM",
      "commitName": "1403b84b122fb76ef2b085a728b5402c32499c1f",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "06/06/15 9:17 AM",
      "commitNameOld": "e46cb800028c95f9bce575d05268cd10d0913222",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 19.36,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,67 @@\n   static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n   boolean upgradeToIdBasedLayout, File blockRoot,\n       List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n-      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n-        FileInputStream in \u003d new FileInputStream(from);\n-        try {\n-          FileOutputStream out \u003d new FileOutputStream(to);\n-          try {\n-            IOUtils.copyBytes(in, out, 16*1024);\n-            hl.linkStats.countPhysicalFileCopies++;\n-          } finally {\n-            out.close();\n-          }\n-        } finally {\n-          in.close();\n-        }\n-      } else {\n-        HardLink.createHardLink(from, to);\n-        hl.linkStats.countSingleLinks++;\n-      }\n+      HardLink.createHardLink(from, to);\n+      hl.linkStats.countSingleLinks++;\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(Block.BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n     // any subdirs from the source that contain blocks, since we have a new\n     // directory structure\n     if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n         BLOCK_SUBDIR_PREFIX)) {\n       if (!to.mkdirs())\n         throw new IOException(\"Cannot create directory \" + to);\n     }\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       if (upgradeToIdBasedLayout) {\n         for (String blockName : blockNames) {\n           long blockId \u003d Block.getBlockId(blockName);\n           File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n           if (!blockLocation.exists()) {\n             if (!blockLocation.mkdirs()) {\n               throw new IOException(\"Failed to mkdirs \" + blockLocation);\n             }\n           }\n           idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n               new File(blockLocation, blockName)));\n           hl.linkStats.countSingleLinks++;\n         }\n       } else {\n         HardLink.createHardLinkMult(from, blockNames, to);\n         hl.linkStats.countMultLinks++;\n         hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n       }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n-          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n-            || name.startsWith(COPY_FILE_PREFIX);\n+          return name.startsWith(BLOCK_SUBDIR_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n       linkBlocksHelper(new File(from, otherNames[i]),\n           new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n           blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      HardLink.createHardLink(from, to);\n      hl.linkStats.countSingleLinks++;\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1522. Combine two BLOCK_FILE_PREFIX constants into one. Contributed by Dongming Liang.",
      "commitDate": "04/03/15 5:51 PM",
      "commitName": "430b5371883e22abb65f37c3e3d4afc3f421fc89",
      "commitAuthor": "Dongming Liang",
      "commitDateOld": "04/02/15 12:10 PM",
      "commitNameOld": "40a415799b1ff3602fbb461765f8b36f1133bda2",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 28.24,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n   boolean upgradeToIdBasedLayout, File blockRoot,\n       List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n-        return name.startsWith(BLOCK_FILE_PREFIX);\n+        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n     // any subdirs from the source that contain blocks, since we have a new\n     // directory structure\n     if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n         BLOCK_SUBDIR_PREFIX)) {\n       if (!to.mkdirs())\n         throw new IOException(\"Cannot create directory \" + to);\n     }\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       if (upgradeToIdBasedLayout) {\n         for (String blockName : blockNames) {\n           long blockId \u003d Block.getBlockId(blockName);\n           File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n           if (!blockLocation.exists()) {\n             if (!blockLocation.mkdirs()) {\n               throw new IOException(\"Failed to mkdirs \" + blockLocation);\n             }\n           }\n           idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n               new File(blockLocation, blockName)));\n           hl.linkStats.countSingleLinks++;\n         }\n       } else {\n         HardLink.createHardLinkMult(from, blockNames, to);\n         hl.linkStats.countMultLinks++;\n         hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n       }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX) \n             || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n       linkBlocksHelper(new File(from, otherNames[i]),\n           new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n           blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(Block.BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "1ba3f8971433cdbc3e43fd3605065d811dab5b16": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6482. Use block ID-based block layout on datanodes (James Thomas via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615223 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/08/14 1:41 PM",
      "commitName": "1ba3f8971433cdbc3e43fd3605065d811dab5b16",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-6482. Use block ID-based block layout on datanodes (James Thomas via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615223 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/08/14 1:41 PM",
          "commitName": "1ba3f8971433cdbc3e43fd3605065d811dab5b16",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "29/04/14 3:27 AM",
          "commitNameOld": "9d21180c1a625295bb9da0d9d5d8c55740944008",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 94.43,
          "commitsBetweenForRepo": 594,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,83 @@\n-  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n-  throws IOException {\n+  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n+  boolean upgradeToIdBasedLayout, File blockRoot,\n+      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n-    if (!to.mkdirs())\n-      throw new IOException(\"Cannot create directory \" + to);\n-    \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(BLOCK_FILE_PREFIX);\n       }\n     });\n \n+    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n+    // any subdirs from the source that contain blocks, since we have a new\n+    // directory structure\n+    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n+        BLOCK_SUBDIR_PREFIX)) {\n+      if (!to.mkdirs())\n+        throw new IOException(\"Cannot create directory \" + to);\n+    }\n+\n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n-      HardLink.createHardLinkMult(from, blockNames, to);\n-      hl.linkStats.countMultLinks++;\n-      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      if (upgradeToIdBasedLayout) {\n+        for (String blockName : blockNames) {\n+          long blockId \u003d Block.getBlockId(blockName);\n+          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n+          if (!blockLocation.exists()) {\n+            if (!blockLocation.mkdirs()) {\n+              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n+            }\n+          }\n+          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n+              new File(blockLocation, blockName)));\n+          hl.linkStats.countSingleLinks++;\n+        }\n+      } else {\n+        HardLink.createHardLinkMult(from, blockNames, to);\n+        hl.linkStats.countMultLinks++;\n+        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX) \n             || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n-      linkBlocks(new File(from, otherNames[i]), \n-          new File(to, otherNames[i]), oldLV, hl);\n+      linkBlocksHelper(new File(from, otherNames[i]),\n+          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+          blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
          "extendedDetails": {
            "oldValue": "linkBlocks",
            "newValue": "linkBlocksHelper"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6482. Use block ID-based block layout on datanodes (James Thomas via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615223 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/08/14 1:41 PM",
          "commitName": "1ba3f8971433cdbc3e43fd3605065d811dab5b16",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "29/04/14 3:27 AM",
          "commitNameOld": "9d21180c1a625295bb9da0d9d5d8c55740944008",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 94.43,
          "commitsBetweenForRepo": 594,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,83 @@\n-  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n-  throws IOException {\n+  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n+  boolean upgradeToIdBasedLayout, File blockRoot,\n+      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n-    if (!to.mkdirs())\n-      throw new IOException(\"Cannot create directory \" + to);\n-    \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(BLOCK_FILE_PREFIX);\n       }\n     });\n \n+    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n+    // any subdirs from the source that contain blocks, since we have a new\n+    // directory structure\n+    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n+        BLOCK_SUBDIR_PREFIX)) {\n+      if (!to.mkdirs())\n+        throw new IOException(\"Cannot create directory \" + to);\n+    }\n+\n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n-      HardLink.createHardLinkMult(from, blockNames, to);\n-      hl.linkStats.countMultLinks++;\n-      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      if (upgradeToIdBasedLayout) {\n+        for (String blockName : blockNames) {\n+          long blockId \u003d Block.getBlockId(blockName);\n+          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n+          if (!blockLocation.exists()) {\n+            if (!blockLocation.mkdirs()) {\n+              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n+            }\n+          }\n+          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n+              new File(blockLocation, blockName)));\n+          hl.linkStats.countSingleLinks++;\n+        }\n+      } else {\n+        HardLink.createHardLinkMult(from, blockNames, to);\n+        hl.linkStats.countMultLinks++;\n+        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX) \n             || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n-      linkBlocks(new File(from, otherNames[i]), \n-          new File(to, otherNames[i]), oldLV, hl);\n+      linkBlocksHelper(new File(from, otherNames[i]),\n+          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+          blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
          "extendedDetails": {
            "oldValue": "[from-File, to-File, oldLV-int, hl-HardLink]",
            "newValue": "[from-File, to-File, oldLV-int, hl-HardLink, upgradeToIdBasedLayout-boolean, blockRoot-File, idBasedLayoutSingleLinks-List\u003cLinkArgs\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6482. Use block ID-based block layout on datanodes (James Thomas via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615223 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/08/14 1:41 PM",
          "commitName": "1ba3f8971433cdbc3e43fd3605065d811dab5b16",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "29/04/14 3:27 AM",
          "commitNameOld": "9d21180c1a625295bb9da0d9d5d8c55740944008",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 94.43,
          "commitsBetweenForRepo": 594,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,83 @@\n-  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n-  throws IOException {\n+  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n+  boolean upgradeToIdBasedLayout, File blockRoot,\n+      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n-    if (!to.mkdirs())\n-      throw new IOException(\"Cannot create directory \" + to);\n-    \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n       @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(BLOCK_FILE_PREFIX);\n       }\n     });\n \n+    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n+    // any subdirs from the source that contain blocks, since we have a new\n+    // directory structure\n+    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n+        BLOCK_SUBDIR_PREFIX)) {\n+      if (!to.mkdirs())\n+        throw new IOException(\"Cannot create directory \" + to);\n+    }\n+\n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n-      HardLink.createHardLinkMult(from, blockNames, to);\n-      hl.linkStats.countMultLinks++;\n-      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      if (upgradeToIdBasedLayout) {\n+        for (String blockName : blockNames) {\n+          long blockId \u003d Block.getBlockId(blockName);\n+          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n+          if (!blockLocation.exists()) {\n+            if (!blockLocation.mkdirs()) {\n+              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n+            }\n+          }\n+          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n+              new File(blockLocation, blockName)));\n+          hl.linkStats.countSingleLinks++;\n+        }\n+      } else {\n+        HardLink.createHardLinkMult(from, blockNames, to);\n+        hl.linkStats.countMultLinks++;\n+        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      }\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX) \n             || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n-      linkBlocks(new File(from, otherNames[i]), \n-          new File(to, otherNames[i]), oldLV, hl);\n+      linkBlocksHelper(new File(from, otherNames[i]),\n+          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n+          blockRoot, idBasedLayoutSingleLinks);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void linkBlocksHelper(File from, File to, int oldLV, HardLink hl,\n  boolean upgradeToIdBasedLayout, File blockRoot,\n      List\u003cLinkArgs\u003e idBasedLayoutSingleLinks) throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // If we are upgrading to block ID-based layout, we don\u0027t want to recreate\n    // any subdirs from the source that contain blocks, since we have a new\n    // directory structure\n    if (!upgradeToIdBasedLayout || !to.getName().startsWith(\n        BLOCK_SUBDIR_PREFIX)) {\n      if (!to.mkdirs())\n        throw new IOException(\"Cannot create directory \" + to);\n    }\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      if (upgradeToIdBasedLayout) {\n        for (String blockName : blockNames) {\n          long blockId \u003d Block.getBlockId(blockName);\n          File blockLocation \u003d DatanodeUtil.idToBlockDir(blockRoot, blockId);\n          if (!blockLocation.exists()) {\n            if (!blockLocation.mkdirs()) {\n              throw new IOException(\"Failed to mkdirs \" + blockLocation);\n            }\n          }\n          idBasedLayoutSingleLinks.add(new LinkArgs(new File(from, blockName),\n              new File(blockLocation, blockName)));\n          hl.linkStats.countSingleLinks++;\n        }\n      } else {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      }\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocksHelper(new File(from, otherNames[i]),\n          new File(to, otherNames[i]), oldLV, hl, upgradeToIdBasedLayout,\n          blockRoot, idBasedLayoutSingleLinks);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
          "extendedDetails": {}
        }
      ]
    },
    "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3659. Add missing @Override to methods across the hadoop-hdfs project. Contributed by Brandon Li. (harsh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361894 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/12 7:58 PM",
      "commitName": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthor": "Harsh J",
      "commitDateOld": "02/04/12 10:38 AM",
      "commitNameOld": "bc13dfb1426944ce45293cb8f444239a7406762c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 104.39,
      "commitsBetweenForRepo": 651,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,60 @@\n   static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n   throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     if (!to.mkdirs())\n       throw new IOException(\"Cannot create directory \" + to);\n     \n     String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n+      @Override\n       public boolean accept(File dir, String name) {\n         return name.startsWith(BLOCK_FILE_PREFIX);\n       }\n     });\n \n     // Block files just need hard links with the same file names\n     // but a different directory\n     if (blockNames.length \u003e 0) {\n       HardLink.createHardLinkMult(from, blockNames, to);\n       hl.linkStats.countMultLinks++;\n       hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n     } else {\n       hl.linkStats.countEmptyDirs++;\n     }\n     \n     // Now take care of the rest of the files and subdirectories\n     String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n+        @Override\n         public boolean accept(File dir, String name) {\n           return name.startsWith(BLOCK_SUBDIR_PREFIX) \n             || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n     for(int i \u003d 0; i \u003c otherNames.length; i++)\n       linkBlocks(new File(from, otherNames[i]), \n           new File(to, otherNames[i]), oldLV, hl);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n  throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    if (!to.mkdirs())\n      throw new IOException(\"Cannot create directory \" + to);\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      @Override\n      public boolean accept(File dir, String name) {\n        return name.startsWith(BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      HardLink.createHardLinkMult(from, blockNames, to);\n      hl.linkStats.countMultLinks++;\n      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        @Override\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocks(new File(from, otherNames[i]), \n          new File(to, otherNames[i]), oldLV, hl);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "64641c28b5ea8538033060452b0c45b7f2eeb60c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3137. Bump LAST_UPGRADABLE_LAYOUT_VERSION to -16. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1307173 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/03/12 5:11 PM",
      "commitName": "64641c28b5ea8538033060452b0c45b7f2eeb60c",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "28/03/12 1:37 PM",
      "commitNameOld": "99a68a14237b4cd1936ba5e9468d25d35dad594c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,58 @@\n   static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n   throws IOException {\n     if (!from.exists()) {\n       return;\n     }\n     if (!from.isDirectory()) {\n       if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n         FileInputStream in \u003d new FileInputStream(from);\n         try {\n           FileOutputStream out \u003d new FileOutputStream(to);\n           try {\n             IOUtils.copyBytes(in, out, 16*1024);\n             hl.linkStats.countPhysicalFileCopies++;\n           } finally {\n             out.close();\n           }\n         } finally {\n           in.close();\n         }\n       } else {\n-        \n-        //check if we are upgrading from pre-generation stamp version.\n-        if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n-          // Link to the new file name.\n-          to \u003d new File(convertMetatadataFileName(to.getAbsolutePath()));\n-        }\n-        \n         HardLink.createHardLink(from, to);\n         hl.linkStats.countSingleLinks++;\n       }\n       return;\n     }\n     // from is a directory\n     hl.linkStats.countDirs++;\n     \n     if (!to.mkdirs())\n       throw new IOException(\"Cannot create directory \" + to);\n     \n-    //If upgrading from old stuff, need to munge the filenames.  That has to\n-    //be done one file at a time, so hardlink them one at a time (slow).\n-    if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n-      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n-          public boolean accept(File dir, String name) {\n-            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n-              || name.startsWith(BLOCK_FILE_PREFIX)\n-              || name.startsWith(COPY_FILE_PREFIX);\n-          }\n-        });\n-      if (blockNames.length \u003d\u003d 0) {\n-        hl.linkStats.countEmptyDirs++;\n+    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n+      public boolean accept(File dir, String name) {\n+        return name.startsWith(BLOCK_FILE_PREFIX);\n       }\n-      else for(int i \u003d 0; i \u003c blockNames.length; i++)\n-        linkBlocks(new File(from, blockNames[i]), \n-            new File(to, blockNames[i]), oldLV, hl);\n-    } \n-    else {\n-      //If upgrading from a relatively new version, we only need to create\n-      //links with the same filename.  This can be done in bulk (much faster).\n-      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n+    });\n+\n+    // Block files just need hard links with the same file names\n+    // but a different directory\n+    if (blockNames.length \u003e 0) {\n+      HardLink.createHardLinkMult(from, blockNames, to);\n+      hl.linkStats.countMultLinks++;\n+      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+    } else {\n+      hl.linkStats.countEmptyDirs++;\n+    }\n+    \n+    // Now take care of the rest of the files and subdirectories\n+    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n         public boolean accept(File dir, String name) {\n-          return name.startsWith(BLOCK_FILE_PREFIX);\n+          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n+            || name.startsWith(COPY_FILE_PREFIX);\n         }\n       });\n-      if (blockNames.length \u003e 0) {\n-        HardLink.createHardLinkMult(from, blockNames, to);\n-        hl.linkStats.countMultLinks++;\n-        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n-      } else {\n-        hl.linkStats.countEmptyDirs++;\n-      }\n-      \n-      //now take care of the rest of the files and subdirectories\n-      String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n-          public boolean accept(File dir, String name) {\n-            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n-              || name.startsWith(COPY_FILE_PREFIX);\n-          }\n-        });\n-      for(int i \u003d 0; i \u003c otherNames.length; i++)\n-        linkBlocks(new File(from, otherNames[i]), \n-            new File(to, otherNames[i]), oldLV, hl);\n-    }\n+    for(int i \u003d 0; i \u003c otherNames.length; i++)\n+      linkBlocks(new File(from, otherNames[i]), \n+          new File(to, otherNames[i]), oldLV, hl);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n  throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    if (!to.mkdirs())\n      throw new IOException(\"Cannot create directory \" + to);\n    \n    String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n      public boolean accept(File dir, String name) {\n        return name.startsWith(BLOCK_FILE_PREFIX);\n      }\n    });\n\n    // Block files just need hard links with the same file names\n    // but a different directory\n    if (blockNames.length \u003e 0) {\n      HardLink.createHardLinkMult(from, blockNames, to);\n      hl.linkStats.countMultLinks++;\n      hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n    } else {\n      hl.linkStats.countEmptyDirs++;\n    }\n    \n    // Now take care of the rest of the files and subdirectories\n    String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_SUBDIR_PREFIX) \n            || name.startsWith(COPY_FILE_PREFIX);\n        }\n      });\n    for(int i \u003d 0; i \u003c otherNames.length; i++)\n      linkBlocks(new File(from, otherNames[i]), \n          new File(to, otherNames[i]), oldLV, hl);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n  throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        \n        //check if we are upgrading from pre-generation stamp version.\n        if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n          // Link to the new file name.\n          to \u003d new File(convertMetatadataFileName(to.getAbsolutePath()));\n        }\n        \n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    if (!to.mkdirs())\n      throw new IOException(\"Cannot create directory \" + to);\n    \n    //If upgrading from old stuff, need to munge the filenames.  That has to\n    //be done one file at a time, so hardlink them one at a time (slow).\n    if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(BLOCK_FILE_PREFIX)\n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      if (blockNames.length \u003d\u003d 0) {\n        hl.linkStats.countEmptyDirs++;\n      }\n      else for(int i \u003d 0; i \u003c blockNames.length; i++)\n        linkBlocks(new File(from, blockNames[i]), \n            new File(to, blockNames[i]), oldLV, hl);\n    } \n    else {\n      //If upgrading from a relatively new version, we only need to create\n      //links with the same filename.  This can be done in bulk (much faster).\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_FILE_PREFIX);\n        }\n      });\n      if (blockNames.length \u003e 0) {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      } else {\n        hl.linkStats.countEmptyDirs++;\n      }\n      \n      //now take care of the rest of the files and subdirectories\n      String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      for(int i \u003d 0; i \u003c otherNames.length; i++)\n        linkBlocks(new File(from, otherNames[i]), \n            new File(to, otherNames[i]), oldLV, hl);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n  throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        \n        //check if we are upgrading from pre-generation stamp version.\n        if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n          // Link to the new file name.\n          to \u003d new File(convertMetatadataFileName(to.getAbsolutePath()));\n        }\n        \n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    if (!to.mkdirs())\n      throw new IOException(\"Cannot create directory \" + to);\n    \n    //If upgrading from old stuff, need to munge the filenames.  That has to\n    //be done one file at a time, so hardlink them one at a time (slow).\n    if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(BLOCK_FILE_PREFIX)\n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      if (blockNames.length \u003d\u003d 0) {\n        hl.linkStats.countEmptyDirs++;\n      }\n      else for(int i \u003d 0; i \u003c blockNames.length; i++)\n        linkBlocks(new File(from, blockNames[i]), \n            new File(to, blockNames[i]), oldLV, hl);\n    } \n    else {\n      //If upgrading from a relatively new version, we only need to create\n      //links with the same filename.  This can be done in bulk (much faster).\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_FILE_PREFIX);\n        }\n      });\n      if (blockNames.length \u003e 0) {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      } else {\n        hl.linkStats.countEmptyDirs++;\n      }\n      \n      //now take care of the rest of the files and subdirectories\n      String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      for(int i \u003d 0; i \u003c otherNames.length; i++)\n        linkBlocks(new File(from, otherNames[i]), \n            new File(to, otherNames[i]), oldLV, hl);\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,83 @@\n+  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n+  throws IOException {\n+    if (!from.exists()) {\n+      return;\n+    }\n+    if (!from.isDirectory()) {\n+      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n+        FileInputStream in \u003d new FileInputStream(from);\n+        try {\n+          FileOutputStream out \u003d new FileOutputStream(to);\n+          try {\n+            IOUtils.copyBytes(in, out, 16*1024);\n+            hl.linkStats.countPhysicalFileCopies++;\n+          } finally {\n+            out.close();\n+          }\n+        } finally {\n+          in.close();\n+        }\n+      } else {\n+        \n+        //check if we are upgrading from pre-generation stamp version.\n+        if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n+          // Link to the new file name.\n+          to \u003d new File(convertMetatadataFileName(to.getAbsolutePath()));\n+        }\n+        \n+        HardLink.createHardLink(from, to);\n+        hl.linkStats.countSingleLinks++;\n+      }\n+      return;\n+    }\n+    // from is a directory\n+    hl.linkStats.countDirs++;\n+    \n+    if (!to.mkdirs())\n+      throw new IOException(\"Cannot create directory \" + to);\n+    \n+    //If upgrading from old stuff, need to munge the filenames.  That has to\n+    //be done one file at a time, so hardlink them one at a time (slow).\n+    if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n+      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n+          public boolean accept(File dir, String name) {\n+            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n+              || name.startsWith(BLOCK_FILE_PREFIX)\n+              || name.startsWith(COPY_FILE_PREFIX);\n+          }\n+        });\n+      if (blockNames.length \u003d\u003d 0) {\n+        hl.linkStats.countEmptyDirs++;\n+      }\n+      else for(int i \u003d 0; i \u003c blockNames.length; i++)\n+        linkBlocks(new File(from, blockNames[i]), \n+            new File(to, blockNames[i]), oldLV, hl);\n+    } \n+    else {\n+      //If upgrading from a relatively new version, we only need to create\n+      //links with the same filename.  This can be done in bulk (much faster).\n+      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n+        public boolean accept(File dir, String name) {\n+          return name.startsWith(BLOCK_FILE_PREFIX);\n+        }\n+      });\n+      if (blockNames.length \u003e 0) {\n+        HardLink.createHardLinkMult(from, blockNames, to);\n+        hl.linkStats.countMultLinks++;\n+        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n+      } else {\n+        hl.linkStats.countEmptyDirs++;\n+      }\n+      \n+      //now take care of the rest of the files and subdirectories\n+      String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n+          public boolean accept(File dir, String name) {\n+            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n+              || name.startsWith(COPY_FILE_PREFIX);\n+          }\n+        });\n+      for(int i \u003d 0; i \u003c otherNames.length; i++)\n+        linkBlocks(new File(from, otherNames[i]), \n+            new File(to, otherNames[i]), oldLV, hl);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static void linkBlocks(File from, File to, int oldLV, HardLink hl) \n  throws IOException {\n    if (!from.exists()) {\n      return;\n    }\n    if (!from.isDirectory()) {\n      if (from.getName().startsWith(COPY_FILE_PREFIX)) {\n        FileInputStream in \u003d new FileInputStream(from);\n        try {\n          FileOutputStream out \u003d new FileOutputStream(to);\n          try {\n            IOUtils.copyBytes(in, out, 16*1024);\n            hl.linkStats.countPhysicalFileCopies++;\n          } finally {\n            out.close();\n          }\n        } finally {\n          in.close();\n        }\n      } else {\n        \n        //check if we are upgrading from pre-generation stamp version.\n        if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n          // Link to the new file name.\n          to \u003d new File(convertMetatadataFileName(to.getAbsolutePath()));\n        }\n        \n        HardLink.createHardLink(from, to);\n        hl.linkStats.countSingleLinks++;\n      }\n      return;\n    }\n    // from is a directory\n    hl.linkStats.countDirs++;\n    \n    if (!to.mkdirs())\n      throw new IOException(\"Cannot create directory \" + to);\n    \n    //If upgrading from old stuff, need to munge the filenames.  That has to\n    //be done one file at a time, so hardlink them one at a time (slow).\n    if (oldLV \u003e\u003d PRE_GENERATIONSTAMP_LAYOUT_VERSION) {\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(BLOCK_FILE_PREFIX)\n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      if (blockNames.length \u003d\u003d 0) {\n        hl.linkStats.countEmptyDirs++;\n      }\n      else for(int i \u003d 0; i \u003c blockNames.length; i++)\n        linkBlocks(new File(from, blockNames[i]), \n            new File(to, blockNames[i]), oldLV, hl);\n    } \n    else {\n      //If upgrading from a relatively new version, we only need to create\n      //links with the same filename.  This can be done in bulk (much faster).\n      String[] blockNames \u003d from.list(new java.io.FilenameFilter() {\n        public boolean accept(File dir, String name) {\n          return name.startsWith(BLOCK_FILE_PREFIX);\n        }\n      });\n      if (blockNames.length \u003e 0) {\n        HardLink.createHardLinkMult(from, blockNames, to);\n        hl.linkStats.countMultLinks++;\n        hl.linkStats.countFilesMultLinks +\u003d blockNames.length;\n      } else {\n        hl.linkStats.countEmptyDirs++;\n      }\n      \n      //now take care of the rest of the files and subdirectories\n      String[] otherNames \u003d from.list(new java.io.FilenameFilter() {\n          public boolean accept(File dir, String name) {\n            return name.startsWith(BLOCK_SUBDIR_PREFIX) \n              || name.startsWith(COPY_FILE_PREFIX);\n          }\n        });\n      for(int i \u003d 0; i \u003c otherNames.length; i++)\n        linkBlocks(new File(from, otherNames[i]), \n            new File(to, otherNames[i]), oldLV, hl);\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataStorage.java"
    }
  }
}