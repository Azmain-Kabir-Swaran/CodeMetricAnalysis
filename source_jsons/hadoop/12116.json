{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataNode.java",
  "functionName": "initDataXceiver",
  "functionId": "initDataXceiver",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
  "functionStartLine": 1154,
  "functionEndLine": 1194,
  "numCommitsSeen": 358,
  "timeTaken": 2108,
  "changeHistory": [
    "dfcb331ba3516264398121c9f23af3a79c0509cc"
  ],
  "changeHistoryShort": {
    "dfcb331ba3516264398121c9f23af3a79c0509cc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dfcb331ba3516264398121c9f23af3a79c0509cc": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13076: [SPS]: Addendum. Resolve conflicts after rebasing branch to trunk. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "dfcb331ba3516264398121c9f23af3a79c0509cc",
      "commitAuthor": "Rakesh Radhakrishnan",
      "diff": "@@ -0,0 +1,41 @@\n+  private void initDataXceiver() throws IOException {\n+    // find free port or use privileged port provided\n+    TcpPeerServer tcpPeerServer;\n+    if (secureResources !\u003d null) {\n+      tcpPeerServer \u003d new TcpPeerServer(secureResources);\n+    } else {\n+      int backlogLength \u003d getConf().getInt(\n+          CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_KEY,\n+          CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT);\n+      tcpPeerServer \u003d new TcpPeerServer(dnConf.socketWriteTimeout,\n+          DataNode.getStreamingAddr(getConf()), backlogLength);\n+    }\n+    if (dnConf.getTransferSocketRecvBufferSize() \u003e 0) {\n+      tcpPeerServer.setReceiveBufferSize(\n+          dnConf.getTransferSocketRecvBufferSize());\n+    }\n+    streamingAddr \u003d tcpPeerServer.getStreamingAddr();\n+    LOG.info(\"Opened streaming server at {}\", streamingAddr);\n+    this.threadGroup \u003d new ThreadGroup(\"dataXceiverServer\");\n+    xserver \u003d new DataXceiverServer(tcpPeerServer, getConf(), this);\n+    this.dataXceiverServer \u003d new Daemon(threadGroup, xserver);\n+    this.threadGroup.setDaemon(true); // auto destroy when empty\n+\n+    if (getConf().getBoolean(\n+        HdfsClientConfigKeys.Read.ShortCircuit.KEY,\n+        HdfsClientConfigKeys.Read.ShortCircuit.DEFAULT) ||\n+        getConf().getBoolean(\n+            HdfsClientConfigKeys.DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC,\n+            HdfsClientConfigKeys\n+              .DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC_DEFAULT)) {\n+      DomainPeerServer domainPeerServer \u003d\n+                getDomainPeerServer(getConf(), streamingAddr.getPort());\n+      if (domainPeerServer !\u003d null) {\n+        this.localDataXceiverServer \u003d new Daemon(threadGroup,\n+            new DataXceiverServer(domainPeerServer, getConf(), this));\n+        LOG.info(\"Listening on UNIX domain socket: {}\",\n+            domainPeerServer.getBindPath());\n+      }\n+    }\n+    this.shortCircuitRegistry \u003d new ShortCircuitRegistry(getConf());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void initDataXceiver() throws IOException {\n    // find free port or use privileged port provided\n    TcpPeerServer tcpPeerServer;\n    if (secureResources !\u003d null) {\n      tcpPeerServer \u003d new TcpPeerServer(secureResources);\n    } else {\n      int backlogLength \u003d getConf().getInt(\n          CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_KEY,\n          CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT);\n      tcpPeerServer \u003d new TcpPeerServer(dnConf.socketWriteTimeout,\n          DataNode.getStreamingAddr(getConf()), backlogLength);\n    }\n    if (dnConf.getTransferSocketRecvBufferSize() \u003e 0) {\n      tcpPeerServer.setReceiveBufferSize(\n          dnConf.getTransferSocketRecvBufferSize());\n    }\n    streamingAddr \u003d tcpPeerServer.getStreamingAddr();\n    LOG.info(\"Opened streaming server at {}\", streamingAddr);\n    this.threadGroup \u003d new ThreadGroup(\"dataXceiverServer\");\n    xserver \u003d new DataXceiverServer(tcpPeerServer, getConf(), this);\n    this.dataXceiverServer \u003d new Daemon(threadGroup, xserver);\n    this.threadGroup.setDaemon(true); // auto destroy when empty\n\n    if (getConf().getBoolean(\n        HdfsClientConfigKeys.Read.ShortCircuit.KEY,\n        HdfsClientConfigKeys.Read.ShortCircuit.DEFAULT) ||\n        getConf().getBoolean(\n            HdfsClientConfigKeys.DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC,\n            HdfsClientConfigKeys\n              .DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC_DEFAULT)) {\n      DomainPeerServer domainPeerServer \u003d\n                getDomainPeerServer(getConf(), streamingAddr.getPort());\n      if (domainPeerServer !\u003d null) {\n        this.localDataXceiverServer \u003d new Daemon(threadGroup,\n            new DataXceiverServer(domainPeerServer, getConf(), this));\n        LOG.info(\"Listening on UNIX domain socket: {}\",\n            domainPeerServer.getBindPath());\n      }\n    }\n    this.shortCircuitRegistry \u003d new ShortCircuitRegistry(getConf());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}