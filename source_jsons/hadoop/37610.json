{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DelegationTokenRenewer.java",
  "functionName": "handleAppSubmitEvent",
  "functionId": "handleAppSubmitEvent___evt-AbstractDelegationTokenRenewerAppEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
  "functionStartLine": 459,
  "functionEndLine": 560,
  "numCommitsSeen": 61,
  "timeTaken": 6528,
  "changeHistory": [
    "5abd0148eb9484381c7ff92b4bfab9ac8a81c681",
    "b4870bce3a8336dbd638d26b8662037c4d4cdae9",
    "0696828a090bc06446f75b29c967697f1d6d845b",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "69fa81679f59378fd19a2c65db8019393d7c05a2",
    "f10ebc67f57a4a2e3cc916c41154ab9b6a4635c9",
    "d3a34a4f388155f6a7ef040e244ce7be788cd28b",
    "bb6dde68f19be1885a9e7f7949316a03825b6f3e",
    "9c5911294e0ba71aefe4763731b0e780cde9d0ca",
    "0402bada1989258ecbfdc437cb339322a1f55a97",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "28fca92521b04e9d9b6f4d095c593282a06e0a36",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4"
  ],
  "changeHistoryShort": {
    "5abd0148eb9484381c7ff92b4bfab9ac8a81c681": "Ybodychange",
    "b4870bce3a8336dbd638d26b8662037c4d4cdae9": "Ybodychange",
    "0696828a090bc06446f75b29c967697f1d6d845b": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "69fa81679f59378fd19a2c65db8019393d7c05a2": "Ybodychange",
    "f10ebc67f57a4a2e3cc916c41154ab9b6a4635c9": "Ybodychange",
    "d3a34a4f388155f6a7ef040e244ce7be788cd28b": "Yparameterchange",
    "bb6dde68f19be1885a9e7f7949316a03825b6f3e": "Ybodychange",
    "9c5911294e0ba71aefe4763731b0e780cde9d0ca": "Ybodychange",
    "0402bada1989258ecbfdc437cb339322a1f55a97": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ymultichange(Yexceptionschange,Ybodychange)",
    "28fca92521b04e9d9b6f4d095c593282a06e0a36": "Ybodychange",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5abd0148eb9484381c7ff92b4bfab9ac8a81c681": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9768. RM Renew Delegation token thread should timeout and retry. Contributed by Manikandan R.\n",
      "commitDate": "28/01/20 10:06 AM",
      "commitName": "5abd0148eb9484381c7ff92b4bfab9ac8a81c681",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "21/01/20 5:45 PM",
      "commitNameOld": "b4870bce3a8336dbd638d26b8662037c4d4cdae9",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 6.68,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           Configuration tokenConf;\n           if (evt.tokenConf !\u003d null) {\n             // Override conf with app provided conf - this is required in cases\n             // where RM does not have the required conf to communicate with\n             // remote hdfs cluster. The conf is provided by the application\n             // itself.\n             tokenConf \u003d evt.tokenConf;\n             LOG.info(\"Using app provided token conf for renewal,\"\n                 + \" number of configs \u003d \" + tokenConf.size());\n             if (LOG.isDebugEnabled()) {\n               for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                    tokenConf.iterator(); itor.hasNext(); ) {\n                 Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n-                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n+                LOG.debug(\"Token conf key is {} and value is {}\",\n+                    entry.getKey(), entry.getValue());\n               }\n             }\n           }  else {\n             tokenConf \u003d getConfig();\n           }\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               tokenConf, now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             if (ioe instanceof SecretManager.InvalidToken\n                 \u0026\u0026 dttr.maxDate \u003c Time.now()\n                 \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                 \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n               LOG.info(\"Failed to renew hdfs token \" + dttr\n                   + \" on recovery as it expired, requesting new hdfs token for \"\n                   + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n               requestNewHdfsDelegationTokenAsProxyUser(\n                   Arrays.asList(applicationId), evt.getUser(),\n                   evt.shouldCancelAtEnd());\n               continue;\n             }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n           evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          Configuration tokenConf;\n          if (evt.tokenConf !\u003d null) {\n            // Override conf with app provided conf - this is required in cases\n            // where RM does not have the required conf to communicate with\n            // remote hdfs cluster. The conf is provided by the application\n            // itself.\n            tokenConf \u003d evt.tokenConf;\n            LOG.info(\"Using app provided token conf for renewal,\"\n                + \" number of configs \u003d \" + tokenConf.size());\n            if (LOG.isDebugEnabled()) {\n              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                   tokenConf.iterator(); itor.hasNext(); ) {\n                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                LOG.debug(\"Token conf key is {} and value is {}\",\n                    entry.getKey(), entry.getValue());\n              }\n            }\n          }  else {\n            tokenConf \u003d getConfig();\n          }\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "b4870bce3a8336dbd638d26b8662037c4d4cdae9": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-9768. RM Renew Delegation token thread should timeout and retry. Contributed by Manikandan R.\"\n\nThis reverts commit 0696828a090bc06446f75b29c967697f1d6d845b.\n",
      "commitDate": "21/01/20 5:45 PM",
      "commitName": "b4870bce3a8336dbd638d26b8662037c4d4cdae9",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "21/01/20 1:41 PM",
      "commitNameOld": "0696828a090bc06446f75b29c967697f1d6d845b",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,101 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           Configuration tokenConf;\n           if (evt.tokenConf !\u003d null) {\n             // Override conf with app provided conf - this is required in cases\n             // where RM does not have the required conf to communicate with\n             // remote hdfs cluster. The conf is provided by the application\n             // itself.\n             tokenConf \u003d evt.tokenConf;\n             LOG.info(\"Using app provided token conf for renewal,\"\n                 + \" number of configs \u003d \" + tokenConf.size());\n             if (LOG.isDebugEnabled()) {\n               for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                    tokenConf.iterator(); itor.hasNext(); ) {\n                 Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n-                LOG.debug(\"Token conf key is {} and value is {}\",\n-                    entry.getKey(), entry.getValue());\n+                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n               }\n             }\n           }  else {\n             tokenConf \u003d getConfig();\n           }\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               tokenConf, now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             if (ioe instanceof SecretManager.InvalidToken\n                 \u0026\u0026 dttr.maxDate \u003c Time.now()\n                 \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                 \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n               LOG.info(\"Failed to renew hdfs token \" + dttr\n                   + \" on recovery as it expired, requesting new hdfs token for \"\n                   + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n               requestNewHdfsDelegationTokenAsProxyUser(\n                   Arrays.asList(applicationId), evt.getUser(),\n                   evt.shouldCancelAtEnd());\n               continue;\n             }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n           evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          Configuration tokenConf;\n          if (evt.tokenConf !\u003d null) {\n            // Override conf with app provided conf - this is required in cases\n            // where RM does not have the required conf to communicate with\n            // remote hdfs cluster. The conf is provided by the application\n            // itself.\n            tokenConf \u003d evt.tokenConf;\n            LOG.info(\"Using app provided token conf for renewal,\"\n                + \" number of configs \u003d \" + tokenConf.size());\n            if (LOG.isDebugEnabled()) {\n              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                   tokenConf.iterator(); itor.hasNext(); ) {\n                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n              }\n            }\n          }  else {\n            tokenConf \u003d getConfig();\n          }\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "0696828a090bc06446f75b29c967697f1d6d845b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9768. RM Renew Delegation token thread should timeout and retry. Contributed by Manikandan R.\n",
      "commitDate": "21/01/20 1:41 PM",
      "commitName": "0696828a090bc06446f75b29c967697f1d6d845b",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 311.93,
      "commitsBetweenForRepo": 1984,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           Configuration tokenConf;\n           if (evt.tokenConf !\u003d null) {\n             // Override conf with app provided conf - this is required in cases\n             // where RM does not have the required conf to communicate with\n             // remote hdfs cluster. The conf is provided by the application\n             // itself.\n             tokenConf \u003d evt.tokenConf;\n             LOG.info(\"Using app provided token conf for renewal,\"\n                 + \" number of configs \u003d \" + tokenConf.size());\n             if (LOG.isDebugEnabled()) {\n               for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                    tokenConf.iterator(); itor.hasNext(); ) {\n                 Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n-                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n+                LOG.debug(\"Token conf key is {} and value is {}\",\n+                    entry.getKey(), entry.getValue());\n               }\n             }\n           }  else {\n             tokenConf \u003d getConfig();\n           }\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               tokenConf, now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             if (ioe instanceof SecretManager.InvalidToken\n                 \u0026\u0026 dttr.maxDate \u003c Time.now()\n                 \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                 \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n               LOG.info(\"Failed to renew hdfs token \" + dttr\n                   + \" on recovery as it expired, requesting new hdfs token for \"\n                   + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n               requestNewHdfsDelegationTokenAsProxyUser(\n                   Arrays.asList(applicationId), evt.getUser(),\n                   evt.shouldCancelAtEnd());\n               continue;\n             }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n           evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          Configuration tokenConf;\n          if (evt.tokenConf !\u003d null) {\n            // Override conf with app provided conf - this is required in cases\n            // where RM does not have the required conf to communicate with\n            // remote hdfs cluster. The conf is provided by the application\n            // itself.\n            tokenConf \u003d evt.tokenConf;\n            LOG.info(\"Using app provided token conf for renewal,\"\n                + \" number of configs \u003d \" + tokenConf.size());\n            if (LOG.isDebugEnabled()) {\n              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                   tokenConf.iterator(); itor.hasNext(); ) {\n                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                LOG.debug(\"Token conf key is {} and value is {}\",\n                    entry.getKey(), entry.getValue());\n              }\n            }\n          }  else {\n            tokenConf \u003d getConfig();\n          }\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,101 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Registering tokens for renewal for:\" +\n-          \" appId \u003d \" + applicationId);\n-    }\n+    LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           Configuration tokenConf;\n           if (evt.tokenConf !\u003d null) {\n             // Override conf with app provided conf - this is required in cases\n             // where RM does not have the required conf to communicate with\n             // remote hdfs cluster. The conf is provided by the application\n             // itself.\n             tokenConf \u003d evt.tokenConf;\n             LOG.info(\"Using app provided token conf for renewal,\"\n                 + \" number of configs \u003d \" + tokenConf.size());\n             if (LOG.isDebugEnabled()) {\n               for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                    tokenConf.iterator(); itor.hasNext(); ) {\n                 Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                 LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n               }\n             }\n           }  else {\n             tokenConf \u003d getConfig();\n           }\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               tokenConf, now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             if (ioe instanceof SecretManager.InvalidToken\n                 \u0026\u0026 dttr.maxDate \u003c Time.now()\n                 \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                 \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n               LOG.info(\"Failed to renew hdfs token \" + dttr\n                   + \" on recovery as it expired, requesting new hdfs token for \"\n                   + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n               requestNewHdfsDelegationTokenAsProxyUser(\n                   Arrays.asList(applicationId), evt.getUser(),\n                   evt.shouldCancelAtEnd());\n               continue;\n             }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n           evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    LOG.debug(\"Registering tokens for renewal for: appId \u003d {}\", applicationId);\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          Configuration tokenConf;\n          if (evt.tokenConf !\u003d null) {\n            // Override conf with app provided conf - this is required in cases\n            // where RM does not have the required conf to communicate with\n            // remote hdfs cluster. The conf is provided by the application\n            // itself.\n            tokenConf \u003d evt.tokenConf;\n            LOG.info(\"Using app provided token conf for renewal,\"\n                + \" number of configs \u003d \" + tokenConf.size());\n            if (LOG.isDebugEnabled()) {\n              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                   tokenConf.iterator(); itor.hasNext(); ) {\n                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n              }\n            }\n          }  else {\n            tokenConf \u003d getConfig();\n          }\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "69fa81679f59378fd19a2c65db8019393d7c05a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5910. Support for multi-cluster delegation tokens. Contributed by Jian He\n",
      "commitDate": "23/01/17 9:12 AM",
      "commitName": "69fa81679f59378fd19a2c65db8019393d7c05a2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/07/16 7:25 PM",
      "commitNameOld": "06c56ff79b4cdf82f733498d3edfa0b6e531a2db",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 194.62,
      "commitsBetweenForRepo": 1287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,104 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n+          Configuration tokenConf;\n+          if (evt.tokenConf !\u003d null) {\n+            // Override conf with app provided conf - this is required in cases\n+            // where RM does not have the required conf to communicate with\n+            // remote hdfs cluster. The conf is provided by the application\n+            // itself.\n+            tokenConf \u003d evt.tokenConf;\n+            LOG.info(\"Using app provided token conf for renewal,\"\n+                + \" number of configs \u003d \" + tokenConf.size());\n+            if (LOG.isDebugEnabled()) {\n+              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n+                   tokenConf.iterator(); itor.hasNext(); ) {\n+                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n+                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n+              }\n+            }\n+          }  else {\n+            tokenConf \u003d getConfig();\n+          }\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n-              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n+              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             if (ioe instanceof SecretManager.InvalidToken\n                 \u0026\u0026 dttr.maxDate \u003c Time.now()\n                 \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                 \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n               LOG.info(\"Failed to renew hdfs token \" + dttr\n                   + \" on recovery as it expired, requesting new hdfs token for \"\n                   + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n               requestNewHdfsDelegationTokenAsProxyUser(\n                   Arrays.asList(applicationId), evt.getUser(),\n                   evt.shouldCancelAtEnd());\n               continue;\n             }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n           evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          Configuration tokenConf;\n          if (evt.tokenConf !\u003d null) {\n            // Override conf with app provided conf - this is required in cases\n            // where RM does not have the required conf to communicate with\n            // remote hdfs cluster. The conf is provided by the application\n            // itself.\n            tokenConf \u003d evt.tokenConf;\n            LOG.info(\"Using app provided token conf for renewal,\"\n                + \" number of configs \u003d \" + tokenConf.size());\n            if (LOG.isDebugEnabled()) {\n              for (Iterator\u003cMap.Entry\u003cString, String\u003e\u003e itor \u003d\n                   tokenConf.iterator(); itor.hasNext(); ) {\n                Map.Entry\u003cString, String\u003e entry \u003d itor.next();\n                LOG.info(entry.getKey() + \" \u003d\u003d\u003d\u003e \" + entry.getValue());\n              }\n            }\n          }  else {\n            tokenConf \u003d getConfig();\n          }\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              tokenConf, now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "f10ebc67f57a4a2e3cc916c41154ab9b6a4635c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5098. Fixed ResourceManager\u0027s DelegationTokenRenewer to replace expiring system-tokens if RM stops and only restarts after a long time. Contributed by Jian He.\n",
      "commitDate": "03/06/16 1:00 PM",
      "commitName": "f10ebc67f57a4a2e3cc916c41154ab9b6a4635c9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/16 9:50 PM",
      "commitNameOld": "47c41e7ac7e6b905a58550f8899f629c1cf8b138",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 27.63,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,85 @@\n   private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               getConfig(), now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n+            if (ioe instanceof SecretManager.InvalidToken\n+                \u0026\u0026 dttr.maxDate \u003c Time.now()\n+                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n+                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n+              LOG.info(\"Failed to renew hdfs token \" + dttr\n+                  + \" on recovery as it expired, requesting new hdfs token for \"\n+                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n+              requestNewHdfsDelegationTokenAsProxyUser(\n+                  Arrays.asList(applicationId), evt.getUser(),\n+                  evt.shouldCancelAtEnd());\n+              continue;\n+            }\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n-      requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n+      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n+          evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            if (ioe instanceof SecretManager.InvalidToken\n                \u0026\u0026 dttr.maxDate \u003c Time.now()\n                \u0026\u0026 evt instanceof DelegationTokenRenewerAppRecoverEvent\n                \u0026\u0026 token.getKind().equals(HDFS_DELEGATION_KIND)) {\n              LOG.info(\"Failed to renew hdfs token \" + dttr\n                  + \" on recovery as it expired, requesting new hdfs token for \"\n                  + applicationId + \", user\u003d\" + evt.getUser(), ioe);\n              requestNewHdfsDelegationTokenAsProxyUser(\n                  Arrays.asList(applicationId), evt.getUser(),\n                  evt.shouldCancelAtEnd());\n              continue;\n            }\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationTokenAsProxyUser(Arrays.asList(applicationId),\n          evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "d3a34a4f388155f6a7ef040e244ce7be788cd28b": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-4041. Slow delegation token renewal can severely prolong RM recovery. Contributed by Sunil G\n",
      "commitDate": "23/10/15 1:57 PM",
      "commitName": "d3a34a4f388155f6a7ef040e244ce7be788cd28b",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/10/15 5:12 PM",
      "commitNameOld": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n-  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n+  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n         if (skipTokenRenewal(token)) {\n           continue;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               getConfig(), now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(AbstractDelegationTokenRenewerAppEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {
        "oldValue": "[evt-DelegationTokenRenewerAppSubmitEvent]",
        "newValue": "[evt-AbstractDelegationTokenRenewerAppEvent]"
      }
    },
    "bb6dde68f19be1885a9e7f7949316a03825b6f3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3021. YARN\u0027s delegation-token handling disallows certain trust setups to operate properly over DistCp. Contributed by Yongjun Zhang\n",
      "commitDate": "16/04/15 7:43 PM",
      "commitName": "bb6dde68f19be1885a9e7f7949316a03825b6f3e",
      "commitAuthor": "Jian He",
      "commitDateOld": "13/04/15 2:07 PM",
      "commitNameOld": "a1afbc48b53f6bdbd30dc8eb56a7621d49c5d6db",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,72 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n-        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n+        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n+        if (skipTokenRenewal(token)) {\n+          continue;\n+        }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n         if (dttr \u003d\u003d null) {\n           dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n               getConfig(), now, shouldCancelAtEnd, evt.getUser());\n           try {\n             renewToken(dttr);\n           } catch (IOException ioe) {\n             throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n         }\n         tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         DelegationTokenToRenew currentDtr \u003d\n             allTokens.putIfAbsent(dtr.token, dtr);\n         if (currentDtr !\u003d null) {\n           // another job beat us\n           currentDtr.referringAppIds.add(applicationId);\n           appTokens.get(applicationId).add(currentDtr);\n         } else {\n           appTokens.get(applicationId).add(dtr);\n           setTimerForTokenRenewal(dtr);\n         }\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(HDFS_DELEGATION_KIND)) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n        if (skipTokenRenewal(token)) {\n          continue;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "9c5911294e0ba71aefe4763731b0e780cde9d0ca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3055. Fixed ResourceManager\u0027s DelegationTokenRenewer to not stop token renewal of applications part of a bigger workflow. Contributed by Daryn Sharp.\n",
      "commitDate": "09/04/15 1:08 PM",
      "commitName": "9c5911294e0ba71aefe4763731b0e780cde9d0ca",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/03/15 10:45 AM",
      "commitNameOld": "6ca1f12024fd7cec7b01df0f039ca59f3f365dc1",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 17.1,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,69 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n \n         DelegationTokenToRenew dttr \u003d allTokens.get(token);\n-        if (dttr !\u003d null) {\n-          // If any of the jobs sharing the same token doesn\u0027t want to cancel\n-          // the token, we should not cancel the token.\n-          if (!evt.shouldCancelAtEnd) {\n-            dttr.shouldCancelAtEnd \u003d evt.shouldCancelAtEnd;\n-            LOG.info(\"Set shouldCancelAtEnd\u003d\" + shouldCancelAtEnd\n-                + \" for token \" + dttr.token);\n+        if (dttr \u003d\u003d null) {\n+          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n+              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n+          try {\n+            renewToken(dttr);\n+          } catch (IOException ioe) {\n+            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n           }\n-          continue;\n         }\n-\n-        tokenList.add(new DelegationTokenToRenew(applicationId, token,\n-          getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n+        tokenList.add(dttr);\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n-        try {\n-          renewToken(dtr);\n-        } catch (IOException ioe) {\n-          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n+        DelegationTokenToRenew currentDtr \u003d\n+            allTokens.putIfAbsent(dtr.token, dtr);\n+        if (currentDtr !\u003d null) {\n+          // another job beat us\n+          currentDtr.referringAppIds.add(applicationId);\n+          appTokens.get(applicationId).add(currentDtr);\n+        } else {\n+          appTokens.get(applicationId).add(dtr);\n+          setTimerForTokenRenewal(dtr);\n         }\n       }\n-      for (DelegationTokenToRenew dtr : tokenList) {\n-        appTokens.get(applicationId).add(dtr);\n-        allTokens.put(dtr.token, dtr);\n-        setTimerForTokenRenewal(dtr);\n-      }\n     }\n \n     if (!hasHdfsToken) {\n-      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n+      requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr \u003d\u003d null) {\n          dttr \u003d new DelegationTokenToRenew(Arrays.asList(applicationId), token,\n              getConfig(), now, shouldCancelAtEnd, evt.getUser());\n          try {\n            renewToken(dttr);\n          } catch (IOException ioe) {\n            throw new IOException(\"Failed to renew token: \" + dttr.token, ioe);\n          }\n        }\n        tokenList.add(dttr);\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        DelegationTokenToRenew currentDtr \u003d\n            allTokens.putIfAbsent(dtr.token, dtr);\n        if (currentDtr !\u003d null) {\n          // another job beat us\n          currentDtr.referringAppIds.add(applicationId);\n          appTokens.get(applicationId).add(currentDtr);\n        } else {\n          appTokens.get(applicationId).add(dtr);\n          setTimerForTokenRenewal(dtr);\n        }\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(Arrays.asList(applicationId), evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "0402bada1989258ecbfdc437cb339322a1f55a97": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2964. RM prematurely cancels tokens for jobs that submit jobs (oozie). Contributed by Jian He\n",
      "commitDate": "18/12/14 3:28 PM",
      "commitName": "0402bada1989258ecbfdc437cb339322a1f55a97",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "17/12/14 5:40 PM",
      "commitNameOld": "2b4b0e8847048850206f091c6870a02e08cfe836",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,72 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n       throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     appTokens.put(applicationId,\n       Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n     Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n     boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n-        tokenList.add(new DelegationTokenToRenew(applicationId,\n-            token, getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n         if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n           LOG.info(applicationId + \" found existing hdfs token \" + token);\n           hasHdfsToken \u003d true;\n         }\n+\n+        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n+        if (dttr !\u003d null) {\n+          // If any of the jobs sharing the same token doesn\u0027t want to cancel\n+          // the token, we should not cancel the token.\n+          if (!evt.shouldCancelAtEnd) {\n+            dttr.shouldCancelAtEnd \u003d evt.shouldCancelAtEnd;\n+            LOG.info(\"Set shouldCancelAtEnd\u003d\" + shouldCancelAtEnd\n+                + \" for token \" + dttr.token);\n+          }\n+          continue;\n+        }\n+\n+        tokenList.add(new DelegationTokenToRenew(applicationId, token,\n+          getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n       }\n     }\n \n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         try {\n           renewToken(dtr);\n         } catch (IOException ioe) {\n           throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n         }\n       }\n       for (DelegationTokenToRenew dtr : tokenList) {\n         appTokens.get(applicationId).add(dtr);\n+        allTokens.put(dtr.token, dtr);\n         setTimerForTokenRenewal(dtr);\n       }\n     }\n \n     if (!hasHdfsToken) {\n       requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n         shouldCancelAtEnd);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n\n        DelegationTokenToRenew dttr \u003d allTokens.get(token);\n        if (dttr !\u003d null) {\n          // If any of the jobs sharing the same token doesn\u0027t want to cancel\n          // the token, we should not cancel the token.\n          if (!evt.shouldCancelAtEnd) {\n            dttr.shouldCancelAtEnd \u003d evt.shouldCancelAtEnd;\n            LOG.info(\"Set shouldCancelAtEnd\u003d\" + shouldCancelAtEnd\n                + \" for token \" + dttr.token);\n          }\n          continue;\n        }\n\n        tokenList.add(new DelegationTokenToRenew(applicationId, token,\n          getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        try {\n          renewToken(dtr);\n        } catch (IOException ioe) {\n          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n        }\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        appTokens.get(applicationId).add(dtr);\n        allTokens.put(dtr.token, dtr);\n        setTimerForTokenRenewal(dtr);\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
          "commitDate": "27/10/14 3:49 PM",
          "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "29/08/14 11:16 AM",
          "commitNameOld": "3de66011c2e80d7c458a67f80042af986fcc677d",
          "commitAuthorOld": "Hitesh Shah",
          "daysBetweenCommits": 59.19,
          "commitsBetweenForRepo": 586,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,58 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n-      throws IOException {\n+      throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n-    List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n-        new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n+    appTokens.put(applicationId,\n+      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n+    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n+    boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         tokenList.add(new DelegationTokenToRenew(applicationId,\n-            token, getConfig(), now, shouldCancelAtEnd));\n+            token, getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n+        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n+          LOG.info(applicationId + \" found existing hdfs token \" + token);\n+          hasHdfsToken \u003d true;\n+        }\n       }\n     }\n+\n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         try {\n           renewToken(dtr);\n         } catch (IOException ioe) {\n           throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n         }\n       }\n       for (DelegationTokenToRenew dtr : tokenList) {\n-        addTokenToList(dtr);\n+        appTokens.get(applicationId).add(dtr);\n         setTimerForTokenRenewal(dtr);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n-              + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n-        }\n       }\n     }\n+\n+    if (!hasHdfsToken) {\n+      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n+        shouldCancelAtEnd);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        tokenList.add(new DelegationTokenToRenew(applicationId,\n            token, getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        try {\n          renewToken(dtr);\n        } catch (IOException ioe) {\n          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n        }\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        appTokens.get(applicationId).add(dtr);\n        setTimerForTokenRenewal(dtr);\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
          "commitDate": "27/10/14 3:49 PM",
          "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "29/08/14 11:16 AM",
          "commitNameOld": "3de66011c2e80d7c458a67f80042af986fcc677d",
          "commitAuthorOld": "Hitesh Shah",
          "daysBetweenCommits": 59.19,
          "commitsBetweenForRepo": 586,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,58 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n-      throws IOException {\n+      throws IOException, InterruptedException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n-    List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n-        new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n+    appTokens.put(applicationId,\n+      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n+    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n+    boolean hasHdfsToken \u003d false;\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         tokenList.add(new DelegationTokenToRenew(applicationId,\n-            token, getConfig(), now, shouldCancelAtEnd));\n+            token, getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n+        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n+          LOG.info(applicationId + \" found existing hdfs token \" + token);\n+          hasHdfsToken \u003d true;\n+        }\n       }\n     }\n+\n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n         try {\n           renewToken(dtr);\n         } catch (IOException ioe) {\n           throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n         }\n       }\n       for (DelegationTokenToRenew dtr : tokenList) {\n-        addTokenToList(dtr);\n+        appTokens.get(applicationId).add(dtr);\n         setTimerForTokenRenewal(dtr);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n-              + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n-        }\n       }\n     }\n+\n+    if (!hasHdfsToken) {\n+      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n+        shouldCancelAtEnd);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException, InterruptedException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    appTokens.put(applicationId,\n      Collections.synchronizedSet(new HashSet\u003cDelegationTokenToRenew\u003e()));\n    Set\u003cDelegationTokenToRenew\u003e tokenList \u003d new HashSet\u003cDelegationTokenToRenew\u003e();\n    boolean hasHdfsToken \u003d false;\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        tokenList.add(new DelegationTokenToRenew(applicationId,\n            token, getConfig(), now, shouldCancelAtEnd, evt.getUser()));\n        if (token.getKind().equals(new Text(\"HDFS_DELEGATION_TOKEN\"))) {\n          LOG.info(applicationId + \" found existing hdfs token \" + token);\n          hasHdfsToken \u003d true;\n        }\n      }\n    }\n\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        try {\n          renewToken(dtr);\n        } catch (IOException ioe) {\n          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n        }\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        appTokens.get(applicationId).add(dtr);\n        setTimerForTokenRenewal(dtr);\n      }\n    }\n\n    if (!hasHdfsToken) {\n      requestNewHdfsDelegationToken(applicationId, evt.getUser(),\n        shouldCancelAtEnd);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
          "extendedDetails": {}
        }
      ]
    },
    "28fca92521b04e9d9b6f4d095c593282a06e0a36": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2147. client lacks delegation token exception details when application submit fails. Contributed by Chen He\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612950 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/14 2:40 PM",
      "commitName": "28fca92521b04e9d9b6f4d095c593282a06e0a36",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "25/03/14 11:21 AM",
      "commitNameOld": "d14eff7d3896b75d4da10fcfff15c42fcca48f7c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 120.14,
      "commitsBetweenForRepo": 753,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,50 @@\n   private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n       throws IOException {\n     ApplicationId applicationId \u003d evt.getApplicationId();\n     Credentials ts \u003d evt.getCredentials();\n     boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n     if (ts \u003d\u003d null) {\n       return; // nothing to add\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Registering tokens for renewal for:\" +\n           \" appId \u003d \" + applicationId);\n     }\n \n     Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n     long now \u003d System.currentTimeMillis();\n \n     // find tokens for renewal, but don\u0027t add timers until we know\n     // all renewable tokens are valid\n     // At RM restart it is safe to assume that all the previously added tokens\n     // are valid\n     List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n         new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n     for (Token\u003c?\u003e token : tokens) {\n       if (token.isManaged()) {\n         tokenList.add(new DelegationTokenToRenew(applicationId,\n             token, getConfig(), now, shouldCancelAtEnd));\n       }\n     }\n     if (!tokenList.isEmpty()) {\n       // Renewing token and adding it to timer calls are separated purposefully\n       // If user provides incorrect token then it should not be added for\n       // renewal.\n       for (DelegationTokenToRenew dtr : tokenList) {\n-        renewToken(dtr);\n+        try {\n+          renewToken(dtr);\n+        } catch (IOException ioe) {\n+          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n+        }\n       }\n       for (DelegationTokenToRenew dtr : tokenList) {\n         addTokenToList(dtr);\n         setTimerForTokenRenewal(dtr);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n               + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n        new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        tokenList.add(new DelegationTokenToRenew(applicationId,\n            token, getConfig(), now, shouldCancelAtEnd));\n      }\n    }\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        try {\n          renewToken(dtr);\n        } catch (IOException ioe) {\n          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n        }\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        addTokenToList(dtr);\n        setTimerForTokenRenewal(dtr);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n              + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java",
      "extendedDetails": {}
    },
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": {
      "type": "Yintroduced",
      "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:20 PM",
      "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,46 @@\n+  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n+      throws IOException {\n+    ApplicationId applicationId \u003d evt.getApplicationId();\n+    Credentials ts \u003d evt.getCredentials();\n+    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n+    if (ts \u003d\u003d null) {\n+      return; // nothing to add\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Registering tokens for renewal for:\" +\n+          \" appId \u003d \" + applicationId);\n+    }\n+\n+    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n+    long now \u003d System.currentTimeMillis();\n+\n+    // find tokens for renewal, but don\u0027t add timers until we know\n+    // all renewable tokens are valid\n+    // At RM restart it is safe to assume that all the previously added tokens\n+    // are valid\n+    List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n+        new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n+    for (Token\u003c?\u003e token : tokens) {\n+      if (token.isManaged()) {\n+        tokenList.add(new DelegationTokenToRenew(applicationId,\n+            token, getConfig(), now, shouldCancelAtEnd));\n+      }\n+    }\n+    if (!tokenList.isEmpty()) {\n+      // Renewing token and adding it to timer calls are separated purposefully\n+      // If user provides incorrect token then it should not be added for\n+      // renewal.\n+      for (DelegationTokenToRenew dtr : tokenList) {\n+        renewToken(dtr);\n+      }\n+      for (DelegationTokenToRenew dtr : tokenList) {\n+        addTokenToList(dtr);\n+        setTimerForTokenRenewal(dtr);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n+              + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException {\n    ApplicationId applicationId \u003d evt.getApplicationId();\n    Credentials ts \u003d evt.getCredentials();\n    boolean shouldCancelAtEnd \u003d evt.shouldCancelAtEnd();\n    if (ts \u003d\u003d null) {\n      return; // nothing to add\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId \u003d \" + applicationId);\n    }\n\n    Collection\u003cToken\u003c?\u003e\u003e tokens \u003d ts.getAllTokens();\n    long now \u003d System.currentTimeMillis();\n\n    // find tokens for renewal, but don\u0027t add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    List\u003cDelegationTokenToRenew\u003e tokenList \u003d\n        new ArrayList\u003cDelegationTokenRenewer.DelegationTokenToRenew\u003e();\n    for (Token\u003c?\u003e token : tokens) {\n      if (token.isManaged()) {\n        tokenList.add(new DelegationTokenToRenew(applicationId,\n            token, getConfig(), now, shouldCancelAtEnd));\n      }\n    }\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        renewToken(dtr);\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        addTokenToList(dtr);\n        setTimerForTokenRenewal(dtr);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Registering token for renewal for:\" + \" service \u003d \"\n              + dtr.token.getService() + \" for appId \u003d \" + dtr.applicationId);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/DelegationTokenRenewer.java"
    }
  }
}