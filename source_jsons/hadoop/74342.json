{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslRpcClient.java",
  "functionName": "saslConnect",
  "functionId": "saslConnect___ipcStreams-IpcStreams",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
  "functionStartLine": 358,
  "functionEndLine": 448,
  "numCommitsSeen": 61,
  "timeTaken": 3229,
  "changeHistory": [
    "d4d076876a8d0002bd3a73491d8459d11cb4896c",
    "23abb09c1f979d8c18ece81e32630a35ed569399",
    "2f4b6d1157f280c8a6e1b2e7217fd2ec16991985",
    "c6ba793b65014306ec1ff40c61938399412e72c1",
    "65be21267587f04a2c33af65b951211cc9085b15",
    "5f9b4c14a175873b4f82654513e289c657c694eb",
    "9550b1a78bd430ad151fc481987369014a04394d",
    "fe8f635b78d59e286771ec75ff73245b40d30907",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
    "940389afce6a1b9b9e1519aed528cbc444786756"
  ],
  "changeHistoryShort": {
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": "Ymultichange(Yparameterchange,Ybodychange)",
    "23abb09c1f979d8c18ece81e32630a35ed569399": "Ybodychange",
    "2f4b6d1157f280c8a6e1b2e7217fd2ec16991985": "Ybodychange",
    "c6ba793b65014306ec1ff40c61938399412e72c1": "Ybodychange",
    "65be21267587f04a2c33af65b951211cc9085b15": "Ymultichange(Yreturntypechange,Ybodychange)",
    "5f9b4c14a175873b4f82654513e289c657c694eb": "Ybodychange",
    "9550b1a78bd430ad151fc481987369014a04394d": "Ybodychange",
    "fe8f635b78d59e286771ec75ff73245b40d30907": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": "Ybodychange",
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": "Ymultichange(Yreturntypechange,Ybodychange)",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d4d076876a8d0002bd3a73491d8459d11cb4896c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-10940. RPC client does no bounds checking of responses. Contributed by Daryn Sharp.\n",
      "commitDate": "09/09/16 8:39 AM",
      "commitName": "d4d076876a8d0002bd3a73491d8459d11cb4896c",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-10940. RPC client does no bounds checking of responses. Contributed by Daryn Sharp.\n",
          "commitDate": "09/09/16 8:39 AM",
          "commitName": "d4d076876a8d0002bd3a73491d8459d11cb4896c",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "02/09/16 9:03 AM",
          "commitNameOld": "23abb09c1f979d8c18ece81e32630a35ed569399",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 6.98,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,91 @@\n-  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n-      throws IOException {\n-    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n-    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n-        outS));\n-    \n+  public AuthMethod saslConnect(IpcStreams ipcStreams) throws IOException {\n     // redefined if/when a SASL negotiation starts, can be queried if the\n     // negotiation fails\n     authMethod \u003d AuthMethod.SIMPLE;\n \n-    sendSaslMessage(outStream, negotiateRequest);\n-\n+    sendSaslMessage(ipcStreams.out, negotiateRequest);\n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n-      int rpcLen \u003d inStream.readInt();\n-      ByteBuffer bb \u003d ByteBuffer.allocate(rpcLen);\n-      inStream.readFully(bb.array());\n+      ByteBuffer bb \u003d ipcStreams.readResponse();\n \n       RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n       RpcResponseHeaderProto header \u003d\n           saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n       if (saslPacket.remaining() \u003e 0) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n           // create a compatible SASL client, throws if no supported auths\n           SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n           // define auth being attempted, caller can query if connect fails\n           authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n           \n           byte[] responseToken \u003d null;\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n             done \u003d true; // not going to wait for success ack\n           } else {\n             byte[] challengeToken \u003d null;\n             if (saslAuthType.hasChallenge()) {\n               // server provided the first challenge\n               challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n               saslAuthType \u003d\n                   SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n             } else if (saslClient.hasInitialResponse()) {\n               challengeToken \u003d new byte[0];\n             }\n             responseToken \u003d (challengeToken !\u003d null)\n                 ? saslClient.evaluateChallenge(challengeToken)\n                     : new byte[0];\n           }\n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n           if (saslClient \u003d\u003d null) {\n             // should probably instantiate a client to allow a server to\n             // demand a specific negotiation\n             throw new SaslException(\"Server sent unsolicited challenge\");\n           }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n           // simple server sends immediate success to a SASL client for\n           // switch to simple\n           if (saslClient \u003d\u003d null) {\n             authMethod \u003d AuthMethod.SIMPLE;\n           } else {\n             saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n-        sendSaslMessage(outStream, response.build());\n+        sendSaslMessage(ipcStreams.out, response.build());\n       }\n     } while (!done);\n     return authMethod;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AuthMethod saslConnect(IpcStreams ipcStreams) throws IOException {\n    // redefined if/when a SASL negotiation starts, can be queried if the\n    // negotiation fails\n    authMethod \u003d AuthMethod.SIMPLE;\n\n    sendSaslMessage(ipcStreams.out, negotiateRequest);\n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      ByteBuffer bb \u003d ipcStreams.readResponse();\n\n      RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n      RpcResponseHeaderProto header \u003d\n          saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n      if (saslPacket.remaining() \u003e 0) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          // define auth being attempted, caller can query if connect fails\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(ipcStreams.out, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {
            "oldValue": "[inS-InputStream, outS-OutputStream]",
            "newValue": "[ipcStreams-IpcStreams]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10940. RPC client does no bounds checking of responses. Contributed by Daryn Sharp.\n",
          "commitDate": "09/09/16 8:39 AM",
          "commitName": "d4d076876a8d0002bd3a73491d8459d11cb4896c",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "02/09/16 9:03 AM",
          "commitNameOld": "23abb09c1f979d8c18ece81e32630a35ed569399",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 6.98,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,91 @@\n-  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n-      throws IOException {\n-    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n-    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n-        outS));\n-    \n+  public AuthMethod saslConnect(IpcStreams ipcStreams) throws IOException {\n     // redefined if/when a SASL negotiation starts, can be queried if the\n     // negotiation fails\n     authMethod \u003d AuthMethod.SIMPLE;\n \n-    sendSaslMessage(outStream, negotiateRequest);\n-\n+    sendSaslMessage(ipcStreams.out, negotiateRequest);\n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n-      int rpcLen \u003d inStream.readInt();\n-      ByteBuffer bb \u003d ByteBuffer.allocate(rpcLen);\n-      inStream.readFully(bb.array());\n+      ByteBuffer bb \u003d ipcStreams.readResponse();\n \n       RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n       RpcResponseHeaderProto header \u003d\n           saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n       if (saslPacket.remaining() \u003e 0) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n           // create a compatible SASL client, throws if no supported auths\n           SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n           // define auth being attempted, caller can query if connect fails\n           authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n           \n           byte[] responseToken \u003d null;\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n             done \u003d true; // not going to wait for success ack\n           } else {\n             byte[] challengeToken \u003d null;\n             if (saslAuthType.hasChallenge()) {\n               // server provided the first challenge\n               challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n               saslAuthType \u003d\n                   SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n             } else if (saslClient.hasInitialResponse()) {\n               challengeToken \u003d new byte[0];\n             }\n             responseToken \u003d (challengeToken !\u003d null)\n                 ? saslClient.evaluateChallenge(challengeToken)\n                     : new byte[0];\n           }\n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n           if (saslClient \u003d\u003d null) {\n             // should probably instantiate a client to allow a server to\n             // demand a specific negotiation\n             throw new SaslException(\"Server sent unsolicited challenge\");\n           }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n           // simple server sends immediate success to a SASL client for\n           // switch to simple\n           if (saslClient \u003d\u003d null) {\n             authMethod \u003d AuthMethod.SIMPLE;\n           } else {\n             saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n-        sendSaslMessage(outStream, response.build());\n+        sendSaslMessage(ipcStreams.out, response.build());\n       }\n     } while (!done);\n     return authMethod;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AuthMethod saslConnect(IpcStreams ipcStreams) throws IOException {\n    // redefined if/when a SASL negotiation starts, can be queried if the\n    // negotiation fails\n    authMethod \u003d AuthMethod.SIMPLE;\n\n    sendSaslMessage(ipcStreams.out, negotiateRequest);\n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      ByteBuffer bb \u003d ipcStreams.readResponse();\n\n      RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n      RpcResponseHeaderProto header \u003d\n          saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n      if (saslPacket.remaining() \u003e 0) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          // define auth being attempted, caller can query if connect fails\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(ipcStreams.out, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "23abb09c1f979d8c18ece81e32630a35ed569399": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13547. Optimize IPC client protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "02/09/16 9:03 AM",
      "commitName": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "18/08/16 2:55 PM",
      "commitNameOld": "c5c3e81b49ae6ef0cf9022f90f3709166aa4488d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 14.76,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,99 @@\n   public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n     \n     // redefined if/when a SASL negotiation starts, can be queried if the\n     // negotiation fails\n     authMethod \u003d AuthMethod.SIMPLE;\n \n     sendSaslMessage(outStream, negotiateRequest);\n \n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n-      int totalLen \u003d inStream.readInt();\n-      RpcResponseMessageWrapper responseWrapper \u003d\n-          new RpcResponseMessageWrapper();\n-      responseWrapper.readFields(inStream);\n-      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n+      int rpcLen \u003d inStream.readInt();\n+      ByteBuffer bb \u003d ByteBuffer.allocate(rpcLen);\n+      inStream.readFully(bb.array());\n+\n+      RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n+      RpcResponseHeaderProto header \u003d\n+          saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n-      if (totalLen !\u003d responseWrapper.getLength()) {\n-        throw new SaslException(\"Received malformed response length\");\n-      }\n-      \n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n-          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n+          saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n+      if (saslPacket.remaining() \u003e 0) {\n+        throw new SaslException(\"Received malformed response length\");\n+      }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n           // create a compatible SASL client, throws if no supported auths\n           SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n           // define auth being attempted, caller can query if connect fails\n           authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n           \n           byte[] responseToken \u003d null;\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n             done \u003d true; // not going to wait for success ack\n           } else {\n             byte[] challengeToken \u003d null;\n             if (saslAuthType.hasChallenge()) {\n               // server provided the first challenge\n               challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n               saslAuthType \u003d\n                   SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n             } else if (saslClient.hasInitialResponse()) {\n               challengeToken \u003d new byte[0];\n             }\n             responseToken \u003d (challengeToken !\u003d null)\n                 ? saslClient.evaluateChallenge(challengeToken)\n                     : new byte[0];\n           }\n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n           if (saslClient \u003d\u003d null) {\n             // should probably instantiate a client to allow a server to\n             // demand a specific negotiation\n             throw new SaslException(\"Server sent unsolicited challenge\");\n           }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n           // simple server sends immediate success to a SASL client for\n           // switch to simple\n           if (saslClient \u003d\u003d null) {\n             authMethod \u003d AuthMethod.SIMPLE;\n           } else {\n             saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n         sendSaslMessage(outStream, response.build());\n       }\n     } while (!done);\n     return authMethod;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // redefined if/when a SASL negotiation starts, can be queried if the\n    // negotiation fails\n    authMethod \u003d AuthMethod.SIMPLE;\n\n    sendSaslMessage(outStream, negotiateRequest);\n\n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int rpcLen \u003d inStream.readInt();\n      ByteBuffer bb \u003d ByteBuffer.allocate(rpcLen);\n      inStream.readFully(bb.array());\n\n      RpcWritable.Buffer saslPacket \u003d RpcWritable.Buffer.wrap(bb);\n      RpcResponseHeaderProto header \u003d\n          saslPacket.getValue(RpcResponseHeaderProto.getDefaultInstance());\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          saslPacket.getValue(RpcSaslProto.getDefaultInstance());\n      if (saslPacket.remaining() \u003e 0) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          // define auth being attempted, caller can query if connect fails\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "2f4b6d1157f280c8a6e1b2e7217fd2ec16991985": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11962. Sasl message with MD5 challenge text shouldn\u0027t be LOG out even in debug level. Contributed by Junping Du.\n",
      "commitDate": "12/05/15 10:30 AM",
      "commitName": "2f4b6d1157f280c8a6e1b2e7217fd2ec16991985",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/02/15 10:34 AM",
      "commitNameOld": "3472e3bd6c50558870b86c9ccfea5072385fa991",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 98.96,
      "commitsBetweenForRepo": 1001,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,98 @@\n   public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n     \n     // redefined if/when a SASL negotiation starts, can be queried if the\n     // negotiation fails\n     authMethod \u003d AuthMethod.SIMPLE;\n     \n     sendSaslMessage(outStream, negotiateRequest);\n     \n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n       int totalLen \u003d inStream.readInt();\n       RpcResponseMessageWrapper responseWrapper \u003d\n           new RpcResponseMessageWrapper();\n       responseWrapper.readFields(inStream);\n       RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (totalLen !\u003d responseWrapper.getLength()) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       \n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Received SASL message \"+saslMessage);\n-      }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n           // create a compatible SASL client, throws if no supported auths\n           SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n           // define auth being attempted, caller can query if connect fails\n           authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n           \n           byte[] responseToken \u003d null;\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n             done \u003d true; // not going to wait for success ack\n           } else {\n             byte[] challengeToken \u003d null;\n             if (saslAuthType.hasChallenge()) {\n               // server provided the first challenge\n               challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n               saslAuthType \u003d\n                   SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n             } else if (saslClient.hasInitialResponse()) {\n               challengeToken \u003d new byte[0];\n             }\n             responseToken \u003d (challengeToken !\u003d null)\n                 ? saslClient.evaluateChallenge(challengeToken)\n                     : new byte[0];\n           }\n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n           if (saslClient \u003d\u003d null) {\n             // should probably instantiate a client to allow a server to\n             // demand a specific negotiation\n             throw new SaslException(\"Server sent unsolicited challenge\");\n           }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n           // simple server sends immediate success to a SASL client for\n           // switch to simple\n           if (saslClient \u003d\u003d null) {\n             authMethod \u003d AuthMethod.SIMPLE;\n           } else {\n             saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n         sendSaslMessage(outStream, response.build());\n       }\n     } while (!done);\n     return authMethod;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // redefined if/when a SASL negotiation starts, can be queried if the\n    // negotiation fails\n    authMethod \u003d AuthMethod.SIMPLE;\n    \n    sendSaslMessage(outStream, negotiateRequest);\n    \n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int totalLen \u003d inStream.readInt();\n      RpcResponseMessageWrapper responseWrapper \u003d\n          new RpcResponseMessageWrapper();\n      responseWrapper.readFields(inStream);\n      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (totalLen !\u003d responseWrapper.getLength()) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      \n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          // define auth being attempted, caller can query if connect fails\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "c6ba793b65014306ec1ff40c61938399412e72c1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9850. RPC kerberos errors don\u0027t trigger relogin. Contributed by Daryn Sharp.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1511823 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 8:03 AM",
      "commitName": "c6ba793b65014306ec1ff40c61938399412e72c1",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "05/08/13 3:02 PM",
      "commitNameOld": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,101 @@\n   public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n     \n-    // redefined if/when a SASL negotiation completes\n-    AuthMethod authMethod \u003d AuthMethod.SIMPLE;\n+    // redefined if/when a SASL negotiation starts, can be queried if the\n+    // negotiation fails\n+    authMethod \u003d AuthMethod.SIMPLE;\n     \n     sendSaslMessage(outStream, negotiateRequest);\n     \n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n       int totalLen \u003d inStream.readInt();\n       RpcResponseMessageWrapper responseWrapper \u003d\n           new RpcResponseMessageWrapper();\n       responseWrapper.readFields(inStream);\n       RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (totalLen !\u003d responseWrapper.getLength()) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       \n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Received SASL message \"+saslMessage);\n       }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n           // create a compatible SASL client, throws if no supported auths\n           SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n+          // define auth being attempted, caller can query if connect fails\n           authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n           \n           byte[] responseToken \u003d null;\n           if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n             done \u003d true; // not going to wait for success ack\n           } else {\n             byte[] challengeToken \u003d null;\n             if (saslAuthType.hasChallenge()) {\n               // server provided the first challenge\n               challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n               saslAuthType \u003d\n                   SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n             } else if (saslClient.hasInitialResponse()) {\n               challengeToken \u003d new byte[0];\n             }\n             responseToken \u003d (challengeToken !\u003d null)\n                 ? saslClient.evaluateChallenge(challengeToken)\n                     : new byte[0];\n           }\n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n           if (saslClient \u003d\u003d null) {\n             // should probably instantiate a client to allow a server to\n             // demand a specific negotiation\n             throw new SaslException(\"Server sent unsolicited challenge\");\n           }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n           // simple server sends immediate success to a SASL client for\n           // switch to simple\n           if (saslClient \u003d\u003d null) {\n             authMethod \u003d AuthMethod.SIMPLE;\n           } else {\n             saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n         sendSaslMessage(outStream, response.build());\n       }\n     } while (!done);\n     return authMethod;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // redefined if/when a SASL negotiation starts, can be queried if the\n    // negotiation fails\n    authMethod \u003d AuthMethod.SIMPLE;\n    \n    sendSaslMessage(outStream, negotiateRequest);\n    \n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int totalLen \u003d inStream.readInt();\n      RpcResponseMessageWrapper responseWrapper \u003d\n          new RpcResponseMessageWrapper();\n      responseWrapper.readFields(inStream);\n      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (totalLen !\u003d responseWrapper.getLength()) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      \n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received SASL message \"+saslMessage);\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          // define auth being attempted, caller can query if connect fails\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/13 7:44 AM",
          "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "18/07/13 4:44 PM",
          "commitNameOld": "8724ceb2359af66c800043e665c17a2a30981c7d",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 10.63,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,99 @@\n-  public boolean saslConnect(InputStream inS, OutputStream outS)\n+  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n     \n-    // track if SASL ever started, or server switched us to simple\n-    boolean inSasl \u003d false;\n+    // redefined if/when a SASL negotiation completes\n+    AuthMethod authMethod \u003d AuthMethod.SIMPLE;\n+    \n     sendSaslMessage(outStream, negotiateRequest);\n     \n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n       int totalLen \u003d inStream.readInt();\n       RpcResponseMessageWrapper responseWrapper \u003d\n           new RpcResponseMessageWrapper();\n       responseWrapper.readFields(inStream);\n       RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (totalLen !\u003d responseWrapper.getLength()) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       \n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Received SASL message \"+saslMessage);\n       }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n-          inSasl \u003d true;\n-          // TODO: should instantiate sasl client based on advertisement\n-          // but just blindly use the pre-instantiated sasl client for now\n-          String clientAuthMethod \u003d authMethod.toString();\n-          SaslAuth saslAuthType \u003d null;\n-          for (SaslAuth authType : saslMessage.getAuthsList()) {\n-            if (clientAuthMethod.equals(authType.getMethod())) {\n-              saslAuthType \u003d authType;\n-              break;\n+          // create a compatible SASL client, throws if no supported auths\n+          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n+          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n+          \n+          byte[] responseToken \u003d null;\n+          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n+            done \u003d true; // not going to wait for success ack\n+          } else {\n+            byte[] challengeToken \u003d null;\n+            if (saslAuthType.hasChallenge()) {\n+              // server provided the first challenge\n+              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n+              saslAuthType \u003d\n+                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n+            } else if (saslClient.hasInitialResponse()) {\n+              challengeToken \u003d new byte[0];\n             }\n+            responseToken \u003d (challengeToken !\u003d null)\n+                ? saslClient.evaluateChallenge(challengeToken)\n+                    : new byte[0];\n           }\n-          if (saslAuthType \u003d\u003d null) {\n-            saslAuthType \u003d SaslAuth.newBuilder()\n-                .setMethod(clientAuthMethod)\n-                .setMechanism(saslClient.getMechanismName())\n-                .build();\n-          }\n-          \n-          byte[] challengeToken \u003d null;\n-          if (saslAuthType !\u003d null \u0026\u0026 saslAuthType.hasChallenge()) {\n-            // server provided the first challenge\n-            challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n-            saslAuthType \u003d\n-              SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n-          } else if (saslClient.hasInitialResponse()) {\n-            challengeToken \u003d new byte[0];\n-          }\n-          byte[] responseToken \u003d (challengeToken !\u003d null)\n-              ? saslClient.evaluateChallenge(challengeToken)\n-              : new byte[0];\n-          \n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n-          inSasl \u003d true;\n+          if (saslClient \u003d\u003d null) {\n+            // should probably instantiate a client to allow a server to\n+            // demand a specific negotiation\n+            throw new SaslException(\"Server sent unsolicited challenge\");\n+          }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n-          if (inSasl \u0026\u0026 saslEvaluateToken(saslMessage, true) !\u003d null) {\n-            throw new SaslException(\"SASL client generated spurious token\");\n+          // simple server sends immediate success to a SASL client for\n+          // switch to simple\n+          if (saslClient \u003d\u003d null) {\n+            authMethod \u003d AuthMethod.SIMPLE;\n+          } else {\n+            saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n         sendSaslMessage(outStream, response.build());\n       }\n     } while (!done);\n-    if (!inSasl \u0026\u0026 !fallbackAllowed) {\n-      throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n-          \"auth, but this client is configured to only allow secure \" +\n-          \"connections.\");\n-    }\n-    return inSasl;\n+    return authMethod;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // redefined if/when a SASL negotiation completes\n    AuthMethod authMethod \u003d AuthMethod.SIMPLE;\n    \n    sendSaslMessage(outStream, negotiateRequest);\n    \n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int totalLen \u003d inStream.readInt();\n      RpcResponseMessageWrapper responseWrapper \u003d\n          new RpcResponseMessageWrapper();\n      responseWrapper.readFields(inStream);\n      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (totalLen !\u003d responseWrapper.getLength()) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      \n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received SASL message \"+saslMessage);\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "AuthMethod"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/13 7:44 AM",
          "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "18/07/13 4:44 PM",
          "commitNameOld": "8724ceb2359af66c800043e665c17a2a30981c7d",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 10.63,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,99 @@\n-  public boolean saslConnect(InputStream inS, OutputStream outS)\n+  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n     \n-    // track if SASL ever started, or server switched us to simple\n-    boolean inSasl \u003d false;\n+    // redefined if/when a SASL negotiation completes\n+    AuthMethod authMethod \u003d AuthMethod.SIMPLE;\n+    \n     sendSaslMessage(outStream, negotiateRequest);\n     \n     // loop until sasl is complete or a rpc error occurs\n     boolean done \u003d false;\n     do {\n       int totalLen \u003d inStream.readInt();\n       RpcResponseMessageWrapper responseWrapper \u003d\n           new RpcResponseMessageWrapper();\n       responseWrapper.readFields(inStream);\n       RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n       switch (header.getStatus()) {\n         case ERROR: // might get a RPC error during \n         case FATAL:\n           throw new RemoteException(header.getExceptionClassName(),\n                                     header.getErrorMsg());\n         default: break;\n       }\n       if (totalLen !\u003d responseWrapper.getLength()) {\n         throw new SaslException(\"Received malformed response length\");\n       }\n       \n       if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n         throw new SaslException(\"Non-SASL response during negotiation\");\n       }\n       RpcSaslProto saslMessage \u003d\n           RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Received SASL message \"+saslMessage);\n       }\n       // handle sasl negotiation process\n       RpcSaslProto.Builder response \u003d null;\n       switch (saslMessage.getState()) {\n         case NEGOTIATE: {\n-          inSasl \u003d true;\n-          // TODO: should instantiate sasl client based on advertisement\n-          // but just blindly use the pre-instantiated sasl client for now\n-          String clientAuthMethod \u003d authMethod.toString();\n-          SaslAuth saslAuthType \u003d null;\n-          for (SaslAuth authType : saslMessage.getAuthsList()) {\n-            if (clientAuthMethod.equals(authType.getMethod())) {\n-              saslAuthType \u003d authType;\n-              break;\n+          // create a compatible SASL client, throws if no supported auths\n+          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n+          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n+          \n+          byte[] responseToken \u003d null;\n+          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n+            done \u003d true; // not going to wait for success ack\n+          } else {\n+            byte[] challengeToken \u003d null;\n+            if (saslAuthType.hasChallenge()) {\n+              // server provided the first challenge\n+              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n+              saslAuthType \u003d\n+                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n+            } else if (saslClient.hasInitialResponse()) {\n+              challengeToken \u003d new byte[0];\n             }\n+            responseToken \u003d (challengeToken !\u003d null)\n+                ? saslClient.evaluateChallenge(challengeToken)\n+                    : new byte[0];\n           }\n-          if (saslAuthType \u003d\u003d null) {\n-            saslAuthType \u003d SaslAuth.newBuilder()\n-                .setMethod(clientAuthMethod)\n-                .setMechanism(saslClient.getMechanismName())\n-                .build();\n-          }\n-          \n-          byte[] challengeToken \u003d null;\n-          if (saslAuthType !\u003d null \u0026\u0026 saslAuthType.hasChallenge()) {\n-            // server provided the first challenge\n-            challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n-            saslAuthType \u003d\n-              SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n-          } else if (saslClient.hasInitialResponse()) {\n-            challengeToken \u003d new byte[0];\n-          }\n-          byte[] responseToken \u003d (challengeToken !\u003d null)\n-              ? saslClient.evaluateChallenge(challengeToken)\n-              : new byte[0];\n-          \n           response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n           response.addAuths(saslAuthType);\n           break;\n         }\n         case CHALLENGE: {\n-          inSasl \u003d true;\n+          if (saslClient \u003d\u003d null) {\n+            // should probably instantiate a client to allow a server to\n+            // demand a specific negotiation\n+            throw new SaslException(\"Server sent unsolicited challenge\");\n+          }\n           byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n           response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n           break;\n         }\n         case SUCCESS: {\n-          if (inSasl \u0026\u0026 saslEvaluateToken(saslMessage, true) !\u003d null) {\n-            throw new SaslException(\"SASL client generated spurious token\");\n+          // simple server sends immediate success to a SASL client for\n+          // switch to simple\n+          if (saslClient \u003d\u003d null) {\n+            authMethod \u003d AuthMethod.SIMPLE;\n+          } else {\n+            saslEvaluateToken(saslMessage, true);\n           }\n           done \u003d true;\n           break;\n         }\n         default: {\n           throw new SaslException(\n               \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n         }\n       }\n       if (response !\u003d null) {\n         sendSaslMessage(outStream, response.build());\n       }\n     } while (!done);\n-    if (!inSasl \u0026\u0026 !fallbackAllowed) {\n-      throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n-          \"auth, but this client is configured to only allow secure \" +\n-          \"connections.\");\n-    }\n-    return inSasl;\n+    return authMethod;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AuthMethod saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // redefined if/when a SASL negotiation completes\n    AuthMethod authMethod \u003d AuthMethod.SIMPLE;\n    \n    sendSaslMessage(outStream, negotiateRequest);\n    \n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int totalLen \u003d inStream.readInt();\n      RpcResponseMessageWrapper responseWrapper \u003d\n          new RpcResponseMessageWrapper();\n      responseWrapper.readFields(inStream);\n      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (totalLen !\u003d responseWrapper.getLength()) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      \n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received SASL message \"+saslMessage);\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          // create a compatible SASL client, throws if no supported auths\n          SaslAuth saslAuthType \u003d selectSaslClient(saslMessage.getAuthsList());\n          authMethod \u003d AuthMethod.valueOf(saslAuthType.getMethod());\n          \n          byte[] responseToken \u003d null;\n          if (authMethod \u003d\u003d AuthMethod.SIMPLE) { // switching to SIMPLE\n            done \u003d true; // not going to wait for success ack\n          } else {\n            byte[] challengeToken \u003d null;\n            if (saslAuthType.hasChallenge()) {\n              // server provided the first challenge\n              challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n              saslAuthType \u003d\n                  SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n            } else if (saslClient.hasInitialResponse()) {\n              challengeToken \u003d new byte[0];\n            }\n            responseToken \u003d (challengeToken !\u003d null)\n                ? saslClient.evaluateChallenge(challengeToken)\n                    : new byte[0];\n          }\n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          if (saslClient \u003d\u003d null) {\n            // should probably instantiate a client to allow a server to\n            // demand a specific negotiation\n            throw new SaslException(\"Server sent unsolicited challenge\");\n          }\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          // simple server sends immediate success to a SASL client for\n          // switch to simple\n          if (saslClient \u003d\u003d null) {\n            authMethod \u003d AuthMethod.SIMPLE;\n          } else {\n            saslEvaluateToken(saslMessage, true);\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    return authMethod;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f9b4c14a175873b4f82654513e289c657c694eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9421. [RPC v9] Convert SASL to use ProtoBuf and provide negotiation capabilities (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495577 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/13 1:09 PM",
      "commitName": "5f9b4c14a175873b4f82654513e289c657c694eb",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "19/06/13 10:31 AM",
      "commitNameOld": "9550b1a78bd430ad151fc481987369014a04394d",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,105 @@\n   public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n-\n-    try {\n-      byte[] saslToken \u003d new byte[0];\n-      if (saslClient.hasInitialResponse())\n-        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n-      while (saslToken !\u003d null) {\n-        outStream.writeInt(saslToken.length);\n-        outStream.write(saslToken, 0, saslToken.length);\n-        outStream.flush();\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have sent token of size \" + saslToken.length\n-              + \" from initSASLContext.\");\n-        readStatus(inStream);\n-        int len \u003d inStream.readInt();\n-        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n-          if (!fallbackAllowed) {\n-            throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n-                \"auth, but this client is configured to only allow secure \" +\n-                \"connections.\");\n+    \n+    // track if SASL ever started, or server switched us to simple\n+    boolean inSasl \u003d false;\n+    sendSaslMessage(outStream, negotiateRequest);\n+    \n+    // loop until sasl is complete or a rpc error occurs\n+    boolean done \u003d false;\n+    do {\n+      int totalLen \u003d inStream.readInt();\n+      RpcResponseMessageWrapper responseWrapper \u003d\n+          new RpcResponseMessageWrapper();\n+      responseWrapper.readFields(inStream);\n+      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n+      switch (header.getStatus()) {\n+        case ERROR: // might get a RPC error during \n+        case FATAL:\n+          throw new RemoteException(header.getExceptionClassName(),\n+                                    header.getErrorMsg());\n+        default: break;\n+      }\n+      if (totalLen !\u003d responseWrapper.getLength()) {\n+        throw new SaslException(\"Received malformed response length\");\n+      }\n+      \n+      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n+        throw new SaslException(\"Non-SASL response during negotiation\");\n+      }\n+      RpcSaslProto saslMessage \u003d\n+          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Received SASL message \"+saslMessage);\n+      }\n+      // handle sasl negotiation process\n+      RpcSaslProto.Builder response \u003d null;\n+      switch (saslMessage.getState()) {\n+        case NEGOTIATE: {\n+          inSasl \u003d true;\n+          // TODO: should instantiate sasl client based on advertisement\n+          // but just blindly use the pre-instantiated sasl client for now\n+          String clientAuthMethod \u003d authMethod.toString();\n+          SaslAuth saslAuthType \u003d null;\n+          for (SaslAuth authType : saslMessage.getAuthsList()) {\n+            if (clientAuthMethod.equals(authType.getMethod())) {\n+              saslAuthType \u003d authType;\n+              break;\n+            }\n           }\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Server asks us to fall back to simple auth.\");\n-          saslClient.dispose();\n-          return false;\n-        } else if ((len \u003d\u003d 0) \u0026\u0026 saslClient.isComplete()) {\n+          if (saslAuthType \u003d\u003d null) {\n+            saslAuthType \u003d SaslAuth.newBuilder()\n+                .setMethod(clientAuthMethod)\n+                .setMechanism(saslClient.getMechanismName())\n+                .build();\n+          }\n+          \n+          byte[] challengeToken \u003d null;\n+          if (saslAuthType !\u003d null \u0026\u0026 saslAuthType.hasChallenge()) {\n+            // server provided the first challenge\n+            challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n+            saslAuthType \u003d\n+              SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n+          } else if (saslClient.hasInitialResponse()) {\n+            challengeToken \u003d new byte[0];\n+          }\n+          byte[] responseToken \u003d (challengeToken !\u003d null)\n+              ? saslClient.evaluateChallenge(challengeToken)\n+              : new byte[0];\n+          \n+          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n+          response.addAuths(saslAuthType);\n           break;\n         }\n-        saslToken \u003d new byte[len];\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Will read input token of size \" + saslToken.length\n-              + \" for processing by initSASLContext\");\n-        inStream.readFully(saslToken);\n-        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n+        case CHALLENGE: {\n+          inSasl \u003d true;\n+          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n+          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n+          break;\n+        }\n+        case SUCCESS: {\n+          if (inSasl \u0026\u0026 saslEvaluateToken(saslMessage, true) !\u003d null) {\n+            throw new SaslException(\"SASL client generated spurious token\");\n+          }\n+          done \u003d true;\n+          break;\n+        }\n+        default: {\n+          throw new SaslException(\n+              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n+        }\n       }\n-      if (!saslClient.isComplete()) { // shouldn\u0027t happen\n-        throw new SaslException(\"Internal negotiation error\");\n+      if (response !\u003d null) {\n+        sendSaslMessage(outStream, response.build());\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n-            + saslClient.getNegotiatedProperty(Sasl.QOP));\n-      }\n-      return true;\n-    } catch (IOException e) {\n-      try {\n-        saslClient.dispose();\n-      } catch (SaslException ignored) {\n-        // ignore further exceptions during cleanup\n-      }\n-      throw e;\n+    } while (!done);\n+    if (!inSasl \u0026\u0026 !fallbackAllowed) {\n+      throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n+          \"auth, but this client is configured to only allow secure \" +\n+          \"connections.\");\n     }\n+    return inSasl;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n    \n    // track if SASL ever started, or server switched us to simple\n    boolean inSasl \u003d false;\n    sendSaslMessage(outStream, negotiateRequest);\n    \n    // loop until sasl is complete or a rpc error occurs\n    boolean done \u003d false;\n    do {\n      int totalLen \u003d inStream.readInt();\n      RpcResponseMessageWrapper responseWrapper \u003d\n          new RpcResponseMessageWrapper();\n      responseWrapper.readFields(inStream);\n      RpcResponseHeaderProto header \u003d responseWrapper.getMessageHeader();\n      switch (header.getStatus()) {\n        case ERROR: // might get a RPC error during \n        case FATAL:\n          throw new RemoteException(header.getExceptionClassName(),\n                                    header.getErrorMsg());\n        default: break;\n      }\n      if (totalLen !\u003d responseWrapper.getLength()) {\n        throw new SaslException(\"Received malformed response length\");\n      }\n      \n      if (header.getCallId() !\u003d AuthProtocol.SASL.callId) {\n        throw new SaslException(\"Non-SASL response during negotiation\");\n      }\n      RpcSaslProto saslMessage \u003d\n          RpcSaslProto.parseFrom(responseWrapper.getMessageBytes());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Received SASL message \"+saslMessage);\n      }\n      // handle sasl negotiation process\n      RpcSaslProto.Builder response \u003d null;\n      switch (saslMessage.getState()) {\n        case NEGOTIATE: {\n          inSasl \u003d true;\n          // TODO: should instantiate sasl client based on advertisement\n          // but just blindly use the pre-instantiated sasl client for now\n          String clientAuthMethod \u003d authMethod.toString();\n          SaslAuth saslAuthType \u003d null;\n          for (SaslAuth authType : saslMessage.getAuthsList()) {\n            if (clientAuthMethod.equals(authType.getMethod())) {\n              saslAuthType \u003d authType;\n              break;\n            }\n          }\n          if (saslAuthType \u003d\u003d null) {\n            saslAuthType \u003d SaslAuth.newBuilder()\n                .setMethod(clientAuthMethod)\n                .setMechanism(saslClient.getMechanismName())\n                .build();\n          }\n          \n          byte[] challengeToken \u003d null;\n          if (saslAuthType !\u003d null \u0026\u0026 saslAuthType.hasChallenge()) {\n            // server provided the first challenge\n            challengeToken \u003d saslAuthType.getChallenge().toByteArray();\n            saslAuthType \u003d\n              SaslAuth.newBuilder(saslAuthType).clearChallenge().build();\n          } else if (saslClient.hasInitialResponse()) {\n            challengeToken \u003d new byte[0];\n          }\n          byte[] responseToken \u003d (challengeToken !\u003d null)\n              ? saslClient.evaluateChallenge(challengeToken)\n              : new byte[0];\n          \n          response \u003d createSaslReply(SaslState.INITIATE, responseToken);\n          response.addAuths(saslAuthType);\n          break;\n        }\n        case CHALLENGE: {\n          inSasl \u003d true;\n          byte[] responseToken \u003d saslEvaluateToken(saslMessage, false);\n          response \u003d createSaslReply(SaslState.RESPONSE, responseToken);\n          break;\n        }\n        case SUCCESS: {\n          if (inSasl \u0026\u0026 saslEvaluateToken(saslMessage, true) !\u003d null) {\n            throw new SaslException(\"SASL client generated spurious token\");\n          }\n          done \u003d true;\n          break;\n        }\n        default: {\n          throw new SaslException(\n              \"RPC client doesn\u0027t support SASL \" + saslMessage.getState());\n        }\n      }\n      if (response !\u003d null) {\n        sendSaslMessage(outStream, response.build());\n      }\n    } while (!done);\n    if (!inSasl \u0026\u0026 !fallbackAllowed) {\n      throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n          \"auth, but this client is configured to only allow secure \" +\n          \"connections.\");\n    }\n    return inSasl;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "9550b1a78bd430ad151fc481987369014a04394d": {
      "type": "Ybodychange",
      "commitMessage": "Clean up an IPC error message. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/13 10:31 AM",
      "commitName": "9550b1a78bd430ad151fc481987369014a04394d",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "13/11/12 9:10 AM",
      "commitNameOld": "fe8f635b78d59e286771ec75ff73245b40d30907",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 218.01,
      "commitsBetweenForRepo": 1234,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,56 @@\n   public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n \n     try {\n       byte[] saslToken \u003d new byte[0];\n       if (saslClient.hasInitialResponse())\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n       while (saslToken !\u003d null) {\n         outStream.writeInt(saslToken.length);\n         outStream.write(saslToken, 0, saslToken.length);\n         outStream.flush();\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have sent token of size \" + saslToken.length\n               + \" from initSASLContext.\");\n         readStatus(inStream);\n         int len \u003d inStream.readInt();\n         if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n+          if (!fallbackAllowed) {\n+            throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n+                \"auth, but this client is configured to only allow secure \" +\n+                \"connections.\");\n+          }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Server asks us to fall back to simple auth.\");\n           saslClient.dispose();\n           return false;\n         } else if ((len \u003d\u003d 0) \u0026\u0026 saslClient.isComplete()) {\n           break;\n         }\n         saslToken \u003d new byte[len];\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Will read input token of size \" + saslToken.length\n               + \" for processing by initSASLContext\");\n         inStream.readFully(saslToken);\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n       }\n       if (!saslClient.isComplete()) { // shouldn\u0027t happen\n         throw new SaslException(\"Internal negotiation error\");\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"SASL client context established. Negotiated QoP: \"\n             + saslClient.getNegotiatedProperty(Sasl.QOP));\n       }\n       return true;\n     } catch (IOException e) {\n       try {\n         saslClient.dispose();\n       } catch (SaslException ignored) {\n         // ignore further exceptions during cleanup\n       }\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      while (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (!fallbackAllowed) {\n            throw new IOException(\"Server asks us to fall back to SIMPLE \" +\n                \"auth, but this client is configured to only allow secure \" +\n                \"connections.\");\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        } else if ((len \u003d\u003d 0) \u0026\u0026 saslClient.isComplete()) {\n          break;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      }\n      if (!saslClient.isComplete()) { // shouldn\u0027t happen\n        throw new SaslException(\"Internal negotiation error\");\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "fe8f635b78d59e286771ec75ff73245b40d30907": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8999. SASL negotiation is flawed (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1408837 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 9:10 AM",
      "commitName": "fe8f635b78d59e286771ec75ff73245b40d30907",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "07/11/12 8:05 AM",
      "commitNameOld": "3c02237459359463c32df228c5e525bd1cf94e29",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 6.05,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,51 @@\n   public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n \n     try {\n       byte[] saslToken \u003d new byte[0];\n       if (saslClient.hasInitialResponse())\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n-      if (saslToken !\u003d null) {\n+      while (saslToken !\u003d null) {\n         outStream.writeInt(saslToken.length);\n         outStream.write(saslToken, 0, saslToken.length);\n         outStream.flush();\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have sent token of size \" + saslToken.length\n               + \" from initSASLContext.\");\n-      }\n-      if (!saslClient.isComplete()) {\n         readStatus(inStream);\n         int len \u003d inStream.readInt();\n         if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Server asks us to fall back to simple auth.\");\n           saslClient.dispose();\n           return false;\n+        } else if ((len \u003d\u003d 0) \u0026\u0026 saslClient.isComplete()) {\n+          break;\n         }\n         saslToken \u003d new byte[len];\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Will read input token of size \" + saslToken.length\n               + \" for processing by initSASLContext\");\n         inStream.readFully(saslToken);\n-      }\n-\n-      while (!saslClient.isComplete()) {\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n-        if (saslToken !\u003d null) {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Will send token of size \" + saslToken.length\n-                + \" from initSASLContext.\");\n-          outStream.writeInt(saslToken.length);\n-          outStream.write(saslToken, 0, saslToken.length);\n-          outStream.flush();\n-        }\n-        if (!saslClient.isComplete()) {\n-          readStatus(inStream);\n-          saslToken \u003d new byte[inStream.readInt()];\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Will read input token of size \" + saslToken.length\n-                + \" for processing by initSASLContext\");\n-          inStream.readFully(saslToken);\n-        }\n+      }\n+      if (!saslClient.isComplete()) { // shouldn\u0027t happen\n+        throw new SaslException(\"Internal negotiation error\");\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"SASL client context established. Negotiated QoP: \"\n             + saslClient.getNegotiatedProperty(Sasl.QOP));\n       }\n       return true;\n     } catch (IOException e) {\n       try {\n         saslClient.dispose();\n       } catch (SaslException ignored) {\n         // ignore further exceptions during cleanup\n       }\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      while (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        } else if ((len \u003d\u003d 0) \u0026\u0026 saslClient.isComplete()) {\n          break;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      }\n      if (!saslClient.isComplete()) { // shouldn\u0027t happen\n        throw new SaslException(\"Internal negotiation error\");\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          readStatus(inStream);\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          readStatus(inStream);\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/security/SaslRpcClient.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          readStatus(inStream);\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/security/SaslRpcClient.java",
        "newPath": "common/src/java/org/apache/hadoop/security/SaslRpcClient.java"
      }
    },
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6589. Provide better error messages when RPC authentication fails.\n(Kan Zhang via omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@916915 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/10 10:17 PM",
      "commitName": "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "22/02/10 2:28 PM",
      "commitNameOld": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 4.33,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n \n     try {\n       byte[] saslToken \u003d new byte[0];\n       if (saslClient.hasInitialResponse())\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n       if (saslToken !\u003d null) {\n         outStream.writeInt(saslToken.length);\n         outStream.write(saslToken, 0, saslToken.length);\n         outStream.flush();\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have sent token of size \" + saslToken.length\n               + \" from initSASLContext.\");\n       }\n       if (!saslClient.isComplete()) {\n+        readStatus(inStream);\n         int len \u003d inStream.readInt();\n         if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Server asks us to fall back to simple auth.\");\n           saslClient.dispose();\n           return false;\n         }\n         saslToken \u003d new byte[len];\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Will read input token of size \" + saslToken.length\n               + \" for processing by initSASLContext\");\n         inStream.readFully(saslToken);\n       }\n \n       while (!saslClient.isComplete()) {\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n         if (saslToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + saslToken.length\n                 + \" from initSASLContext.\");\n           outStream.writeInt(saslToken.length);\n           outStream.write(saslToken, 0, saslToken.length);\n           outStream.flush();\n         }\n         if (!saslClient.isComplete()) {\n+          readStatus(inStream);\n           saslToken \u003d new byte[inStream.readInt()];\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will read input token of size \" + saslToken.length\n                 + \" for processing by initSASLContext\");\n           inStream.readFully(saslToken);\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"SASL client context established. Negotiated QoP: \"\n             + saslClient.getNegotiatedProperty(Sasl.QOP));\n       }\n       return true;\n     } catch (IOException e) {\n       try {\n         saslClient.dispose();\n       } catch (SaslException ignored) {\n         // ignore further exceptions during cleanup\n       }\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        readStatus(inStream);\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          readStatus(inStream);\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
      "path": "src/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-6543. Allows secure clients to talk to unsecure clusters. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/10 2:28 PM",
      "commitName": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
      "commitAuthor": "Devaraj Das",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-6543. Allows secure clients to talk to unsecure clusters. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915097 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/10 2:28 PM",
          "commitName": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "02/02/10 5:30 PM",
          "commitNameOld": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthorOld": "Devaraj Das",
          "daysBetweenCommits": 19.87,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,65 @@\n-  public void saslConnect(InputStream inS, OutputStream outS)\n+  public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n \n     try {\n       byte[] saslToken \u003d new byte[0];\n       if (saslClient.hasInitialResponse())\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n       if (saslToken !\u003d null) {\n         outStream.writeInt(saslToken.length);\n         outStream.write(saslToken, 0, saslToken.length);\n         outStream.flush();\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have sent token of size \" + saslToken.length\n               + \" from initSASLContext.\");\n       }\n       if (!saslClient.isComplete()) {\n-        saslToken \u003d new byte[inStream.readInt()];\n+        int len \u003d inStream.readInt();\n+        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Server asks us to fall back to simple auth.\");\n+          saslClient.dispose();\n+          return false;\n+        }\n+        saslToken \u003d new byte[len];\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Will read input token of size \" + saslToken.length\n               + \" for processing by initSASLContext\");\n         inStream.readFully(saslToken);\n       }\n \n       while (!saslClient.isComplete()) {\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n         if (saslToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + saslToken.length\n                 + \" from initSASLContext.\");\n           outStream.writeInt(saslToken.length);\n           outStream.write(saslToken, 0, saslToken.length);\n           outStream.flush();\n         }\n         if (!saslClient.isComplete()) {\n           saslToken \u003d new byte[inStream.readInt()];\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will read input token of size \" + saslToken.length\n                 + \" for processing by initSASLContext\");\n           inStream.readFully(saslToken);\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"SASL client context established. Negotiated QoP: \"\n             + saslClient.getNegotiatedProperty(Sasl.QOP));\n       }\n+      return true;\n     } catch (IOException e) {\n-      saslClient.dispose();\n+      try {\n+        saslClient.dispose();\n+      } catch (SaslException ignored) {\n+        // ignore further exceptions during cleanup\n+      }\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
          "path": "src/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6543. Allows secure clients to talk to unsecure clusters. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915097 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/02/10 2:28 PM",
          "commitName": "c5622e5d4df0ec83ffedb46f1d4cfdeed9e43539",
          "commitAuthor": "Devaraj Das",
          "commitDateOld": "02/02/10 5:30 PM",
          "commitNameOld": "940389afce6a1b9b9e1519aed528cbc444786756",
          "commitAuthorOld": "Devaraj Das",
          "daysBetweenCommits": 19.87,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,65 @@\n-  public void saslConnect(InputStream inS, OutputStream outS)\n+  public boolean saslConnect(InputStream inS, OutputStream outS)\n       throws IOException {\n     DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n     DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n         outS));\n \n     try {\n       byte[] saslToken \u003d new byte[0];\n       if (saslClient.hasInitialResponse())\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n       if (saslToken !\u003d null) {\n         outStream.writeInt(saslToken.length);\n         outStream.write(saslToken, 0, saslToken.length);\n         outStream.flush();\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have sent token of size \" + saslToken.length\n               + \" from initSASLContext.\");\n       }\n       if (!saslClient.isComplete()) {\n-        saslToken \u003d new byte[inStream.readInt()];\n+        int len \u003d inStream.readInt();\n+        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Server asks us to fall back to simple auth.\");\n+          saslClient.dispose();\n+          return false;\n+        }\n+        saslToken \u003d new byte[len];\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Will read input token of size \" + saslToken.length\n               + \" for processing by initSASLContext\");\n         inStream.readFully(saslToken);\n       }\n \n       while (!saslClient.isComplete()) {\n         saslToken \u003d saslClient.evaluateChallenge(saslToken);\n         if (saslToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + saslToken.length\n                 + \" from initSASLContext.\");\n           outStream.writeInt(saslToken.length);\n           outStream.write(saslToken, 0, saslToken.length);\n           outStream.flush();\n         }\n         if (!saslClient.isComplete()) {\n           saslToken \u003d new byte[inStream.readInt()];\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will read input token of size \" + saslToken.length\n                 + \" for processing by initSASLContext\");\n           inStream.readFully(saslToken);\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"SASL client context established. Negotiated QoP: \"\n             + saslClient.getNegotiatedProperty(Sasl.QOP));\n       }\n+      return true;\n     } catch (IOException e) {\n-      saslClient.dispose();\n+      try {\n+        saslClient.dispose();\n+      } catch (SaslException ignored) {\n+        // ignore further exceptions during cleanup\n+      }\n       throw e;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        int len \u003d inStream.readInt();\n        if (len \u003d\u003d SaslRpcServer.SWITCH_TO_SIMPLE_AUTH) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Server asks us to fall back to simple auth.\");\n          saslClient.dispose();\n          return false;\n        }\n        saslToken \u003d new byte[len];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n      return true;\n    } catch (IOException e) {\n      try {\n        saslClient.dispose();\n      } catch (SaslException ignored) {\n        // ignore further exceptions during cleanup\n      }\n      throw e;\n    }\n  }",
          "path": "src/java/org/apache/hadoop/security/SaslRpcClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "diff": "@@ -0,0 +1,53 @@\n+  public void saslConnect(InputStream inS, OutputStream outS)\n+      throws IOException {\n+    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n+    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n+        outS));\n+\n+    try {\n+      byte[] saslToken \u003d new byte[0];\n+      if (saslClient.hasInitialResponse())\n+        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n+      if (saslToken !\u003d null) {\n+        outStream.writeInt(saslToken.length);\n+        outStream.write(saslToken, 0, saslToken.length);\n+        outStream.flush();\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(\"Have sent token of size \" + saslToken.length\n+              + \" from initSASLContext.\");\n+      }\n+      if (!saslClient.isComplete()) {\n+        saslToken \u003d new byte[inStream.readInt()];\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(\"Will read input token of size \" + saslToken.length\n+              + \" for processing by initSASLContext\");\n+        inStream.readFully(saslToken);\n+      }\n+\n+      while (!saslClient.isComplete()) {\n+        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n+        if (saslToken !\u003d null) {\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Will send token of size \" + saslToken.length\n+                + \" from initSASLContext.\");\n+          outStream.writeInt(saslToken.length);\n+          outStream.write(saslToken, 0, saslToken.length);\n+          outStream.flush();\n+        }\n+        if (!saslClient.isComplete()) {\n+          saslToken \u003d new byte[inStream.readInt()];\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Will read input token of size \" + saslToken.length\n+                + \" for processing by initSASLContext\");\n+          inStream.readFully(saslToken);\n+        }\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n+            + saslClient.getNegotiatedProperty(Sasl.QOP));\n+      }\n+    } catch (IOException e) {\n+      saslClient.dispose();\n+      throw e;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void saslConnect(InputStream inS, OutputStream outS)\n      throws IOException {\n    DataInputStream inStream \u003d new DataInputStream(new BufferedInputStream(inS));\n    DataOutputStream outStream \u003d new DataOutputStream(new BufferedOutputStream(\n        outS));\n\n    try {\n      byte[] saslToken \u003d new byte[0];\n      if (saslClient.hasInitialResponse())\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n      if (saslToken !\u003d null) {\n        outStream.writeInt(saslToken.length);\n        outStream.write(saslToken, 0, saslToken.length);\n        outStream.flush();\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have sent token of size \" + saslToken.length\n              + \" from initSASLContext.\");\n      }\n      if (!saslClient.isComplete()) {\n        saslToken \u003d new byte[inStream.readInt()];\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Will read input token of size \" + saslToken.length\n              + \" for processing by initSASLContext\");\n        inStream.readFully(saslToken);\n      }\n\n      while (!saslClient.isComplete()) {\n        saslToken \u003d saslClient.evaluateChallenge(saslToken);\n        if (saslToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + saslToken.length\n                + \" from initSASLContext.\");\n          outStream.writeInt(saslToken.length);\n          outStream.write(saslToken, 0, saslToken.length);\n          outStream.flush();\n        }\n        if (!saslClient.isComplete()) {\n          saslToken \u003d new byte[inStream.readInt()];\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will read input token of size \" + saslToken.length\n                + \" for processing by initSASLContext\");\n          inStream.readFully(saslToken);\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"SASL client context established. Negotiated QoP: \"\n            + saslClient.getNegotiatedProperty(Sasl.QOP));\n      }\n    } catch (IOException e) {\n      saslClient.dispose();\n      throw e;\n    }\n  }",
      "path": "src/java/org/apache/hadoop/security/SaslRpcClient.java"
    }
  }
}