{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationService.java",
  "functionName": "initAppAggregator",
  "functionId": "initAppAggregator___appId-ApplicationId(modifiers-final)__user-String__credentials-Credentials__appAcls-Map__ApplicationAccessType,String____logAggregationContext-LogAggregationContext__recoveredLogInitedTime-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
  "functionStartLine": 243,
  "functionEndLine": 307,
  "numCommitsSeen": 110,
  "timeTaken": 6598,
  "changeHistory": [
    "4b540bbfcf02d828052999215c6135603d98f5db",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
    "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
    "7bd418e48c71590fc8026d69f9b8f8ad42f2aade",
    "16b9037dc1300b8bdbe54ba7cd47c53fe16e93d8",
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
    "5c0381c96aa79196829edbca497c649eb6776944",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a",
    "df5e2b83526634ac7c1c1131bf1aad73ac353d01",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1cf60106758c482991f08caa136446885d5f8f27"
  ],
  "changeHistoryShort": {
    "4b540bbfcf02d828052999215c6135603d98f5db": "Ybodychange",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": "Ybodychange",
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": "Ymultichange(Yparameterchange,Ybodychange)",
    "6161d9ba5230f553db5f5490dce67e2afd1e29ca": "Ybodychange",
    "7bd418e48c71590fc8026d69f9b8f8ad42f2aade": "Ybodychange",
    "16b9037dc1300b8bdbe54ba7cd47c53fe16e93d8": "Ybodychange",
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c": "Ymultichange(Yparameterchange,Ybodychange)",
    "5c0381c96aa79196829edbca497c649eb6776944": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ybodychange",
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": "Ybodychange",
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Ymultichange(Yparameterchange,Ybodychange)",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a": "Ybodychange",
    "df5e2b83526634ac7c1c1131bf1aad73ac353d01": "Ymultichange(Ymodifierchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1cf60106758c482991f08caa136446885d5f8f27": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4b540bbfcf02d828052999215c6135603d98f5db": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8418. App local logs could leaked if log aggregation fails to initialize for the app. (Bibin A Chundatt via wangda)\n\nChange-Id: I29a23ca4b219b48c92e7975cd44cddb8b0e04104\n",
      "commitDate": "31/07/18 12:08 PM",
      "commitName": "4b540bbfcf02d828052999215c6135603d98f5db",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "30/07/18 10:55 AM",
      "commitNameOld": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,65 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext,\n       long recoveredLogInitedTime) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n-    LogAggregationFileController logAggregationFileController\n-        \u003d getLogAggregationFileController(getConfig());\n+    LogAggregationFileController logAggregationFileController \u003d\n+        getLogAggregationFileController(getConfig());\n     logAggregationFileController.verifyAndCreateRemoteLogDir();\n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             logAggregationFileController.getRemoteNodeLogFileForApp(appId,\n             user, nodeId), appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n             recoveredLogInitedTime, logAggregationFileController);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       logAggregationFileController.createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n+\n+      // add to disabled aggregators if due to InvalidToken\n+      if (e.getCause() instanceof SecretManager.InvalidToken) {\n+        invalidTokenApps.add(appId);\n+      }\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n-      appLogAggregators.remove(appId);\n-      closeFileSystems(userUgi);\n-      throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n+\n+    if (appDirException !\u003d null) {\n+      throw appDirException;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext,\n      long recoveredLogInitedTime) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    LogAggregationFileController logAggregationFileController \u003d\n        getLogAggregationFileController(getConfig());\n    logAggregationFileController.verifyAndCreateRemoteLogDir();\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            logAggregationFileController.getRemoteNodeLogFileForApp(appId,\n            user, nodeId), appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n            recoveredLogInitedTime, logAggregationFileController);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      logAggregationFileController.createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n\n      // add to disabled aggregators if due to InvalidToken\n      if (e.getCause() instanceof SecretManager.InvalidToken) {\n        invalidTokenApps.add(appId);\n      }\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n\n    if (appDirException !\u003d null) {\n      throw appDirException;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "24/08/17 1:36 PM",
      "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.52,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,59 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext,\n       long recoveredLogInitedTime) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n+    LogAggregationFileController logAggregationFileController\n+        \u003d getLogAggregationFileController(getConfig());\n+    logAggregationFileController.verifyAndCreateRemoteLogDir();\n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n-            getRemoteNodeLogFileForApp(appId, user),\n-            appAcls, logAggregationContext, this.context,\n+            logAggregationFileController.getRemoteNodeLogFileForApp(appId,\n+            user, nodeId), appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n-            recoveredLogInitedTime);\n+            recoveredLogInitedTime, logAggregationFileController);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n-      createAppDir(user, appId, userUgi);\n+      logAggregationFileController.createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext,\n      long recoveredLogInitedTime) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    LogAggregationFileController logAggregationFileController\n        \u003d getLogAggregationFileController(getConfig());\n    logAggregationFileController.verifyAndCreateRemoteLogDir();\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            logAggregationFileController.getRemoteNodeLogFileForApp(appId,\n            user, nodeId), appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n            recoveredLogInitedTime, logAggregationFileController);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      logAggregationFileController.createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      throw appDirException;\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "e07519b8dbb96d73c48e910a4de12563c5c2f8aa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
      "commitDate": "25/05/16 10:25 AM",
      "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
          "commitDate": "25/05/16 10:25 AM",
          "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "22/05/16 4:04 PM",
          "commitNameOld": "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,56 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n-      LogAggregationContext logAggregationContext) {\n+      LogAggregationContext logAggregationContext,\n+      long recoveredLogInitedTime) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n-            getLocalFileContext(getConfig()), this.rollingMonitorInterval);\n+            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n+            recoveredLogInitedTime);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext,\n      long recoveredLogInitedTime) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n            recoveredLogInitedTime);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      throw appDirException;\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {
            "oldValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, appAcls-Map\u003cApplicationAccessType,String\u003e, logAggregationContext-LogAggregationContext]",
            "newValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, appAcls-Map\u003cApplicationAccessType,String\u003e, logAggregationContext-LogAggregationContext, recoveredLogInitedTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4766. NM should not aggregate logs older than the retention policy (haibochen via rkanter)\n",
          "commitDate": "25/05/16 10:25 AM",
          "commitName": "e07519b8dbb96d73c48e910a4de12563c5c2f8aa",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "22/05/16 4:04 PM",
          "commitNameOld": "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,56 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n-      LogAggregationContext logAggregationContext) {\n+      LogAggregationContext logAggregationContext,\n+      long recoveredLogInitedTime) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n-            getLocalFileContext(getConfig()), this.rollingMonitorInterval);\n+            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n+            recoveredLogInitedTime);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext,\n      long recoveredLogInitedTime) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()), this.rollingMonitorInterval,\n            recoveredLogInitedTime);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      throw appDirException;\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {}
        }
      ]
    },
    "6161d9ba5230f553db5f5490dce67e2afd1e29ca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5112. Excessive log warnings for directory permission issue on NM recovery. Contributed by Jian He.\n(cherry picked from commit 867cd2f5a2e5966d6a7c5f5accb2fce78f9e7778)\n",
      "commitDate": "22/05/16 4:04 PM",
      "commitName": "6161d9ba5230f553db5f5490dce67e2afd1e29ca",
      "commitAuthor": "Junping Du",
      "commitDateOld": "16/05/16 8:40 AM",
      "commitNameOld": "81effb7dcde2b31423438d6f1b8b8204d4ca05b3",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.31,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n-            getLocalFileContext(getConfig()));\n+            getLocalFileContext(getConfig()), this.rollingMonitorInterval);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()), this.rollingMonitorInterval);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      throw appDirException;\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "7bd418e48c71590fc8026d69f9b8f8ad42f2aade": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4984. LogAggregationService shouldn\u0027t swallow exception in handling createAppDir() which cause thread leak. (Junping Du via wangda)\n",
      "commitDate": "04/05/16 11:38 AM",
      "commitName": "7bd418e48c71590fc8026d69f9b8f8ad42f2aade",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "24/02/16 3:00 PM",
      "commitNameOld": "954dd57043d2de4f962876c1b89753bfc7e4ce55",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 69.82,
      "commitsBetweenForRepo": 416,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n         appDirException \u003d new YarnRuntimeException(e);\n       } else {\n         appDirException \u003d (YarnRuntimeException)e;\n       }\n+      appLogAggregators.remove(appId);\n+      closeFileSystems(userUgi);\n+      throw appDirException;\n     }\n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n-\n-    if (appDirException !\u003d null) {\n-      throw appDirException;\n-    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      throw appDirException;\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "16b9037dc1300b8bdbe54ba7cd47c53fe16e93d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4096. App local logs are leaked if log aggregation fails to initialize for the app. Contributed by Jason Lowe.\n",
      "commitDate": "08/09/15 12:29 PM",
      "commitName": "16b9037dc1300b8bdbe54ba7cd47c53fe16e93d8",
      "commitAuthor": "Zhihai Xu",
      "commitDateOld": "22/08/15 4:25 PM",
      "commitNameOld": "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 16.84,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,55 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n+    YarnRuntimeException appDirException \u003d null;\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n-      appLogAggregators.remove(appId);\n-      closeFileSystems(userUgi);\n+      appLogAggregator.disableLogAggregation();\n       if (!(e instanceof YarnRuntimeException)) {\n-        e \u003d new YarnRuntimeException(e);\n+        appDirException \u003d new YarnRuntimeException(e);\n+      } else {\n+        appDirException \u003d (YarnRuntimeException)e;\n       }\n-      throw (YarnRuntimeException)e;\n     }\n \n-\n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n+\n+    if (appDirException !\u003d null) {\n+      throw appDirException;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    YarnRuntimeException appDirException \u003d null;\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregator.disableLogAggregation();\n      if (!(e instanceof YarnRuntimeException)) {\n        appDirException \u003d new YarnRuntimeException(e);\n      } else {\n        appDirException \u003d (YarnRuntimeException)e;\n      }\n    }\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n\n    if (appDirException !\u003d null) {\n      throw appDirException;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "37e1c3d82a96d781e1c9982988b7de4aa5242d0c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-221. NM should provide a way for AM to tell it not to aggregate\nlogs. Contributed by Ming Ma\n",
      "commitDate": "22/08/15 4:25 PM",
      "commitName": "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-221. NM should provide a way for AM to tell it not to aggregate\nlogs. Contributed by Ming Ma\n",
          "commitDate": "22/08/15 4:25 PM",
          "commitName": "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
          "commitAuthor": "Xuan",
          "commitDateOld": "08/05/15 3:10 PM",
          "commitNameOld": "088156de43abb07bec590a3fcd1a5af2feb02cd2",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 106.05,
          "commitsBetweenForRepo": 708,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,51 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n-      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n-      Map\u003cApplicationAccessType, String\u003e appAcls,\n+      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n-            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n+            getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {
            "oldValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, logRetentionPolicy-ContainerLogsRetentionPolicy, appAcls-Map\u003cApplicationAccessType,String\u003e, logAggregationContext-LogAggregationContext]",
            "newValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, appAcls-Map\u003cApplicationAccessType,String\u003e, logAggregationContext-LogAggregationContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-221. NM should provide a way for AM to tell it not to aggregate\nlogs. Contributed by Ming Ma\n",
          "commitDate": "22/08/15 4:25 PM",
          "commitName": "37e1c3d82a96d781e1c9982988b7de4aa5242d0c",
          "commitAuthor": "Xuan",
          "commitDateOld": "08/05/15 3:10 PM",
          "commitNameOld": "088156de43abb07bec590a3fcd1a5af2feb02cd2",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 106.05,
          "commitsBetweenForRepo": 708,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,51 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n-      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n-      Map\u003cApplicationAccessType, String\u003e appAcls,\n+      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n-            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n+            getRemoteNodeLogFileForApp(appId, user),\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user),\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {}
        }
      ]
    },
    "5c0381c96aa79196829edbca497c649eb6776944": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2790. Fixed a NodeManager bug that was causing log-aggregation to fail beyond HFDS delegation-token expiry even when RM is a proxy-user (YARN-2704). Contributed by Jian He.\n",
      "commitDate": "01/11/14 4:32 PM",
      "commitName": "5c0381c96aa79196829edbca497c649eb6776944",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/14 3:49 PM",
      "commitNameOld": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.03,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,52 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      Credentials systemCredentials \u003d\n-          context.getSystemCredentialsForApps().get(appId);\n-      if (systemCredentials !\u003d null) {\n-        LOG.info(\"Adding new framework tokens from RM for \" + appId);\n-        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n-          LOG.info(\"Adding new application-token for log-aggregation: \" + token);\n-        }\n-        credentials \u003d systemCredentials;\n-      }\n-    }\n-\n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/10/14 10:31 AM",
      "commitNameOld": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,64 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials systemCredentials \u003d\n+          context.getSystemCredentialsForApps().get(appId);\n+      if (systemCredentials !\u003d null) {\n+        LOG.info(\"Adding new framework tokens from RM for \" + appId);\n+        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n+          LOG.info(\"Adding new application-token for log-aggregation: \" + token);\n+        }\n+        credentials \u003d systemCredentials;\n+      }\n+    }\n+\n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls, logAggregationContext, this.context,\n             getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials systemCredentials \u003d\n          context.getSystemCredentialsForApps().get(appId);\n      if (systemCredentials !\u003d null) {\n        LOG.info(\"Adding new framework tokens from RM for \" + appId);\n        for (Token\u003c?\u003e token : systemCredentials.getAllTokens()) {\n          LOG.info(\"Adding new application-token for log-aggregation: \" + token);\n        }\n        credentials \u003d systemCredentials;\n      }\n    }\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "6f2028bd1514d90b831f889fd0ee7f2ba5c15000": {
      "type": "Ybodychange",
      "commitMessage": "YARN-90. NodeManager should identify failed disks becoming good again. Contributed by Varun Vasudev\n",
      "commitDate": "21/10/14 10:31 AM",
      "commitName": "6f2028bd1514d90b831f889fd0ee7f2ba5c15000",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "10/10/14 12:11 AM",
      "commitNameOld": "cb81bac0029fce3a9726df3523f0b692cd3375b8",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 11.43,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n-            appAcls, logAggregationContext, this.context);\n+            appAcls, logAggregationContext, this.context,\n+            getLocalFileContext(getConfig()));\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context,\n            getLocalFileContext(getConfig()));\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "cb81bac0029fce3a9726df3523f0b692cd3375b8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2583. Modified AggregatedLogDeletionService to be able to delete rolling aggregated logs. Contributed by Xuan Gong.\n",
      "commitDate": "10/10/14 12:11 AM",
      "commitName": "cb81bac0029fce3a9726df3523f0b692cd3375b8",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/10/14 12:15 PM",
      "commitNameOld": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.5,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls,\n       LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n-            getConfig(), appId, userUgi, dirsHandler,\n+            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls, logAggregationContext, this.context);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, this.nodeId, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.35,
          "commitsBetweenForRepo": 563,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n-      Map\u003cApplicationAccessType, String\u003e appAcls) {\n+      Map\u003cApplicationAccessType, String\u003e appAcls,\n+      LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n-            appAcls);\n+            appAcls, logAggregationContext, this.context);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {
            "oldValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, logRetentionPolicy-ContainerLogsRetentionPolicy, appAcls-Map\u003cApplicationAccessType,String\u003e]",
            "newValue": "[appId-ApplicationId(modifiers-final), user-String, credentials-Credentials, logRetentionPolicy-ContainerLogsRetentionPolicy, appAcls-Map\u003cApplicationAccessType,String\u003e, logAggregationContext-LogAggregationContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/08/14 3:56 AM",
          "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 52.35,
          "commitsBetweenForRepo": 563,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n-      Map\u003cApplicationAccessType, String\u003e appAcls) {\n+      Map\u003cApplicationAccessType, String\u003e appAcls,\n+      LogAggregationContext logAggregationContext) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n-            appAcls);\n+            appAcls, logAggregationContext, this.context);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n       if (!(e instanceof YarnRuntimeException)) {\n         e \u003d new YarnRuntimeException(e);\n       }\n       throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls,\n      LogAggregationContext logAggregationContext) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls, logAggregationContext, this.context);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {}
        }
      ]
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/05/13 7:25 AM",
      "commitNameOld": "31c96829c767a093d6de8bdc30e06089eeba860b",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 5.57,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n-      throw new YarnException(\"Duplicate initApp for \" + appId);\n+      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n     } catch (Exception e) {\n       appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n-      if (!(e instanceof YarnException)) {\n-        e \u003d new YarnException(e);\n+      if (!(e instanceof YarnRuntimeException)) {\n+        e \u003d new YarnRuntimeException(e);\n       }\n-      throw (YarnException)e;\n+      throw (YarnRuntimeException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnRuntimeException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnRuntimeException)) {\n        e \u003d new YarnRuntimeException(e);\n      }\n      throw (YarnRuntimeException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-68. NodeManager will refuse to shutdown indefinitely due to container log aggregation (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1381317 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/12 12:39 PM",
      "commitName": "726b48f51ab8f48e69a0b6bc2e8a73234aaea07a",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "20/08/12 11:32 AM",
      "commitNameOld": "df5e2b83526634ac7c1c1131bf1aad73ac353d01",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 16.05,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls) {\n \n     // Get user\u0027s FileSystem credentials\n     final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n-      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n-          .getAllTokens()) {\n-        userUgi.addToken(token);\n-      }\n+      userUgi.addCredentials(credentials);\n     }\n \n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnException(\"Duplicate initApp for \" + appId);\n     }\n     // wait until check for existing aggregator to create dirs\n     try {\n       // Create the app dir\n       createAppDir(user, appId, userUgi);\n-    } catch (YarnException e) {\n+    } catch (Exception e) {\n+      appLogAggregators.remove(appId);\n       closeFileSystems(userUgi);\n-      throw e;\n+      if (!(e instanceof YarnException)) {\n+        e \u003d new YarnException(e);\n+      }\n+      throw (YarnException)e;\n     }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n           closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      userUgi.addCredentials(credentials);\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (Exception e) {\n      appLogAggregators.remove(appId);\n      closeFileSystems(userUgi);\n      if (!(e instanceof YarnException)) {\n        e \u003d new YarnException(e);\n      }\n      throw (YarnException)e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {}
    },
    "df5e2b83526634ac7c1c1131bf1aad73ac353d01": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-4323. NM leaks filesystems (Jason Lowe via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375164 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/08/12 11:32 AM",
      "commitName": "df5e2b83526634ac7c1c1131bf1aad73ac353d01",
      "commitAuthor": "Jonathan Turner Eagles",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-4323. NM leaks filesystems (Jason Lowe via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375164 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/08/12 11:32 AM",
          "commitName": "df5e2b83526634ac7c1c1131bf1aad73ac353d01",
          "commitAuthor": "Jonathan Turner Eagles",
          "commitDateOld": "17/08/12 1:29 PM",
          "commitNameOld": "7fc6ad661d4723cc2ea1df1ff0c4611d5f534f9e",
          "commitAuthorOld": "Thomas Graves",
          "daysBetweenCommits": 2.92,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  public void initAppAggregator(final ApplicationId appId, String user,\n+  protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls) {\n \n     // Get user\u0027s FileSystem credentials\n-    UserGroupInformation userUgi \u003d\n+    final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n           .getAllTokens()) {\n         userUgi.addToken(token);\n       }\n     }\n \n-    // Create the app dir\n-    createAppDir(user, appId, userUgi);\n-\n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnException(\"Duplicate initApp for \" + appId);\n     }\n+    // wait until check for existing aggregator to create dirs\n+    try {\n+      // Create the app dir\n+      createAppDir(user, appId, userUgi);\n+    } catch (YarnException e) {\n+      closeFileSystems(userUgi);\n+      throw e;\n+    }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n+          closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n          .getAllTokens()) {\n        userUgi.addToken(token);\n      }\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (YarnException e) {\n      closeFileSystems(userUgi);\n      throw e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-4323. NM leaks filesystems (Jason Lowe via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375164 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "20/08/12 11:32 AM",
          "commitName": "df5e2b83526634ac7c1c1131bf1aad73ac353d01",
          "commitAuthor": "Jonathan Turner Eagles",
          "commitDateOld": "17/08/12 1:29 PM",
          "commitNameOld": "7fc6ad661d4723cc2ea1df1ff0c4611d5f534f9e",
          "commitAuthorOld": "Thomas Graves",
          "daysBetweenCommits": 2.92,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,49 @@\n-  public void initAppAggregator(final ApplicationId appId, String user,\n+  protected void initAppAggregator(final ApplicationId appId, String user,\n       Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n       Map\u003cApplicationAccessType, String\u003e appAcls) {\n \n     // Get user\u0027s FileSystem credentials\n-    UserGroupInformation userUgi \u003d\n+    final UserGroupInformation userUgi \u003d\n         UserGroupInformation.createRemoteUser(user);\n     if (credentials !\u003d null) {\n       for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n           .getAllTokens()) {\n         userUgi.addToken(token);\n       }\n     }\n \n-    // Create the app dir\n-    createAppDir(user, appId, userUgi);\n-\n     // New application\n     final AppLogAggregator appLogAggregator \u003d\n         new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n             getConfig(), appId, userUgi, dirsHandler,\n             getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n             appAcls);\n     if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n       throw new YarnException(\"Duplicate initApp for \" + appId);\n     }\n+    // wait until check for existing aggregator to create dirs\n+    try {\n+      // Create the app dir\n+      createAppDir(user, appId, userUgi);\n+    } catch (YarnException e) {\n+      closeFileSystems(userUgi);\n+      throw e;\n+    }\n \n \n     // TODO Get the user configuration for the list of containers that need log\n     // aggregation.\n \n     // Schedule the aggregator.\n     Runnable aggregatorWrapper \u003d new Runnable() {\n       public void run() {\n         try {\n           appLogAggregator.run();\n         } finally {\n           appLogAggregators.remove(appId);\n+          closeFileSystems(userUgi);\n         }\n       }\n     };\n     this.threadPool.execute(aggregatorWrapper);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    final UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n          .getAllTokens()) {\n        userUgi.addToken(token);\n      }\n    }\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnException(\"Duplicate initApp for \" + appId);\n    }\n    // wait until check for existing aggregator to create dirs\n    try {\n      // Create the app dir\n      createAppDir(user, appId, userUgi);\n    } catch (YarnException e) {\n      closeFileSystems(userUgi);\n      throw e;\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n          closeFileSystems(userUgi);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n          .getAllTokens()) {\n        userUgi.addToken(token);\n      }\n    }\n\n    // Create the app dir\n    createAppDir(user, appId, userUgi);\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnException(\"Duplicate initApp for \" + appId);\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java"
      }
    },
    "1cf60106758c482991f08caa136446885d5f8f27": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-4302. NM goes down if error encountered during log aggregation (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1345362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/12 2:54 PM",
      "commitName": "1cf60106758c482991f08caa136446885d5f8f27",
      "commitAuthor": "Robert Joseph Evans",
      "diff": "@@ -0,0 +1,43 @@\n+  public void initAppAggregator(final ApplicationId appId, String user,\n+      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n+      Map\u003cApplicationAccessType, String\u003e appAcls) {\n+\n+    // Get user\u0027s FileSystem credentials\n+    UserGroupInformation userUgi \u003d\n+        UserGroupInformation.createRemoteUser(user);\n+    if (credentials !\u003d null) {\n+      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n+          .getAllTokens()) {\n+        userUgi.addToken(token);\n+      }\n+    }\n+\n+    // Create the app dir\n+    createAppDir(user, appId, userUgi);\n+\n+    // New application\n+    final AppLogAggregator appLogAggregator \u003d\n+        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n+            getConfig(), appId, userUgi, dirsHandler,\n+            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n+            appAcls);\n+    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n+      throw new YarnException(\"Duplicate initApp for \" + appId);\n+    }\n+\n+\n+    // TODO Get the user configuration for the list of containers that need log\n+    // aggregation.\n+\n+    // Schedule the aggregator.\n+    Runnable aggregatorWrapper \u003d new Runnable() {\n+      public void run() {\n+        try {\n+          appLogAggregator.run();\n+        } finally {\n+          appLogAggregators.remove(appId);\n+        }\n+      }\n+    };\n+    this.threadPool.execute(aggregatorWrapper);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void initAppAggregator(final ApplicationId appId, String user,\n      Credentials credentials, ContainerLogsRetentionPolicy logRetentionPolicy,\n      Map\u003cApplicationAccessType, String\u003e appAcls) {\n\n    // Get user\u0027s FileSystem credentials\n    UserGroupInformation userUgi \u003d\n        UserGroupInformation.createRemoteUser(user);\n    if (credentials !\u003d null) {\n      for (Token\u003c? extends TokenIdentifier\u003e token : credentials\n          .getAllTokens()) {\n        userUgi.addToken(token);\n      }\n    }\n\n    // Create the app dir\n    createAppDir(user, appId, userUgi);\n\n    // New application\n    final AppLogAggregator appLogAggregator \u003d\n        new AppLogAggregatorImpl(this.dispatcher, this.deletionService,\n            getConfig(), appId, userUgi, dirsHandler,\n            getRemoteNodeLogFileForApp(appId, user), logRetentionPolicy,\n            appAcls);\n    if (this.appLogAggregators.putIfAbsent(appId, appLogAggregator) !\u003d null) {\n      throw new YarnException(\"Duplicate initApp for \" + appId);\n    }\n\n\n    // TODO Get the user configuration for the list of containers that need log\n    // aggregation.\n\n    // Schedule the aggregator.\n    Runnable aggregatorWrapper \u003d new Runnable() {\n      public void run() {\n        try {\n          appLogAggregator.run();\n        } finally {\n          appLogAggregators.remove(appId);\n        }\n      }\n    };\n    this.threadPool.execute(aggregatorWrapper);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/LogAggregationService.java"
    }
  }
}