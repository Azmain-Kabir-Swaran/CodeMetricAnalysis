{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ClientRMService.java",
  "functionName": "updateApplicationTimeouts",
  "functionId": "updateApplicationTimeouts___request-UpdateApplicationTimeoutsRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
  "functionStartLine": 1749,
  "functionEndLine": 1811,
  "numCommitsSeen": 128,
  "timeTaken": 3731,
  "changeHistory": [
    "56d93d2e39ead89bb79c4f4096554820dc77e84b",
    "cffea251be4b73ca16e5e11f0be2d22651330f73",
    "1f12867a69544a1642aa986d4f9a8249be495434",
    "bcc15c6290b3912a054323695a6a931b0de163bd"
  ],
  "changeHistoryShort": {
    "56d93d2e39ead89bb79c4f4096554820dc77e84b": "Ybodychange",
    "cffea251be4b73ca16e5e11f0be2d22651330f73": "Ybodychange",
    "1f12867a69544a1642aa986d4f9a8249be495434": "Ybodychange",
    "bcc15c6290b3912a054323695a6a931b0de163bd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56d93d2e39ead89bb79c4f4096554820dc77e84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6600. Introduce default and max lifetime of application at LeafQueue level. Contributed by Rohith Sharma K S.\n",
      "commitDate": "07/09/17 6:45 PM",
      "commitName": "56d93d2e39ead89bb79c4f4096554820dc77e84b",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/08/17 6:26 PM",
      "commitNameOld": "312b1fd9da2781da97f8c76fe1262c4d99b9c37f",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 10.01,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,63 @@\n   public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n       UpdateApplicationTimeoutsRequest request)\n       throws YarnException, IOException {\n \n     ApplicationId applicationId \u003d request.getApplicationId();\n     Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n         request.getApplicationTimeouts();\n \n     UserGroupInformation callerUGI \u003d\n         getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n     RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n         AuditConstants.UPDATE_APP_TIMEOUTS, ApplicationAccessType.MODIFY_APP,\n         true);\n \n     if (applicationTimeouts.isEmpty()) {\n       String message \u003d\n           \"At least one ApplicationTimeoutType should be configured\"\n               + \" for updating timeouts.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           message, applicationId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     UpdateApplicationTimeoutsResponse response \u003d recordFactory\n         .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n \n     RMAppState state \u003d application.getState();\n     if (!EnumSet\n         .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n         .contains(state)) {\n       if (application.isAppInCompletedStates()) {\n         // If Application is in any of the final states, update timeout\n         // can be skipped rather throwing exception.\n         RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n             AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n             applicationId);\n+        response.setApplicationTimeouts(applicationTimeouts);\n         return response;\n       }\n       String msg \u003d\n           \"Application is in \" + state + \" state can not update timeout.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           msg);\n       throw RPCUtil.getRemoteException(msg);\n     }\n \n     try {\n-      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n+      applicationTimeouts \u003d rmAppManager.updateApplicationTimeout(application,\n+          applicationTimeouts);\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n         AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n+    response.setApplicationTimeouts(applicationTimeouts);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n      UpdateApplicationTimeoutsRequest request)\n      throws YarnException, IOException {\n\n    ApplicationId applicationId \u003d request.getApplicationId();\n    Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n        request.getApplicationTimeouts();\n\n    UserGroupInformation callerUGI \u003d\n        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n        AuditConstants.UPDATE_APP_TIMEOUTS, ApplicationAccessType.MODIFY_APP,\n        true);\n\n    if (applicationTimeouts.isEmpty()) {\n      String message \u003d\n          \"At least one ApplicationTimeoutType should be configured\"\n              + \" for updating timeouts.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          message, applicationId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    UpdateApplicationTimeoutsResponse response \u003d recordFactory\n        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n\n    RMAppState state \u003d application.getState();\n    if (!EnumSet\n        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n        .contains(state)) {\n      if (application.isAppInCompletedStates()) {\n        // If Application is in any of the final states, update timeout\n        // can be skipped rather throwing exception.\n        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n            AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n            applicationId);\n        response.setApplicationTimeouts(applicationTimeouts);\n        return response;\n      }\n      String msg \u003d\n          \"Application is in \" + state + \" state can not update timeout.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n\n    try {\n      applicationTimeouts \u003d rmAppManager.updateApplicationTimeout(application,\n          applicationTimeouts);\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n        AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n    response.setApplicationTimeouts(applicationTimeouts);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "cffea251be4b73ca16e5e11f0be2d22651330f73": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5956. Refactor ClientRMService for unify error handling across apis. Contributed by Kai Sasaki.\n",
      "commitDate": "25/03/17 9:56 AM",
      "commitName": "cffea251be4b73ca16e5e11f0be2d22651330f73",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/02/17 11:04 AM",
      "commitNameOld": "e0bb867c3fa638c9f689ee0b044b400481cf02b5",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 24.91,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n   public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n       UpdateApplicationTimeoutsRequest request)\n       throws YarnException, IOException {\n \n     ApplicationId applicationId \u003d request.getApplicationId();\n     Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n         request.getApplicationTimeouts();\n \n     UserGroupInformation callerUGI \u003d\n         getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n     RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n-        AuditConstants.UPDATE_APP_TIMEOUTS);\n+        AuditConstants.UPDATE_APP_TIMEOUTS, ApplicationAccessType.MODIFY_APP,\n+        true);\n \n     if (applicationTimeouts.isEmpty()) {\n       String message \u003d\n           \"At least one ApplicationTimeoutType should be configured\"\n               + \" for updating timeouts.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           message, applicationId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     UpdateApplicationTimeoutsResponse response \u003d recordFactory\n         .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n \n     RMAppState state \u003d application.getState();\n     if (!EnumSet\n         .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n         .contains(state)) {\n-      if (COMPLETED_APP_STATES.contains(state)) {\n+      if (application.isAppInCompletedStates()) {\n         // If Application is in any of the final states, update timeout\n         // can be skipped rather throwing exception.\n         RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n             AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n             applicationId);\n         return response;\n       }\n       String msg \u003d\n           \"Application is in \" + state + \" state can not update timeout.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           msg);\n       throw RPCUtil.getRemoteException(msg);\n     }\n \n     try {\n       rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n         AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n      UpdateApplicationTimeoutsRequest request)\n      throws YarnException, IOException {\n\n    ApplicationId applicationId \u003d request.getApplicationId();\n    Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n        request.getApplicationTimeouts();\n\n    UserGroupInformation callerUGI \u003d\n        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n        AuditConstants.UPDATE_APP_TIMEOUTS, ApplicationAccessType.MODIFY_APP,\n        true);\n\n    if (applicationTimeouts.isEmpty()) {\n      String message \u003d\n          \"At least one ApplicationTimeoutType should be configured\"\n              + \" for updating timeouts.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          message, applicationId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    UpdateApplicationTimeoutsResponse response \u003d recordFactory\n        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n\n    RMAppState state \u003d application.getState();\n    if (!EnumSet\n        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n        .contains(state)) {\n      if (application.isAppInCompletedStates()) {\n        // If Application is in any of the final states, update timeout\n        // can be skipped rather throwing exception.\n        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n            AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n            applicationId);\n        return response;\n      }\n      String msg \u003d\n          \"Application is in \" + state + \" state can not update timeout.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n\n    try {\n      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n        AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "1f12867a69544a1642aa986d4f9a8249be495434": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5649. Add REST endpoints for updating application timeouts. Contributed by Rohith Sharma K S\n",
      "commitDate": "23/11/16 4:25 PM",
      "commitName": "1f12867a69544a1642aa986d4f9a8249be495434",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/11/16 1:19 AM",
      "commitNameOld": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 1.63,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n       UpdateApplicationTimeoutsRequest request)\n       throws YarnException, IOException {\n \n     ApplicationId applicationId \u003d request.getApplicationId();\n     Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n         request.getApplicationTimeouts();\n \n     UserGroupInformation callerUGI \u003d\n         getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n     RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n         AuditConstants.UPDATE_APP_TIMEOUTS);\n \n     if (applicationTimeouts.isEmpty()) {\n       String message \u003d\n           \"At least one ApplicationTimeoutType should be configured\"\n               + \" for updating timeouts.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           message, applicationId);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     UpdateApplicationTimeoutsResponse response \u003d recordFactory\n         .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n \n     RMAppState state \u003d application.getState();\n     if (!EnumSet\n         .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n         .contains(state)) {\n       if (COMPLETED_APP_STATES.contains(state)) {\n         // If Application is in any of the final states, update timeout\n         // can be skipped rather throwing exception.\n         RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n             AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n             applicationId);\n         return response;\n       }\n       String msg \u003d\n           \"Application is in \" + state + \" state can not update timeout.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           msg);\n       throw RPCUtil.getRemoteException(msg);\n     }\n \n     try {\n       rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n-      throw RPCUtil.getRemoteException(ex);\n+      throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n         AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n      UpdateApplicationTimeoutsRequest request)\n      throws YarnException, IOException {\n\n    ApplicationId applicationId \u003d request.getApplicationId();\n    Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n        request.getApplicationTimeouts();\n\n    UserGroupInformation callerUGI \u003d\n        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n        AuditConstants.UPDATE_APP_TIMEOUTS);\n\n    if (applicationTimeouts.isEmpty()) {\n      String message \u003d\n          \"At least one ApplicationTimeoutType should be configured\"\n              + \" for updating timeouts.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          message, applicationId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    UpdateApplicationTimeoutsResponse response \u003d recordFactory\n        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n\n    RMAppState state \u003d application.getState();\n    if (!EnumSet\n        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n        .contains(state)) {\n      if (COMPLETED_APP_STATES.contains(state)) {\n        // If Application is in any of the final states, update timeout\n        // can be skipped rather throwing exception.\n        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n            AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n            applicationId);\n        return response;\n      }\n      String msg \u003d\n          \"Application is in \" + state + \" state can not update timeout.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n\n    try {\n      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n        AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "bcc15c6290b3912a054323695a6a931b0de163bd": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5611. Provide an API to update lifetime of an application. Contributed by Rohith Sharma K S\n",
      "commitDate": "09/11/16 4:08 PM",
      "commitName": "bcc15c6290b3912a054323695a6a931b0de163bd",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,59 @@\n+  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n+      UpdateApplicationTimeoutsRequest request)\n+      throws YarnException, IOException {\n+\n+    ApplicationId applicationId \u003d request.getApplicationId();\n+    Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n+        request.getApplicationTimeouts();\n+\n+    UserGroupInformation callerUGI \u003d\n+        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n+    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n+        AuditConstants.UPDATE_APP_TIMEOUTS);\n+\n+    if (applicationTimeouts.isEmpty()) {\n+      String message \u003d\n+          \"At least one ApplicationTimeoutType should be configured\"\n+              + \" for updating timeouts.\";\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n+          message, applicationId);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+\n+    UpdateApplicationTimeoutsResponse response \u003d recordFactory\n+        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n+\n+    RMAppState state \u003d application.getState();\n+    if (!EnumSet\n+        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n+        .contains(state)) {\n+      if (COMPLETED_APP_STATES.contains(state)) {\n+        // If Application is in any of the final states, update timeout\n+        // can be skipped rather throwing exception.\n+        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n+            AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n+            applicationId);\n+        return response;\n+      }\n+      String msg \u003d\n+          \"Application is in \" + state + \" state can not update timeout.\";\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n+          msg);\n+      throw RPCUtil.getRemoteException(msg);\n+    }\n+\n+    try {\n+      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n+    } catch (YarnException ex) {\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n+          ex.getMessage());\n+      throw RPCUtil.getRemoteException(ex);\n+    }\n+\n+    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n+        AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public UpdateApplicationTimeoutsResponse updateApplicationTimeouts(\n      UpdateApplicationTimeoutsRequest request)\n      throws YarnException, IOException {\n\n    ApplicationId applicationId \u003d request.getApplicationId();\n    Map\u003cApplicationTimeoutType, String\u003e applicationTimeouts \u003d\n        request.getApplicationTimeouts();\n\n    UserGroupInformation callerUGI \u003d\n        getCallerUgi(applicationId, AuditConstants.UPDATE_APP_TIMEOUTS);\n    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n        AuditConstants.UPDATE_APP_TIMEOUTS);\n\n    if (applicationTimeouts.isEmpty()) {\n      String message \u003d\n          \"At least one ApplicationTimeoutType should be configured\"\n              + \" for updating timeouts.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          message, applicationId);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    UpdateApplicationTimeoutsResponse response \u003d recordFactory\n        .newRecordInstance(UpdateApplicationTimeoutsResponse.class);\n\n    RMAppState state \u003d application.getState();\n    if (!EnumSet\n        .of(RMAppState.SUBMITTED, RMAppState.ACCEPTED, RMAppState.RUNNING)\n        .contains(state)) {\n      if (COMPLETED_APP_STATES.contains(state)) {\n        // If Application is in any of the final states, update timeout\n        // can be skipped rather throwing exception.\n        RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n            AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\",\n            applicationId);\n        return response;\n      }\n      String msg \u003d\n          \"Application is in \" + state + \" state can not update timeout.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          msg);\n      throw RPCUtil.getRemoteException(msg);\n    }\n\n    try {\n      rmAppManager.updateApplicationTimeout(application, applicationTimeouts);\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.UPDATE_APP_TIMEOUTS, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw RPCUtil.getRemoteException(ex);\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(),\n        AuditConstants.UPDATE_APP_TIMEOUTS, \"ClientRMService\", applicationId);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java"
    }
  }
}