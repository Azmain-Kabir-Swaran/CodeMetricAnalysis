{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StripedBlockReader.java",
  "functionName": "createBlockReader",
  "functionId": "createBlockReader___offsetInBlock-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
  "functionStartLine": 105,
  "functionEndLine": 139,
  "numCommitsSeen": 13,
  "timeTaken": 4782,
  "changeHistory": [
    "3f223bebfa6b382a762edcc518fcbae310ce22e5",
    "5d748bd056a32f2c6922514cd0c5b31d866a9919",
    "2ed9d61aadaffbf56ae0ed124520edab97646b49",
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
    "56a13a6a59cb128cf6fdac78a074faf7e5603967",
    "2ab1ef15c5e0b05fed5106d6bbecb3ead2b25f9a",
    "8b281bce85474501868d68f8d5590a6086abb7b7",
    "f308561f1d885491b88db73ac63003202056d661",
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f"
  ],
  "changeHistoryShort": {
    "3f223bebfa6b382a762edcc518fcbae310ce22e5": "Ybodychange",
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": "Ybodychange",
    "2ed9d61aadaffbf56ae0ed124520edab97646b49": "Ybodychange",
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ybodychange",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": "Ybodychange",
    "56a13a6a59cb128cf6fdac78a074faf7e5603967": "Ybodychange",
    "2ab1ef15c5e0b05fed5106d6bbecb3ead2b25f9a": "Ybodychange",
    "8b281bce85474501868d68f8d5590a6086abb7b7": "Ybodychange",
    "f308561f1d885491b88db73ac63003202056d661": "Ybodychange",
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3f223bebfa6b382a762edcc518fcbae310ce22e5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14844. Make buffer of BlockReaderRemote#newBlockReader#BufferedOutputStream configurable. Contributed by Lisheng Sun.\n",
      "commitDate": "20/09/19 11:45 AM",
      "commitName": "3f223bebfa6b382a762edcc518fcbae310ce22e5",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "08/10/18 8:31 PM",
      "commitNameOld": "08bb6c49a5aec32b7d9f29238560f947420405d6",
      "commitAuthorOld": "Hrishikesh Gadre",
      "daysBetweenCommits": 346.63,
      "commitsBetweenForRepo": 2685,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     Peer peer \u003d null;\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n           StorageType.EMPTY_ARRAY, new String[0]);\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n       peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n       if (peer.isLocal()) {\n         this.isLocal \u003d true;\n       }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n-          null, stripedReader.getCachingStrategy(), -1);\n+          null, stripedReader.getCachingStrategy(), -1, conf);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       IOUtils.closeStream(peer);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    Peer peer \u003d null;\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n          StorageType.EMPTY_ARRAY, new String[0]);\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), -1, conf);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      IOUtils.closeStream(peer);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13702. Remove HTrace hooks from DFSClient to reduce CPU usage. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 3:11 AM",
      "commitName": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/01/18 4:40 PM",
      "commitNameOld": "2ed9d61aadaffbf56ae0ed124520edab97646b49",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 163.4,
      "commitsBetweenForRepo": 1745,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     Peer peer \u003d null;\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n           StorageType.EMPTY_ARRAY, new String[0]);\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n       peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n       if (peer.isLocal()) {\n         this.isLocal \u003d true;\n       }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n-          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n+          null, stripedReader.getCachingStrategy(), -1);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       IOUtils.closeStream(peer);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    Peer peer \u003d null;\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n          StorageType.EMPTY_ARRAY, new String[0]);\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      IOUtils.closeStream(peer);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "2ed9d61aadaffbf56ae0ed124520edab97646b49": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13039. StripedBlockReader.createBlockReader leaks socket on IOException. (Lei (Eddy) Xu)\n",
      "commitDate": "19/01/18 4:40 PM",
      "commitName": "2ed9d61aadaffbf56ae0ed124520edab97646b49",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "05/05/17 12:01 PM",
      "commitNameOld": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 259.24,
      "commitsBetweenForRepo": 1768,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n+    Peer peer \u003d null;\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n           StorageType.EMPTY_ARRAY, new String[0]);\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n-      Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n+      peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n       if (peer.isLocal()) {\n         this.isLocal \u003d true;\n       }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n+      IOUtils.closeStream(peer);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    Peer peer \u003d null;\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n          StorageType.EMPTY_ARRAY, new String[0]);\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      IOUtils.closeStream(peer);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "25/04/17 11:57 PM",
      "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 9.5,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n-          StorageType.EMPTY_ARRAY);\n+          StorageType.EMPTY_ARRAY, new String[0]);\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n       Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n       if (peer.isLocal()) {\n         this.isLocal \u003d true;\n       }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n          StorageType.EMPTY_ARRAY, new String[0]);\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6708. StorageType should be encoded in the block token. Contributed by Ewan Higgs\n",
      "commitDate": "25/04/17 11:57 PM",
      "commitName": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "21/12/16 10:18 PM",
      "commitNameOld": "56a13a6a59cb128cf6fdac78a074faf7e5603967",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 125.03,
      "commitsBetweenForRepo": 655,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n-          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n+          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n+          StorageType.EMPTY_ARRAY);\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n       Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n       if (peer.isLocal()) {\n         this.isLocal \u003d true;\n       }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ),\n          StorageType.EMPTY_ARRAY);\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "56a13a6a59cb128cf6fdac78a074faf7e5603967": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11216. Add remoteBytesRead counter metrics for erasure coding reconstruction task. Contributed by Sammi Chen\n",
      "commitDate": "21/12/16 10:18 PM",
      "commitName": "56a13a6a59cb128cf6fdac78a074faf7e5603967",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "13/12/16 10:50 PM",
      "commitNameOld": "1f14f6d038aecad55a5398c6fa4137c9d2f44729",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 7.98,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n+      Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n+      if (peer.isLocal()) {\n+        this.isLocal \u003d true;\n+      }\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n-          block.getNumBytes() - offsetInBlock, true,\n-          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n+          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      Peer peer \u003d newConnectedPeer(block, dnAddr, blockToken, source);\n      if (peer.isLocal()) {\n        this.isLocal \u003d true;\n      }\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true, \"\", peer, source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "2ab1ef15c5e0b05fed5106d6bbecb3ead2b25f9a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10908. Improve StripedBlockReader#createBlockReader error logging. Contributed by Manoj Govindassamy.\n",
      "commitDate": "30/09/16 12:35 PM",
      "commitName": "2ab1ef15c5e0b05fed5106d6bbecb3ead2b25f9a",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "12/08/16 10:52 PM",
      "commitNameOld": "b5af9be72c72734d668f817c99d889031922a951",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 48.57,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n       return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true,\n           \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n-      LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n+      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true,\n          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.info(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "8b281bce85474501868d68f8d5590a6086abb7b7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10548. Remove the long deprecated BlockReaderRemote. Contributed by Kai Zheng\n",
      "commitDate": "02/07/16 8:56 PM",
      "commitName": "8b281bce85474501868d68f8d5590a6086abb7b7",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "25/04/16 12:01 PM",
      "commitNameOld": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 68.37,
      "commitsBetweenForRepo": 478,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n-      return BlockReaderRemote2.newBlockReader(\n+      return BlockReaderRemote.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true,\n           \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      return BlockReaderRemote.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true,\n          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/04/16 10:50 PM",
      "commitNameOld": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 18.55,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private BlockReader createBlockReader(long offsetInBlock) {\n     if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n       return null;\n     }\n     try {\n       InetSocketAddress dnAddr \u003d\n           stripedReader.getSocketAddress4Transfer(source);\n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n           block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n         /*\n          * This can be further improved if the replica is local, then we can\n          * read directly from DN and need to check the replica is FINALIZED\n          * state, notice we should not use short-circuit local read which\n          * requires config for domain-socket in UNIX or legacy config in\n          * Windows. The network distance value isn\u0027t used for this scenario.\n          *\n          * TODO: add proper tracer\n          */\n-      return RemoteBlockReader2.newBlockReader(\n+      return BlockReaderRemote2.newBlockReader(\n           \"dummy\", block, blockToken, offsetInBlock,\n           block.getNumBytes() - offsetInBlock, true,\n           \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n           null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n     } catch (IOException e) {\n       LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n           source, e);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      return BlockReaderRemote2.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true,\n          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java",
      "extendedDetails": {}
    },
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9719. Refactoring ErasureCodingWorker into smaller reusable constructs. Contributed by Kai Zheng.\n",
      "commitDate": "06/04/16 10:50 PM",
      "commitName": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,29 @@\n+  private BlockReader createBlockReader(long offsetInBlock) {\n+    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n+      return null;\n+    }\n+    try {\n+      InetSocketAddress dnAddr \u003d\n+          stripedReader.getSocketAddress4Transfer(source);\n+      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n+          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n+        /*\n+         * This can be further improved if the replica is local, then we can\n+         * read directly from DN and need to check the replica is FINALIZED\n+         * state, notice we should not use short-circuit local read which\n+         * requires config for domain-socket in UNIX or legacy config in\n+         * Windows. The network distance value isn\u0027t used for this scenario.\n+         *\n+         * TODO: add proper tracer\n+         */\n+      return RemoteBlockReader2.newBlockReader(\n+          \"dummy\", block, blockToken, offsetInBlock,\n+          block.getNumBytes() - offsetInBlock, true,\n+          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n+          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n+    } catch (IOException e) {\n+      LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n+          source, e);\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockReader createBlockReader(long offsetInBlock) {\n    if (offsetInBlock \u003e\u003d block.getNumBytes()) {\n      return null;\n    }\n    try {\n      InetSocketAddress dnAddr \u003d\n          stripedReader.getSocketAddress4Transfer(source);\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d datanode.getBlockAccessToken(\n          block, EnumSet.of(BlockTokenIdentifier.AccessMode.READ));\n        /*\n         * This can be further improved if the replica is local, then we can\n         * read directly from DN and need to check the replica is FINALIZED\n         * state, notice we should not use short-circuit local read which\n         * requires config for domain-socket in UNIX or legacy config in\n         * Windows. The network distance value isn\u0027t used for this scenario.\n         *\n         * TODO: add proper tracer\n         */\n      return RemoteBlockReader2.newBlockReader(\n          \"dummy\", block, blockToken, offsetInBlock,\n          block.getNumBytes() - offsetInBlock, true,\n          \"\", newConnectedPeer(block, dnAddr, blockToken, source), source,\n          null, stripedReader.getCachingStrategy(), datanode.getTracer(), -1);\n    } catch (IOException e) {\n      LOG.debug(\"Exception while creating remote block reader, datanode {}\",\n          source, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockReader.java"
    }
  }
}