{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RetriableFileCopyCommand.java",
  "functionName": "doCopy",
  "functionId": "doCopy___source-CopyListingFileStatus__target-Path__context-Mapper.Context__fileAttributes-EnumSet__FileAttribute____sourceStatus-FileStatus",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
  "functionStartLine": 126,
  "functionEndLine": 176,
  "numCommitsSeen": 70,
  "timeTaken": 7202,
  "changeHistory": [
    "c757cb61ebc9e69d9f6f143da91189b9f0517ee9",
    "51c64b357d4bd1a0038e61df3d4b8ea0a3ad7449",
    "c765584eb231f8482f5b90b7e8f61f9f7a931d09",
    "de804e53b9d20a2df75a4c7252bf83ed52011488",
    "bf3fb585aaf2b179836e139c041fc87920a3c886",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03",
    "5af572b6443715b7a741296c1bd520a1840f9a7c",
    "a1a0281e12ea96476e75b076f76d5b5eb5254eea",
    "3671a5e16fbddbe5a0516289ce98e1305e02291c",
    "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
    "e57843e02a846e5b3bb19c4bf9c3f61675d3e8ff",
    "b05c70bd9630af19300f221ae4f05d6a7ae15629",
    "6167123bcbb1ce01b7c626ad73269cd7b2df530c",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67"
  ],
  "changeHistoryShort": {
    "c757cb61ebc9e69d9f6f143da91189b9f0517ee9": "Ymultichange(Yparameterchange,Ybodychange)",
    "51c64b357d4bd1a0038e61df3d4b8ea0a3ad7449": "Ybodychange",
    "c765584eb231f8482f5b90b7e8f61f9f7a931d09": "Ybodychange",
    "de804e53b9d20a2df75a4c7252bf83ed52011488": "Ybodychange",
    "bf3fb585aaf2b179836e139c041fc87920a3c886": "Ybodychange",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": "Ybodychange",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": "Ybodychange",
    "5af572b6443715b7a741296c1bd520a1840f9a7c": "Ybodychange",
    "a1a0281e12ea96476e75b076f76d5b5eb5254eea": "Ymultichange(Yparameterchange,Ybodychange)",
    "3671a5e16fbddbe5a0516289ce98e1305e02291c": "Ybodychange",
    "067d52b98c1d17a73b142bb53acc8aaa9c041f38": "Ybodychange",
    "e57843e02a846e5b3bb19c4bf9c3f61675d3e8ff": "Ybodychange",
    "b05c70bd9630af19300f221ae4f05d6a7ae15629": "Ybodychange",
    "6167123bcbb1ce01b7c626ad73269cd7b2df530c": "Ybodychange",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c757cb61ebc9e69d9f6f143da91189b9f0517ee9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-14254. Add a Distcp option to preserve Erasure Coding attributes. Contributed by Ayush Saxena.\n",
      "commitDate": "13/05/20 12:01 PM",
      "commitName": "c757cb61ebc9e69d9f6f143da91189b9f0517ee9",
      "commitAuthor": "Ayush Saxena",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14254. Add a Distcp option to preserve Erasure Coding attributes. Contributed by Ayush Saxena.\n",
          "commitDate": "13/05/20 12:01 PM",
          "commitName": "c757cb61ebc9e69d9f6f143da91189b9f0517ee9",
          "commitAuthor": "Ayush Saxena",
          "commitDateOld": "02/01/20 7:36 AM",
          "commitNameOld": "b6dc00f481189821e5d982083eba6d01f108b3de",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 132.14,
          "commitsBetweenForRepo": 454,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n-      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n+      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes,\n+      FileStatus sourceStatus)\n       throws IOException {\n     LOG.info(\"Copying {} to {}\", source.getPath(), target);\n \n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n     Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n \n     LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n         : \"direct\", targetPath);\n \n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n           targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n-          offset, context, fileAttributes, sourceChecksum);\n+          offset, context, fileAttributes, sourceChecksum, sourceStatus);\n \n       if (!source.isSplit()) {\n         DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n                 sourcePath, sourceChecksum, targetFS,\n                 targetPath, skipCrc, source.getLen());\n       }\n       // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n       // write to a temporary file, then rename it to the target path.\n       if (useTempTarget) {\n         LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n             target);\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (useTempTarget) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes,\n      FileStatus sourceStatus)\n      throws IOException {\n    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n\n    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n        : \"direct\", targetPath);\n\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum, sourceStatus);\n\n      if (!source.isSplit()) {\n        DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n                sourcePath, sourceChecksum, targetFS,\n                targetPath, skipCrc, source.getLen());\n      }\n      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n      // write to a temporary file, then rename it to the target path.\n      if (useTempTarget) {\n        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n            target);\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (useTempTarget) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
          "extendedDetails": {
            "oldValue": "[source-CopyListingFileStatus, target-Path, context-Mapper.Context, fileAttributes-EnumSet\u003cFileAttribute\u003e]",
            "newValue": "[source-CopyListingFileStatus, target-Path, context-Mapper.Context, fileAttributes-EnumSet\u003cFileAttribute\u003e, sourceStatus-FileStatus]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14254. Add a Distcp option to preserve Erasure Coding attributes. Contributed by Ayush Saxena.\n",
          "commitDate": "13/05/20 12:01 PM",
          "commitName": "c757cb61ebc9e69d9f6f143da91189b9f0517ee9",
          "commitAuthor": "Ayush Saxena",
          "commitDateOld": "02/01/20 7:36 AM",
          "commitNameOld": "b6dc00f481189821e5d982083eba6d01f108b3de",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 132.14,
          "commitsBetweenForRepo": 454,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,51 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n-      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n+      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes,\n+      FileStatus sourceStatus)\n       throws IOException {\n     LOG.info(\"Copying {} to {}\", source.getPath(), target);\n \n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n     Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n \n     LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n         : \"direct\", targetPath);\n \n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n           targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n-          offset, context, fileAttributes, sourceChecksum);\n+          offset, context, fileAttributes, sourceChecksum, sourceStatus);\n \n       if (!source.isSplit()) {\n         DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n                 sourcePath, sourceChecksum, targetFS,\n                 targetPath, skipCrc, source.getLen());\n       }\n       // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n       // write to a temporary file, then rename it to the target path.\n       if (useTempTarget) {\n         LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n             target);\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (useTempTarget) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes,\n      FileStatus sourceStatus)\n      throws IOException {\n    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n\n    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n        : \"direct\", targetPath);\n\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum, sourceStatus);\n\n      if (!source.isSplit()) {\n        DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n                sourcePath, sourceChecksum, targetFS,\n                targetPath, skipCrc, source.getLen());\n      }\n      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n      // write to a temporary file, then rename it to the target path.\n      if (useTempTarget) {\n        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n            target);\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (useTempTarget) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
          "extendedDetails": {}
        }
      ]
    },
    "51c64b357d4bd1a0038e61df3d4b8ea0a3ad7449": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13660. DistCp job fails when new data is appended in the file while the DistCp copy job is running\n\nThis uses the length of the file known at the start of the copy to determine the amount of data to copy.\n\n* If a file is appended to during the copy, the original bytes are copied.\n* If a file is truncated during a copy, or the attempt to read the data fails with a truncated stream,\n  distcp will now fail. Until now these failures were not detected.\n\nContributed by Mukund Thakur.\n\nChange-Id: I576a49d951fa48d37a45a7e4c82c47488aa8e884\n",
      "commitDate": "24/09/19 3:23 AM",
      "commitName": "51c64b357d4bd1a0038e61df3d4b8ea0a3ad7449",
      "commitAuthor": "Mukund Thakur",
      "commitDateOld": "18/08/19 6:46 PM",
      "commitNameOld": "c765584eb231f8482f5b90b7e8f61f9f7a931d09",
      "commitAuthorOld": "KAI XIE",
      "daysBetweenCommits": 36.36,
      "commitsBetweenForRepo": 313,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     LOG.info(\"Copying {} to {}\", source.getPath(), target);\n \n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n     Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n \n     LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n         : \"direct\", targetPath);\n \n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n           targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n       if (!source.isSplit()) {\n-        DistCpUtils.compareFileLengthsAndChecksums(sourceFS, sourcePath,\n-            sourceChecksum, targetFS, targetPath, skipCrc);\n+        DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n+                sourcePath, sourceChecksum, targetFS,\n+                targetPath, skipCrc, source.getLen());\n       }\n       // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n       // write to a temporary file, then rename it to the target path.\n       if (useTempTarget) {\n         LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n             target);\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (useTempTarget) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n\n    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n        : \"direct\", targetPath);\n\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      if (!source.isSplit()) {\n        DistCpUtils.compareFileLengthsAndChecksums(source.getLen(), sourceFS,\n                sourcePath, sourceChecksum, targetFS,\n                targetPath, skipCrc, source.getLen());\n      }\n      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n      // write to a temporary file, then rename it to the target path.\n      if (useTempTarget) {\n        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n            target);\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (useTempTarget) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "c765584eb231f8482f5b90b7e8f61f9f7a931d09": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16158. DistCp to support checksum validation when copy blocks in parallel (#919)\n\n* DistCp to support checksum validation when copy blocks in parallel\r\n\r\n* address review comments\r\n\r\n* add checksums comparison test for combine mode\r\n",
      "commitDate": "18/08/19 6:46 PM",
      "commitName": "c765584eb231f8482f5b90b7e8f61f9f7a931d09",
      "commitAuthor": "KAI XIE",
      "commitDateOld": "07/02/19 2:07 AM",
      "commitNameOld": "de804e53b9d20a2df75a4c7252bf83ed52011488",
      "commitAuthorOld": "Andrew Olson",
      "daysBetweenCommits": 192.65,
      "commitsBetweenForRepo": 1483,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,49 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     LOG.info(\"Copying {} to {}\", source.getPath(), target);\n \n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n     Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n \n     LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n         : \"direct\", targetPath);\n \n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n           targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n       if (!source.isSplit()) {\n-        compareFileLengths(source, targetPath, configuration, bytesRead\n-            + offset);\n-      }\n-      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n-      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        if (!source.isSplit()) {\n-          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n-              targetFS, targetPath);\n-        }\n+        DistCpUtils.compareFileLengthsAndChecksums(sourceFS, sourcePath,\n+            sourceChecksum, targetFS, targetPath, skipCrc);\n       }\n       // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n       // write to a temporary file, then rename it to the target path.\n       if (useTempTarget) {\n         LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n             target);\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (useTempTarget) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n\n    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n        : \"direct\", targetPath);\n\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      if (!source.isSplit()) {\n        DistCpUtils.compareFileLengthsAndChecksums(sourceFS, sourcePath,\n            sourceChecksum, targetFS, targetPath, skipCrc);\n      }\n      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n      // write to a temporary file, then rename it to the target path.\n      if (useTempTarget) {\n        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n            target);\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (useTempTarget) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "de804e53b9d20a2df75a4c7252bf83ed52011488": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15281. Distcp to add no-rename copy option.\n\nContributed by Andrew Olson.\n",
      "commitDate": "07/02/19 2:07 AM",
      "commitName": "de804e53b9d20a2df75a4c7252bf83ed52011488",
      "commitAuthor": "Andrew Olson",
      "commitDateOld": "15/08/18 8:31 AM",
      "commitNameOld": "3e3963b035911703c61e6d9a2939eb894da5644c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 175.77,
      "commitsBetweenForRepo": 1362,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,56 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n+    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n+\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n-    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n+    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n+    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n+\n+    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n+        : \"direct\", targetPath);\n+\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n-        LOG.debug(\"Target file path: \" + targetPath);\n-      }\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n           targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n       if (!source.isSplit()) {\n         compareFileLengths(source, targetPath, configuration, bytesRead\n             + offset);\n       }\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n         if (!source.isSplit()) {\n           compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n               targetFS, targetPath);\n         }\n       }\n-      // it\u0027s not append case, thus we first write to a temporary file, rename\n-      // it to the target path.\n-      if (!toAppend) {\n+      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n+      // write to a temporary file, then rename it to the target path.\n+      if (useTempTarget) {\n+        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n+            target);\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n+      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n-      if (!toAppend) {\n+      if (useTempTarget) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    LOG.info(\"Copying {} to {}\", source.getPath(), target);\n\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    final boolean useTempTarget \u003d !toAppend \u0026\u0026 !directWrite;\n    Path targetPath \u003d useTempTarget ? getTempFile(target, context) : target;\n\n    LOG.info(\"Writing to {} target file path {}\", useTempTarget ? \"temporary\"\n        : \"direct\", targetPath);\n\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      if (!source.isSplit()) {\n        compareFileLengths(source, targetPath, configuration, bytesRead\n            + offset);\n      }\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        if (!source.isSplit()) {\n          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n              targetFS, targetPath);\n        }\n      }\n      // it\u0027s not append or direct write (preferred for s3a) case, thus we first\n      // write to a temporary file, then rename it to the target path.\n      if (useTempTarget) {\n        LOG.info(\"Renaming temporary target file path {} to {}\", targetPath,\n            target);\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      LOG.info(\"Completed writing {} ({} bytes)\", target, bytesRead);\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (useTempTarget) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "bf3fb585aaf2b179836e139c041fc87920a3c886": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen, Rosie Li.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,50 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n-      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n-          target).getLen() : 0;\n+      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n+          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n-      compareFileLengths(source, targetPath, configuration, bytesRead\n-          + offset);\n+      if (!source.isSplit()) {\n+        compareFileLengths(source, targetPath, configuration, bytesRead\n+            + offset);\n+      }\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n-            targetFS, targetPath);\n+        if (!source.isSplit()) {\n+          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n+              targetFS, targetPath);\n+        }\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (!toAppend) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      if (!source.isSplit()) {\n        compareFileLengths(source, targetPath, configuration, bytesRead\n            + offset);\n      }\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        if (!source.isSplit()) {\n          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n              targetFS, targetPath);\n        }\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\"\n\nThis reverts commit 064c8b25eca9bc825dc07a54d9147d65c9290a03.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:01 PM",
      "commitNameOld": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,46 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n-      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n-          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n+      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n+          target).getLen() : 0;\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n-      if (!source.isSplit()) {\n-        compareFileLengths(source, targetPath, configuration, bytesRead\n-            + offset);\n-      }\n+      compareFileLengths(source, targetPath, configuration, bytesRead\n+          + offset);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        if (!source.isSplit()) {\n-          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n-              targetFS, targetPath);\n-        }\n+        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n+            targetFS, targetPath);\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (!toAppend) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n          target).getLen() : 0;\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(source, targetPath, configuration, bytesRead\n          + offset);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n            targetFS, targetPath);\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "30/03/17 5:01 PM",
      "commitName": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "28/03/17 10:14 PM",
      "commitNameOld": "0e6f8e4bc6642f90dc7b33848bfb1129ec20ee49",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,50 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n-      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n-          target).getLen() : 0;\n+      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n+          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n-      compareFileLengths(source, targetPath, configuration, bytesRead\n-          + offset);\n+      if (!source.isSplit()) {\n+        compareFileLengths(source, targetPath, configuration, bytesRead\n+            + offset);\n+      }\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n-            targetFS, targetPath);\n+        if (!source.isSplit()) {\n+          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n+              targetFS, targetPath);\n+        }\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (!toAppend) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long offset \u003d (action \u003d\u003d FileAction.APPEND) ?\n          targetFS.getFileStatus(target).getLen() : source.getChunkOffset();\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      if (!source.isSplit()) {\n        compareFileLengths(source, targetPath, configuration, bytesRead\n            + offset);\n      }\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        if (!source.isSplit()) {\n          compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n              targetFS, targetPath);\n        }\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "5af572b6443715b7a741296c1bd520a1840f9a7c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13427. Eliminate needless uses of FileSystem#{exists(), isFile(), isDirectory()}. Contributed by Steve Loughran and Mingliang Liu\n",
      "commitDate": "15/11/16 10:57 AM",
      "commitName": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "24/10/16 12:46 PM",
      "commitNameOld": "a1a0281e12ea96476e75b076f76d5b5eb5254eea",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 21.97,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n       final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n           target).getLen() : 0;\n       long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n       compareFileLengths(source, targetPath, configuration, bytesRead\n           + offset);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n         compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n             targetFS, targetPath);\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n-      if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n+      if (!toAppend) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n          target).getLen() : 0;\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(source, targetPath, configuration, bytesRead\n          + offset);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n            targetFS, targetPath);\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "a1a0281e12ea96476e75b076f76d5b5eb5254eea": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13626. Remove distcp dependency on FileStatus serialization\n",
      "commitDate": "24/10/16 12:46 PM",
      "commitName": "a1a0281e12ea96476e75b076f76d5b5eb5254eea",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13626. Remove distcp dependency on FileStatus serialization\n",
          "commitDate": "24/10/16 12:46 PM",
          "commitName": "a1a0281e12ea96476e75b076f76d5b5eb5254eea",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "11/01/16 9:46 AM",
          "commitNameOld": "95f32015ad9273420299130a9f10acdbafe63556",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 287.08,
          "commitsBetweenForRepo": 2025,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,46 @@\n-  private long doCopy(FileStatus sourceFileStatus, Path target,\n+  private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n+        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n-      final Path sourcePath \u003d sourceFileStatus.getPath();\n+      final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n           target).getLen() : 0;\n-      long bytesRead \u003d copyToFile(targetPath, targetFS, sourceFileStatus,\n+      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n-      compareFileLengths(sourceFileStatus, targetPath, configuration, bytesRead\n+      compareFileLengths(source, targetPath, configuration, bytesRead\n           + offset);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n+        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n             targetFS, targetPath);\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n          target).getLen() : 0;\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(source, targetPath, configuration, bytesRead\n          + offset);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n            targetFS, targetPath);\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
          "extendedDetails": {
            "oldValue": "[sourceFileStatus-FileStatus, target-Path, context-Mapper.Context, fileAttributes-EnumSet\u003cFileAttribute\u003e]",
            "newValue": "[source-CopyListingFileStatus, target-Path, context-Mapper.Context, fileAttributes-EnumSet\u003cFileAttribute\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13626. Remove distcp dependency on FileStatus serialization\n",
          "commitDate": "24/10/16 12:46 PM",
          "commitName": "a1a0281e12ea96476e75b076f76d5b5eb5254eea",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "11/01/16 9:46 AM",
          "commitNameOld": "95f32015ad9273420299130a9f10acdbafe63556",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 287.08,
          "commitsBetweenForRepo": 2025,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,46 @@\n-  private long doCopy(FileStatus sourceFileStatus, Path target,\n+  private long doCopy(CopyListingFileStatus source, Path target,\n       Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n       throws IOException {\n     final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n     Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n+        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n         LOG.debug(\"Target file path: \" + targetPath);\n       }\n-      final Path sourcePath \u003d sourceFileStatus.getPath();\n+      final Path sourcePath \u003d source.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n       final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n           target).getLen() : 0;\n-      long bytesRead \u003d copyToFile(targetPath, targetFS, sourceFileStatus,\n+      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n           offset, context, fileAttributes, sourceChecksum);\n \n-      compareFileLengths(sourceFileStatus, targetPath, configuration, bytesRead\n+      compareFileLengths(source, targetPath, configuration, bytesRead\n           + offset);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n+        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n             targetFS, targetPath);\n       }\n       // it\u0027s not append case, thus we first write to a temporary file, rename\n       // it to the target path.\n       if (!toAppend) {\n         promoteTmpToTarget(targetPath, target, targetFS);\n       }\n       return bytesRead;\n     } finally {\n       // note that for append case, it is possible that we append partial data\n       // and then fail. In that case, for the next retry, we either reuse the\n       // partial appended data if it is good or we overwrite the whole file\n       if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n         targetFS.delete(targetPath, false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long doCopy(CopyListingFileStatus source, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + source.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d source.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n          target).getLen() : 0;\n      long bytesRead \u003d copyToFile(targetPath, targetFS, source,\n          offset, context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(source, targetPath, configuration, bytesRead\n          + offset);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, source.getPath(), sourceChecksum,\n            targetFS, targetPath);\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
          "extendedDetails": {}
        }
      ]
    },
    "3671a5e16fbddbe5a0516289ce98e1305e02291c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5899. Support incremental data copy in DistCp. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596931 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/05/14 11:17 AM",
      "commitName": "3671a5e16fbddbe5a0516289ce98e1305e02291c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/01/14 3:53 PM",
      "commitNameOld": "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 111.77,
      "commitsBetweenForRepo": 836,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,46 @@\n   private long doCopy(FileStatus sourceFileStatus, Path target,\n-                      Mapper.Context context,\n-                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n-          throws IOException {\n-\n-    Path tmpTargetPath \u003d getTmpFile(target, context);\n+      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n+      throws IOException {\n+    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n+    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n-        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n+        LOG.debug(\"Target file path: \" + targetPath);\n       }\n       final Path sourcePath \u003d sourceFileStatus.getPath();\n       final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n       final FileChecksum sourceChecksum \u003d fileAttributes\n           .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n           .getFileChecksum(sourcePath) : null;\n \n-      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n-          context, fileAttributes, sourceChecksum);\n+      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n+          target).getLen() : 0;\n+      long bytesRead \u003d copyToFile(targetPath, targetFS, sourceFileStatus,\n+          offset, context, fileAttributes, sourceChecksum);\n \n-      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration,\n-          bytesRead);\n+      compareFileLengths(sourceFileStatus, targetPath, configuration, bytesRead\n+          + offset);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n         compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n-            targetFS, tmpTargetPath);\n+            targetFS, targetPath);\n       }\n-      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n+      // it\u0027s not append case, thus we first write to a temporary file, rename\n+      // it to the target path.\n+      if (!toAppend) {\n+        promoteTmpToTarget(targetPath, target, targetFS);\n+      }\n       return bytesRead;\n-\n     } finally {\n-      if (targetFS.exists(tmpTargetPath))\n-        targetFS.delete(tmpTargetPath, false);\n+      // note that for append case, it is possible that we append partial data\n+      // and then fail. In that case, for the next retry, we either reuse the\n+      // partial appended data if it is good or we overwrite the whole file\n+      if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n+        targetFS.delete(targetPath, false);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n      Mapper.Context context, EnumSet\u003cFileAttribute\u003e fileAttributes)\n      throws IOException {\n    final boolean toAppend \u003d action \u003d\u003d FileAction.APPEND;\n    Path targetPath \u003d toAppend ? target : getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Target file path: \" + targetPath);\n      }\n      final Path sourcePath \u003d sourceFileStatus.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      final long offset \u003d action \u003d\u003d FileAction.APPEND ? targetFS.getFileStatus(\n          target).getLen() : 0;\n      long bytesRead \u003d copyToFile(targetPath, targetFS, sourceFileStatus,\n          offset, context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(sourceFileStatus, targetPath, configuration, bytesRead\n          + offset);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n            targetFS, targetPath);\n      }\n      // it\u0027s not append case, thus we first write to a temporary file, rename\n      // it to the target path.\n      if (!toAppend) {\n        promoteTmpToTarget(targetPath, target, targetFS);\n      }\n      return bytesRead;\n    } finally {\n      // note that for append case, it is possible that we append partial data\n      // and then fail. In that case, for the next retry, we either reuse the\n      // partial appended data if it is good or we overwrite the whole file\n      if (!toAppend \u0026\u0026 targetFS.exists(targetPath)) {\n        targetFS.delete(targetPath, false);\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "067d52b98c1d17a73b142bb53acc8aaa9c041f38": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10295. Allow distcp to automatically identify the checksum type of source files and use it for the target. Contributed by Jing Zhao and Laurent Goujon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563019 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 3:53 PM",
      "commitName": "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/12/13 7:47 AM",
      "commitNameOld": "9ea61e44153b938309841b1499488360e9abd176",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 56.34,
      "commitsBetweenForRepo": 291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,38 @@\n   private long doCopy(FileStatus sourceFileStatus, Path target,\n                       Mapper.Context context,\n                       EnumSet\u003cFileAttribute\u003e fileAttributes)\n           throws IOException {\n \n     Path tmpTargetPath \u003d getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n         LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n       }\n-      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n-              configuration);\n-      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n-                                     context, fileAttributes);\n+      final Path sourcePath \u003d sourceFileStatus.getPath();\n+      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n+      final FileChecksum sourceChecksum \u003d fileAttributes\n+          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n+          .getFileChecksum(sourcePath) : null;\n \n-      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n+      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n+          context, fileAttributes, sourceChecksum);\n+\n+      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration,\n+          bytesRead);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n       if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n-        compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n+        compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n+            targetFS, tmpTargetPath);\n       }\n       promoteTmpToTarget(tmpTargetPath, target, targetFS);\n       return bytesRead;\n \n     } finally {\n       if (targetFS.exists(tmpTargetPath))\n         targetFS.delete(tmpTargetPath, false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n                      Mapper.Context context,\n                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n          throws IOException {\n\n    Path tmpTargetPath \u003d getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n      }\n      final Path sourcePath \u003d sourceFileStatus.getPath();\n      final FileSystem sourceFS \u003d sourcePath.getFileSystem(configuration);\n      final FileChecksum sourceChecksum \u003d fileAttributes\n          .contains(FileAttribute.CHECKSUMTYPE) ? sourceFS\n          .getFileChecksum(sourcePath) : null;\n\n      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n          context, fileAttributes, sourceChecksum);\n\n      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration,\n          bytesRead);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, sourceFileStatus.getPath(), sourceChecksum,\n            targetFS, tmpTargetPath);\n      }\n      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n      return bytesRead;\n\n    } finally {\n      if (targetFS.exists(tmpTargetPath))\n        targetFS.delete(tmpTargetPath, false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "e57843e02a846e5b3bb19c4bf9c3f61675d3e8ff": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3054. distcp -skipcrccheck has no effect. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1381296 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/12 11:54 AM",
      "commitName": "e57843e02a846e5b3bb19c4bf9c3f61675d3e8ff",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/08/12 12:50 PM",
      "commitNameOld": "b05c70bd9630af19300f221ae4f05d6a7ae15629",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 20.96,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   private long doCopy(FileStatus sourceFileStatus, Path target,\n                       Mapper.Context context,\n                       EnumSet\u003cFileAttribute\u003e fileAttributes)\n           throws IOException {\n \n     Path tmpTargetPath \u003d getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n         LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n       }\n       FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n               configuration);\n       long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                      context, fileAttributes);\n \n       compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n-      if (bytesRead !\u003d 0) { \n+      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n         compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n       }\n       promoteTmpToTarget(tmpTargetPath, target, targetFS);\n       return bytesRead;\n \n     } finally {\n       if (targetFS.exists(tmpTargetPath))\n         targetFS.delete(tmpTargetPath, false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n                      Mapper.Context context,\n                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n          throws IOException {\n\n    Path tmpTargetPath \u003d getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n      }\n      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n              configuration);\n      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                     context, fileAttributes);\n\n      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if ((bytesRead !\u003d 0) \u0026\u0026 (!skipCrc)) {\n        compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n      }\n      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n      return bytesRead;\n\n    } finally {\n      if (targetFS.exists(tmpTargetPath))\n        targetFS.delete(tmpTargetPath, false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "b05c70bd9630af19300f221ae4f05d6a7ae15629": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8703: Fix formatting issue.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/08/12 12:50 PM",
      "commitName": "b05c70bd9630af19300f221ae4f05d6a7ae15629",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "15/08/12 12:16 PM",
      "commitNameOld": "6167123bcbb1ce01b7c626ad73269cd7b2df530c",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   private long doCopy(FileStatus sourceFileStatus, Path target,\n                       Mapper.Context context,\n                       EnumSet\u003cFileAttribute\u003e fileAttributes)\n           throws IOException {\n \n     Path tmpTargetPath \u003d getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n         LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n       }\n       FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n               configuration);\n       long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                      context, fileAttributes);\n \n       compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n       //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n-      if (bytesRead !\u003d 0) \n-          compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n+      if (bytesRead !\u003d 0) { \n+        compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n+      }\n       promoteTmpToTarget(tmpTargetPath, target, targetFS);\n       return bytesRead;\n \n     } finally {\n       if (targetFS.exists(tmpTargetPath))\n         targetFS.delete(tmpTargetPath, false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n                      Mapper.Context context,\n                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n          throws IOException {\n\n    Path tmpTargetPath \u003d getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n      }\n      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n              configuration);\n      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                     context, fileAttributes);\n\n      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if (bytesRead !\u003d 0) { \n        compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n      }\n      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n      return bytesRead;\n\n    } finally {\n      if (targetFS.exists(tmpTargetPath))\n        targetFS.delete(tmpTargetPath, false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "6167123bcbb1ce01b7c626ad73269cd7b2df530c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8703. distcpV2: turn CRC checking off for 0 byte size (Dave Thompson via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373581 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/08/12 12:16 PM",
      "commitName": "6167123bcbb1ce01b7c626ad73269cd7b2df530c",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "27/04/12 7:39 AM",
      "commitNameOld": "500dc615230f3010305a4318276bf7128d5cde18",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 110.19,
      "commitsBetweenForRepo": 577,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   private long doCopy(FileStatus sourceFileStatus, Path target,\n                       Mapper.Context context,\n                       EnumSet\u003cFileAttribute\u003e fileAttributes)\n           throws IOException {\n \n     Path tmpTargetPath \u003d getTmpFile(target, context);\n     final Configuration configuration \u003d context.getConfiguration();\n     FileSystem targetFS \u003d target.getFileSystem(configuration);\n \n     try {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n         LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n       }\n       FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n               configuration);\n       long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                      context, fileAttributes);\n \n       compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n-      compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n+      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n+      if (bytesRead !\u003d 0) \n+          compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n       promoteTmpToTarget(tmpTargetPath, target, targetFS);\n       return bytesRead;\n \n     } finally {\n       if (targetFS.exists(tmpTargetPath))\n         targetFS.delete(tmpTargetPath, false);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n                      Mapper.Context context,\n                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n          throws IOException {\n\n    Path tmpTargetPath \u003d getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n      }\n      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n              configuration);\n      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                     context, fileAttributes);\n\n      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n      //At this point, src\u0026dest lengths are same. if length\u003d\u003d0, we skip checksum\n      if (bytesRead !\u003d 0) \n          compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n      return bytesRead;\n\n    } finally {\n      if (targetFS.exists(tmpTargetPath))\n        targetFS.delete(tmpTargetPath, false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java",
      "extendedDetails": {}
    },
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2765. DistCp Rewrite. (Mithun Radhakrishnan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236045 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:36 PM",
      "commitName": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthor": "Mahadev Konar",
      "diff": "@@ -0,0 +1,29 @@\n+  private long doCopy(FileStatus sourceFileStatus, Path target,\n+                      Mapper.Context context,\n+                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n+          throws IOException {\n+\n+    Path tmpTargetPath \u003d getTmpFile(target, context);\n+    final Configuration configuration \u003d context.getConfiguration();\n+    FileSystem targetFS \u003d target.getFileSystem(configuration);\n+\n+    try {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n+        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n+      }\n+      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n+              configuration);\n+      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n+                                     context, fileAttributes);\n+\n+      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n+      compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n+      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n+      return bytesRead;\n+\n+    } finally {\n+      if (targetFS.exists(tmpTargetPath))\n+        targetFS.delete(tmpTargetPath, false);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long doCopy(FileStatus sourceFileStatus, Path target,\n                      Mapper.Context context,\n                      EnumSet\u003cFileAttribute\u003e fileAttributes)\n          throws IOException {\n\n    Path tmpTargetPath \u003d getTmpFile(target, context);\n    final Configuration configuration \u003d context.getConfiguration();\n    FileSystem targetFS \u003d target.getFileSystem(configuration);\n\n    try {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Copying \" + sourceFileStatus.getPath() + \" to \" + target);\n        LOG.debug(\"Tmp-file path: \" + tmpTargetPath);\n      }\n      FileSystem sourceFS \u003d sourceFileStatus.getPath().getFileSystem(\n              configuration);\n      long bytesRead \u003d copyToTmpFile(tmpTargetPath, targetFS, sourceFileStatus,\n                                     context, fileAttributes);\n\n      compareFileLengths(sourceFileStatus, tmpTargetPath, configuration, bytesRead);\n      compareCheckSums(sourceFS, sourceFileStatus.getPath(), targetFS, tmpTargetPath);\n      promoteTmpToTarget(tmpTargetPath, target, targetFS);\n      return bytesRead;\n\n    } finally {\n      if (targetFS.exists(tmpTargetPath))\n        targetFS.delete(tmpTargetPath, false);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/mapred/RetriableFileCopyCommand.java"
    }
  }
}