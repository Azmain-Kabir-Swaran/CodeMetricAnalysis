{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageFormat.java",
  "functionName": "loadINode",
  "functionId": "loadINode___localName-byte[](modifiers-final)__isSnapshotINode-boolean__in-DataInput__counter-Counter",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
  "functionStartLine": 730,
  "functionEndLine": 879,
  "numCommitsSeen": 180,
  "timeTaken": 10183,
  "changeHistory": [
    "164cbe643988f878f0f4100a4de51783e5b6738e",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
    "4fdd9abd7e43a0fb7b569982954a8f9660b9268b",
    "49d5cff49011cc0878665204e22b5c832bc914ce",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557",
    "cdc13efb1af54d931585d25c5ba696a012412828",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "c9103e9cacc67a614940e32fa87c5dbc3daa60de",
    "f6e1160ef1e946a5f6c9503b06832e6b84c36edb",
    "d0d75a833907f6cf723a42a007ca04e0004a8e52",
    "26971e52ae65590e618a23621be244e588845adc",
    "f2231cebcddc80f0b753c4a7cb45ee4040846951",
    "5dae97a584d30cef3e34141edfaca49c4ec57913",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0",
    "bb84f1fccb18c6c7373851e05d2451d55e908242",
    "e79c98c11fa8b4ddd8c63b613698d2d508135e83",
    "042b33f20b01aadb5cd03da731ae7a3d94026aac",
    "6f41baa6233dad92865af23ec6b7a89733c11ddd",
    "76a621ffd2d66bf012a554f4400091a92a5b473e",
    "1e89eba47d0f291b33fc26f9406231fc70b63a87",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a",
    "d03acc756094a332f98167426a39db8faf38f450",
    "14f1f76bf609704d36a1699c05fa85750cefe917",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "25e9d2e895cfa27ba45b429171abc2e077d7d5a5",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823",
    "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a",
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b",
    "ce68f410b05a58ad05965f32ad7f5b246b363a75",
    "aa002344d0466a62672eae73cdb2bb2ae7c19a72",
    "da8e962e39bd41b73b53966826c82e741b08010b",
    "0fa5cad0b27780c27a284c23101b1099d4886506"
  ],
  "changeHistoryShort": {
    "164cbe643988f878f0f4100a4de51783e5b6738e": "Ybodychange",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": "Ybodychange",
    "4fdd9abd7e43a0fb7b569982954a8f9660b9268b": "Ybodychange",
    "49d5cff49011cc0878665204e22b5c832bc914ce": "Ybodychange",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": "Ybodychange",
    "cdc13efb1af54d931585d25c5ba696a012412828": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "c9103e9cacc67a614940e32fa87c5dbc3daa60de": "Ybodychange",
    "f6e1160ef1e946a5f6c9503b06832e6b84c36edb": "Ybodychange",
    "d0d75a833907f6cf723a42a007ca04e0004a8e52": "Ybodychange",
    "26971e52ae65590e618a23621be244e588845adc": "Ybodychange",
    "f2231cebcddc80f0b753c4a7cb45ee4040846951": "Ybodychange",
    "5dae97a584d30cef3e34141edfaca49c4ec57913": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": "Ybodychange",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ybodychange",
    "e79c98c11fa8b4ddd8c63b613698d2d508135e83": "Ybodychange",
    "042b33f20b01aadb5cd03da731ae7a3d94026aac": "Ybodychange",
    "6f41baa6233dad92865af23ec6b7a89733c11ddd": "Ybodychange",
    "76a621ffd2d66bf012a554f4400091a92a5b473e": "Ybodychange",
    "1e89eba47d0f291b33fc26f9406231fc70b63a87": "Ybodychange",
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": "Ybodychange",
    "d03acc756094a332f98167426a39db8faf38f450": "Ybodychange",
    "14f1f76bf609704d36a1699c05fa85750cefe917": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "25e9d2e895cfa27ba45b429171abc2e077d7d5a5": "Ybodychange",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Ybodychange",
    "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a": "Ybodychange",
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b": "Ybodychange",
    "ce68f410b05a58ad05965f32ad7f5b246b363a75": "Ybodychange",
    "aa002344d0466a62672eae73cdb2bb2ae7c19a72": "Ybodychange",
    "da8e962e39bd41b73b53966826c82e741b08010b": "Ymultichange(Yparameterchange,Ybodychange)",
    "0fa5cad0b27780c27a284c23101b1099d4886506": "Ybodychange"
  },
  "changeHistoryDetails": {
    "164cbe643988f878f0f4100a4de51783e5b6738e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8909. Erasure coding: update BlockInfoContiguousUC and BlockInfoStripedUC to use BlockUnderConstructionFeature. Contributed by Jing Zhao.\n",
      "commitDate": "27/08/15 1:02 AM",
      "commitName": "164cbe643988f878f0f4100a4de51783e5b6738e",
      "commitAuthor": "Walter Su",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.5,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      Block[] blocks \u003d new BlockInfoContiguous[numBlocks];\n+      BlockInfo[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n-              Block lastBlk \u003d blocks[blocks.length - 1];\n-              blocks[blocks.length - 1] \u003d\n-                  new BlockInfoContiguousUnderConstruction(lastBlk, replication);\n+              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n+              lastBlk.convertToBlockUnderConstruction(\n+                  HdfsServerConstants.BlockUCState.UNDER_CONSTRUCTION, null);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, (BlockInfoContiguous[]) blocks,\n           replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n              lastBlk.convertToBlockUnderConstruction(\n                  HdfsServerConstants.BlockUCState.UNDER_CONSTRUCTION, null);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, (BlockInfoContiguous[]) blocks,\n          replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\"\n\nThis reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/06/15 11:38 AM",
      "commitNameOld": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 54.95,
      "commitsBetweenForRepo": 341,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,149 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n-              blocks[blocks.length - 1] \u003d\n-                  new BlockInfoUnderConstructionContiguous(\n-                      lastBlk, replication);\n+              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n+                  lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "4fdd9abd7e43a0fb7b569982954a8f9660b9268b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8787. Erasure coding: rename BlockInfoContiguousUC and BlockInfoStripedUC to be consistent with trunk.\n",
      "commitDate": "15/07/15 8:13 PM",
      "commitName": "4fdd9abd7e43a0fb7b569982954a8f9660b9268b",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "15/07/15 9:49 AM",
      "commitNameOld": "7e091de1366f4b57b5433bc19d738199dc05313d",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       Block[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               Block lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d\n-                  new BlockInfoContiguousUnderConstruction(lastBlk, replication);\n+                  new BlockInfoUnderConstructionContiguous(lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, (BlockInfoContiguous[]) blocks,\n           replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      Block[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              Block lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d\n                  new BlockInfoUnderConstructionContiguous(lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, (BlockInfoContiguous[]) blocks,\n          replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "49d5cff49011cc0878665204e22b5c832bc914ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8559. Erasure Coding: fix non-protobuf fsimage for striped blocks. (Jing Zhao via yliu)\n",
      "commitDate": "14/06/15 12:39 AM",
      "commitName": "49d5cff49011cc0878665204e22b5c832bc914ce",
      "commitAuthor": "yliu",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "c9103e9cacc67a614940e32fa87c5dbc3daa60de",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 18.53,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,150 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n-    final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n-            NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n-            \u0026\u0026 (in.readBoolean());\n     final int numBlocks \u003d in.readInt();\n-    // TODO: ECSchema can be restored from persisted file (HDFS-7859).\n-    final ECSchema schema \u003d isStriped ?\n-        ErasureCodingSchemaManager.getSystemDefaultSchema() : null;\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      Block[] blocks;\n-      if (isStriped) {\n-        blocks \u003d new Block[numBlocks];\n-        for (int j \u003d 0; j \u003c numBlocks; j++) {\n-          blocks[j] \u003d new BlockInfoStriped(new Block(), schema);\n-          blocks[j].readFields(in);\n-        }\n-      } else {\n-        blocks \u003d new BlockInfoContiguous[numBlocks];\n-        for (int j \u003d 0; j \u003c numBlocks; j++) {\n-          blocks[j] \u003d new BlockInfoContiguous(replication);\n-          blocks[j].readFields(in);\n-        }\n+      Block[] blocks \u003d new BlockInfoContiguous[numBlocks];\n+      for (int j \u003d 0; j \u003c numBlocks; j++) {\n+        blocks[j] \u003d new BlockInfoContiguous(replication);\n+        blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               Block lastBlk \u003d blocks[blocks.length - 1];\n-              if (isStriped){\n-                BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n-                blocks[blocks.length - 1]\n-                        \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n-                                lastStripedBlk.getSchema());\n-              } else {\n-                blocks[blocks.length - 1]\n-                        \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n-                                replication);\n-              }\n+              blocks[blocks.length - 1] \u003d\n+                  new BlockInfoContiguousUnderConstruction(lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n-      INodeFile file;\n-      if (isStriped) {\n-        file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n-            atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n-        file.addStripedBlocksFeature();\n-        for (Block block : blocks) {\n-          file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n-        }\n-      } else {\n-        file \u003d new INodeFile(inodeId, localName, permissions,\n-            modificationTime, atime, (BlockInfoContiguous[]) blocks,\n-            replication, blockSize);\n-      }\n+      INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n+          modificationTime, atime, (BlockInfoContiguous[]) blocks,\n+          replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      Block[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              Block lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d\n                  new BlockInfoContiguousUnderConstruction(lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, (BlockInfoContiguous[]) blocks,\n          replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\n",
      "commitDate": "12/06/15 11:38 AM",
      "commitName": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "01/06/15 11:42 AM",
      "commitNameOld": "cdc13efb1af54d931585d25c5ba696a012412828",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,150 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n-              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n-                  lastBlk, replication);\n+              blocks[blocks.length - 1] \u003d\n+                  new BlockInfoUnderConstructionContiguous(\n+                      lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d\n                  new BlockInfoUnderConstructionContiguous(\n                      lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "cdc13efb1af54d931585d25c5ba696a012412828": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8489. Subclass BlockInfo to represent contiguous blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "01/06/15 11:42 AM",
      "commitName": "cdc13efb1af54d931585d25c5ba696a012412828",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "27/05/15 3:42 PM",
      "commitNameOld": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n-        blocks[j] \u003d new BlockInfo(replication);\n+        blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/05/15 11:04 PM",
      "commitNameOld": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 18.69,
      "commitsBetweenForRepo": 146,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n+      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n-        blocks[j] \u003d new BlockInfoContiguous(replication);\n+        blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n-              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n+              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "c9103e9cacc67a614940e32fa87c5dbc3daa60de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8367 BlockInfoStriped uses EC schema. Contributed by Kai Sasaki\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "c9103e9cacc67a614940e32fa87c5dbc3daa60de",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "26/05/15 11:59 AM",
      "commitNameOld": "f6e1160ef1e946a5f6c9503b06832e6b84c36edb",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,183 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n             NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n             \u0026\u0026 (in.readBoolean());\n     final int numBlocks \u003d in.readInt();\n+    // TODO: ECSchema can be restored from persisted file (HDFS-7859).\n+    final ECSchema schema \u003d isStriped ?\n+        ErasureCodingSchemaManager.getSystemDefaultSchema() : null;\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       Block[] blocks;\n       if (isStriped) {\n         blocks \u003d new Block[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n-          blocks[j] \u003d new BlockInfoStriped(new Block(),\n-              HdfsConstants.NUM_DATA_BLOCKS, HdfsConstants.NUM_PARITY_BLOCKS);\n+          blocks[j] \u003d new BlockInfoStriped(new Block(), schema);\n           blocks[j].readFields(in);\n         }\n       } else {\n         blocks \u003d new BlockInfoContiguous[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfoContiguous(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               Block lastBlk \u003d blocks[blocks.length - 1];\n               if (isStriped){\n                 BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n                 blocks[blocks.length - 1]\n                         \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n-                                lastStripedBlk.getDataBlockNum(),\n-                                lastStripedBlk.getParityBlockNum());\n+                                lastStripedBlk.getSchema());\n               } else {\n                 blocks[blocks.length - 1]\n                         \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n                                 replication);\n               }\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       INodeFile file;\n       if (isStriped) {\n         file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n             atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n         file.addStripedBlocksFeature();\n         for (Block block : blocks) {\n           file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n         }\n       } else {\n         file \u003d new INodeFile(inodeId, localName, permissions,\n             modificationTime, atime, (BlockInfoContiguous[]) blocks,\n             replication, blockSize);\n       }\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n            NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n            \u0026\u0026 (in.readBoolean());\n    final int numBlocks \u003d in.readInt();\n    // TODO: ECSchema can be restored from persisted file (HDFS-7859).\n    final ECSchema schema \u003d isStriped ?\n        ErasureCodingSchemaManager.getSystemDefaultSchema() : null;\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      Block[] blocks;\n      if (isStriped) {\n        blocks \u003d new Block[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfoStriped(new Block(), schema);\n          blocks[j].readFields(in);\n        }\n      } else {\n        blocks \u003d new BlockInfoContiguous[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfoContiguous(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              Block lastBlk \u003d blocks[blocks.length - 1];\n              if (isStriped){\n                BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n                                lastStripedBlk.getSchema());\n              } else {\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n                                replication);\n              }\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file;\n      if (isStriped) {\n        file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n            atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n        file.addStripedBlocksFeature();\n        for (Block block : blocks) {\n          file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n        }\n      } else {\n        file \u003d new INodeFile(inodeId, localName, permissions,\n            modificationTime, atime, (BlockInfoContiguous[]) blocks,\n            replication, blockSize);\n      }\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "f6e1160ef1e946a5f6c9503b06832e6b84c36edb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8145. Fix the editlog corruption exposed by failed TestAddStripedBlocks. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:59 AM",
      "commitName": "f6e1160ef1e946a5f6c9503b06832e6b84c36edb",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:59 AM",
      "commitNameOld": "4c039b0876bb9399c2b4a751ad7b99b36349117b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,184 +1,182 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n             NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n             \u0026\u0026 (in.readBoolean());\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       Block[] blocks;\n       if (isStriped) {\n         blocks \u003d new Block[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n-          short dataBlockNum \u003d in.readShort();\n-          short parityBlockNum \u003d in.readShort();\n           blocks[j] \u003d new BlockInfoStriped(new Block(),\n-                  dataBlockNum, parityBlockNum);\n+              HdfsConstants.NUM_DATA_BLOCKS, HdfsConstants.NUM_PARITY_BLOCKS);\n           blocks[j].readFields(in);\n         }\n       } else {\n         blocks \u003d new BlockInfoContiguous[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfoContiguous(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               Block lastBlk \u003d blocks[blocks.length - 1];\n               if (isStriped){\n                 BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n                 blocks[blocks.length - 1]\n                         \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n                                 lastStripedBlk.getDataBlockNum(),\n                                 lastStripedBlk.getParityBlockNum());\n               } else {\n                 blocks[blocks.length - 1]\n                         \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n                                 replication);\n               }\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       INodeFile file;\n       if (isStriped) {\n         file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n             atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n         file.addStripedBlocksFeature();\n         for (Block block : blocks) {\n           file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n         }\n       } else {\n         file \u003d new INodeFile(inodeId, localName, permissions,\n             modificationTime, atime, (BlockInfoContiguous[]) blocks,\n             replication, blockSize);\n       }\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n            NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n            \u0026\u0026 (in.readBoolean());\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      Block[] blocks;\n      if (isStriped) {\n        blocks \u003d new Block[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfoStriped(new Block(),\n              HdfsConstants.NUM_DATA_BLOCKS, HdfsConstants.NUM_PARITY_BLOCKS);\n          blocks[j].readFields(in);\n        }\n      } else {\n        blocks \u003d new BlockInfoContiguous[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfoContiguous(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              Block lastBlk \u003d blocks[blocks.length - 1];\n              if (isStriped){\n                BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n                                lastStripedBlk.getDataBlockNum(),\n                                lastStripedBlk.getParityBlockNum());\n              } else {\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n                                replication);\n              }\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file;\n      if (isStriped) {\n        file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n            atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n        file.addStripedBlocksFeature();\n        for (Block block : blocks) {\n          file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n        }\n      } else {\n        file \u003d new INodeFile(inodeId, localName, permissions,\n            modificationTime, atime, (BlockInfoContiguous[]) blocks,\n            replication, blockSize);\n      }\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "d0d75a833907f6cf723a42a007ca04e0004a8e52": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7827. Erasure Coding: support striped blocks in non-protobuf fsimage. Contributed by Hui Zheng.\n",
      "commitDate": "26/05/15 11:43 AM",
      "commitName": "d0d75a833907f6cf723a42a007ca04e0004a8e52",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:32 AM",
      "commitNameOld": "1e1e93040748231dc913190aec1e031c379d8271",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,184 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n+    final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n+            NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n+            \u0026\u0026 (in.readBoolean());\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n-      for (int j \u003d 0; j \u003c numBlocks; j++) {\n-        blocks[j] \u003d new BlockInfoContiguous(replication);\n-        blocks[j].readFields(in);\n+      Block[] blocks;\n+      if (isStriped) {\n+        blocks \u003d new Block[numBlocks];\n+        for (int j \u003d 0; j \u003c numBlocks; j++) {\n+          short dataBlockNum \u003d in.readShort();\n+          short parityBlockNum \u003d in.readShort();\n+          blocks[j] \u003d new BlockInfoStriped(new Block(),\n+                  dataBlockNum, parityBlockNum);\n+          blocks[j].readFields(in);\n+        }\n+      } else {\n+        blocks \u003d new BlockInfoContiguous[numBlocks];\n+        for (int j \u003d 0; j \u003c numBlocks; j++) {\n+          blocks[j] \u003d new BlockInfoContiguous(replication);\n+          blocks[j].readFields(in);\n+        }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n-              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n-              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n-                  lastBlk, replication);\n+              Block lastBlk \u003d blocks[blocks.length - 1];\n+              if (isStriped){\n+                BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n+                blocks[blocks.length - 1]\n+                        \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n+                                lastStripedBlk.getDataBlockNum(),\n+                                lastStripedBlk.getParityBlockNum());\n+              } else {\n+                blocks[blocks.length - 1]\n+                        \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n+                                replication);\n+              }\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n-      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n-          modificationTime, atime, blocks, replication, blockSize);\n+      INodeFile file;\n+      if (isStriped) {\n+        file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n+            atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n+        file.addStripedBlocksFeature();\n+        for (Block block : blocks) {\n+          file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n+        }\n+      } else {\n+        file \u003d new INodeFile(inodeId, localName, permissions,\n+            modificationTime, atime, (BlockInfoContiguous[]) blocks,\n+            replication, blockSize);\n+      }\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n-        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n-      } else if (numBlocks \u003d\u003d -1) {\n-        //directory\n+      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n+    } else if (numBlocks \u003d\u003d -1) {\n+      //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n       if (!FileSystem.areSymlinksEnabled()) {\n         throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n       }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final boolean isStriped \u003d NameNodeLayoutVersion.supports(\n            NameNodeLayoutVersion.Feature.ERASURE_CODING, imgVersion)\n            \u0026\u0026 (in.readBoolean());\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      Block[] blocks;\n      if (isStriped) {\n        blocks \u003d new Block[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          short dataBlockNum \u003d in.readShort();\n          short parityBlockNum \u003d in.readShort();\n          blocks[j] \u003d new BlockInfoStriped(new Block(),\n                  dataBlockNum, parityBlockNum);\n          blocks[j].readFields(in);\n        }\n      } else {\n        blocks \u003d new BlockInfoContiguous[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfoContiguous(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              Block lastBlk \u003d blocks[blocks.length - 1];\n              if (isStriped){\n                BlockInfoStriped lastStripedBlk \u003d (BlockInfoStriped) lastBlk;\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoStripedUnderConstruction(lastBlk,\n                                lastStripedBlk.getDataBlockNum(),\n                                lastStripedBlk.getParityBlockNum());\n              } else {\n                blocks[blocks.length - 1]\n                        \u003d new BlockInfoContiguousUnderConstruction(lastBlk,\n                                replication);\n              }\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      INodeFile file;\n      if (isStriped) {\n        file \u003d new INodeFile(inodeId, localName, permissions, modificationTime,\n            atime, new BlockInfoContiguous[0], (short) 0, blockSize);\n        file.addStripedBlocksFeature();\n        for (Block block : blocks) {\n          file.getStripedBlocksFeature().addBlock((BlockInfoStriped) block);\n        }\n      } else {\n        file \u003d new INodeFile(inodeId, localName, permissions,\n            modificationTime, atime, (BlockInfoContiguous[]) blocks,\n            replication, blockSize);\n      }\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "26971e52ae65590e618a23621be244e588845adc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11852. Disable symlinks in trunk.\n",
      "commitDate": "23/04/15 11:47 AM",
      "commitName": "26971e52ae65590e618a23621be244e588845adc",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "20/03/15 12:02 PM",
      "commitNameOld": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 33.99,
      "commitsBetweenForRepo": 289,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,149 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n             nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n+      if (!FileSystem.areSymlinksEnabled()) {\n+        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n+      }\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n      if (!FileSystem.areSymlinksEnabled()) {\n        throw new IOException(\"Symlinks not supported - please remove symlink before upgrading to this version of HDFS\");\n      }\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "f2231cebcddc80f0b753c4a7cb45ee4040846951": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7775. Use consistent naming for NN-internal quota related types and functions. (Contributed bu Xiaoyu Yao)\n",
      "commitDate": "13/02/15 9:01 PM",
      "commitName": "f2231cebcddc80f0b753c4a7cb45ee4040846951",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "11/02/15 10:41 AM",
      "commitNameOld": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.43,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n-            nameSpaceQuota(nsQuota).spaceQuota(dsQuota).build());\n+            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).storageSpaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "5dae97a584d30cef3e34141edfaca49c4ec57913": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7723. Quota By Storage Type namenode implemenation. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "11/02/15 10:41 AM",
      "commitName": "5dae97a584d30cef3e34141edfaca49c4ec57913",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/02/15 11:51 AM",
      "commitNameOld": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,146 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n               blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n-        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n+        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n+            nameSpaceQuota(nsQuota).spaceQuota(dsQuota).build());\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(new DirectoryWithQuotaFeature.Builder().\n            nameSpaceQuota(nsQuota).spaceQuota(dsQuota).build());\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/12/14 3:13 PM",
      "commitNameOld": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 57.86,
      "commitsBetweenForRepo": 371,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n+      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n-        blocks[j] \u003d new BlockInfo(replication);\n+        blocks[j] \u003d new BlockInfoContiguous(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n-              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n-              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n+              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n+              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfoContiguous(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfoContiguous lastBlk \u003d blocks[blocks.length - 1];\n              blocks[blocks.length - 1] \u003d new BlockInfoContiguousUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7462. Consolidate implementation of mkdirs() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "02/12/14 2:53 PM",
      "commitName": "185e0c7b4c056b88f606362c71e4a22aae7076e0",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "25/11/14 3:37 PM",
      "commitNameOld": "f43a20c529ac3f104add95b222de6580757b3763",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n-        : namesystem.allocateNewInodeId();\n+        : namesystem.dir.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.dir.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "commitDateOld": "18/09/14 10:26 PM",
      "commitNameOld": "f8bbf80067ac03400acae4655615c9808c538ca8",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,145 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n-      // Images in the old format will not have the lazyPersist flag so it is\n-      // safe to pass false always.\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "e79c98c11fa8b4ddd8c63b613698d2d508135e83": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7091. Add forwarding constructor for INodeFile for existing callers. (Arpit Agarwal)\n",
      "commitDate": "18/09/14 7:20 PM",
      "commitName": "e79c98c11fa8b4ddd8c63b613698d2d508135e83",
      "commitAuthor": "arp",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "042b33f20b01aadb5cd03da731ae7a3d94026aac",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 21.9,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n \n       // Images in the old format will not have the lazyPersist flag so it is\n       // safe to pass false always.\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n-          modificationTime, atime, blocks, replication, blockSize, false);\n+          modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      // Images in the old format will not have the lazyPersist flag so it is\n      // safe to pass false always.\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "042b33f20b01aadb5cd03da731ae7a3d94026aac": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6922. Add LazyPersist flag to INodeFile, save it in FsImage and edit logs. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "042b33f20b01aadb5cd03da731ae7a3d94026aac",
      "commitAuthor": "arp",
      "commitDateOld": "24/07/14 4:42 PM",
      "commitNameOld": "e171254d56bfff467a67a6cf9160595c941f50c0",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 34.21,
      "commitsBetweenForRepo": 268,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,147 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n+\n+      // Images in the old format will not have the lazyPersist flag so it is\n+      // safe to pass false always.\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n-          modificationTime, atime, blocks, replication, blockSize);\n+          modificationTime, atime, blocks, replication, blockSize, false);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n\n      // Images in the old format will not have the lazyPersist flag so it is\n      // safe to pass false always.\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize, false);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "6f41baa6233dad92865af23ec6b7a89733c11ddd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6677. Change INodeFile and FSImage to support storage policy ID.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1610525 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 1:57 PM",
      "commitName": "6f41baa6233dad92865af23ec6b7a89733c11ddd",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/07/14 5:08 PM",
      "commitNameOld": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n-          modificationTime, atime, blocks, replication, blockSize);\n+          modificationTime, atime, blocks, replication, blockSize, (byte)0);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       if (snapshottable) {\n         dir.addSnapshottableFeature();\n       }\n       return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize, (byte)0);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "76a621ffd2d66bf012a554f4400091a92a5b473e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6609. Use DirectorySnapshottableFeature to represent a snapshottable directory. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1608631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 5:08 PM",
      "commitName": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/06/14 12:39 AM",
      "commitNameOld": "1e89eba47d0f291b33fc26f9406231fc70b63a87",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 15.69,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,144 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n-      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n+      if (snapshottable) {\n+        dir.addSnapshottableFeature();\n+      }\n+      return dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      if (snapshottable) {\n        dir.addSnapshottableFeature();\n      }\n      return dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "1e89eba47d0f291b33fc26f9406231fc70b63a87": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6583. Remove clientNode in FileUnderConstructionFeature. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604541 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/06/14 12:39 AM",
      "commitName": "1e89eba47d0f291b33fc26f9406231fc70b63a87",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "21/05/14 6:57 AM",
      "commitNameOld": "ac23a55547716df29b3e25c98a113399e184d9d1",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 31.74,
      "commitsBetweenForRepo": 189,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,141 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n-        file.toUnderConstruction(clientName, clientMachine, null);\n+        file.toUnderConstruction(clientName, clientMachine);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "f36f0dde8866e2233dad26b38a8d432d2302a51a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6276. Remove unnecessary conditions and null check. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589586 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/14 10:05 PM",
      "commitName": "f36f0dde8866e2233dad26b38a8d432d2302a51a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "23/04/14 1:13 PM",
      "commitNameOld": "876fd8ab7913a259ff9f69c16cc2d9af46ad3f9b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,141 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n         : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (NameNodeLayoutVersion.supports(\n         LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n-            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n+            if (blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n       }\n         return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else if (numBlocks \u003d\u003d -1) {\n         //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (NameNodeLayoutVersion.supports(\n           LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "d03acc756094a332f98167426a39db8faf38f450": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5914. Incorporate ACLs with the changes from HDFS-5698. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1566991 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/14 10:25 PM",
      "commitName": "d03acc756094a332f98167426a39db8faf38f450",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "09/02/14 11:45 AM",
      "commitNameOld": "2ed075e1bb085a2897fbefda53b1c1db54c81d92",
      "commitAuthorOld": "",
      "daysBetweenCommits": 1.44,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,135 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n       }\n-\n-      if (permissions.getPermission().getAclBit()) {\n-        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n-        if (aclFeature !\u003d null) {\n-          file.addAclFeature(aclFeature);\n-        }\n-      }\n-\n-      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n-\n-    } else if (numBlocks \u003d\u003d -1) {\n-      //directory\n+        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n+      } else if (numBlocks \u003d\u003d -1) {\n+        //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n-\n-      if (permissions.getPermission().getAclBit()) {\n-        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n-        if (aclFeature !\u003d null) {\n-          dir.addAclFeature(aclFeature);\n-        }\n-      }\n-\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n      }\n        return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else if (numBlocks \u003d\u003d -1) {\n        //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "14f1f76bf609704d36a1699c05fa85750cefe917": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5614. NameNode: implement handling of ACLs in combination with snapshots. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1563304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 2:21 PM",
      "commitName": "14f1f76bf609704d36a1699c05fa85750cefe917",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "17/01/14 10:50 PM",
      "commitNameOld": "8a9a6dbd7e8da2fff7e769b8f6a0aa220faad28f",
      "commitAuthorOld": "",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,152 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n       }\n \n-      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n-      if (aclFeature !\u003d null) {\n-        file.addAclFeature(aclFeature);\n+      if (permissions.getPermission().getAclBit()) {\n+        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n+        if (aclFeature !\u003d null) {\n+          file.addAclFeature(aclFeature);\n+        }\n       }\n \n       return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n \n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n \n-      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n-      if (aclFeature !\u003d null) {\n-        dir.addAclFeature(aclFeature);\n+      if (permissions.getPermission().getAclBit()) {\n+        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n+        if (aclFeature !\u003d null) {\n+          dir.addAclFeature(aclFeature);\n+        }\n       }\n \n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n      }\n\n      if (permissions.getPermission().getAclBit()) {\n        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n        if (aclFeature !\u003d null) {\n          file.addAclFeature(aclFeature);\n        }\n      }\n\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n\n      if (permissions.getPermission().getAclBit()) {\n        AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n        if (aclFeature !\u003d null) {\n          dir.addAclFeature(aclFeature);\n        }\n      }\n\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/01/14 5:32 PM",
      "commitNameOld": "a7ec44d41b0ad1fa133408a10caaae32a27ea569",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 14.08,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,143 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n-    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n+    if (NameNodeLayoutVersion.supports(\n+        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n-    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n-           in.readLong() : namesystem.allocateNewInodeId();\n+    long inodeId \u003d NameNodeLayoutVersion.supports(\n+        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n+        : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n-    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n+    if (NameNodeLayoutVersion.supports(\n+        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n-      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n+      if (NameNodeLayoutVersion.supports(\n+          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n           return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else {\n           return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n-      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n+      if (NameNodeLayoutVersion.supports(\n+          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n-      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n+      if (NameNodeLayoutVersion.supports(\n+          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.ADD_INODE_ID, imgVersion) ? in.readLong()\n        : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (NameNodeLayoutVersion.supports(\n        LayoutVersion.Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else {\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (NameNodeLayoutVersion.supports(\n          LayoutVersion.Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "25e9d2e895cfa27ba45b429171abc2e077d7d5a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5618. NameNode: persist ACLs in fsimage. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1553221 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/12/13 1:45 PM",
      "commitName": "25e9d2e895cfa27ba45b429171abc2e077d7d5a5",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 9.48,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,148 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n-          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n-      } else {\n-          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       }\n+\n+      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n+      if (aclFeature !\u003d null) {\n+        file.addAclFeature(aclFeature);\n+      }\n+\n+      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n+\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n+\n+      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n+      if (aclFeature !\u003d null) {\n+        dir.addAclFeature(aclFeature);\n+      }\n+\n       if (withSnapshot) {\n         dir.addSnapshotFeature(null);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n      }\n\n      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n      if (aclFeature !\u003d null) {\n        file.addAclFeature(aclFeature);\n      }\n\n      return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n\n      AclFeature aclFeature \u003d loadAclFeature(in, imgVersion);\n      if (aclFeature !\u003d null) {\n        dir.addAclFeature(aclFeature);\n      }\n\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/12/13 10:17 PM",
      "commitNameOld": "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n           return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else {\n           return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n-      return snapshottable ? new INodeDirectorySnapshottable(dir)\n-          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n-          : dir;\n+      if (withSnapshot) {\n+        dir.addSnapshotFeature(null);\n+      }\n+      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else {\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      if (withSnapshot) {\n        dir.addSnapshotFeature(null);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir) : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5554. Flatten INodeFile hierarchy: Replace INodeFileWithSnapshot with FileWithSnapshotFeature.  Contributed by jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548796 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/12/13 10:17 PM",
      "commitName": "4c87a27ad851ffaa3cc3e2074a9ef7073b5a164a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/11/13 12:32 PM",
      "commitNameOld": "8df119da214babde03e73243c7ca4cfe6d0ca562",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 9.41,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,136 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n-        return fileDiffs \u003d\u003d null ? file : new INodeFileWithSnapshot(file,\n-            fileDiffs);\n+          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       } else {\n-        return fileDiffs \u003d\u003d null ? file : \n-          new INodeFileWithSnapshot(file, fileDiffs);\n+          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n       }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n           permissions, modificationTime);\n       if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n         dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n       }\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      } else {\n          return fileDiffs \u003d\u003d null ? file : new INodeFile(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5286. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithQuota with DirectoryWithQuotaFeature.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/11/13 10:33 AM",
      "commitName": "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/11/13 5:39 PM",
      "commitNameOld": "ce68f410b05a58ad05965f32ad7f5b246b363a75",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.7,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,138 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n       for (int j \u003d 0; j \u003c numBlocks; j++) {\n         blocks[j] \u003d new BlockInfo(replication);\n         blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n         file.toUnderConstruction(clientName, clientMachine, null);\n         return fileDiffs \u003d\u003d null ? file : new INodeFileWithSnapshot(file,\n             fileDiffs);\n       } else {\n         return fileDiffs \u003d\u003d null ? file : \n           new INodeFileWithSnapshot(file, fileDiffs);\n       }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n-      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n-          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n-              modificationTime, nsQuota, dsQuota)\n-          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n+      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n+          permissions, modificationTime);\n+      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n+        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n+      }\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n        return fileDiffs \u003d\u003d null ? file : new INodeFileWithSnapshot(file,\n            fileDiffs);\n      } else {\n        return fileDiffs \u003d\u003d null ? file : \n          new INodeFileWithSnapshot(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d new INodeDirectory(inodeId, localName,\n          permissions, modificationTime);\n      if (nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0) {\n        dir.addDirectoryWithQuotaFeature(nsQuota, dsQuota);\n      }\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "ce68f410b05a58ad05965f32ad7f5b246b363a75": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5285. Flatten INodeFile hierarchy: Replace INodeFileUnderConstruction and INodeFileUnderConstructionWithSnapshot with FileUnderContructionFeature.  Contributed by jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544389 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 5:39 PM",
      "commitName": "ce68f410b05a58ad05965f32ad7f5b246b363a75",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "20/11/13 7:17 PM",
      "commitNameOld": "5f458ef23f097c784f12a973b326f7e1254ae0b2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,137 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n-      BlockInfo[] blocks \u003d null;\n-      if (numBlocks \u003e\u003d 0) {\n-        blocks \u003d new BlockInfo[numBlocks];\n-        for (int j \u003d 0; j \u003c numBlocks; j++) {\n-          blocks[j] \u003d new BlockInfo(replication);\n-          blocks[j].readFields(in);\n-        }\n+      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n+      for (int j \u003d 0; j \u003c numBlocks; j++) {\n+        blocks[j] \u003d new BlockInfo(replication);\n+        blocks[j].readFields(in);\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n             // convert the last block to BlockUC\n             if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n               BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n               blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                   lastBlk, replication);\n             }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       if (underConstruction) {\n-        INodeFileUnderConstruction fileUC \u003d new INodeFileUnderConstruction(\n-            file, clientName, clientMachine, null);\n-        return fileDiffs \u003d\u003d null ? fileUC :\n-          new INodeFileUnderConstructionWithSnapshot(fileUC, fileDiffs);\n+        file.toUnderConstruction(clientName, clientMachine, null);\n+        return fileDiffs \u003d\u003d null ? file : new INodeFileWithSnapshot(file,\n+            fileDiffs);\n       } else {\n         return fileDiffs \u003d\u003d null ? file : \n           new INodeFileWithSnapshot(file, fileDiffs);\n       }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n           new INodeDirectoryWithQuota(inodeId, localName, permissions,\n               modificationTime, nsQuota, dsQuota)\n           : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d new BlockInfo[numBlocks];\n      for (int j \u003d 0; j \u003c numBlocks; j++) {\n        blocks[j] \u003d new BlockInfo(replication);\n        blocks[j].readFields(in);\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        file.toUnderConstruction(clientName, clientMachine, null);\n        return fileDiffs \u003d\u003d null ? file : new INodeFileWithSnapshot(file,\n            fileDiffs);\n      } else {\n        return fileDiffs \u003d\u003d null ? file : \n          new INodeFileWithSnapshot(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n              modificationTime, nsQuota, dsQuota)\n          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "aa002344d0466a62672eae73cdb2bb2ae7c19a72": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5428. Under construction files deletion after snapshot+checkpoint+nn restart leads nn safemode. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543329 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 11:31 PM",
      "commitName": "aa002344d0466a62672eae73cdb2bb2ae7c19a72",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/11/13 2:10 PM",
      "commitNameOld": "8162fdcdbc23d749fdb188ae8419e173c59cb1ed",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 6.39,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,141 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d null;\n       if (numBlocks \u003e\u003d 0) {\n         blocks \u003d new BlockInfo[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfo(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n+            // convert the last block to BlockUC\n+            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n+              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n+              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n+                  lastBlk, replication);\n+            }\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n-      return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n-          : underConstruction? new INodeFileUnderConstruction(\n-              file, clientName, clientMachine, null)\n-          : file;\n+      if (underConstruction) {\n+        INodeFileUnderConstruction fileUC \u003d new INodeFileUnderConstruction(\n+            file, clientName, clientMachine, null);\n+        return fileDiffs \u003d\u003d null ? fileUC :\n+          new INodeFileUnderConstructionWithSnapshot(fileUC, fileDiffs);\n+      } else {\n+        return fileDiffs \u003d\u003d null ? file : \n+          new INodeFileWithSnapshot(file, fileDiffs);\n+      }\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n           new INodeDirectoryWithQuota(inodeId, localName, permissions,\n               modificationTime, nsQuota, dsQuota)\n           : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       if (counter !\u003d null) {\n         counter.increment();\n       }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       // Intentionally do not increment counter, because it is too difficult at\n       // this point to assess whether or not this is a reference that counts\n       // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d null;\n      if (numBlocks \u003e\u003d 0) {\n        blocks \u003d new BlockInfo[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfo(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n            // convert the last block to BlockUC\n            if (blocks !\u003d null \u0026\u0026 blocks.length \u003e 0) {\n              BlockInfo lastBlk \u003d blocks[blocks.length - 1]; \n              blocks[blocks.length - 1] \u003d new BlockInfoUnderConstruction(\n                  lastBlk, replication);\n            }\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      if (underConstruction) {\n        INodeFileUnderConstruction fileUC \u003d new INodeFileUnderConstruction(\n            file, clientName, clientMachine, null);\n        return fileDiffs \u003d\u003d null ? fileUC :\n          new INodeFileUnderConstructionWithSnapshot(fileUC, fileDiffs);\n      } else {\n        return fileDiffs \u003d\u003d null ? file : \n          new INodeFileWithSnapshot(file, fileDiffs);\n      }\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n              modificationTime, nsQuota, dsQuota)\n          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    },
    "da8e962e39bd41b73b53966826c82e741b08010b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:35 PM",
      "commitName": "da8e962e39bd41b73b53966826c82e741b08010b",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/13 10:35 PM",
          "commitName": "da8e962e39bd41b73b53966826c82e741b08010b",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "07/07/13 10:29 PM",
          "commitNameOld": "6770de7ec4f73e16740f1723f4e35d2fef2c22c8",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 3.0,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,130 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n-      DataInput in) throws IOException {\n+      DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d null;\n       if (numBlocks \u003e\u003d 0) {\n         blocks \u003d new BlockInfo[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfo(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n           : underConstruction? new INodeFileUnderConstruction(\n               file, clientName, clientMachine, null)\n           : file;\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n           new INodeDirectoryWithQuota(inodeId, localName, permissions,\n               modificationTime, nsQuota, dsQuota)\n           : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n+      // Intentionally do not increment counter, because it is too difficult at\n+      // this point to assess whether or not this is a reference that counts\n+      // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d null;\n      if (numBlocks \u003e\u003d 0) {\n        blocks \u003d new BlockInfo[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfo(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n          : underConstruction? new INodeFileUnderConstruction(\n              file, clientName, clientMachine, null)\n          : file;\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n              modificationTime, nsQuota, dsQuota)\n          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
          "extendedDetails": {
            "oldValue": "[localName-byte[](modifiers-final), isSnapshotINode-boolean, in-DataInput]",
            "newValue": "[localName-byte[](modifiers-final), isSnapshotINode-boolean, in-DataInput, counter-Counter]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/07/13 10:35 PM",
          "commitName": "da8e962e39bd41b73b53966826c82e741b08010b",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "07/07/13 10:29 PM",
          "commitNameOld": "6770de7ec4f73e16740f1723f4e35d2fef2c22c8",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 3.0,
          "commitsBetweenForRepo": 22,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,118 +1,130 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n-      DataInput in) throws IOException {\n+      DataInput in, Counter counter) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d null;\n       if (numBlocks \u003e\u003d 0) {\n         blocks \u003d new BlockInfo[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfo(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n           : underConstruction? new INodeFileUnderConstruction(\n               file, clientName, clientMachine, null)\n           : file;\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n           new INodeDirectoryWithQuota(inodeId, localName, permissions,\n               modificationTime, nsQuota, dsQuota)\n           : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n+      if (counter !\u003d null) {\n+        counter.increment();\n+      }\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n+      // Intentionally do not increment counter, because it is too difficult at\n+      // this point to assess whether or not this is a reference that counts\n+      // toward quota.\n       \n       final boolean isWithName \u003d in.readBoolean();\n       // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n       int snapshotId \u003d in.readInt();\n       \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n           return new INodeReference.WithName(null, withCount, localName,\n               snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n             withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in, Counter counter) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d null;\n      if (numBlocks \u003e\u003d 0) {\n        blocks \u003d new BlockInfo[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfo(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n          : underConstruction? new INodeFileUnderConstruction(\n              file, clientName, clientMachine, null)\n          : file;\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n              modificationTime, nsQuota, dsQuota)\n          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      if (counter !\u003d null) {\n        counter.increment();\n      }\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      // Intentionally do not increment counter, because it is too difficult at\n      // this point to assess whether or not this is a reference that counts\n      // toward quota.\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
          "extendedDetails": {}
        }
      ]
    },
    "0fa5cad0b27780c27a284c23101b1099d4886506": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4686. Update quota computation for rename and INodeReference.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1471647 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/13 1:31 PM",
      "commitName": "0fa5cad0b27780c27a284c23101b1099d4886506",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/04/13 5:11 PM",
      "commitNameOld": "10a2d82b45353ed3dbaa19d87c7e887c0afa2c57",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.85,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,118 @@\n   INode loadINode(final byte[] localName, boolean isSnapshotINode,\n       DataInput in) throws IOException {\n     final int imgVersion \u003d getLayoutVersion();\n     if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n       namesystem.getFSDirectory().verifyINodeName(localName);\n     }\n \n     long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n            in.readLong() : namesystem.allocateNewInodeId();\n     \n     final short replication \u003d namesystem.getBlockManager().adjustReplication(\n         in.readShort());\n     final long modificationTime \u003d in.readLong();\n     long atime \u003d 0;\n     if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n       atime \u003d in.readLong();\n     }\n     final long blockSize \u003d in.readLong();\n     final int numBlocks \u003d in.readInt();\n \n     if (numBlocks \u003e\u003d 0) {\n       // file\n       \n       // read blocks\n       BlockInfo[] blocks \u003d null;\n       if (numBlocks \u003e\u003d 0) {\n         blocks \u003d new BlockInfo[numBlocks];\n         for (int j \u003d 0; j \u003c numBlocks; j++) {\n           blocks[j] \u003d new BlockInfo(replication);\n           blocks[j].readFields(in);\n         }\n       }\n \n       String clientName \u003d \"\";\n       String clientMachine \u003d \"\";\n       boolean underConstruction \u003d false;\n       FileDiffList fileDiffs \u003d null;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         // read diffs\n         fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n \n         if (isSnapshotINode) {\n           underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             clientName \u003d FSImageSerialization.readString(in);\n             clientMachine \u003d FSImageSerialization.readString(in);\n           }\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       // return\n       final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n           modificationTime, atime, blocks, replication, blockSize);\n       return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n           : underConstruction? new INodeFileUnderConstruction(\n               file, clientName, clientMachine, null)\n           : file;\n     } else if (numBlocks \u003d\u003d -1) {\n       //directory\n       \n       //read quotas\n       final long nsQuota \u003d in.readLong();\n       long dsQuota \u003d -1L;\n       if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n         dsQuota \u003d in.readLong();\n       }\n \n       //read snapshot info\n       boolean snapshottable \u003d false;\n       boolean withSnapshot \u003d false;\n       if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n         snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           withSnapshot \u003d in.readBoolean();\n         }\n       }\n \n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n \n       //return\n       final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n           new INodeDirectoryWithQuota(inodeId, localName, permissions,\n               modificationTime, nsQuota, dsQuota)\n           : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n       return snapshottable ? new INodeDirectorySnapshottable(dir)\n           : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n           : dir;\n     } else if (numBlocks \u003d\u003d -2) {\n       //symlink\n \n       final String symlink \u003d Text.readString(in);\n       final PermissionStatus permissions \u003d PermissionStatus.read(in);\n       return new INodeSymlink(inodeId, localName, permissions,\n           modificationTime, atime, symlink);\n     } else if (numBlocks \u003d\u003d -3) {\n       //reference\n       \n       final boolean isWithName \u003d in.readBoolean();\n-      int dstSnapshotId \u003d Snapshot.INVALID_ID;\n-      if (!isWithName) {\n-        dstSnapshotId \u003d in.readInt();\n-      }\n+      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n+      int snapshotId \u003d in.readInt();\n+      \n       final INodeReference.WithCount withCount\n           \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n \n       if (isWithName) {\n-        return new INodeReference.WithName(null, withCount, localName);\n+          return new INodeReference.WithName(null, withCount, localName,\n+              snapshotId);\n       } else {\n         final INodeReference ref \u003d new INodeReference.DstReference(null,\n-            withCount, dstSnapshotId);\n-        withCount.setParentReference(ref);\n+            withCount, snapshotId);\n         return ref;\n       }\n     }\n     \n     throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  INode loadINode(final byte[] localName, boolean isSnapshotINode,\n      DataInput in) throws IOException {\n    final int imgVersion \u003d getLayoutVersion();\n    if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n      namesystem.getFSDirectory().verifyINodeName(localName);\n    }\n\n    long inodeId \u003d LayoutVersion.supports(Feature.ADD_INODE_ID, imgVersion) ? \n           in.readLong() : namesystem.allocateNewInodeId();\n    \n    final short replication \u003d namesystem.getBlockManager().adjustReplication(\n        in.readShort());\n    final long modificationTime \u003d in.readLong();\n    long atime \u003d 0;\n    if (LayoutVersion.supports(Feature.FILE_ACCESS_TIME, imgVersion)) {\n      atime \u003d in.readLong();\n    }\n    final long blockSize \u003d in.readLong();\n    final int numBlocks \u003d in.readInt();\n\n    if (numBlocks \u003e\u003d 0) {\n      // file\n      \n      // read blocks\n      BlockInfo[] blocks \u003d null;\n      if (numBlocks \u003e\u003d 0) {\n        blocks \u003d new BlockInfo[numBlocks];\n        for (int j \u003d 0; j \u003c numBlocks; j++) {\n          blocks[j] \u003d new BlockInfo(replication);\n          blocks[j].readFields(in);\n        }\n      }\n\n      String clientName \u003d \"\";\n      String clientMachine \u003d \"\";\n      boolean underConstruction \u003d false;\n      FileDiffList fileDiffs \u003d null;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        // read diffs\n        fileDiffs \u003d SnapshotFSImageFormat.loadFileDiffList(in, this);\n\n        if (isSnapshotINode) {\n          underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            clientName \u003d FSImageSerialization.readString(in);\n            clientMachine \u003d FSImageSerialization.readString(in);\n          }\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      // return\n      final INodeFile file \u003d new INodeFile(inodeId, localName, permissions,\n          modificationTime, atime, blocks, replication, blockSize);\n      return fileDiffs !\u003d null? new INodeFileWithSnapshot(file, fileDiffs)\n          : underConstruction? new INodeFileUnderConstruction(\n              file, clientName, clientMachine, null)\n          : file;\n    } else if (numBlocks \u003d\u003d -1) {\n      //directory\n      \n      //read quotas\n      final long nsQuota \u003d in.readLong();\n      long dsQuota \u003d -1L;\n      if (LayoutVersion.supports(Feature.DISKSPACE_QUOTA, imgVersion)) {\n        dsQuota \u003d in.readLong();\n      }\n\n      //read snapshot info\n      boolean snapshottable \u003d false;\n      boolean withSnapshot \u003d false;\n      if (LayoutVersion.supports(Feature.SNAPSHOT, imgVersion)) {\n        snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          withSnapshot \u003d in.readBoolean();\n        }\n      }\n\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n\n      //return\n      final INodeDirectory dir \u003d nsQuota \u003e\u003d 0 || dsQuota \u003e\u003d 0?\n          new INodeDirectoryWithQuota(inodeId, localName, permissions,\n              modificationTime, nsQuota, dsQuota)\n          : new INodeDirectory(inodeId, localName, permissions, modificationTime);\n      return snapshottable ? new INodeDirectorySnapshottable(dir)\n          : withSnapshot ? new INodeDirectoryWithSnapshot(dir)\n          : dir;\n    } else if (numBlocks \u003d\u003d -2) {\n      //symlink\n\n      final String symlink \u003d Text.readString(in);\n      final PermissionStatus permissions \u003d PermissionStatus.read(in);\n      return new INodeSymlink(inodeId, localName, permissions,\n          modificationTime, atime, symlink);\n    } else if (numBlocks \u003d\u003d -3) {\n      //reference\n      \n      final boolean isWithName \u003d in.readBoolean();\n      // lastSnapshotId for WithName node, dstSnapshotId for DstReference node\n      int snapshotId \u003d in.readInt();\n      \n      final INodeReference.WithCount withCount\n          \u003d referenceMap.loadINodeReferenceWithCount(isSnapshotINode, in, this);\n\n      if (isWithName) {\n          return new INodeReference.WithName(null, withCount, localName,\n              snapshotId);\n      } else {\n        final INodeReference ref \u003d new INodeReference.DstReference(null,\n            withCount, snapshotId);\n        return ref;\n      }\n    }\n    \n    throw new IOException(\"Unknown inode type: numBlocks\u003d\" + numBlocks);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageFormat.java",
      "extendedDetails": {}
    }
  }
}