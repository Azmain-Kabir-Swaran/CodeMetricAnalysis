{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryPlan.java",
  "functionName": "incrementAllocation",
  "functionId": "incrementAllocation___reservation-ReservationAllocation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
  "functionStartLine": 185,
  "functionEndLine": 245,
  "numCommitsSeen": 19,
  "timeTaken": 2948,
  "changeHistory": [
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "742632e346604fd2b263bd42367165638fcf2416",
    "da1016365aba1cee9c06771ab142d077379f27af",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168"
  ],
  "changeHistoryShort": {
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ybodychange",
    "da1016365aba1cee9c06771ab142d077379f27af": "Ybodychange",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ybodychange",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,61 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n-    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n-    if (resAlloc \u003d\u003d null) {\n-      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n-      userResourceAlloc.put(user, resAlloc);\n-    }\n+    long period \u003d reservation.getPeriodicity();\n+    RLESparseResourceAllocation resAlloc \u003d\n+        getUserRLEResourceAllocation(user, period);\n+\n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n     if (resCount \u003d\u003d null) {\n       resCount \u003d new RLESparseResourceAllocation(resCalc);\n       userActiveReservationCount.put(user, resCount);\n     }\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n \n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-      resAlloc.addInterval(r.getKey(), r.getValue());\n-      rleSparseVector.addInterval(r.getKey(), r.getValue());\n-      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-          ZERO_RESOURCE)) {\n-        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+\n+      if (period \u003e 0L) {\n+        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n+\n+          long rStart \u003d r.getKey().getStartTime() + i * period;\n+          long rEnd \u003d r.getKey().getEndTime() + i * period;\n+\n+          // handle wrap-around\n+          if (rEnd \u003e periodicRle.getTimePeriod()) {\n+            long diff \u003d rEnd - periodicRle.getTimePeriod();\n+            rEnd \u003d periodicRle.getTimePeriod();\n+            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n+            periodicRle.addInterval(newInterval, r.getValue());\n+            resAlloc.addInterval(newInterval, r.getValue());\n+          }\n+\n+          ReservationInterval newInterval \u003d\n+              new ReservationInterval(rStart, rEnd);\n+          periodicRle.addInterval(newInterval, r.getValue());\n+          resAlloc.addInterval(newInterval, r.getValue());\n+        }\n+\n+      } else {\n+        rleSparseVector.addInterval(r.getKey(), r.getValue());\n+        resAlloc.addInterval(r.getKey(), r.getValue());\n+        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+            ZERO_RESOURCE)) {\n+          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+        }\n       }\n     }\n+    // periodic reservations are active from start time and good till cancelled\n+    if (period \u003e 0L) {\n+      earliestActive \u003d reservation.getStartTime();\n+      latestActive \u003d Long.MAX_VALUE;\n+    }\n     resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n         Resource.newInstance(1, 1));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    long period \u003d reservation.getPeriodicity();\n    RLESparseResourceAllocation resAlloc \u003d\n        getUserRLEResourceAllocation(user, period);\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    if (resCount \u003d\u003d null) {\n      resCount \u003d new RLESparseResourceAllocation(resCalc);\n      userActiveReservationCount.put(user, resCount);\n    }\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n\n      if (period \u003e 0L) {\n        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n\n          long rStart \u003d r.getKey().getStartTime() + i * period;\n          long rEnd \u003d r.getKey().getEndTime() + i * period;\n\n          // handle wrap-around\n          if (rEnd \u003e periodicRle.getTimePeriod()) {\n            long diff \u003d rEnd - periodicRle.getTimePeriod();\n            rEnd \u003d periodicRle.getTimePeriod();\n            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n            periodicRle.addInterval(newInterval, r.getValue());\n            resAlloc.addInterval(newInterval, r.getValue());\n          }\n\n          ReservationInterval newInterval \u003d\n              new ReservationInterval(rStart, rEnd);\n          periodicRle.addInterval(newInterval, r.getValue());\n          resAlloc.addInterval(newInterval, r.getValue());\n        }\n\n      } else {\n        rleSparseVector.addInterval(r.getKey(), r.getValue());\n        resAlloc.addInterval(r.getKey(), r.getValue());\n        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n            ZERO_RESOURCE)) {\n          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n        }\n      }\n    }\n    // periodic reservations are active from start time and good till cancelled\n    if (period \u003e 0L) {\n      earliestActive \u003d reservation.getStartTime();\n      latestActive \u003d Long.MAX_VALUE;\n    }\n    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,33 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n-    long period \u003d reservation.getPeriodicity();\n-    RLESparseResourceAllocation resAlloc \u003d\n-        getUserRLEResourceAllocation(user, period);\n-\n+    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+    if (resAlloc \u003d\u003d null) {\n+      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n+      userResourceAlloc.put(user, resAlloc);\n+    }\n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n     if (resCount \u003d\u003d null) {\n       resCount \u003d new RLESparseResourceAllocation(resCalc);\n       userActiveReservationCount.put(user, resCount);\n     }\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n \n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-\n-      if (period \u003e 0L) {\n-        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n-\n-          long rStart \u003d r.getKey().getStartTime() + i * period;\n-          long rEnd \u003d r.getKey().getEndTime() + i * period;\n-\n-          // handle wrap-around\n-          if (rEnd \u003e periodicRle.getTimePeriod()) {\n-            long diff \u003d rEnd - periodicRle.getTimePeriod();\n-            rEnd \u003d periodicRle.getTimePeriod();\n-            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n-            periodicRle.addInterval(newInterval, r.getValue());\n-            resAlloc.addInterval(newInterval, r.getValue());\n-          }\n-\n-          ReservationInterval newInterval \u003d\n-              new ReservationInterval(rStart, rEnd);\n-          periodicRle.addInterval(newInterval, r.getValue());\n-          resAlloc.addInterval(newInterval, r.getValue());\n-        }\n-\n-      } else {\n-        rleSparseVector.addInterval(r.getKey(), r.getValue());\n-        resAlloc.addInterval(r.getKey(), r.getValue());\n-        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-            ZERO_RESOURCE)) {\n-          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n-        }\n+      resAlloc.addInterval(r.getKey(), r.getValue());\n+      rleSparseVector.addInterval(r.getKey(), r.getValue());\n+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+          ZERO_RESOURCE)) {\n+        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n       }\n     }\n-    // periodic reservations are active from start time and good till cancelled\n-    if (period \u003e 0L) {\n-      earliestActive \u003d reservation.getStartTime();\n-      latestActive \u003d Long.MAX_VALUE;\n-    }\n     resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n         Resource.newInstance(1, 1));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    if (resAlloc \u003d\u003d null) {\n      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n      userResourceAlloc.put(user, resAlloc);\n    }\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    if (resCount \u003d\u003d null) {\n      resCount \u003d new RLESparseResourceAllocation(resCalc);\n      userActiveReservationCount.put(user, resCount);\n    }\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.addInterval(r.getKey(), r.getValue());\n      rleSparseVector.addInterval(r.getKey(), r.getValue());\n      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n          ZERO_RESOURCE)) {\n        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n      }\n    }\n    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,61 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n-    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n-    if (resAlloc \u003d\u003d null) {\n-      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n-      userResourceAlloc.put(user, resAlloc);\n-    }\n+    long period \u003d reservation.getPeriodicity();\n+    RLESparseResourceAllocation resAlloc \u003d\n+        getUserRLEResourceAllocation(user, period);\n+\n     RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n     if (resCount \u003d\u003d null) {\n       resCount \u003d new RLESparseResourceAllocation(resCalc);\n       userActiveReservationCount.put(user, resCount);\n     }\n \n     long earliestActive \u003d Long.MAX_VALUE;\n     long latestActive \u003d Long.MIN_VALUE;\n \n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n-      resAlloc.addInterval(r.getKey(), r.getValue());\n-      rleSparseVector.addInterval(r.getKey(), r.getValue());\n-      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n-          ZERO_RESOURCE)) {\n-        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n-        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+\n+      if (period \u003e 0L) {\n+        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n+\n+          long rStart \u003d r.getKey().getStartTime() + i * period;\n+          long rEnd \u003d r.getKey().getEndTime() + i * period;\n+\n+          // handle wrap-around\n+          if (rEnd \u003e periodicRle.getTimePeriod()) {\n+            long diff \u003d rEnd - periodicRle.getTimePeriod();\n+            rEnd \u003d periodicRle.getTimePeriod();\n+            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n+            periodicRle.addInterval(newInterval, r.getValue());\n+            resAlloc.addInterval(newInterval, r.getValue());\n+          }\n+\n+          ReservationInterval newInterval \u003d\n+              new ReservationInterval(rStart, rEnd);\n+          periodicRle.addInterval(newInterval, r.getValue());\n+          resAlloc.addInterval(newInterval, r.getValue());\n+        }\n+\n+      } else {\n+        rleSparseVector.addInterval(r.getKey(), r.getValue());\n+        resAlloc.addInterval(r.getKey(), r.getValue());\n+        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+            ZERO_RESOURCE)) {\n+          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+        }\n       }\n     }\n+    // periodic reservations are active from start time and good till cancelled\n+    if (period \u003e 0L) {\n+      earliestActive \u003d reservation.getStartTime();\n+      latestActive \u003d Long.MAX_VALUE;\n+    }\n     resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n         Resource.newInstance(1, 1));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    long period \u003d reservation.getPeriodicity();\n    RLESparseResourceAllocation resAlloc \u003d\n        getUserRLEResourceAllocation(user, period);\n\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    if (resCount \u003d\u003d null) {\n      resCount \u003d new RLESparseResourceAllocation(resCalc);\n      userActiveReservationCount.put(user, resCount);\n    }\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n\n      if (period \u003e 0L) {\n        for (int i \u003d 0; i \u003c periodicRle.getTimePeriod() / period; i++) {\n\n          long rStart \u003d r.getKey().getStartTime() + i * period;\n          long rEnd \u003d r.getKey().getEndTime() + i * period;\n\n          // handle wrap-around\n          if (rEnd \u003e periodicRle.getTimePeriod()) {\n            long diff \u003d rEnd - periodicRle.getTimePeriod();\n            rEnd \u003d periodicRle.getTimePeriod();\n            ReservationInterval newInterval \u003d new ReservationInterval(0, diff);\n            periodicRle.addInterval(newInterval, r.getValue());\n            resAlloc.addInterval(newInterval, r.getValue());\n          }\n\n          ReservationInterval newInterval \u003d\n              new ReservationInterval(rStart, rEnd);\n          periodicRle.addInterval(newInterval, r.getValue());\n          resAlloc.addInterval(newInterval, r.getValue());\n        }\n\n      } else {\n        rleSparseVector.addInterval(r.getKey(), r.getValue());\n        resAlloc.addInterval(r.getKey(), r.getValue());\n        if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n            ZERO_RESOURCE)) {\n          earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n          latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n        }\n      }\n    }\n    // periodic reservations are active from start time and good till cancelled\n    if (period \u003e 0L) {\n      earliestActive \u003d reservation.getStartTime();\n      latestActive \u003d Long.MAX_VALUE;\n    }\n    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "21/11/15 9:59 AM",
      "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 14.48,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,33 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n     if (resAlloc \u003d\u003d null) {\n       resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n       userResourceAlloc.put(user, resAlloc);\n     }\n+    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n+    if (resCount \u003d\u003d null) {\n+      resCount \u003d new RLESparseResourceAllocation(resCalc);\n+      userActiveReservationCount.put(user, resCount);\n+    }\n+\n+    long earliestActive \u003d Long.MAX_VALUE;\n+    long latestActive \u003d Long.MIN_VALUE;\n+\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.addInterval(r.getKey(), r.getValue());\n       rleSparseVector.addInterval(r.getKey(), r.getValue());\n+      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n+          ZERO_RESOURCE)) {\n+        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n+        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n+      }\n     }\n+    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n+        Resource.newInstance(1, 1));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    if (resAlloc \u003d\u003d null) {\n      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n      userResourceAlloc.put(user, resAlloc);\n    }\n    RLESparseResourceAllocation resCount \u003d userActiveReservationCount.get(user);\n    if (resCount \u003d\u003d null) {\n      resCount \u003d new RLESparseResourceAllocation(resCalc);\n      userActiveReservationCount.put(user, resCount);\n    }\n\n    long earliestActive \u003d Long.MAX_VALUE;\n    long latestActive \u003d Long.MIN_VALUE;\n\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.addInterval(r.getKey(), r.getValue());\n      rleSparseVector.addInterval(r.getKey(), r.getValue());\n      if (Resources.greaterThan(resCalc, totalCapacity, r.getValue(),\n          ZERO_RESOURCE)) {\n        earliestActive \u003d Math.min(earliestActive, r.getKey().getStartTime());\n        latestActive \u003d Math.max(latestActive, r.getKey().getEndTime());\n      }\n    }\n    resCount.addInterval(new ReservationInterval(earliestActive, latestActive),\n        Resource.newInstance(1, 1));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "22/10/15 6:51 AM",
      "commitNameOld": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthorOld": "Anubhav Dhoot",
      "daysBetweenCommits": 30.17,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n     if (resAlloc \u003d\u003d null) {\n-      resAlloc \u003d new RLESparseResourceAllocation(resCalc, minAlloc);\n+      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n       userResourceAlloc.put(user, resAlloc);\n     }\n     for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.addInterval(r.getKey(), r.getValue());\n       rleSparseVector.addInterval(r.getKey(), r.getValue());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    if (resAlloc \u003d\u003d null) {\n      resAlloc \u003d new RLESparseResourceAllocation(resCalc);\n      userResourceAlloc.put(user, resAlloc);\n    }\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.addInterval(r.getKey(), r.getValue());\n      rleSparseVector.addInterval(r.getKey(), r.getValue());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 279.05,
      "commitsBetweenForRepo": 2291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n   private void incrementAllocation(ReservationAllocation reservation) {\n     assert (readWriteLock.isWriteLockedByCurrentThread());\n-    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         reservation.getAllocationRequests();\n     // check if we have encountered the user earlier and if not add an entry\n     String user \u003d reservation.getUser();\n     RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n     if (resAlloc \u003d\u003d null) {\n       resAlloc \u003d new RLESparseResourceAllocation(resCalc, minAlloc);\n       userResourceAlloc.put(user, resAlloc);\n     }\n-    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n+    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n         .entrySet()) {\n       resAlloc.addInterval(r.getKey(), r.getValue());\n       rleSparseVector.addInterval(r.getKey(), r.getValue());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    if (resAlloc \u003d\u003d null) {\n      resAlloc \u003d new RLESparseResourceAllocation(resCalc, minAlloc);\n      userResourceAlloc.put(user, resAlloc);\n    }\n    for (Map.Entry\u003cReservationInterval, Resource\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.addInterval(r.getKey(), r.getValue());\n      rleSparseVector.addInterval(r.getKey(), r.getValue());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1709. In-memory data structures used to track resources over time to enable reservations.\n(cherry picked from commit 0d8b2cd88b958b1e602fd4ea4078ef8d4742a7c3)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "cf4b34282aafee9f6b09d3433c4de1ae4b359168",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,17 @@\n+  private void incrementAllocation(ReservationAllocation reservation) {\n+    assert (readWriteLock.isWriteLockedByCurrentThread());\n+    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n+        reservation.getAllocationRequests();\n+    // check if we have encountered the user earlier and if not add an entry\n+    String user \u003d reservation.getUser();\n+    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n+    if (resAlloc \u003d\u003d null) {\n+      resAlloc \u003d new RLESparseResourceAllocation(resCalc, minAlloc);\n+      userResourceAlloc.put(user, resAlloc);\n+    }\n+    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n+        .entrySet()) {\n+      resAlloc.addInterval(r.getKey(), r.getValue());\n+      rleSparseVector.addInterval(r.getKey(), r.getValue());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void incrementAllocation(ReservationAllocation reservation) {\n    assert (readWriteLock.isWriteLockedByCurrentThread());\n    Map\u003cReservationInterval, ReservationRequest\u003e allocationRequests \u003d\n        reservation.getAllocationRequests();\n    // check if we have encountered the user earlier and if not add an entry\n    String user \u003d reservation.getUser();\n    RLESparseResourceAllocation resAlloc \u003d userResourceAlloc.get(user);\n    if (resAlloc \u003d\u003d null) {\n      resAlloc \u003d new RLESparseResourceAllocation(resCalc, minAlloc);\n      userResourceAlloc.put(user, resAlloc);\n    }\n    for (Map.Entry\u003cReservationInterval, ReservationRequest\u003e r : allocationRequests\n        .entrySet()) {\n      resAlloc.addInterval(r.getKey(), r.getValue());\n      rleSparseVector.addInterval(r.getKey(), r.getValue());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java"
    }
  }
}