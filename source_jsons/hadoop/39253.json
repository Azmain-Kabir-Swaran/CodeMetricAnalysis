{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "initScheduler",
  "functionId": "initScheduler___configuration-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 294,
  "functionEndLine": 394,
  "numCommitsSeen": 239,
  "timeTaken": 15364,
  "changeHistory": [
    "e575df5ca6f9630199b5c1696136184e88af3160",
    "5462d2176f7a64b236f06700cd247f946798cb26",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "3fa46394214181ed1cc7f06b886282bbdf67a10f",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
    "2d319e37937c1e20c6a7dc4477ef88defd1f8464",
    "1606dad133de0dbee59175509a22994ec570ea41",
    "042ef2fa7bcc22e3ca4eb8205c34d83e594bc7de",
    "09c5dfe937f0570cd9494b34d210df2d5f0737a7",
    "ef686635c1aa0cd4bd52ca212a95769f2532aa1a",
    "ef59cbe08aabe9844159cb4192d6345e4e3caab2",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
    "adb84f34db7e1cdcd72aa8e3deb464c48da9e353",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "a9c8ea71aa427ff5f25caec98be15bc880e578a7",
    "c39ca541f498712133890961598bbff50d89d68b",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "a4ba451802c6c61a0c804809740d46dd76059f25"
  ],
  "changeHistoryShort": {
    "e575df5ca6f9630199b5c1696136184e88af3160": "Yexceptionschange",
    "5462d2176f7a64b236f06700cd247f946798cb26": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "3fa46394214181ed1cc7f06b886282bbdf67a10f": "Ybodychange",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Ybodychange",
    "2d319e37937c1e20c6a7dc4477ef88defd1f8464": "Ybodychange",
    "1606dad133de0dbee59175509a22994ec570ea41": "Ybodychange",
    "042ef2fa7bcc22e3ca4eb8205c34d83e594bc7de": "Ybodychange",
    "09c5dfe937f0570cd9494b34d210df2d5f0737a7": "Ybodychange",
    "ef686635c1aa0cd4bd52ca212a95769f2532aa1a": "Ybodychange",
    "ef59cbe08aabe9844159cb4192d6345e4e3caab2": "Ybodychange",
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": "Ybodychange",
    "adb84f34db7e1cdcd72aa8e3deb464c48da9e353": "Ybodychange",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Ybodychange",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Ymodifierchange,Ybodychange)",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "a9c8ea71aa427ff5f25caec98be15bc880e578a7": "Ybodychange",
    "c39ca541f498712133890961598bbff50d89d68b": "Ybodychange",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "a4ba451802c6c61a0c804809740d46dd76059f25": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e575df5ca6f9630199b5c1696136184e88af3160": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-10006. IOException used in place of YARNException in CapaitySheduler\n\nContributed by Adam Antal. Reviewed by Szilard Nemeth.\n",
      "commitDate": "05/12/19 11:21 PM",
      "commitName": "e575df5ca6f9630199b5c1696136184e88af3160",
      "commitAuthor": "prabhujoseph",
      "commitDateOld": "22/11/19 12:06 AM",
      "commitNameOld": "8afabe41e4175551ae71217a45f7c4276f10b7da",
      "commitAuthorOld": "Tao Yang",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   void initScheduler(Configuration configuration) throws\n-      IOException {\n+      IOException, YarnException {\n     writeLock.lock();\n     try {\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DominantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.workflowPriorityMappingsMgr \u003d new WorkflowPriorityMappingsManager();\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n         asyncMaxPendingBacklogs \u003d this.conf.getInt(\n             CapacitySchedulerConfiguration.\n                 SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n             CapacitySchedulerConfiguration.\n                 DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       // Register CS specific multi-node policies to common MultiNodeManager\n       // which will add to a MultiNodeSorter which gives a pre-sorted list of\n       // nodes to scheduler\u0027s allocation.\n       multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n       if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n         rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n             multiNodePlacementEnabled,\n             this.conf.getMultiNodePlacementPolicies());\n       }\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n           + multiNodePlacementEnabled);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException, YarnException {\n    writeLock.lock();\n    try {\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DominantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.workflowPriorityMappingsMgr \u003d new WorkflowPriorityMappingsManager();\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      // Register CS specific multi-node policies to common MultiNodeManager\n      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n      // nodes to scheduler\u0027s allocation.\n      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n            multiNodePlacementEnabled,\n            this.conf.getMultiNodePlacementPolicies());\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n          + multiNodePlacementEnabled);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldValue": "[IOException]",
        "newValue": "[IOException, YarnException]"
      }
    },
    "5462d2176f7a64b236f06700cd247f946798cb26": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9760. Support configuring application priorities on a workflow level. Contributed by Varun Saxena\n",
      "commitDate": "08/10/19 11:20 AM",
      "commitName": "5462d2176f7a64b236f06700cd247f946798cb26",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "31/08/19 9:24 PM",
      "commitNameOld": "d2d963f3d4819704351c04dbeb90fc8154488f91",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 37.58,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,101 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     writeLock.lock();\n     try {\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DominantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n+      this.workflowPriorityMappingsMgr \u003d new WorkflowPriorityMappingsManager();\n+\n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n         asyncMaxPendingBacklogs \u003d this.conf.getInt(\n             CapacitySchedulerConfiguration.\n                 SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n             CapacitySchedulerConfiguration.\n                 DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       // Register CS specific multi-node policies to common MultiNodeManager\n       // which will add to a MultiNodeSorter which gives a pre-sorted list of\n       // nodes to scheduler\u0027s allocation.\n       multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n       if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n         rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n             multiNodePlacementEnabled,\n             this.conf.getMultiNodePlacementPolicies());\n       }\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n           + multiNodePlacementEnabled);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    writeLock.lock();\n    try {\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DominantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.workflowPriorityMappingsMgr \u003d new WorkflowPriorityMappingsManager();\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      // Register CS specific multi-node policies to common MultiNodeManager\n      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n      // nodes to scheduler\u0027s allocation.\n      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n            multiNodePlacementEnabled,\n            this.conf.getMultiNodePlacementPolicies());\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n          + multiNodePlacementEnabled);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DominantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n         asyncMaxPendingBacklogs \u003d this.conf.getInt(\n             CapacitySchedulerConfiguration.\n                 SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n             CapacitySchedulerConfiguration.\n                 DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       // Register CS specific multi-node policies to common MultiNodeManager\n       // which will add to a MultiNodeSorter which gives a pre-sorted list of\n       // nodes to scheduler\u0027s allocation.\n       multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n       if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n         rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n             multiNodePlacementEnabled,\n             this.conf.getMultiNodePlacementPolicies());\n       }\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n           + multiNodePlacementEnabled);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    writeLock.lock();\n    try {\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DominantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      // Register CS specific multi-node policies to common MultiNodeManager\n      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n      // nodes to scheduler\u0027s allocation.\n      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n            multiNodePlacementEnabled,\n            this.conf.getMultiNodePlacementPolicies());\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n          + multiNodePlacementEnabled);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3fa46394214181ed1cc7f06b886282bbdf67a10f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8723. Fix a typo in CS init error message when resource calculator is not correctly set. Contributed by Abhishek Modi.\n",
      "commitDate": "28/08/18 8:13 PM",
      "commitName": "3fa46394214181ed1cc7f06b886282bbdf67a10f",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "21/08/18 7:42 AM",
      "commitNameOld": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 7.52,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n-            + \" DomainantResourceCalculator instead to make effective use of\"\n+            + \" DominantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n         asyncMaxPendingBacklogs \u003d this.conf.getInt(\n             CapacitySchedulerConfiguration.\n                 SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n             CapacitySchedulerConfiguration.\n                 DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       // Register CS specific multi-node policies to common MultiNodeManager\n       // which will add to a MultiNodeSorter which gives a pre-sorted list of\n       // nodes to scheduler\u0027s allocation.\n       multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n       if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n         rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n             multiNodePlacementEnabled,\n             this.conf.getMultiNodePlacementPolicies());\n       }\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n           + multiNodePlacementEnabled);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DominantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      // Register CS specific multi-node policies to common MultiNodeManager\n      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n      // nodes to scheduler\u0027s allocation.\n      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n            multiNodePlacementEnabled,\n            this.conf.getMultiNodePlacementPolicies());\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n          + multiNodePlacementEnabled);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "31/07/18 8:03 PM",
      "commitNameOld": "6310c0d17d6422a595f856a55b4f1fb82be43739",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 20.49,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,99 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DomainantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n         asyncMaxPendingBacklogs \u003d this.conf.getInt(\n             CapacitySchedulerConfiguration.\n                 SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n             CapacitySchedulerConfiguration.\n                 DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n+      // Register CS specific multi-node policies to common MultiNodeManager\n+      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n+      // nodes to scheduler\u0027s allocation.\n+      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n+      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n+        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n+            multiNodePlacementEnabled,\n+            this.conf.getMultiNodePlacementPolicies());\n+      }\n+\n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n-          + asyncScheduleInterval + \"ms\");\n+          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n+          + multiNodePlacementEnabled);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DomainantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      // Register CS specific multi-node policies to common MultiNodeManager\n      // which will add to a MultiNodeSorter which gives a pre-sorted list of\n      // nodes to scheduler\u0027s allocation.\n      multiNodePlacementEnabled \u003d this.conf.getMultiNodePlacementEnabled();\n      if(rmContext.getMultiNodeSortingManager() !\u003d null) {\n        rmContext.getMultiNodeSortingManager().registerMultiNodePolicyNames(\n            multiNodePlacementEnabled,\n            this.conf.getMultiNodePlacementPolicies());\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\" + \",multiNodePlacementEnabled\u003d\"\n          + multiNodePlacementEnabled);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "2d319e37937c1e20c6a7dc4477ef88defd1f8464": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8212. Pending backlog for async allocation threads should be configurable. Contributed by Tao Yang.\n",
      "commitDate": "30/04/18 6:47 PM",
      "commitName": "2d319e37937c1e20c6a7dc4477ef88defd1f8464",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "09/04/18 8:47 AM",
      "commitNameOld": "821b0de4c59156d4a65112de03ba3e7e1c88e309",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 21.42,
      "commitsBetweenForRepo": 665,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,88 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n       case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DomainantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n+        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n+            CapacitySchedulerConfiguration.\n+                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n+            CapacitySchedulerConfiguration.\n+                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DomainantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n        asyncMaxPendingBacklogs \u003d this.conf.getInt(\n            CapacitySchedulerConfiguration.\n                SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS,\n            CapacitySchedulerConfiguration.\n                DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "1606dad133de0dbee59175509a22994ec570ea41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7497. Add file system based scheduler configuration store. Contributed by Jiandan Yang.\n",
      "commitDate": "30/03/18 6:41 AM",
      "commitName": "1606dad133de0dbee59175509a22994ec570ea41",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/03/18 11:07 AM",
      "commitNameOld": "47f711eebca315804c80012eea5f31275ac25518",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 1.82,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,83 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n+      case YarnConfiguration.FS_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       if (this.calculator instanceof DefaultResourceCalculator\n           \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n         throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n             + \" used only memory as resource-type but invalid resource-types\"\n             + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n             + \" DomainantResourceCalculator instead to make effective use of\"\n             + \" these resource-types\");\n       }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n      case YarnConfiguration.FS_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DomainantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "042ef2fa7bcc22e3ca4eb8205c34d83e594bc7de": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7789. Should fail RM if 3rd resource type is configured but RM uses DefaultResourceCalculator. (Zian Chen via wangda)\n\nChange-Id: I1f6a451fe16758def6f47c046a9b8a67ad7255af\n",
      "commitDate": "14/02/18 7:11 AM",
      "commitName": "042ef2fa7bcc22e3ca4eb8205c34d83e594bc7de",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/02/18 10:28 AM",
      "commitNameOld": "6e5ba9366fc05719906ff2789b1a0fd26001182b",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 11.86,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,82 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n           YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n       case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n       case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n       case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n       case YarnConfiguration.ZK_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n         throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n+      if (this.calculator instanceof DefaultResourceCalculator\n+          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n+        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n+            + \" used only memory as resource-type but invalid resource-types\"\n+            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n+            + \" DomainantResourceCalculator instead to make effective use of\"\n+            + \" these resource-types\");\n+      }\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      if (this.calculator instanceof DefaultResourceCalculator\n          \u0026\u0026 ResourceUtils.getNumberOfKnownResourceTypes() \u003e 2) {\n        throw new YarnRuntimeException(\"RM uses DefaultResourceCalculator which\"\n            + \" used only memory as resource-type but invalid resource-types\"\n            + \" specified \" + ResourceUtils.getResourceTypes() + \". Use\"\n            + \" DomainantResourceCalculator instead to make effective use of\"\n            + \" these resource-types\");\n      }\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "09c5dfe937f0570cd9494b34d210df2d5f0737a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7251. Misc changes to YARN-5734\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "09c5dfe937f0570cd9494b34d210df2d5f0737a7",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "d6622daaa3c95a5040d06f91dc0c793bafa70f95",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,74 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n-          CapacitySchedulerConfiguration.CS_CONF_PROVIDER,\n-          CapacitySchedulerConfiguration.DEFAULT_CS_CONF_PROVIDER);\n+          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n+          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n       switch (confProviderStr) {\n-      case CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER:\n+      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n         this.csConfProvider \u003d\n             new FileBasedCSConfigurationProvider(rmContext);\n         break;\n-      case CapacitySchedulerConfiguration.STORE_CS_CONF_PROVIDER:\n+      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n+      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n+      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n         this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n         break;\n       default:\n-        throw new IOException(\"Invalid CS configuration provider: \" +\n+        throw new IOException(\"Invalid configuration store class: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          YarnConfiguration.SCHEDULER_CONFIGURATION_STORE_CLASS,\n          YarnConfiguration.DEFAULT_CONFIGURATION_STORE);\n      switch (confProviderStr) {\n      case YarnConfiguration.FILE_CONFIGURATION_STORE:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case YarnConfiguration.MEMORY_CONFIGURATION_STORE:\n      case YarnConfiguration.LEVELDB_CONFIGURATION_STORE:\n      case YarnConfiguration.ZK_CONFIGURATION_STORE:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid configuration store class: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ef686635c1aa0cd4bd52ca212a95769f2532aa1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5948. Implement MutableConfigurationManager for handling storage into configuration store\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "ef686635c1aa0cd4bd52ca212a95769f2532aa1a",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "09/10/17 11:11 AM",
      "commitNameOld": "ef59cbe08aabe9844159cb4192d6345e4e3caab2",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,72 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       String confProviderStr \u003d configuration.get(\n           CapacitySchedulerConfiguration.CS_CONF_PROVIDER,\n           CapacitySchedulerConfiguration.DEFAULT_CS_CONF_PROVIDER);\n-      if (confProviderStr.equals(\n-          CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER)) {\n-        this.csConfProvider \u003d new FileBasedCSConfigurationProvider(rmContext);\n-      } else {\n+      switch (confProviderStr) {\n+      case CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER:\n+        this.csConfProvider \u003d\n+            new FileBasedCSConfigurationProvider(rmContext);\n+        break;\n+      case CapacitySchedulerConfiguration.STORE_CS_CONF_PROVIDER:\n+        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n+        break;\n+      default:\n         throw new IOException(\"Invalid CS configuration provider: \" +\n             confProviderStr);\n       }\n       this.csConfProvider.init(configuration);\n       this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          CapacitySchedulerConfiguration.CS_CONF_PROVIDER,\n          CapacitySchedulerConfiguration.DEFAULT_CS_CONF_PROVIDER);\n      switch (confProviderStr) {\n      case CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER:\n        this.csConfProvider \u003d\n            new FileBasedCSConfigurationProvider(rmContext);\n        break;\n      case CapacitySchedulerConfiguration.STORE_CS_CONF_PROVIDER:\n        this.csConfProvider \u003d new MutableCSConfigurationProvider(rmContext);\n        break;\n      default:\n        throw new IOException(\"Invalid CS configuration provider: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ef59cbe08aabe9844159cb4192d6345e4e3caab2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5951. Changes to allow CapacityScheduler to use configuration store\n",
      "commitDate": "09/10/17 11:11 AM",
      "commitName": "ef59cbe08aabe9844159cb4192d6345e4e3caab2",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 27.08,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,67 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n-      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n+      String confProviderStr \u003d configuration.get(\n+          CapacitySchedulerConfiguration.CS_CONF_PROVIDER,\n+          CapacitySchedulerConfiguration.DEFAULT_CS_CONF_PROVIDER);\n+      if (confProviderStr.equals(\n+          CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER)) {\n+        this.csConfProvider \u003d new FileBasedCSConfigurationProvider(rmContext);\n+      } else {\n+        throw new IOException(\"Invalid CS configuration provider: \" +\n+            confProviderStr);\n+      }\n+      this.csConfProvider.init(configuration);\n+      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d super.getMinimumAllocation();\n       initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      String confProviderStr \u003d configuration.get(\n          CapacitySchedulerConfiguration.CS_CONF_PROVIDER,\n          CapacitySchedulerConfiguration.DEFAULT_CS_CONF_PROVIDER);\n      if (confProviderStr.equals(\n          CapacitySchedulerConfiguration.FILE_CS_CONF_PROVIDER)) {\n        this.csConfProvider \u003d new FileBasedCSConfigurationProvider(rmContext);\n      } else {\n        throw new IOException(\"Invalid CS configuration provider: \" +\n            confProviderStr);\n      }\n      this.csConfProvider.init(configuration);\n      this.conf \u003d this.csConfProvider.loadConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "6708ac330147b2d3816a31f2ee83e09c41fe0dd9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5587. Add support for resource profiles. (vvasudev via asuresh)\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "07/09/17 6:45 PM",
      "commitNameOld": "56d93d2e39ead89bb79c4f4096554820dc77e84b",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 4.61,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n-      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n-      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n+      this.minimumAllocation \u003d super.getMinimumAllocation();\n+      initMaximumResourceCapability(super.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n       this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d super.getMinimumAllocation();\n      initMaximumResourceCapability(super.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "adb84f34db7e1cdcd72aa8e3deb464c48da9e353": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4161. Capacity Scheduler : Assign single or multiple containers per heart beat driven by configuration. (Wei Yan via wangda)\n\nChange-Id: Ic441ae4e0bf72e7232411eb54243ec143d5fd0d3\n",
      "commitDate": "07/08/17 11:32 AM",
      "commitName": "adb84f34db7e1cdcd72aa8e3deb464c48da9e353",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/07/17 3:40 PM",
      "commitNameOld": "9845bea59c0009b8ffff7050403e5ba270054164",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 25.83,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,56 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n           this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n+      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n+      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n+\n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      this.assignMultipleEnabled \u003d this.conf.getAssignMultipleEnabled();\n      this.maxAssignPerHeartbeat \u003d this.conf.getMaxAssignPerHeartbeat();\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/01/17 10:31 AM",
      "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.92,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n+      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n       this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n-          this.labelManager);\n+          this.labelManager, this.appPriorityACLManager);\n       this.queueManager.setCapacitySchedulerContext(this);\n \n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.appPriorityACLManager \u003d new AppPriorityACLsManager(conf);\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager, this.appPriorityACLManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n   void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n-      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n+      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n+          this.labelManager);\n+      this.queueManager.setCapacitySchedulerContext(this);\n+\n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n \n       // number of threads for async scheduling\n       int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n           CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n           1);\n       maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n \n       if (scheduleAsynchronously) {\n         asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n           asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n         }\n         resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n       // Setup how many containers we can allocate for each round\n       offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n \n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      this.queueManager \u003d new CapacitySchedulerQueueManager(yarnConf,\n          this.labelManager);\n      this.queueManager.setCapacitySchedulerContext(this);\n\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "01/11/16 3:02 AM",
          "commitNameOld": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 6.34,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,49 @@\n-  private void initScheduler(Configuration configuration) throws\n+  void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n+\n+      // number of threads for async scheduling\n+      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n+          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n+          1);\n+      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n+\n       if (scheduleAsynchronously) {\n-        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n+        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n+          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n+        }\n+        resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n+      // Setup how many containers we can allocate for each round\n+      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n+\n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "01/11/16 3:02 AM",
          "commitNameOld": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
          "commitAuthorOld": "Varun Saxena",
          "daysBetweenCommits": 6.34,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,49 @@\n-  private void initScheduler(Configuration configuration) throws\n+  void initScheduler(Configuration configuration) throws\n       IOException {\n     try {\n       writeLock.lock();\n       this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n       validateConf(this.conf);\n       this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n       initMaximumResourceCapability(this.conf.getMaximumAllocation());\n       this.calculator \u003d this.conf.getResourceCalculator();\n       this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n       this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n       this.labelManager \u003d rmContext.getNodeLabelManager();\n       authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n       this.activitiesManager \u003d new ActivitiesManager(rmContext);\n       activitiesManager.init(conf);\n       initializeQueues(this.conf);\n       this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n       scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n       asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n           DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n+\n+      // number of threads for async scheduling\n+      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n+          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n+          1);\n+      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n+\n       if (scheduleAsynchronously) {\n-        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n+        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n+          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n+        }\n+        resourceCommitterService \u003d new ResourceCommitterService(this);\n       }\n \n+      // Setup how many containers we can allocate for each round\n+      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n+\n       LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n           + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n           + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n           + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n           + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n           + asyncScheduleInterval + \"ms\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n\n      // number of threads for async scheduling\n      int maxAsyncSchedulingThreads \u003d this.conf.getInt(\n          CapacitySchedulerConfiguration.SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD,\n          1);\n      maxAsyncSchedulingThreads \u003d Math.max(maxAsyncSchedulingThreads, 1);\n\n      if (scheduleAsynchronously) {\n        asyncSchedulerThreads \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c maxAsyncSchedulingThreads; i++) {\n          asyncSchedulerThreads.add(new AsyncScheduleThread(this));\n        }\n        resourceCommitterService \u003d new ResourceCommitterService(this);\n      }\n\n      // Setup how many containers we can allocate for each round\n      offswitchPerHeartbeatLimit \u003d this.conf.getOffSwitchPerHeartbeatLimit();\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  private synchronized void initScheduler(Configuration configuration) throws\n+  private void initScheduler(Configuration configuration) throws\n       IOException {\n-    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n-    validateConf(this.conf);\n-    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n-    this.calculator \u003d this.conf.getResourceCalculator();\n-    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n-    this.labelManager \u003d rmContext.getNodeLabelManager();\n-    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n-    this.activitiesManager \u003d new ActivitiesManager(rmContext);\n-    activitiesManager.init(conf);\n-    initializeQueues(this.conf);\n-    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n+    try {\n+      writeLock.lock();\n+      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n+      validateConf(this.conf);\n+      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n+      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n+      this.calculator \u003d this.conf.getResourceCalculator();\n+      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n+      this.labelManager \u003d rmContext.getNodeLabelManager();\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n+      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n+      activitiesManager.init(conf);\n+      initializeQueues(this.conf);\n+      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n-    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n-    asyncScheduleInterval \u003d\n-        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n-            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n-    if (scheduleAsynchronously) {\n-      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n+      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n+          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n+      if (scheduleAsynchronously) {\n+        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+      }\n+\n+      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n+          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n+          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n+          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n+          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n+          + asyncScheduleInterval + \"ms\");\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    LOG.info(\"Initialized CapacityScheduler with \" +\n-        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n-        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n-        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n-        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n-        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n      if (scheduleAsynchronously) {\n        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  private synchronized void initScheduler(Configuration configuration) throws\n+  private void initScheduler(Configuration configuration) throws\n       IOException {\n-    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n-    validateConf(this.conf);\n-    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n-    this.calculator \u003d this.conf.getResourceCalculator();\n-    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n-    this.labelManager \u003d rmContext.getNodeLabelManager();\n-    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n-    this.activitiesManager \u003d new ActivitiesManager(rmContext);\n-    activitiesManager.init(conf);\n-    initializeQueues(this.conf);\n-    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n+    try {\n+      writeLock.lock();\n+      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n+      validateConf(this.conf);\n+      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n+      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n+      this.calculator \u003d this.conf.getResourceCalculator();\n+      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n+      this.labelManager \u003d rmContext.getNodeLabelManager();\n+      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n+      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n+      activitiesManager.init(conf);\n+      initializeQueues(this.conf);\n+      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n-    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n-    asyncScheduleInterval \u003d\n-        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n-            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n-    if (scheduleAsynchronously) {\n-      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n+      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n+          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n+      if (scheduleAsynchronously) {\n+        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+      }\n+\n+      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n+          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n+          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n+          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n+          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n+          + asyncScheduleInterval + \"ms\");\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    LOG.info(\"Initialized CapacityScheduler with \" +\n-        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n-        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n-        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n-        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n-        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void initScheduler(Configuration configuration) throws\n      IOException {\n    try {\n      writeLock.lock();\n      this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n      validateConf(this.conf);\n      this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n      initMaximumResourceCapability(this.conf.getMaximumAllocation());\n      this.calculator \u003d this.conf.getResourceCalculator();\n      this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n      this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n      this.labelManager \u003d rmContext.getNodeLabelManager();\n      authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n      this.activitiesManager \u003d new ActivitiesManager(rmContext);\n      activitiesManager.init(conf);\n      initializeQueues(this.conf);\n      this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n      scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n      asyncScheduleInterval \u003d this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n          DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n      if (scheduleAsynchronously) {\n        asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n      }\n\n      LOG.info(\"Initialized CapacityScheduler with \" + \"calculator\u003d\"\n          + getResourceCalculator().getClass() + \", \" + \"minimumAllocation\u003d\u003c\"\n          + getMinimumResourceCapability() + \"\u003e, \" + \"maximumAllocation\u003d\u003c\"\n          + getMaximumResourceCapability() + \"\u003e, \" + \"asynchronousScheduling\u003d\"\n          + scheduleAsynchronously + \", \" + \"asyncScheduleInterval\u003d\"\n          + asyncScheduleInterval + \"ms\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/07/16 9:22 PM",
      "commitNameOld": "d62e121ffc0239e7feccc1e23ece92c5fac685f6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.54,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n+    this.activitiesManager \u003d new ActivitiesManager(rmContext);\n+    activitiesManager.init(conf);\n     initializeQueues(this.conf);\n     this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    this.activitiesManager \u003d new ActivitiesManager(rmContext);\n    activitiesManager.init(conf);\n    initializeQueues(this.conf);\n    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,29 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    this.applications \u003d\n-        new ConcurrentHashMap\u003cApplicationId,\n-            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n+    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n+    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n+    this.applications \u003d\n+        new ConcurrentHashMap\u003cApplicationId,\n+            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n-    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/03/16 2:19 PM",
      "commitNameOld": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,29 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n-    this.applications \u003d\n-        new ConcurrentHashMap\u003cApplicationId,\n-            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n+    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n+    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d new ConcurrentHashMap\u003c\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n    this.isLazyPreemptionEnabled \u003d conf.getLazyPreemptionEnabled();\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a9c8ea71aa427ff5f25caec98be15bc880e578a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3250. Support admin cli interface in for Application Priority. Contributed by Rohith Sharma K S\n",
      "commitDate": "27/08/15 1:25 PM",
      "commitName": "a9c8ea71aa427ff5f25caec98be15bc880e578a7",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/08/15 8:36 PM",
      "commitNameOld": "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.7,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,30 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,\n             SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n-    maxClusterLevelAppPriority \u003d Priority.newInstance(yarnConf.getInt(\n-        YarnConfiguration.MAX_CLUSTER_LEVEL_APPLICATION_PRIORITY,\n-        YarnConfiguration.DEFAULT_CLUSTER_LEVEL_APPLICATION_PRIORITY));\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c39ca541f498712133890961598bbff50d89d68b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2003. Support for Application priority : Changes in RM and Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "21/07/15 9:57 AM",
      "commitName": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/07/15 4:31 AM",
      "commitNameOld": "9b272ccae78918e7d756d84920a9322187d61eed",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 4.23,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,\n             SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n     authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n+    maxClusterLevelAppPriority \u003d Priority.newInstance(yarnConf.getInt(\n+        YarnConfiguration.MAX_CLUSTER_LEVEL_APPLICATION_PRIORITY,\n+        YarnConfiguration.DEFAULT_CLUSTER_LEVEL_APPLICATION_PRIORITY));\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n    maxClusterLevelAppPriority \u003d Priority.newInstance(yarnConf.getInt(\n        YarnConfiguration.MAX_CLUSTER_LEVEL_APPLICATION_PRIORITY,\n        YarnConfiguration.DEFAULT_CLUSTER_LEVEL_APPLICATION_PRIORITY));\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3100. Made YARN authorization pluggable. Contributed by Jian He.\n",
      "commitDate": "09/02/15 8:34 PM",
      "commitName": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "05/02/15 11:28 AM",
      "commitNameOld": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,\n             SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n-\n+    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n     initializeQueues(this.conf);\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n    authorizer \u003d YarnAuthorizationProvider.getInstance(yarnConf);\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "21/11/14 10:32 AM",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/11/14 5:45 PM",
      "commitNameOld": "b2cd2698028118b6384904732dbf94942f644732",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 16.7,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n-    this.maximumAllocation \u003d this.conf.getMaximumAllocation();\n+    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,\n             SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n     this.labelManager \u003d rmContext.getNodeLabelManager();\n \n     initializeQueues(this.conf);\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    initMaximumResourceCapability(this.conf.getMaximumAllocation());\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/10/14 2:09 PM",
      "commitNameOld": "f9680d9a160ee527c8f2c1494584abf1a1f70f82",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,30 @@\n   private synchronized void initScheduler(Configuration configuration) throws\n       IOException {\n     this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n     validateConf(this.conf);\n     this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n     this.maximumAllocation \u003d this.conf.getMaximumAllocation();\n     this.calculator \u003d this.conf.getResourceCalculator();\n     this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n     this.applications \u003d\n         new ConcurrentHashMap\u003cApplicationId,\n             SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n+    this.labelManager \u003d rmContext.getNodeLabelManager();\n+\n     initializeQueues(this.conf);\n \n     scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n     asyncScheduleInterval \u003d\n         this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n             DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n     if (scheduleAsynchronously) {\n       asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n     }\n \n     LOG.info(\"Initialized CapacityScheduler with \" +\n         \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n         \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n         \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n         \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n         \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    this.maximumAllocation \u003d this.conf.getMaximumAllocation();\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n    this.labelManager \u003d rmContext.getNodeLabelManager();\n\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a4ba451802c6c61a0c804809740d46dd76059f25": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1474. Make schedulers services. (Tsuyoshi Ozawa via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598908 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/05/14 12:33 PM",
      "commitName": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,29 @@\n+  private synchronized void initScheduler(Configuration configuration) throws\n+      IOException {\n+    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n+    validateConf(this.conf);\n+    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n+    this.maximumAllocation \u003d this.conf.getMaximumAllocation();\n+    this.calculator \u003d this.conf.getResourceCalculator();\n+    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n+    this.applications \u003d\n+        new ConcurrentHashMap\u003cApplicationId,\n+            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n+\n+    initializeQueues(this.conf);\n+\n+    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n+    asyncScheduleInterval \u003d\n+        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n+            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n+    if (scheduleAsynchronously) {\n+      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n+    }\n+\n+    LOG.info(\"Initialized CapacityScheduler with \" +\n+        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n+        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n+        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n+        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n+        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void initScheduler(Configuration configuration) throws\n      IOException {\n    this.conf \u003d loadCapacitySchedulerConfiguration(configuration);\n    validateConf(this.conf);\n    this.minimumAllocation \u003d this.conf.getMinimumAllocation();\n    this.maximumAllocation \u003d this.conf.getMaximumAllocation();\n    this.calculator \u003d this.conf.getResourceCalculator();\n    this.usePortForNodeName \u003d this.conf.getUsePortForNodeName();\n    this.applications \u003d\n        new ConcurrentHashMap\u003cApplicationId,\n            SchedulerApplication\u003cFiCaSchedulerApp\u003e\u003e();\n\n    initializeQueues(this.conf);\n\n    scheduleAsynchronously \u003d this.conf.getScheduleAynschronously();\n    asyncScheduleInterval \u003d\n        this.conf.getLong(ASYNC_SCHEDULER_INTERVAL,\n            DEFAULT_ASYNC_SCHEDULER_INTERVAL);\n    if (scheduleAsynchronously) {\n      asyncSchedulerThread \u003d new AsyncScheduleThread(this);\n    }\n\n    LOG.info(\"Initialized CapacityScheduler with \" +\n        \"calculator\u003d\" + getResourceCalculator().getClass() + \", \" +\n        \"minimumAllocation\u003d\u003c\" + getMinimumResourceCapability() + \"\u003e, \" +\n        \"maximumAllocation\u003d\u003c\" + getMaximumResourceCapability() + \"\u003e, \" +\n        \"asynchronousScheduling\u003d\" + scheduleAsynchronously + \", \" +\n        \"asyncScheduleInterval\u003d\" + asyncScheduleInterval + \"ms\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}