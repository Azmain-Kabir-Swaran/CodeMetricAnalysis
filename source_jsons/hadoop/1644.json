{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslDataTransferClient.java",
  "functionName": "checkTrustAndSend",
  "functionId": "checkTrustAndSend___addr-InetAddress__underlyingOut-OutputStream__underlyingIn-InputStream__encryptionKeyFactory-DataEncryptionKeyFactory__accessToken-Token__BlockTokenIdentifier____datanodeId-DatanodeID__secretKey-SecretKey",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
  "functionStartLine": 222,
  "functionEndLine": 244,
  "numCommitsSeen": 8,
  "timeTaken": 1887,
  "changeHistory": [
    "8aaf5e1a14e577a7d8142bc7d49bb94014032afd",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7"
  ],
  "changeHistoryShort": {
    "8aaf5e1a14e577a7d8142bc7d49bb94014032afd": "Ybodychange",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8aaf5e1a14e577a7d8142bc7d49bb94014032afd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14759. HDFS cat logs an info message.\nContributed by Eric Badger.\n",
      "commitDate": "20/08/19 8:24 PM",
      "commitName": "8aaf5e1a14e577a7d8142bc7d49bb94014032afd",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "11/07/19 1:23 PM",
      "commitNameOld": "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 40.29,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   private IOStreamPair checkTrustAndSend(\n       InetAddress addr, OutputStream underlyingOut, InputStream underlyingIn,\n       DataEncryptionKeyFactory encryptionKeyFactory,\n       Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeID datanodeId,\n       SecretKey secretKey)\n       throws IOException {\n     boolean localTrusted \u003d trustedChannelResolver.isTrusted();\n     boolean remoteTrusted \u003d trustedChannelResolver.isTrusted(addr);\n-    LOG.info(\"SASL encryption trust check: localHostTrusted \u003d {}, \"\n+    LOG.debug(\"SASL encryption trust check: localHostTrusted \u003d {}, \"\n         + \"remoteHostTrusted \u003d {}\", localTrusted, remoteTrusted);\n     if (!localTrusted || !remoteTrusted) {\n       // The encryption key factory only returns a key if encryption is enabled.\n       DataEncryptionKey encryptionKey \u003d\n           encryptionKeyFactory.newDataEncryptionKey();\n       return send(addr, underlyingOut, underlyingIn, encryptionKey, accessToken,\n           datanodeId, secretKey);\n     } else {\n       LOG.debug(\n           \"SASL client skipping handshake on trusted connection for addr \u003d {}, \"\n               + \"datanodeId \u003d {}\", addr, datanodeId);\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair checkTrustAndSend(\n      InetAddress addr, OutputStream underlyingOut, InputStream underlyingIn,\n      DataEncryptionKeyFactory encryptionKeyFactory,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeID datanodeId,\n      SecretKey secretKey)\n      throws IOException {\n    boolean localTrusted \u003d trustedChannelResolver.isTrusted();\n    boolean remoteTrusted \u003d trustedChannelResolver.isTrusted(addr);\n    LOG.debug(\"SASL encryption trust check: localHostTrusted \u003d {}, \"\n        + \"remoteHostTrusted \u003d {}\", localTrusted, remoteTrusted);\n    if (!localTrusted || !remoteTrusted) {\n      // The encryption key factory only returns a key if encryption is enabled.\n      DataEncryptionKey encryptionKey \u003d\n          encryptionKeyFactory.newDataEncryptionKey();\n      return send(addr, underlyingOut, underlyingIn, encryptionKey, accessToken,\n          datanodeId, secretKey);\n    } else {\n      LOG.debug(\n          \"SASL client skipping handshake on trusted connection for addr \u003d {}, \"\n              + \"datanodeId \u003d {}\", addr, datanodeId);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
      "extendedDetails": {}
    },
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.\n",
      "commitDate": "12/04/19 5:37 PM",
      "commitName": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
      "commitAuthor": "Chen Liang",
      "diff": "@@ -0,0 +1,23 @@\n+  private IOStreamPair checkTrustAndSend(\n+      InetAddress addr, OutputStream underlyingOut, InputStream underlyingIn,\n+      DataEncryptionKeyFactory encryptionKeyFactory,\n+      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeID datanodeId,\n+      SecretKey secretKey)\n+      throws IOException {\n+    boolean localTrusted \u003d trustedChannelResolver.isTrusted();\n+    boolean remoteTrusted \u003d trustedChannelResolver.isTrusted(addr);\n+    LOG.info(\"SASL encryption trust check: localHostTrusted \u003d {}, \"\n+        + \"remoteHostTrusted \u003d {}\", localTrusted, remoteTrusted);\n+    if (!localTrusted || !remoteTrusted) {\n+      // The encryption key factory only returns a key if encryption is enabled.\n+      DataEncryptionKey encryptionKey \u003d\n+          encryptionKeyFactory.newDataEncryptionKey();\n+      return send(addr, underlyingOut, underlyingIn, encryptionKey, accessToken,\n+          datanodeId, secretKey);\n+    } else {\n+      LOG.debug(\n+          \"SASL client skipping handshake on trusted connection for addr \u003d {}, \"\n+              + \"datanodeId \u003d {}\", addr, datanodeId);\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair checkTrustAndSend(\n      InetAddress addr, OutputStream underlyingOut, InputStream underlyingIn,\n      DataEncryptionKeyFactory encryptionKeyFactory,\n      Token\u003cBlockTokenIdentifier\u003e accessToken, DatanodeID datanodeId,\n      SecretKey secretKey)\n      throws IOException {\n    boolean localTrusted \u003d trustedChannelResolver.isTrusted();\n    boolean remoteTrusted \u003d trustedChannelResolver.isTrusted(addr);\n    LOG.info(\"SASL encryption trust check: localHostTrusted \u003d {}, \"\n        + \"remoteHostTrusted \u003d {}\", localTrusted, remoteTrusted);\n    if (!localTrusted || !remoteTrusted) {\n      // The encryption key factory only returns a key if encryption is enabled.\n      DataEncryptionKey encryptionKey \u003d\n          encryptionKeyFactory.newDataEncryptionKey();\n      return send(addr, underlyingOut, underlyingIn, encryptionKey, accessToken,\n          datanodeId, secretKey);\n    } else {\n      LOG.debug(\n          \"SASL client skipping handshake on trusted connection for addr \u003d {}, \"\n              + \"datanodeId \u003d {}\", addr, datanodeId);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java"
    }
  }
}