{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirectory.java",
  "functionName": "compute",
  "functionId": "compute",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
  "functionStartLine": 858,
  "functionEndLine": 925,
  "numCommitsSeen": 422,
  "timeTaken": 3704,
  "changeHistory": [
    "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d",
    "b6ceee9bf42eec15891f60a014bbfa47e03f563c"
  ],
  "changeHistoryShort": {
    "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d": "Ymultichange(Ymovefromfile,Ybodychange)",
    "b6ceee9bf42eec15891f60a014bbfa47e03f563c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-6763. Initialize file system-wide quota once on transitioning to active. Contributed by Kihwal Lee\n",
      "commitDate": "10/09/15 7:16 AM",
      "commitName": "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-6763. Initialize file system-wide quota once on transitioning to active. Contributed by Kihwal Lee\n",
          "commitDate": "10/09/15 7:16 AM",
          "commitName": "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "10/09/15 12:45 AM",
          "commitNameOld": "7b5b2c5822ac722893ef5db753144f18d5056f5b",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 0.27,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n     public void compute() {\n       QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n       dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n           myCounts);\n \n       ReadOnlyList\u003cINode\u003e children \u003d\n-          dir.getChildrenList(Snapshot.CURRENT_STATE_ID);\n+          dir.getChildrenList(CURRENT_STATE_ID);\n \n       if (children.size() \u003e 0) {\n         List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n         for (INode child : children) {\n           final byte childPolicyId \u003d\n               child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n           if (child.isDirectory()) {\n             subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n                 child.asDirectory(), myCounts));\n           } else {\n             // file or symlink. count using the local counts variable\n             myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n-                Snapshot.CURRENT_STATE_ID));\n+                CURRENT_STATE_ID));\n           }\n         }\n         // invoke and wait for completion\n         invokeAll(subtasks);\n       }\n \n       if (dir.isQuotaSet()) {\n         // check if quota is violated. It indicates a software bug.\n         final QuotaCounts q \u003d dir.getQuotaCounts();\n \n         final long nsConsumed \u003d myCounts.getNameSpace();\n         final long nsQuota \u003d q.getNameSpace();\n         if (Quota.isViolated(nsQuota, nsConsumed)) {\n           LOG.warn(\"Namespace quota violation in image for \"\n               + dir.getFullPathName()\n               + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n         }\n \n         final long ssConsumed \u003d myCounts.getStorageSpace();\n         final long ssQuota \u003d q.getStorageSpace();\n         if (Quota.isViolated(ssQuota, ssConsumed)) {\n           LOG.warn(\"Storagespace quota violation in image for \"\n               + dir.getFullPathName()\n               + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n         }\n \n         final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n         for (StorageType t : StorageType.getTypesSupportingQuota()) {\n           final long typeSpace \u003d tsConsumed.get(t);\n           final long typeQuota \u003d q.getTypeSpaces().get(t);\n           if (Quota.isViolated(typeQuota, typeSpace)) {\n             LOG.warn(\"Storage type quota violation in image for \"\n                 + dir.getFullPathName()\n                 + \" type \u003d \" + t.toString() + \" quota \u003d \"\n                 + typeQuota + \" \u003c consumed \" + typeSpace);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n         }\n         dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n             ssConsumed, tsConsumed);\n       }\n \n       synchronized(counts) {\n         counts.add(myCounts);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void compute() {\n      QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n      dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n          myCounts);\n\n      ReadOnlyList\u003cINode\u003e children \u003d\n          dir.getChildrenList(CURRENT_STATE_ID);\n\n      if (children.size() \u003e 0) {\n        List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n        for (INode child : children) {\n          final byte childPolicyId \u003d\n              child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n          if (child.isDirectory()) {\n            subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n                child.asDirectory(), myCounts));\n          } else {\n            // file or symlink. count using the local counts variable\n            myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n                CURRENT_STATE_ID));\n          }\n        }\n        // invoke and wait for completion\n        invokeAll(subtasks);\n      }\n\n      if (dir.isQuotaSet()) {\n        // check if quota is violated. It indicates a software bug.\n        final QuotaCounts q \u003d dir.getQuotaCounts();\n\n        final long nsConsumed \u003d myCounts.getNameSpace();\n        final long nsQuota \u003d q.getNameSpace();\n        if (Quota.isViolated(nsQuota, nsConsumed)) {\n          LOG.warn(\"Namespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n        }\n\n        final long ssConsumed \u003d myCounts.getStorageSpace();\n        final long ssQuota \u003d q.getStorageSpace();\n        if (Quota.isViolated(ssQuota, ssConsumed)) {\n          LOG.warn(\"Storagespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n        }\n\n        final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n        for (StorageType t : StorageType.getTypesSupportingQuota()) {\n          final long typeSpace \u003d tsConsumed.get(t);\n          final long typeQuota \u003d q.getTypeSpaces().get(t);\n          if (Quota.isViolated(typeQuota, typeSpace)) {\n            LOG.warn(\"Storage type quota violation in image for \"\n                + dir.getFullPathName()\n                + \" type \u003d \" + t.toString() + \" quota \u003d \"\n                + typeQuota + \" \u003c consumed \" + typeSpace);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n        }\n        dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n            ssConsumed, tsConsumed);\n      }\n\n      synchronized(counts) {\n        counts.add(myCounts);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "oldMethodName": "compute",
            "newMethodName": "compute"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6763. Initialize file system-wide quota once on transitioning to active. Contributed by Kihwal Lee\n",
          "commitDate": "10/09/15 7:16 AM",
          "commitName": "a40342b0dab1f9137ae4b3679a5aca7f2a57d23d",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "10/09/15 12:45 AM",
          "commitNameOld": "7b5b2c5822ac722893ef5db753144f18d5056f5b",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 0.27,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n     public void compute() {\n       QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n       dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n           myCounts);\n \n       ReadOnlyList\u003cINode\u003e children \u003d\n-          dir.getChildrenList(Snapshot.CURRENT_STATE_ID);\n+          dir.getChildrenList(CURRENT_STATE_ID);\n \n       if (children.size() \u003e 0) {\n         List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n         for (INode child : children) {\n           final byte childPolicyId \u003d\n               child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n           if (child.isDirectory()) {\n             subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n                 child.asDirectory(), myCounts));\n           } else {\n             // file or symlink. count using the local counts variable\n             myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n-                Snapshot.CURRENT_STATE_ID));\n+                CURRENT_STATE_ID));\n           }\n         }\n         // invoke and wait for completion\n         invokeAll(subtasks);\n       }\n \n       if (dir.isQuotaSet()) {\n         // check if quota is violated. It indicates a software bug.\n         final QuotaCounts q \u003d dir.getQuotaCounts();\n \n         final long nsConsumed \u003d myCounts.getNameSpace();\n         final long nsQuota \u003d q.getNameSpace();\n         if (Quota.isViolated(nsQuota, nsConsumed)) {\n           LOG.warn(\"Namespace quota violation in image for \"\n               + dir.getFullPathName()\n               + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n         }\n \n         final long ssConsumed \u003d myCounts.getStorageSpace();\n         final long ssQuota \u003d q.getStorageSpace();\n         if (Quota.isViolated(ssQuota, ssConsumed)) {\n           LOG.warn(\"Storagespace quota violation in image for \"\n               + dir.getFullPathName()\n               + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n         }\n \n         final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n         for (StorageType t : StorageType.getTypesSupportingQuota()) {\n           final long typeSpace \u003d tsConsumed.get(t);\n           final long typeQuota \u003d q.getTypeSpaces().get(t);\n           if (Quota.isViolated(typeQuota, typeSpace)) {\n             LOG.warn(\"Storage type quota violation in image for \"\n                 + dir.getFullPathName()\n                 + \" type \u003d \" + t.toString() + \" quota \u003d \"\n                 + typeQuota + \" \u003c consumed \" + typeSpace);\n           }\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n         }\n         dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n             ssConsumed, tsConsumed);\n       }\n \n       synchronized(counts) {\n         counts.add(myCounts);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void compute() {\n      QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n      dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n          myCounts);\n\n      ReadOnlyList\u003cINode\u003e children \u003d\n          dir.getChildrenList(CURRENT_STATE_ID);\n\n      if (children.size() \u003e 0) {\n        List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n        for (INode child : children) {\n          final byte childPolicyId \u003d\n              child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n          if (child.isDirectory()) {\n            subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n                child.asDirectory(), myCounts));\n          } else {\n            // file or symlink. count using the local counts variable\n            myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n                CURRENT_STATE_ID));\n          }\n        }\n        // invoke and wait for completion\n        invokeAll(subtasks);\n      }\n\n      if (dir.isQuotaSet()) {\n        // check if quota is violated. It indicates a software bug.\n        final QuotaCounts q \u003d dir.getQuotaCounts();\n\n        final long nsConsumed \u003d myCounts.getNameSpace();\n        final long nsQuota \u003d q.getNameSpace();\n        if (Quota.isViolated(nsQuota, nsConsumed)) {\n          LOG.warn(\"Namespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n        }\n\n        final long ssConsumed \u003d myCounts.getStorageSpace();\n        final long ssQuota \u003d q.getStorageSpace();\n        if (Quota.isViolated(ssQuota, ssConsumed)) {\n          LOG.warn(\"Storagespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n        }\n\n        final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n        for (StorageType t : StorageType.getTypesSupportingQuota()) {\n          final long typeSpace \u003d tsConsumed.get(t);\n          final long typeQuota \u003d q.getTypeSpaces().get(t);\n          if (Quota.isViolated(typeQuota, typeSpace)) {\n            LOG.warn(\"Storage type quota violation in image for \"\n                + dir.getFullPathName()\n                + \" type \u003d \" + t.toString() + \" quota \u003d \"\n                + typeQuota + \" \u003c consumed \" + typeSpace);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n        }\n        dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n            ssConsumed, tsConsumed);\n      }\n\n      synchronized(counts) {\n        counts.add(myCounts);\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "b6ceee9bf42eec15891f60a014bbfa47e03f563c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8865. Improve quota initialization performance. Contributed by Kihwal Lee.\n",
      "commitDate": "28/08/15 11:14 AM",
      "commitName": "b6ceee9bf42eec15891f60a014bbfa47e03f563c",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,68 @@\n+    public void compute() {\n+      QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n+      dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n+          myCounts);\n+\n+      ReadOnlyList\u003cINode\u003e children \u003d\n+          dir.getChildrenList(Snapshot.CURRENT_STATE_ID);\n+\n+      if (children.size() \u003e 0) {\n+        List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n+        for (INode child : children) {\n+          final byte childPolicyId \u003d\n+              child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n+          if (child.isDirectory()) {\n+            subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n+                child.asDirectory(), myCounts));\n+          } else {\n+            // file or symlink. count using the local counts variable\n+            myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n+                Snapshot.CURRENT_STATE_ID));\n+          }\n+        }\n+        // invoke and wait for completion\n+        invokeAll(subtasks);\n+      }\n+\n+      if (dir.isQuotaSet()) {\n+        // check if quota is violated. It indicates a software bug.\n+        final QuotaCounts q \u003d dir.getQuotaCounts();\n+\n+        final long nsConsumed \u003d myCounts.getNameSpace();\n+        final long nsQuota \u003d q.getNameSpace();\n+        if (Quota.isViolated(nsQuota, nsConsumed)) {\n+          LOG.warn(\"Namespace quota violation in image for \"\n+              + dir.getFullPathName()\n+              + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n+        }\n+\n+        final long ssConsumed \u003d myCounts.getStorageSpace();\n+        final long ssQuota \u003d q.getStorageSpace();\n+        if (Quota.isViolated(ssQuota, ssConsumed)) {\n+          LOG.warn(\"Storagespace quota violation in image for \"\n+              + dir.getFullPathName()\n+              + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n+        }\n+\n+        final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n+        for (StorageType t : StorageType.getTypesSupportingQuota()) {\n+          final long typeSpace \u003d tsConsumed.get(t);\n+          final long typeQuota \u003d q.getTypeSpaces().get(t);\n+          if (Quota.isViolated(typeQuota, typeSpace)) {\n+            LOG.warn(\"Storage type quota violation in image for \"\n+                + dir.getFullPathName()\n+                + \" type \u003d \" + t.toString() + \" quota \u003d \"\n+                + typeQuota + \" \u003c consumed \" + typeSpace);\n+          }\n+        }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n+        }\n+        dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n+            ssConsumed, tsConsumed);\n+      }\n+\n+      synchronized(counts) {\n+        counts.add(myCounts);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void compute() {\n      QuotaCounts myCounts \u003d  new QuotaCounts.Builder().build();\n      dir.computeQuotaUsage4CurrentDirectory(bsps, blockStoragePolicyId,\n          myCounts);\n\n      ReadOnlyList\u003cINode\u003e children \u003d\n          dir.getChildrenList(Snapshot.CURRENT_STATE_ID);\n\n      if (children.size() \u003e 0) {\n        List\u003cInitQuotaTask\u003e subtasks \u003d new ArrayList\u003cInitQuotaTask\u003e();\n        for (INode child : children) {\n          final byte childPolicyId \u003d\n              child.getStoragePolicyIDForQuota(blockStoragePolicyId);\n          if (child.isDirectory()) {\n            subtasks.add(new InitQuotaTask(bsps, childPolicyId,\n                child.asDirectory(), myCounts));\n          } else {\n            // file or symlink. count using the local counts variable\n            myCounts.add(child.computeQuotaUsage(bsps, childPolicyId, false,\n                Snapshot.CURRENT_STATE_ID));\n          }\n        }\n        // invoke and wait for completion\n        invokeAll(subtasks);\n      }\n\n      if (dir.isQuotaSet()) {\n        // check if quota is violated. It indicates a software bug.\n        final QuotaCounts q \u003d dir.getQuotaCounts();\n\n        final long nsConsumed \u003d myCounts.getNameSpace();\n        final long nsQuota \u003d q.getNameSpace();\n        if (Quota.isViolated(nsQuota, nsConsumed)) {\n          LOG.warn(\"Namespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + nsQuota + \" \u003c consumed \u003d \" + nsConsumed);\n        }\n\n        final long ssConsumed \u003d myCounts.getStorageSpace();\n        final long ssQuota \u003d q.getStorageSpace();\n        if (Quota.isViolated(ssQuota, ssConsumed)) {\n          LOG.warn(\"Storagespace quota violation in image for \"\n              + dir.getFullPathName()\n              + \" quota \u003d \" + ssQuota + \" \u003c consumed \u003d \" + ssConsumed);\n        }\n\n        final EnumCounters\u003cStorageType\u003e tsConsumed \u003d myCounts.getTypeSpaces();\n        for (StorageType t : StorageType.getTypesSupportingQuota()) {\n          final long typeSpace \u003d tsConsumed.get(t);\n          final long typeQuota \u003d q.getTypeSpaces().get(t);\n          if (Quota.isViolated(typeQuota, typeSpace)) {\n            LOG.warn(\"Storage type quota violation in image for \"\n                + dir.getFullPathName()\n                + \" type \u003d \" + t.toString() + \" quota \u003d \"\n                + typeQuota + \" \u003c consumed \" + typeSpace);\n          }\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Setting quota for \" + dir + \"\\n\" + myCounts);\n        }\n        dir.getDirectoryWithQuotaFeature().setSpaceConsumed(nsConsumed,\n            ssConsumed, tsConsumed);\n      }\n\n      synchronized(counts) {\n        counts.add(myCounts);\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}