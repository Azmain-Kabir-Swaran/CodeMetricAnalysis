{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AllocationFileLoaderService.java",
  "functionName": "reloadAllocations",
  "functionId": "reloadAllocations",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
  "functionStartLine": 229,
  "functionEndLine": 273,
  "numCommitsSeen": 67,
  "timeTaken": 10618,
  "changeHistory": [
    "5257f50abb71905ef3068fd45541d00ce9e8f355",
    "814d701d46b4ff87f6ec94ba39667c80475c38d7",
    "7a550448036c9d140d2c35c684cc8023ceb8880e",
    "99292adcefdc6b8f280b8e100605fb39f755c38a",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
    "0996acde6c325667aa19ae0740eb6b40bf4a682a",
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
    "170c4fd4cdbb8b4c1c4bb219e4c74fa0ba81b055",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e",
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
    "934d96a334598fcf0e5aba2043ff539469025f69",
    "32b43304563c2430c00bc3e142a962d2bc5f4d58",
    "c2b185def846f5577a130003a533b9c377b58fab",
    "a22ffc318801698e86cd0e316b4824015f2486ac",
    "43efdd30b52f4ee8967a03dac4d548095d6cafdb",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
    "6fcbf9b848c63465d26a40387a9be212e708f80b",
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
    "3858b9018e3c2f4b883b02021679852591b706f7",
    "3baff29b8cf594145f0ca8da36b1d7603a5992cc",
    "dc523bd18247df232fe814aed7062a116242ab04",
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
    "65bda6d168e47106f5542e15bb7b21522478626e",
    "643b1a401968a21d902b602e76a53c1f98b1a950",
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
    "aa2745abe596c610157f6e3be9c23ba8cc1e21d0",
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
    "19a291a0d65b64e50571c3519414b9d54acbe28a",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
    "576f96f0ac79a2afe49948056498f2c06fe317c3",
    "4920387b8ad95070ba7035d47a8bec9805a666f9",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "5257f50abb71905ef3068fd45541d00ce9e8f355": "Ybodychange",
    "814d701d46b4ff87f6ec94ba39667c80475c38d7": "Ybodychange",
    "7a550448036c9d140d2c35c684cc8023ceb8880e": "Ybodychange",
    "99292adcefdc6b8f280b8e100605fb39f755c38a": "Ybodychange",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": "Ybodychange",
    "0996acde6c325667aa19ae0740eb6b40bf4a682a": "Ybodychange",
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585": "Ybodychange",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": "Ybodychange",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": "Ybodychange",
    "170c4fd4cdbb8b4c1c4bb219e4c74fa0ba81b055": "Ybodychange",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": "Ybodychange",
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a": "Ybodychange",
    "934d96a334598fcf0e5aba2043ff539469025f69": "Ybodychange",
    "32b43304563c2430c00bc3e142a962d2bc5f4d58": "Ymodifierchange",
    "c2b185def846f5577a130003a533b9c377b58fab": "Ymodifierchange",
    "a22ffc318801698e86cd0e316b4824015f2486ac": "Ybodychange",
    "43efdd30b52f4ee8967a03dac4d548095d6cafdb": "Ybodychange",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": "Ybodychange",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": "Ybodychange",
    "6fcbf9b848c63465d26a40387a9be212e708f80b": "Ybodychange",
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4": "Ybodychange",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
    "3858b9018e3c2f4b883b02021679852591b706f7": "Ybodychange",
    "3baff29b8cf594145f0ca8da36b1d7603a5992cc": "Ybodychange",
    "dc523bd18247df232fe814aed7062a116242ab04": "Ybodychange",
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf": "Ybodychange",
    "65bda6d168e47106f5542e15bb7b21522478626e": "Ybodychange",
    "643b1a401968a21d902b602e76a53c1f98b1a950": "Ybodychange",
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d": "Ybodychange",
    "aa2745abe596c610157f6e3be9c23ba8cc1e21d0": "Ybodychange",
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e": "Ybodychange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Ybodychange",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": "Ybodychange",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": "Ybodychange",
    "19a291a0d65b64e50571c3519414b9d54acbe28a": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Ybodychange",
    "576f96f0ac79a2afe49948056498f2c06fe317c3": "Ybodychange",
    "4920387b8ad95070ba7035d47a8bec9805a666f9": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5257f50abb71905ef3068fd45541d00ce9e8f355": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "25/03/19 10:47 PM",
      "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
      "commitAuthor": "yufei",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 21.03,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,45 @@\n   public synchronized void reloadAllocations()\n       throws IOException, ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n         DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(fs.open(allocFile));\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName())) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: top-level element not \u003callocations\u003e\");\n     }\n     NodeList elements \u003d root.getChildNodes();\n \n     AllocationFileParser allocationFileParser \u003d\n         new AllocationFileParser(elements);\n     allocationFileParser.parse();\n \n     AllocationFileQueueParser queueParser \u003d\n         new AllocationFileQueueParser(allocationFileParser.getQueueElements());\n     QueueProperties queueProperties \u003d queueParser.parse();\n \n-    // Load placement policy and pass it configured queues\n-    Configuration conf \u003d getConfig();\n-    QueuePlacementPolicy newPlacementPolicy \u003d\n-        getQueuePlacementPolicy(allocationFileParser, queueProperties, conf);\n+    // Load placement policy\n+    getQueuePlacementPolicy(allocationFileParser);\n     setupRootQueueProperties(allocationFileParser, queueProperties);\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d\n         createReservationQueueConfig(allocationFileParser);\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(queueProperties,\n-        allocationFileParser, newPlacementPolicy, globalReservationQueueConfig);\n+        allocationFileParser, globalReservationQueueConfig);\n \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations()\n      throws IOException, ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n        DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(fs.open(allocFile));\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName())) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: top-level element not \u003callocations\u003e\");\n    }\n    NodeList elements \u003d root.getChildNodes();\n\n    AllocationFileParser allocationFileParser \u003d\n        new AllocationFileParser(elements);\n    allocationFileParser.parse();\n\n    AllocationFileQueueParser queueParser \u003d\n        new AllocationFileQueueParser(allocationFileParser.getQueueElements());\n    QueueProperties queueProperties \u003d queueParser.parse();\n\n    // Load placement policy\n    getQueuePlacementPolicy(allocationFileParser);\n    setupRootQueueProperties(allocationFileParser, queueProperties);\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d\n        createReservationQueueConfig(allocationFileParser);\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(queueProperties,\n        allocationFileParser, globalReservationQueueConfig);\n\n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "814d701d46b4ff87f6ec94ba39667c80475c38d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7841. Cleanup AllocationFileLoaderService\u0027s reloadAllocations method (snemeth via rkanter)\n",
      "commitDate": "06/02/18 2:36 PM",
      "commitName": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "03/01/18 3:31 PM",
      "commitNameOld": "7a550448036c9d140d2c35c684cc8023ceb8880e",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 33.96,
      "commitsBetweenForRepo": 209,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,228 +1,47 @@\n-  public synchronized void reloadAllocations() throws IOException,\n-      ParserConfigurationException, SAXException,\n+  public synchronized void reloadAllocations()\n+      throws IOException, ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n-    // Create some temporary hashmaps to hold the new allocs, and we only save\n-    // them in our fields if we have parsed the entire allocs file successfully.\n-    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, ConfigurableResource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, ConfigurableResource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n-        new HashMap\u003c\u003e();\n-    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n-        new HashMap\u003c\u003e();\n-    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n-    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n-    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n-    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n-    ConfigurableResource queueMaxResourcesDefault \u003d\n-        new ConfigurableResource(Resources.unbounded());\n-    float queueMaxAMShareDefault \u003d 0.5f;\n-    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n-    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n-\n-    // Reservation global configuration knobs\n-    String planner \u003d null;\n-    String reservationAgent \u003d null;\n-    String reservationAdmissionPolicy \u003d null;\n-\n-    QueuePlacementPolicy newPlacementPolicy \u003d null;\n-\n-    // Remember all queue names so we can display them on web UI, etc.\n-    // configuredQueues is segregated based on whether it is a leaf queue\n-    // or a parent queue. This information is used for creating queues\n-    // and also for making queue placement decisions(QueuePlacementRule.java).\n-    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n-\n-    for (FSQueueType queueType : FSQueueType.values()) {\n-      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n-    }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n-      DocumentBuilderFactory.newInstance();\n+        DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(fs.open(allocFile));\n     Element root \u003d doc.getDocumentElement();\n-    if (!\"allocations\".equals(root.getTagName()))\n-      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n-          \"file: top-level element not \u003callocations\u003e\");\n+    if (!\"allocations\".equals(root.getTagName())) {\n+      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n+          + \"file: top-level element not \u003callocations\u003e\");\n+    }\n     NodeList elements \u003d root.getChildNodes();\n-    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n-    Element placementPolicyElement \u003d null;\n-    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n-      Node node \u003d elements.item(i);\n-      if (node instanceof Element) {\n-        Element element \u003d (Element)node;\n-        if (\"queue\".equals(element.getTagName()) ||\n-          \"pool\".equals(element.getTagName())) {\n-          queueElements.add(element);\n-        } else if (\"user\".equals(element.getTagName())) {\n-          String userName \u003d element.getAttribute(\"name\");\n-          NodeList fields \u003d element.getChildNodes();\n-          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n-            Node fieldNode \u003d fields.item(j);\n-            if (!(fieldNode instanceof Element)) {\n-              continue;\n-            }\n-            Element field \u003d (Element) fieldNode;\n-            if (\"maxRunningApps\".equals(field.getTagName())) {\n-              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-              int val \u003d Integer.parseInt(text);\n-              userMaxApps.put(userName, val);\n-            }\n-          }\n-        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          ConfigurableResource val \u003d\n-              FairSchedulerConfiguration.parseResourceConfigValue(text);\n-          queueMaxResourcesDefault \u003d val;\n-        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          int val \u003d Integer.parseInt(text);\n-          userMaxAppsDefault \u003d val;\n-        } else if (\"defaultFairSharePreemptionTimeout\"\n-            .equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          long val \u003d Long.parseLong(text) * 1000L;\n-          defaultFairSharePreemptionTimeout \u003d val;\n-        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n-          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n-            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-            long val \u003d Long.parseLong(text) * 1000L;\n-            defaultFairSharePreemptionTimeout \u003d val;\n-          }\n-        } else if (\"defaultMinSharePreemptionTimeout\"\n-            .equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          long val \u003d Long.parseLong(text) * 1000L;\n-          defaultMinSharePreemptionTimeout \u003d val;\n-        } else if (\"defaultFairSharePreemptionThreshold\"\n-            .equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          float val \u003d Float.parseFloat(text);\n-          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n-          defaultFairSharePreemptionThreshold \u003d val;\n-        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          int val \u003d Integer.parseInt(text);\n-          queueMaxAppsDefault \u003d val;\n-        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          float val \u003d Float.parseFloat(text);\n-          val \u003d Math.min(val, 1.0f);\n-          queueMaxAMShareDefault \u003d val;\n-        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n-            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n-          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n-            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n-              + \"config file: defaultQueueSchedulingPolicy or \"\n-              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n-          }\n-          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n-        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n-          placementPolicyElement \u003d element;\n-        } else if (\"reservation-planner\".equals(element.getTagName())) {\n-          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n-          planner \u003d text;\n-        } else if (\"reservation-agent\".equals(element.getTagName())) {\n-          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n-          reservationAgent \u003d text;\n-        } else if (\"reservation-policy\".equals(element.getTagName())) {\n-          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n-          reservationAdmissionPolicy \u003d text;\n-        } else {\n-          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n-        }\n-      }\n-    }\n \n-    // Load queue elements.  A root queue can either be included or omitted.  If\n-    // it\u0027s included, all other queues must be inside it.\n-    for (Element element : queueElements) {\n-      String parent \u003d \"root\";\n-      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n-        if (queueElements.size() \u003e 1) {\n-          throw new AllocationConfigurationException(\"If configuring root queue,\"\n-              + \" no other queues can be placed alongside it.\");\n-        }\n-        parent \u003d null;\n-      }\n-      loadQueue(parent, element, minQueueResources, maxQueueResources,\n-          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n-          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n-          reservationAcls, configuredQueues, reservableQueues,\n-          nonPreemptableQueues);\n-    }\n+    AllocationFileParser allocationFileParser \u003d\n+        new AllocationFileParser(elements);\n+    allocationFileParser.parse();\n+\n+    AllocationFileQueueParser queueParser \u003d\n+        new AllocationFileQueueParser(allocationFileParser.getQueueElements());\n+    QueueProperties queueProperties \u003d queueParser.parse();\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n-    if (placementPolicyElement !\u003d null) {\n-      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          configuredQueues, conf);\n-    } else {\n-      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n-          configuredQueues);\n-    }\n+    QueuePlacementPolicy newPlacementPolicy \u003d\n+        getQueuePlacementPolicy(allocationFileParser, queueProperties, conf);\n+    setupRootQueueProperties(allocationFileParser, queueProperties);\n \n-    // Set the min/fair share preemption timeout for the root queue\n-    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n-      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n-          defaultMinSharePreemptionTimeout);\n-    }\n-    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n-      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n-          defaultFairSharePreemptionTimeout);\n-    }\n+    ReservationQueueConfiguration globalReservationQueueConfig \u003d\n+        createReservationQueueConfig(allocationFileParser);\n \n-    // Set the fair share preemption threshold for the root queue\n-    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n-      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n-          defaultFairSharePreemptionThreshold);\n-    }\n-\n-    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n-        ReservationQueueConfiguration();\n-    if (planner !\u003d null) {\n-      globalReservationQueueConfig.setPlanner(planner);\n-    }\n-    if (reservationAdmissionPolicy !\u003d null) {\n-      globalReservationQueueConfig.setReservationAdmissionPolicy\n-          (reservationAdmissionPolicy);\n-    }\n-    if (reservationAgent !\u003d null) {\n-      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n-    }\n-\n-    AllocationConfiguration info \u003d\n-        new AllocationConfiguration(minQueueResources, maxQueueResources,\n-          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n-          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n-          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n-          defaultSchedPolicy, minSharePreemptionTimeouts,\n-          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n-          reservationAcls, newPlacementPolicy, configuredQueues,\n-          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n+    AllocationConfiguration info \u003d new AllocationConfiguration(queueProperties,\n+        allocationFileParser, newPlacementPolicy, globalReservationQueueConfig);\n \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations()\n      throws IOException, ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n        DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(fs.open(allocFile));\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName())) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: top-level element not \u003callocations\u003e\");\n    }\n    NodeList elements \u003d root.getChildNodes();\n\n    AllocationFileParser allocationFileParser \u003d\n        new AllocationFileParser(elements);\n    allocationFileParser.parse();\n\n    AllocationFileQueueParser queueParser \u003d\n        new AllocationFileQueueParser(allocationFileParser.getQueueElements());\n    QueueProperties queueProperties \u003d queueParser.parse();\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    QueuePlacementPolicy newPlacementPolicy \u003d\n        getQueuePlacementPolicy(allocationFileParser, queueProperties, conf);\n    setupRootQueueProperties(allocationFileParser, queueProperties);\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d\n        createReservationQueueConfig(allocationFileParser);\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(queueProperties,\n        allocationFileParser, newPlacementPolicy, globalReservationQueueConfig);\n\n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "7a550448036c9d140d2c35c684cc8023ceb8880e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7622. Allow fair-scheduler configuration on HDFS (gphillips via rkanter)\n",
      "commitDate": "03/01/18 3:31 PM",
      "commitName": "7a550448036c9d140d2c35c684cc8023ceb8880e",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "05/10/17 11:51 PM",
      "commitNameOld": "99292adcefdc6b8f280b8e100605fb39f755c38a",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 89.69,
      "commitsBetweenForRepo": 643,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,228 +1,228 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, ConfigurableResource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, ConfigurableResource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n         new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     ConfigurableResource queueMaxResourcesDefault \u003d\n         new ConfigurableResource(Resources.unbounded());\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003c\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n-    Document doc \u003d builder.parse(allocFile);\n+    Document doc \u003d builder.parse(fs.open(allocFile));\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element)) {\n               continue;\n             }\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           ConfigurableResource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n-    \n+\n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ConfigurableResource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ConfigurableResource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    ConfigurableResource queueMaxResourcesDefault \u003d\n        new ConfigurableResource(Resources.unbounded());\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(fs.open(allocFile));\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element)) {\n              continue;\n            }\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          ConfigurableResource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n\n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "99292adcefdc6b8f280b8e100605fb39f755c38a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2162. Add ability in Fair Scheduler to optionally configure maxResources in terms of percentage. (Yufei Gu)\n",
      "commitDate": "05/10/17 11:51 PM",
      "commitName": "99292adcefdc6b8f280b8e100605fb39f755c38a",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "14/09/17 11:23 AM",
      "commitNameOld": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 21.52,
      "commitsBetweenForRepo": 160,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,227 +1,228 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, ConfigurableResource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, ConfigurableResource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n         new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n-    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n+    ConfigurableResource queueMaxResourcesDefault \u003d\n+        new ConfigurableResource(Resources.unbounded());\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003c\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element)) {\n               continue;\n             }\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          Resource val \u003d\n+          ConfigurableResource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ConfigurableResource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ConfigurableResource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    ConfigurableResource queueMaxResourcesDefault \u003d\n        new ConfigurableResource(Resources.unbounded());\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element)) {\n              continue;\n            }\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          ConfigurableResource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)\n",
      "commitDate": "14/09/17 11:23 AM",
      "commitName": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "11/08/17 2:50 PM",
      "commitNameOld": "0996acde6c325667aa19ae0740eb6b40bf4a682a",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 33.86,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,227 +1,227 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n         new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003c\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element)) {\n               continue;\n             }\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element)) {\n              continue;\n            }\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "0996acde6c325667aa19ae0740eb6b40bf4a682a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6882. AllocationFileLoaderService.reloadAllocations() should use the diamond operator\n(Contributed by Larry Lo via Daniel Templeton)\n",
      "commitDate": "11/08/17 2:50 PM",
      "commitName": "0996acde6c325667aa19ae0740eb6b40bf4a682a",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "11/08/17 2:22 PM",
      "commitNameOld": "c7680d4cc4d9302a5b5efcf2467bd32ecea99585",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,227 +1,227 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n         new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n-      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n+      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n-    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n+    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element)) {\n               continue;\n             }\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003c\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003c\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element)) {\n              continue;\n            }\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6884. AllocationFileLoaderService.loadQueue() has an if without braces\n(Contributed by weiyuan via Daniel Templeton)\n",
      "commitDate": "11/08/17 2:22 PM",
      "commitName": "c7680d4cc4d9302a5b5efcf2467bd32ecea99585",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "09/05/17 9:22 AM",
      "commitNameOld": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 94.21,
      "commitsBetweenForRepo": 546,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,226 +1,227 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n         new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n-            if (!(fieldNode instanceof Element))\n+            if (!(fieldNode instanceof Element)) {\n               continue;\n+            }\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element)) {\n              continue;\n            }\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4997. Update fair scheduler to use pluggable auth provider (Contributed by Tao Jie via Daniel Templeton)\n",
      "commitDate": "30/11/16 9:50 AM",
      "commitName": "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "17/08/16 5:40 PM",
      "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 104.72,
      "commitsBetweenForRepo": 759,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,224 +1,226 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n+      reloadListener.onReload(null);\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n-    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n+        new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n-            new HashMap\u003c\u003e();\n+        new HashMap\u003c\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n \n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n           queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, configuredQueues, reservableQueues,\n           nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d\n         new AllocationConfiguration(minQueueResources, maxQueueResources,\n           maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n           queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n           queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n           defaultSchedPolicy, minSharePreemptionTimeouts,\n           fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n           reservationAcls, newPlacementPolicy, configuredQueues,\n           globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      reloadListener.onReload(null);\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n        new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)\n",
      "commitDate": "17/08/16 5:40 PM",
      "commitName": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "15/07/16 2:38 PM",
      "commitNameOld": "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6",
      "commitAuthorOld": "Ray Chiang",
      "daysBetweenCommits": 33.13,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,223 +1,224 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n-    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n-    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n-    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n-    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n-    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n-    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n-    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n-    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n-    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n-    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n-        new HashMap\u003cString, Float\u003e();\n-    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n-        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n+    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n+    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d new HashMap\u003c\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n-            new HashMap\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e();\n-    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n-    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n+            new HashMap\u003c\u003e();\n+    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n+    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n-    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n-        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n+    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n+\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n             throw new AllocationConfigurationException(\"Bad fair scheduler \"\n               + \"config file: defaultQueueSchedulingPolicy or \"\n               + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n           }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n-          fairSharePreemptionThresholds, queueAcls, reservationAcls,\n-          configuredQueues, reservableQueues, nonPreemptableQueues);\n+          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n+          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n+          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n+          reservationAcls, configuredQueues, reservableQueues,\n+          nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n-    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n-        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n-        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n-        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n-        defaultSchedPolicy, minSharePreemptionTimeouts,\n-        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n-        reservationAcls, newPlacementPolicy, configuredQueues,\n-        globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n+    AllocationConfiguration info \u003d\n+        new AllocationConfiguration(minQueueResources, maxQueueResources,\n+          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n+          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n+          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n+          defaultSchedPolicy, minSharePreemptionTimeouts,\n+          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n+          reservationAcls, newPlacementPolicy, configuredQueues,\n+          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Resource\u003e maxChildQueueResources \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003c\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003c\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n            new HashMap\u003c\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003c\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003c\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d new HashMap\u003c\u003e();\n\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n          queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, configuredQueues, reservableQueues,\n          nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d\n        new AllocationConfiguration(minQueueResources, maxQueueResources,\n          maxChildQueueResources, queueMaxApps, userMaxApps, queueWeights,\n          queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n          queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n          defaultSchedPolicy, minSharePreemptionTimeouts,\n          fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n          reservationAcls, newPlacementPolicy, configuredQueues,\n          globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "170c4fd4cdbb8b4c1c4bb219e4c74fa0ba81b055": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4784. Fairscheduler: defaultQueueSchedulingPolicy should not accept FIFO. (Yufei Gu via kasha)\n",
      "commitDate": "20/04/16 11:58 PM",
      "commitName": "170c4fd4cdbb8b4c1c4bb219e4c74fa0ba81b055",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "11/02/16 10:47 AM",
      "commitNameOld": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 69.51,
      "commitsBetweenForRepo": 424,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,218 +1,223 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n             new HashMap\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n+            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n+              + \"config file: defaultQueueSchedulingPolicy or \"\n+              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n+          }\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, reservationAcls,\n           configuredQueues, reservableQueues, nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n         defaultSchedPolicy, minSharePreemptionTimeouts,\n         fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n         reservationAcls, newPlacementPolicy, configuredQueues,\n         globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n            new HashMap\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          if (text.equalsIgnoreCase(FifoPolicy.NAME)) {\n            throw new AllocationConfigurationException(\"Bad fair scheduler \"\n              + \"config file: defaultQueueSchedulingPolicy or \"\n              + \"defaultQueueSchedulingMode can\u0027t be FIFO.\");\n          }\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, reservationAcls,\n          configuredQueues, reservableQueues, nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n        defaultSchedPolicy, minSharePreemptionTimeouts,\n        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n        reservationAcls, newPlacementPolicy, configuredQueues,\n        globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2575. Create separate ACLs for Reservation create/update/delete/list ops (Sean Po via asuresh)\n",
      "commitDate": "11/02/16 10:47 AM",
      "commitName": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "27/01/16 12:29 PM",
      "commitNameOld": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 14.93,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,216 +1,218 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n+    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n+            new HashMap\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n-          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n-          reservableQueues, nonPreemptableQueues);\n+          fairSharePreemptionThresholds, queueAcls, reservationAcls,\n+          configuredQueues, reservableQueues, nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n         defaultSchedPolicy, minSharePreemptionTimeouts,\n         fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n-        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n-        reservableQueues, nonPreemptableQueues);\n+        reservationAcls, newPlacementPolicy, configuredQueues,\n+        globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e reservationAcls \u003d\n            new HashMap\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, reservationAcls,\n          configuredQueues, reservableQueues, nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n        defaultSchedPolicy, minSharePreemptionTimeouts,\n        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n        reservationAcls, newPlacementPolicy, configuredQueues,\n        globalReservationQueueConfig, reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4462. FairScheduler: Disallow preemption from a queue. (Tao Jie via kasha)\n",
      "commitDate": "27/01/16 12:29 PM",
      "commitName": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "18/01/16 1:58 AM",
      "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.44,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,215 +1,216 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException,\n       AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n+    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           Resource val \u003d\n               FairSchedulerConfiguration.parseResourceConfigValue(text);\n           queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, configuredQueues,\n-          reservableQueues);\n+          reservableQueues, nonPreemptableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n         defaultSchedPolicy, minSharePreemptionTimeouts,\n         fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n-        reservableQueues);\n+        reservableQueues, nonPreemptableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    Set\u003cString\u003e nonPreemptableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n          reservableQueues, nonPreemptableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n        defaultSchedPolicy, minSharePreemptionTimeouts,\n        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n        reservableQueues, nonPreemptableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "934d96a334598fcf0e5aba2043ff539469025f69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2913. Fair scheduler should have ability to set MaxResourceDefault for each queue. (Siqi Li via mingma)\n",
      "commitDate": "23/10/15 8:36 AM",
      "commitName": "934d96a334598fcf0e5aba2043ff539469025f69",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "23/03/15 1:22 PM",
      "commitNameOld": "2bc097cd14692e6ceb06bff959f28531534eb307",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 213.8,
      "commitsBetweenForRepo": 1810,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,215 @@\n   public synchronized void reloadAllocations() throws IOException,\n-      ParserConfigurationException, SAXException, AllocationConfigurationException {\n+      ParserConfigurationException, SAXException,\n+      AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n+    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n+        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          Resource val \u003d\n+              FairSchedulerConfiguration.parseResourceConfigValue(text);\n+          queueMaxResourcesDefault \u003d val;\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, configuredQueues,\n           reservableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n-        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n-        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n-        fairSharePreemptionThresholds, queueAcls,\n+        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n+        defaultSchedPolicy, minSharePreemptionTimeouts,\n+        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n         reservableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException,\n      AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    Resource queueMaxResourcesDefault \u003d Resources.unbounded();\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"queueMaxResourcesDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          Resource val \u003d\n              FairSchedulerConfiguration.parseResourceConfigValue(text);\n          queueMaxResourcesDefault \u003d val;\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n          reservableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxResourcesDefault, queueMaxAMShareDefault, queuePolicies,\n        defaultSchedPolicy, minSharePreemptionTimeouts,\n        fairSharePreemptionTimeouts, fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n        reservableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "32b43304563c2430c00bc3e142a962d2bc5f4d58": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert \"YARN-3181. FairScheduler: Fix up outdated findbugs issues. (kasha)\"\n\nThis reverts commit c2b185def846f5577a130003a533b9c377b58fab.\n",
      "commitDate": "17/03/15 12:31 PM",
      "commitName": "32b43304563c2430c00bc3e142a962d2bc5f4d58",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "12/02/15 1:44 PM",
      "commitNameOld": "c2b185def846f5577a130003a533b9c377b58fab",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 32.91,
      "commitsBetweenForRepo": 280,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,208 @@\n-  public void reloadAllocations() throws IOException,\n+  public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, configuredQueues,\n           reservableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n         minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n         fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n         reservableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n          reservableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n        fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n        reservableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "c2b185def846f5577a130003a533b9c377b58fab": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-3181. FairScheduler: Fix up outdated findbugs issues. (kasha)\n",
      "commitDate": "12/02/15 1:44 PM",
      "commitName": "c2b185def846f5577a130003a533b9c377b58fab",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "19/12/14 3:37 PM",
      "commitNameOld": "a22ffc318801698e86cd0e316b4824015f2486ac",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 54.92,
      "commitsBetweenForRepo": 384,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,208 @@\n-  public synchronized void reloadAllocations() throws IOException,\n+  public void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     // Reservation global configuration knobs\n     String planner \u003d null;\n     String reservationAgent \u003d null;\n     String reservationAdmissionPolicy \u003d null;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else if (\"reservation-planner\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           planner \u003d text;\n         } else if (\"reservation-agent\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAgent \u003d text;\n         } else if (\"reservation-policy\".equals(element.getTagName())) {\n           String text \u003d ((Text) element.getFirstChild()).getData().trim();\n           reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, configuredQueues,\n           reservableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n         ReservationQueueConfiguration();\n     if (planner !\u003d null) {\n       globalReservationQueueConfig.setPlanner(planner);\n     }\n     if (reservationAdmissionPolicy !\u003d null) {\n       globalReservationQueueConfig.setReservationAdmissionPolicy\n           (reservationAdmissionPolicy);\n     }\n     if (reservationAgent !\u003d null) {\n       globalReservationQueueConfig.setReservationAgent(reservationAgent);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n         minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n         fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n         reservableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n          reservableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n        fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n        reservableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {
        "oldValue": "[public, synchronized]",
        "newValue": "[public]"
      }
    },
    "a22ffc318801698e86cd0e316b4824015f2486ac": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2738. [YARN-2574] Add FairReservationSystem for FairScheduler. (Anubhav Dhoot via kasha)\n",
      "commitDate": "19/12/14 3:37 PM",
      "commitName": "a22ffc318801698e86cd0e316b4824015f2486ac",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/11/14 4:06 PM",
      "commitNameOld": "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
      "commitAuthorOld": "Sandy Ryza",
      "daysBetweenCommits": 27.98,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,178 +1,208 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n+    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n+    // Reservation global configuration knobs\n+    String planner \u003d null;\n+    String reservationAgent \u003d null;\n+    String reservationAdmissionPolicy \u003d null;\n+\n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n+        } else if (\"reservation-planner\".equals(element.getTagName())) {\n+          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n+          planner \u003d text;\n+        } else if (\"reservation-agent\".equals(element.getTagName())) {\n+          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n+          reservationAgent \u003d text;\n+        } else if (\"reservation-policy\".equals(element.getTagName())) {\n+          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n+          reservationAdmissionPolicy \u003d text;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n-          fairSharePreemptionThresholds, queueAcls, configuredQueues);\n+          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n+          reservableQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n+    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n+        ReservationQueueConfiguration();\n+    if (planner !\u003d null) {\n+      globalReservationQueueConfig.setPlanner(planner);\n+    }\n+    if (reservationAdmissionPolicy !\u003d null) {\n+      globalReservationQueueConfig.setReservationAdmissionPolicy\n+          (reservationAdmissionPolicy);\n+    }\n+    if (reservationAgent !\u003d null) {\n+      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n+    }\n+\n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n         minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n         fairSharePreemptionThresholds, queueAcls,\n-        newPlacementPolicy, configuredQueues);\n+        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n+        reservableQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    Set\u003cString\u003e reservableQueues \u003d new HashSet\u003cString\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    // Reservation global configuration knobs\n    String planner \u003d null;\n    String reservationAgent \u003d null;\n    String reservationAdmissionPolicy \u003d null;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else if (\"reservation-planner\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          planner \u003d text;\n        } else if (\"reservation-agent\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAgent \u003d text;\n        } else if (\"reservation-policy\".equals(element.getTagName())) {\n          String text \u003d ((Text) element.getFirstChild()).getData().trim();\n          reservationAdmissionPolicy \u003d text;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues,\n          reservableQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    ReservationQueueConfiguration globalReservationQueueConfig \u003d new\n        ReservationQueueConfiguration();\n    if (planner !\u003d null) {\n      globalReservationQueueConfig.setPlanner(planner);\n    }\n    if (reservationAdmissionPolicy !\u003d null) {\n      globalReservationQueueConfig.setReservationAdmissionPolicy\n          (reservationAdmissionPolicy);\n    }\n    if (reservationAgent !\u003d null) {\n      globalReservationQueueConfig.setReservationAgent(reservationAgent);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n        fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues, globalReservationQueueConfig,\n        reservableQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "43efdd30b52f4ee8967a03dac4d548095d6cafdb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2539. FairScheduler: Set the default value for maxAMShare to 0.5. (Wei Yan via kasha)\n",
      "commitDate": "22/09/14 4:09 PM",
      "commitName": "43efdd30b52f4ee8967a03dac4d548095d6cafdb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "03/09/14 10:27 AM",
      "commitNameOld": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 19.24,
      "commitsBetweenForRepo": 214,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,178 +1,178 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n         new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n-    float queueMaxAMShareDefault \u003d -1.0f;\n+    float queueMaxAMShareDefault \u003d 0.5f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"defaultFairSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n         } else if (\"defaultMinSharePreemptionTimeout\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"defaultFairSharePreemptionThreshold\"\n             .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n           defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n           fairSharePreemptionThresholds, queueAcls, configuredQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n     // Set the fair share preemption threshold for the root queue\n     if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionThreshold);\n     }\n \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n         minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n         fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d 0.5f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n        fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
      "commitDate": "03/09/14 10:27 AM",
      "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "30/08/14 1:17 AM",
      "commitNameOld": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,178 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n+    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n+        new HashMap\u003cString, Float\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     float queueMaxAMShareDefault \u003d -1.0f;\n     long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n+    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n-        } else if (\"defaultFairSharePreemptionTimeout\".equals(element.getTagName())) {\n+        } else if (\"defaultFairSharePreemptionTimeout\"\n+            .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultFairSharePreemptionTimeout \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n             String text \u003d ((Text)element.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             defaultFairSharePreemptionTimeout \u003d val;\n           }\n-        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n+        } else if (\"defaultMinSharePreemptionTimeout\"\n+            .equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n+        } else if (\"defaultFairSharePreemptionThreshold\"\n+            .equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          float val \u003d Float.parseFloat(text);\n+          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n+          defaultFairSharePreemptionThreshold \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n-          queueAcls, configuredQueues);\n+          fairSharePreemptionThresholds, queueAcls, configuredQueues);\n     }\n \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n \n     // Set the min/fair share preemption timeout for the root queue\n     if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n       minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultMinSharePreemptionTimeout);\n     }\n     if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n       fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n           defaultFairSharePreemptionTimeout);\n     }\n \n+    // Set the fair share preemption threshold for the root queue\n+    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n+      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n+          defaultFairSharePreemptionThreshold);\n+    }\n+\n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n         maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n         queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n         queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n-        minSharePreemptionTimeouts, fairSharePreemptionTimeouts, queueAcls,\n+        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n+        fairSharePreemptionThresholds, queueAcls,\n         newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Float\u003e fairSharePreemptionThresholds \u003d\n        new HashMap\u003cString, Float\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d -1.0f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    float defaultFairSharePreemptionThreshold \u003d 0.5f;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"defaultFairSharePreemptionThreshold\"\n            .equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n          defaultFairSharePreemptionThreshold \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          fairSharePreemptionThresholds, queueAcls, configuredQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    // Set the fair share preemption threshold for the root queue\n    if (!fairSharePreemptionThresholds.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionThresholds.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionThreshold);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n        fairSharePreemptionThresholds, queueAcls,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2395. FairScheduler: Preemption timeout should be configurable per queue. (Wei Yan via kasha)\n",
      "commitDate": "30/08/14 1:17 AM",
      "commitName": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/06/14 12:30 AM",
      "commitNameOld": "6fcbf9b848c63465d26a40387a9be212e708f80b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 70.03,
      "commitsBetweenForRepo": 561,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,160 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n+    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     float queueMaxAMShareDefault \u003d -1.0f;\n-    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n+    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n-    \n+\n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n-    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n+    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n-   \n+\n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n-        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n+        } else if (\"defaultFairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n-          fairSharePreemptionTimeout \u003d val;\n+          defaultFairSharePreemptionTimeout \u003d val;\n+        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n+          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n+            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+            long val \u003d Long.parseLong(text) * 1000L;\n+            defaultFairSharePreemptionTimeout \u003d val;\n+          }\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n-    \n+\n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-          queuePolicies, minSharePreemptionTimeouts, queueAcls,\n-          configuredQueues);\n+          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n+          queueAcls, configuredQueues);\n     }\n-    \n+\n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n-    \n-    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n-        queueMaxApps, userMaxApps, queueWeights, queueMaxAMShares, userMaxAppsDefault,\n-        queueMaxAppsDefault, queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n-        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n+\n+    // Set the min/fair share preemption timeout for the root queue\n+    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n+      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n+          defaultMinSharePreemptionTimeout);\n+    }\n+    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n+      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n+          defaultFairSharePreemptionTimeout);\n+    }\n+\n+    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n+        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n+        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n+        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n+        minSharePreemptionTimeouts, fairSharePreemptionTimeouts, queueAcls,\n         newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Long\u003e fairSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d -1.0f;\n    long defaultFairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n\n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d\n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"defaultFairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultFairSharePreemptionTimeout \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          if (defaultFairSharePreemptionTimeout \u003d\u003d Long.MAX_VALUE) {\n            String text \u003d ((Text)element.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            defaultFairSharePreemptionTimeout \u003d val;\n          }\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n\n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, fairSharePreemptionTimeouts,\n          queueAcls, configuredQueues);\n    }\n\n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n\n    // Set the min/fair share preemption timeout for the root queue\n    if (!minSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)){\n      minSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultMinSharePreemptionTimeout);\n    }\n    if (!fairSharePreemptionTimeouts.containsKey(QueueManager.ROOT_QUEUE)) {\n      fairSharePreemptionTimeouts.put(QueueManager.ROOT_QUEUE,\n          defaultFairSharePreemptionTimeout);\n    }\n\n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources,\n        maxQueueResources, queueMaxApps, userMaxApps, queueWeights,\n        queueMaxAMShares, userMaxAppsDefault, queueMaxAppsDefault,\n        queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy,\n        minSharePreemptionTimeouts, fairSharePreemptionTimeouts, queueAcls,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "6fcbf9b848c63465d26a40387a9be212e708f80b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2187. FairScheduler: Disable max-AM-share check by default. (Robert Kanter via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604321 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/14 12:30 AM",
      "commitName": "6fcbf9b848c63465d26a40387a9be212e708f80b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "06/06/14 5:49 PM",
      "commitNameOld": "969bef3c77c531237e5e0b1708c3e9265b43e153",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 14.28,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,142 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n-    float queueMaxAMShareDefault \u003d 1.0f;\n+    float queueMaxAMShareDefault \u003d -1.0f;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n    \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           float val \u003d Float.parseFloat(text);\n           val \u003d Math.min(val, 1.0f);\n           queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n           queuePolicies, minSharePreemptionTimeouts, queueAcls,\n           configuredQueues);\n     }\n     \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n     \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n         queueMaxApps, userMaxApps, queueWeights, queueMaxAMShares, userMaxAppsDefault,\n         queueMaxAppsDefault, queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n         queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n         newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d -1.0f;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n   \n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, queueAcls,\n          configuredQueues);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, queueMaxAMShares, userMaxAppsDefault,\n        queueMaxAppsDefault, queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1913. With Fair Scheduler, cluster can logjam when all resources are consumed by AMs (Wei Yan via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599400 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/06/14 5:56 PM",
      "commitName": "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "31/05/14 12:33 PM",
      "commitNameOld": "a4ba451802c6c61a0c804809740d46dd76059f25",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 2.22,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,142 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n+    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n+    float queueMaxAMShareDefault \u003d 1.0f;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     // configuredQueues is segregated based on whether it is a leaf queue\n     // or a parent queue. This information is used for creating queues\n     // and also for making queue placement decisions(QueuePlacementRule.java).\n     Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n         new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n     for (FSQueueType queueType : FSQueueType.values()) {\n       configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n     }\n    \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n+        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          float val \u003d Float.parseFloat(text);\n+          val \u003d Math.min(val, 1.0f);\n+          queueMaxAMShareDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n-          minSharePreemptionTimeouts, queueAcls,\n+          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n+          queuePolicies, minSharePreemptionTimeouts, queueAcls,\n           configuredQueues);\n     }\n     \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n           configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n           configuredQueues);\n     }\n     \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n-        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n+        queueMaxApps, userMaxApps, queueWeights, queueMaxAMShares, userMaxAppsDefault,\n+        queueMaxAppsDefault, queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n         queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n         newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Float\u003e queueMaxAMShares \u003d new HashMap\u003cString, Float\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    float queueMaxAMShareDefault \u003d 1.0f;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n   \n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"queueMaxAMShareDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          float val \u003d Float.parseFloat(text);\n          val \u003d Math.min(val, 1.0f);\n          queueMaxAMShareDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n          queuePolicies, minSharePreemptionTimeouts, queueAcls,\n          configuredQueues);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, queueMaxAMShares, userMaxAppsDefault,\n        queueMaxAppsDefault, queueMaxAMShareDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 12:21 AM",
      "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "15/01/14 3:09 PM",
      "commitNameOld": "7274b5ff93afc6e6e96fb6fcd43f2955960f2644",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 112.34,
      "commitsBetweenForRepo": 846,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,135 @@\n   public synchronized void reloadAllocations() throws IOException,\n       ParserConfigurationException, SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) {\n       return;\n     }\n     LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n-    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n-\n+    // configuredQueues is segregated based on whether it is a leaf queue\n+    // or a parent queue. This information is used for creating queues\n+    // and also for making queue placement decisions(QueuePlacementRule.java).\n+    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n+        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n+    for (FSQueueType queueType : FSQueueType.values()) {\n+      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n+    }\n+   \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n           \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n               + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n-      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n-          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-          queueAcls, queueNamesInAllocFile);\n+      loadQueue(parent, element, minQueueResources, maxQueueResources,\n+          queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n+          minSharePreemptionTimeouts, queueAcls,\n+          configuredQueues);\n     }\n     \n     // Load placement policy and pass it configured queues\n     Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          queueNamesInAllocFile, conf);\n+          configuredQueues, conf);\n     } else {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n-          queueNamesInAllocFile);\n+          configuredQueues);\n     }\n     \n     AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n         queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n         queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n         queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n-        newPlacementPolicy, queueNamesInAllocFile);\n+        newPlacementPolicy, configuredQueues);\n     \n     lastSuccessfulReload \u003d clock.getTime();\n     lastReloadAttemptFailed \u003d false;\n \n     reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    // configuredQueues is segregated based on whether it is a leaf queue\n    // or a parent queue. This information is used for creating queues\n    // and also for making queue placement decisions(QueuePlacementRule.java).\n    Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues \u003d \n        new HashMap\u003cFSQueueType, Set\u003cString\u003e\u003e();\n    for (FSQueueType queueType : FSQueueType.values()) {\n      configuredQueues.put(queueType, new HashSet\u003cString\u003e());\n    }\n   \n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n          minSharePreemptionTimeouts, queueAcls,\n          configuredQueues);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          configuredQueues, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          configuredQueues);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, configuredQueues);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yrename)",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,127 @@\n-  public void reloadAllocs() throws IOException, ParserConfigurationException,\n-      SAXException, AllocationConfigurationException {\n-    if (allocFile \u003d\u003d null) return;\n+  public synchronized void reloadAllocations() throws IOException,\n+      ParserConfigurationException, SAXException, AllocationConfigurationException {\n+    if (allocFile \u003d\u003d null) {\n+      return;\n+    }\n+    LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n-    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n-      \t  \"pool\".equals(element.getTagName())) {\n+          \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          SchedulingPolicy.setDefault(text);\n-          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n-          \t\t+ \" no other queues can be placed alongside it.\");\n+              + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n     \n     // Load placement policy and pass it configured queues\n+    Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+          queueNamesInAllocFile, conf);\n     } else {\n-      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n+          queueNamesInAllocFile);\n     }\n+    \n+    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n+        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n+        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n+        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n+        newPlacementPolicy, queueNamesInAllocFile);\n+    \n+    lastSuccessfulReload \u003d clock.getTime();\n+    lastReloadAttemptFailed \u003d false;\n \n-    // Commit the reload; also create any queue defined in the alloc file\n-    // if it does not already exist, so it can be displayed on the web UI.\n-    synchronized (this) {\n-      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n-          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n-      placementPolicy \u003d newPlacementPolicy;\n-      \n-      // Make sure all queues exist\n-      for (String name: queueNamesInAllocFile) {\n-        getLeafQueue(name, true);\n-      }\n-      \n-      for (FSQueue queue : queues.values()) {\n-        // Update queue metrics\n-        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-        queueMetrics.setMinShare(queue.getMinShare());\n-        queueMetrics.setMaxShare(queue.getMaxShare());\n-        // Set scheduling policies\n-        if (queuePolicies.containsKey(queue.getName())) {\n-          queue.setPolicy(queuePolicies.get(queue.getName()));\n-        } else {\n-          queue.setPolicy(SchedulingPolicy.getDefault());\n-        }\n-      }\n- \n-    }\n+    reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          queueNamesInAllocFile, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          queueNamesInAllocFile);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, queueNamesInAllocFile);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
            "oldMethodName": "reloadAllocs",
            "newMethodName": "reloadAllocations"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,127 @@\n-  public void reloadAllocs() throws IOException, ParserConfigurationException,\n-      SAXException, AllocationConfigurationException {\n-    if (allocFile \u003d\u003d null) return;\n+  public synchronized void reloadAllocations() throws IOException,\n+      ParserConfigurationException, SAXException, AllocationConfigurationException {\n+    if (allocFile \u003d\u003d null) {\n+      return;\n+    }\n+    LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n-    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n-      \t  \"pool\".equals(element.getTagName())) {\n+          \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          SchedulingPolicy.setDefault(text);\n-          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n-          \t\t+ \" no other queues can be placed alongside it.\");\n+              + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n     \n     // Load placement policy and pass it configured queues\n+    Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+          queueNamesInAllocFile, conf);\n     } else {\n-      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n+          queueNamesInAllocFile);\n     }\n+    \n+    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n+        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n+        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n+        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n+        newPlacementPolicy, queueNamesInAllocFile);\n+    \n+    lastSuccessfulReload \u003d clock.getTime();\n+    lastReloadAttemptFailed \u003d false;\n \n-    // Commit the reload; also create any queue defined in the alloc file\n-    // if it does not already exist, so it can be displayed on the web UI.\n-    synchronized (this) {\n-      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n-          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n-      placementPolicy \u003d newPlacementPolicy;\n-      \n-      // Make sure all queues exist\n-      for (String name: queueNamesInAllocFile) {\n-        getLeafQueue(name, true);\n-      }\n-      \n-      for (FSQueue queue : queues.values()) {\n-        // Update queue metrics\n-        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-        queueMetrics.setMinShare(queue.getMinShare());\n-        queueMetrics.setMaxShare(queue.getMaxShare());\n-        // Set scheduling policies\n-        if (queuePolicies.containsKey(queue.getName())) {\n-          queue.setPolicy(queuePolicies.get(queue.getName()));\n-        } else {\n-          queue.setPolicy(SchedulingPolicy.getDefault());\n-        }\n-      }\n- \n-    }\n+    reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          queueNamesInAllocFile, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          queueNamesInAllocFile);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, queueNamesInAllocFile);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,127 @@\n-  public void reloadAllocs() throws IOException, ParserConfigurationException,\n-      SAXException, AllocationConfigurationException {\n-    if (allocFile \u003d\u003d null) return;\n+  public synchronized void reloadAllocations() throws IOException,\n+      ParserConfigurationException, SAXException, AllocationConfigurationException {\n+    if (allocFile \u003d\u003d null) {\n+      return;\n+    }\n+    LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n-    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n-      \t  \"pool\".equals(element.getTagName())) {\n+          \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          SchedulingPolicy.setDefault(text);\n-          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n-          \t\t+ \" no other queues can be placed alongside it.\");\n+              + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n     \n     // Load placement policy and pass it configured queues\n+    Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+          queueNamesInAllocFile, conf);\n     } else {\n-      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n+          queueNamesInAllocFile);\n     }\n+    \n+    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n+        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n+        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n+        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n+        newPlacementPolicy, queueNamesInAllocFile);\n+    \n+    lastSuccessfulReload \u003d clock.getTime();\n+    lastReloadAttemptFailed \u003d false;\n \n-    // Commit the reload; also create any queue defined in the alloc file\n-    // if it does not already exist, so it can be displayed on the web UI.\n-    synchronized (this) {\n-      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n-          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n-      placementPolicy \u003d newPlacementPolicy;\n-      \n-      // Make sure all queues exist\n-      for (String name: queueNamesInAllocFile) {\n-        getLeafQueue(name, true);\n-      }\n-      \n-      for (FSQueue queue : queues.values()) {\n-        // Update queue metrics\n-        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-        queueMetrics.setMinShare(queue.getMinShare());\n-        queueMetrics.setMaxShare(queue.getMaxShare());\n-        // Set scheduling policies\n-        if (queuePolicies.containsKey(queue.getName())) {\n-          queue.setPolicy(queuePolicies.get(queue.getName()));\n-        } else {\n-          queue.setPolicy(SchedulingPolicy.getDefault());\n-        }\n-      }\n- \n-    }\n+    reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          queueNamesInAllocFile, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          queueNamesInAllocFile);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, queueNamesInAllocFile);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,127 @@\n-  public void reloadAllocs() throws IOException, ParserConfigurationException,\n-      SAXException, AllocationConfigurationException {\n-    if (allocFile \u003d\u003d null) return;\n+  public synchronized void reloadAllocations() throws IOException,\n+      ParserConfigurationException, SAXException, AllocationConfigurationException {\n+    if (allocFile \u003d\u003d null) {\n+      return;\n+    }\n+    LOG.info(\"Loading allocation file \" + allocFile);\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n     \n     QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n-    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n-      \t  \"pool\".equals(element.getTagName())) {\n+          \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-          SchedulingPolicy.setDefault(text);\n-          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n         } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n           placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n-          \t\t+ \" no other queues can be placed alongside it.\");\n+              + \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n     \n     // Load placement policy and pass it configured queues\n+    Configuration conf \u003d getConfig();\n     if (placementPolicyElement !\u003d null) {\n       newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+          queueNamesInAllocFile, conf);\n     } else {\n-      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n-          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n+          queueNamesInAllocFile);\n     }\n+    \n+    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n+        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n+        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n+        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n+        newPlacementPolicy, queueNamesInAllocFile);\n+    \n+    lastSuccessfulReload \u003d clock.getTime();\n+    lastReloadAttemptFailed \u003d false;\n \n-    // Commit the reload; also create any queue defined in the alloc file\n-    // if it does not already exist, so it can be displayed on the web UI.\n-    synchronized (this) {\n-      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n-          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n-          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n-      placementPolicy \u003d newPlacementPolicy;\n-      \n-      // Make sure all queues exist\n-      for (String name: queueNamesInAllocFile) {\n-        getLeafQueue(name, true);\n-      }\n-      \n-      for (FSQueue queue : queues.values()) {\n-        // Update queue metrics\n-        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-        queueMetrics.setMinShare(queue.getMinShare());\n-        queueMetrics.setMaxShare(queue.getMaxShare());\n-        // Set scheduling policies\n-        if (queuePolicies.containsKey(queue.getName())) {\n-          queue.setPolicy(queuePolicies.get(queue.getName()));\n-        } else {\n-          queue.setPolicy(SchedulingPolicy.getDefault());\n-        }\n-      }\n- \n-    }\n+    reloadListener.onReload(info);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void reloadAllocations() throws IOException,\n      ParserConfigurationException, SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) {\n      return;\n    }\n    LOG.info(\"Loading allocation file \" + allocFile);\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.DEFAULT_POLICY;\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    Set\u003cString\u003e queueNamesInAllocFile \u003d new HashSet\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n          \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          defaultSchedPolicy \u003d SchedulingPolicy.parse(text);\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n              + \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n    \n    // Load placement policy and pass it configured queues\n    Configuration conf \u003d getConfig();\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          queueNamesInAllocFile, conf);\n    } else {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromConfiguration(conf,\n          queueNamesInAllocFile);\n    }\n    \n    AllocationConfiguration info \u003d new AllocationConfiguration(minQueueResources, maxQueueResources,\n        queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n        queueMaxAppsDefault, queuePolicies, defaultSchedPolicy, minSharePreemptionTimeouts,\n        queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout,\n        newPlacementPolicy, queueNamesInAllocFile);\n    \n    lastSuccessfulReload \u003d clock.getTime();\n    lastReloadAttemptFailed \u003d false;\n\n    reloadListener.onReload(info);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "reloadAllocs",
            "newValue": "reloadAllocations"
          }
        }
      ]
    },
    "3858b9018e3c2f4b883b02021679852591b706f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1392. Allow sophisticated app-to-queue placement policies in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:12 PM",
      "commitName": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "22/10/13 4:53 PM",
      "commitNameOld": "3baff29b8cf594145f0ca8da36b1d7603a5992cc",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 22.93,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,142 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+    \n+    QueuePlacementPolicy newPlacementPolicy \u003d null;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n+    Element placementPolicyElement \u003d null;\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n       \t  \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           SchedulingPolicy.setDefault(text);\n           defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n+          placementPolicyElement \u003d element;\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n           \t\t+ \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n+    \n+    // Load placement policy and pass it configured queues\n+    if (placementPolicyElement !\u003d null) {\n+      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n+          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+    } else {\n+      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n+          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n+    }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n+      placementPolicy \u003d newPlacementPolicy;\n       \n       // Make sure all queues exist\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n       for (FSQueue queue : queues.values()) {\n         // Update queue metrics\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n         // Set scheduling policies\n         if (queuePolicies.containsKey(queue.getName())) {\n           queue.setPolicy(queuePolicies.get(queue.getName()));\n         } else {\n           queue.setPolicy(SchedulingPolicy.getDefault());\n         }\n       }\n  \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n    \n    QueuePlacementPolicy newPlacementPolicy \u003d null;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    Element placementPolicyElement \u003d null;\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else if (\"queuePlacementPolicy\".equals(element.getTagName())) {\n          placementPolicyElement \u003d element;\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n    \n    // Load placement policy and pass it configured queues\n    if (placementPolicyElement !\u003d null) {\n      newPlacementPolicy \u003d QueuePlacementPolicy.fromXml(placementPolicyElement,\n          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n    } else {\n      newPlacementPolicy \u003d new QueuePlacementPolicy(getSimplePlacementRules(),\n          new HashSet\u003cString\u003e(queueNamesInAllocFile), scheduler.getConf());\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      placementPolicy \u003d newPlacementPolicy;\n      \n      // Make sure all queues exist\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      for (FSQueue queue : queues.values()) {\n        // Update queue metrics\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n        // Set scheduling policies\n        if (queuePolicies.containsKey(queue.getName())) {\n          queue.setPolicy(queuePolicies.get(queue.getName()));\n        } else {\n          queue.setPolicy(SchedulingPolicy.getDefault());\n        }\n      }\n \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "3baff29b8cf594145f0ca8da36b1d7603a5992cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1330. Fair Scheduler: defaultQueueSchedulingPolicy does not take effect (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/10/13 4:53 PM",
      "commitName": "3baff29b8cf594145f0ca8da36b1d7603a5992cc",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/10/13 11:45 AM",
      "commitNameOld": "dc523bd18247df232fe814aed7062a116242ab04",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,127 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n       \t  \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           SchedulingPolicy.setDefault(text);\n           defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n           \t\t+ \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n-      // Update metrics\n-      for (FSQueue queue : queues.values()) {\n-        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n-        queueMetrics.setMinShare(queue.getMinShare());\n-        queueMetrics.setMaxShare(queue.getMaxShare());\n-      }\n- \n-      // Create all queus\n+      // Make sure all queues exist\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n-      // Set custom policies as specified\n-      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n-        queues.get(entry.getKey()).setPolicy(entry.getValue());\n+      for (FSQueue queue : queues.values()) {\n+        // Update queue metrics\n+        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n+        queueMetrics.setMinShare(queue.getMinShare());\n+        queueMetrics.setMaxShare(queue.getMaxShare());\n+        // Set scheduling policies\n+        if (queuePolicies.containsKey(queue.getName())) {\n+          queue.setPolicy(queuePolicies.get(queue.getName()));\n+        } else {\n+          queue.setPolicy(SchedulingPolicy.getDefault());\n+        }\n       }\n+ \n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Make sure all queues exist\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      for (FSQueue queue : queues.values()) {\n        // Update queue metrics\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n        // Set scheduling policies\n        if (queuePolicies.containsKey(queue.getName())) {\n          queue.setPolicy(queuePolicies.get(queue.getName()));\n        } else {\n          queue.setPolicy(SchedulingPolicy.getDefault());\n        }\n      }\n \n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "dc523bd18247df232fe814aed7062a116242ab04": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1288. Make Fair Scheduler ACLs more user friendly (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534315 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:45 AM",
      "commitName": "dc523bd18247df232fe814aed7062a116242ab04",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/10/13 11:37 AM",
      "commitNameOld": "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,125 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n       \t  \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           SchedulingPolicy.setDefault(text);\n           defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n           \t\t+ \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n-      \n-      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n-      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n-      // neither allow nor prohibit more access to its children.\n-      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n-          new HashMap\u003cQueueACL, AccessControlList\u003e();\n-      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n-      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n-      queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf": {
      "type": "Ybodychange",
      "commitMessage": "Reverting \"YARN-1258: Move to 2.2.1 in CHANGES.txt\" because it contained unintended changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534308 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:37 AM",
      "commitName": "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/10/13 11:31 AM",
      "commitNameOld": "65bda6d168e47106f5542e15bb7b21522478626e",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,134 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n       \t  \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           SchedulingPolicy.setDefault(text);\n           defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n           \t\t+ \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n+      \n+      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n+      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n+      // neither allow nor prohibit more access to its children.\n+      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n+          new HashMap\u003cQueueACL, AccessControlList\u003e();\n+      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n+      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n+      queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "65bda6d168e47106f5542e15bb7b21522478626e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1258: Move to 2.2.1 in CHANGES.txt\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534307 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:31 AM",
      "commitName": "65bda6d168e47106f5542e15bb7b21522478626e",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "09/10/13 2:19 AM",
      "commitNameOld": "643b1a401968a21d902b602e76a53c1f98b1a950",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 12.38,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,125 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (node instanceof Element) {\n         Element element \u003d (Element)node;\n         if (\"queue\".equals(element.getTagName()) ||\n       \t  \"pool\".equals(element.getTagName())) {\n           queueElements.add(element);\n         } else if (\"user\".equals(element.getTagName())) {\n           String userName \u003d element.getAttribute(\"name\");\n           NodeList fields \u003d element.getChildNodes();\n           for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n             Node fieldNode \u003d fields.item(j);\n             if (!(fieldNode instanceof Element))\n               continue;\n             Element field \u003d (Element) fieldNode;\n             if (\"maxRunningApps\".equals(field.getTagName())) {\n               String text \u003d ((Text)field.getFirstChild()).getData().trim();\n               int val \u003d Integer.parseInt(text);\n               userMaxApps.put(userName, val);\n             }\n           }\n         } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           userMaxAppsDefault \u003d val;\n         } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           fairSharePreemptionTimeout \u003d val;\n         } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           long val \u003d Long.parseLong(text) * 1000L;\n           defaultMinSharePreemptionTimeout \u003d val;\n         } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           int val \u003d Integer.parseInt(text);\n           queueMaxAppsDefault \u003d val;\n         } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n             || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n           String text \u003d ((Text)element.getFirstChild()).getData().trim();\n           SchedulingPolicy.setDefault(text);\n           defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n         } else {\n           LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n       }\n     }\n     \n     // Load queue elements.  A root queue can either be included or omitted.  If\n     // it\u0027s included, all other queues must be inside it.\n     for (Element element : queueElements) {\n       String parent \u003d \"root\";\n       if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n         if (queueElements.size() \u003e 1) {\n           throw new AllocationConfigurationException(\"If configuring root queue,\"\n           \t\t+ \" no other queues can be placed alongside it.\");\n         }\n         parent \u003d null;\n       }\n       loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n           userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n           queueAcls, queueNamesInAllocFile);\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n-      \n-      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n-      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n-      // neither allow nor prohibit more access to its children.\n-      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n-          new HashMap\u003cQueueACL, AccessControlList\u003e();\n-      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n-      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n-      queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "643b1a401968a21d902b602e76a53c1f98b1a950": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1258. Allow configuring the Fair Scheduler root queue (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/10/13 2:19 AM",
      "commitName": "643b1a401968a21d902b602e76a53c1f98b1a950",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "02/10/13 6:17 PM",
      "commitNameOld": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 6.33,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,134 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n+    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n-      if (!(node instanceof Element))\n-        continue;\n-      Element element \u003d (Element)node;\n-      if (\"queue\".equals(element.getTagName()) ||\n-    \t  \"pool\".equals(element.getTagName())) {\n-        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n-            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-            queueAcls, queueNamesInAllocFile);\n-      } else if (\"user\".equals(element.getTagName())) {\n-        String userName \u003d element.getAttribute(\"name\");\n-        NodeList fields \u003d element.getChildNodes();\n-        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n-          Node fieldNode \u003d fields.item(j);\n-          if (!(fieldNode instanceof Element))\n-            continue;\n-          Element field \u003d (Element) fieldNode;\n-          if (\"maxRunningApps\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            int val \u003d Integer.parseInt(text);\n-            userMaxApps.put(userName, val);\n+      if (node instanceof Element) {\n+        Element element \u003d (Element)node;\n+        if (\"queue\".equals(element.getTagName()) ||\n+      \t  \"pool\".equals(element.getTagName())) {\n+          queueElements.add(element);\n+        } else if (\"user\".equals(element.getTagName())) {\n+          String userName \u003d element.getAttribute(\"name\");\n+          NodeList fields \u003d element.getChildNodes();\n+          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n+            Node fieldNode \u003d fields.item(j);\n+            if (!(fieldNode instanceof Element))\n+              continue;\n+            Element field \u003d (Element) fieldNode;\n+            if (\"maxRunningApps\".equals(field.getTagName())) {\n+              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+              int val \u003d Integer.parseInt(text);\n+              userMaxApps.put(userName, val);\n+            }\n           }\n+        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          int val \u003d Integer.parseInt(text);\n+          userMaxAppsDefault \u003d val;\n+        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          long val \u003d Long.parseLong(text) * 1000L;\n+          fairSharePreemptionTimeout \u003d val;\n+        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          long val \u003d Long.parseLong(text) * 1000L;\n+          defaultMinSharePreemptionTimeout \u003d val;\n+        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          int val \u003d Integer.parseInt(text);\n+          queueMaxAppsDefault \u003d val;\n+        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n+            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n+          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+          SchedulingPolicy.setDefault(text);\n+          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n+        } else {\n+          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n         }\n-      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n-        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        userMaxAppsDefault \u003d val;\n-      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n-        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        long val \u003d Long.parseLong(text) * 1000L;\n-        fairSharePreemptionTimeout \u003d val;\n-      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n-        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        long val \u003d Long.parseLong(text) * 1000L;\n-        defaultMinSharePreemptionTimeout \u003d val;\n-      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n-        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        queueMaxAppsDefault \u003d val;\n-      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n-          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n-        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        SchedulingPolicy.setDefault(text);\n-        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n-      } else {\n-        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n+    \n+    // Load queue elements.  A root queue can either be included or omitted.  If\n+    // it\u0027s included, all other queues must be inside it.\n+    for (Element element : queueElements) {\n+      String parent \u003d \"root\";\n+      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n+        if (queueElements.size() \u003e 1) {\n+          throw new AllocationConfigurationException(\"If configuring root queue,\"\n+          \t\t+ \" no other queues can be placed alongside it.\");\n+        }\n+        parent \u003d null;\n+      }\n+      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n+          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n+          queueAcls, queueNamesInAllocFile);\n+    }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name, true);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    List\u003cElement\u003e queueElements \u003d new ArrayList\u003cElement\u003e();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (node instanceof Element) {\n        Element element \u003d (Element)node;\n        if (\"queue\".equals(element.getTagName()) ||\n      \t  \"pool\".equals(element.getTagName())) {\n          queueElements.add(element);\n        } else if (\"user\".equals(element.getTagName())) {\n          String userName \u003d element.getAttribute(\"name\");\n          NodeList fields \u003d element.getChildNodes();\n          for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n            Node fieldNode \u003d fields.item(j);\n            if (!(fieldNode instanceof Element))\n              continue;\n            Element field \u003d (Element) fieldNode;\n            if (\"maxRunningApps\".equals(field.getTagName())) {\n              String text \u003d ((Text)field.getFirstChild()).getData().trim();\n              int val \u003d Integer.parseInt(text);\n              userMaxApps.put(userName, val);\n            }\n          }\n        } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          userMaxAppsDefault \u003d val;\n        } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          fairSharePreemptionTimeout \u003d val;\n        } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          long val \u003d Long.parseLong(text) * 1000L;\n          defaultMinSharePreemptionTimeout \u003d val;\n        } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          int val \u003d Integer.parseInt(text);\n          queueMaxAppsDefault \u003d val;\n        } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n            || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n          String text \u003d ((Text)element.getFirstChild()).getData().trim();\n          SchedulingPolicy.setDefault(text);\n          defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n        } else {\n          LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n        }\n      }\n    }\n    \n    // Load queue elements.  A root queue can either be included or omitted.  If\n    // it\u0027s included, all other queues must be inside it.\n    for (Element element : queueElements) {\n      String parent \u003d \"root\";\n      if (element.getAttribute(\"name\").equalsIgnoreCase(\"root\")) {\n        if (queueElements.size() \u003e 1) {\n          throw new AllocationConfigurationException(\"If configuring root queue,\"\n          \t\t+ \" no other queues can be placed alongside it.\");\n        }\n        parent \u003d null;\n      }\n      loadQueue(parent, element, minQueueResources, maxQueueResources, queueMaxApps,\n          userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n          queueAcls, queueNamesInAllocFile);\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "2db1d4d4ee7838f2a8c0b3999b6055456798321d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1213. Restore config to ban submitting to undeclared pools in the Fair Scheduler. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528696 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/10/13 6:17 PM",
      "commitName": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "01/10/13 1:14 PM",
      "commitNameOld": "aa2745abe596c610157f6e3be9c23ba8cc1e21d0",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,119 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;\n       } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n           || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         SchedulingPolicy.setDefault(text);\n         defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n-        getLeafQueue(name);\n+        getLeafQueue(name, true);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;\n      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingPolicy.setDefault(text);\n        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name, true);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "aa2745abe596c610157f6e3be9c23ba8cc1e21d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1228. Clean up Fair Scheduler configuration loading. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528201 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/10/13 1:14 PM",
      "commitName": "aa2745abe596c610157f6e3be9c23ba8cc1e21d0",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "28/06/13 11:59 AM",
      "commitNameOld": "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 95.05,
      "commitsBetweenForRepo": 531,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,119 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n-    Document doc;\n-    if (allocFile instanceof String) {\n-      doc \u003d builder.parse(new File((String) allocFile));\n-    } else {\n-      doc \u003d builder.parse(allocFile.toString());\n-    }\n+    Document doc \u003d builder.parse(allocFile);\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;\n       } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n           || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         SchedulingPolicy.setDefault(text);\n         defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Update metrics\n       for (FSQueue queue : queues.values()) {\n         FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n         queueMetrics.setMinShare(queue.getMinShare());\n         queueMetrics.setMaxShare(queue.getMaxShare());\n       }\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc \u003d builder.parse(allocFile);\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;\n      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingPolicy.setDefault(text);\n        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "c221204ccaadcf70992d9e858ef71c6f8864ff4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-883. Expose Fair Scheduler-specific queue metrics. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1497884 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/06/13 11:59 AM",
      "commitName": "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "21/06/13 11:28 AM",
      "commitNameOld": "37d7935a9d7b86635c9c1ffc03f88b49857f88a0",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 7.02,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,124 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;\n       } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n           || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         SchedulingPolicy.setDefault(text);\n         defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n+      // Update metrics\n+      for (FSQueue queue : queues.values()) {\n+        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n+        queueMetrics.setMinShare(queue.getMinShare());\n+        queueMetrics.setMaxShare(queue.getMaxShare());\n+      }\n+      \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;\n      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingPolicy.setDefault(text);\n        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Update metrics\n      for (FSQueue queue : queues.values()) {\n        FSQueueMetrics queueMetrics \u003d queue.getMetrics();\n        queueMetrics.setMinShare(queue.getMinShare());\n        queueMetrics.setMaxShare(queue.getMaxShare());\n      }\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Ybodychange",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "25/04/13 1:33 AM",
      "commitNameOld": "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 39.38,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n-    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n+    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n     Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;\n       } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n           || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         SchedulingPolicy.setDefault(text);\n         defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n  \n       // Create all queus\n       for (String name: queueNamesInAllocFile) {\n         getLeafQueue(name);\n       }\n       \n       // Set custom policies as specified\n       for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n         queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, ResourceWeights\u003e queueWeights \u003d new HashMap\u003cString, ResourceWeights\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;\n      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingPolicy.setDefault(text);\n        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": {
      "type": "Ybodychange",
      "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 11:11 AM",
      "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "25/03/13 8:25 PM",
      "commitNameOld": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 23.62,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,117 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n-    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n+    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.getDefault();\n+    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n-            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n+            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n-        queueMaxAppsDefault \u003d val;}\n-      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n+        queueMaxAppsDefault \u003d val;\n+      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n+          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        SchedulingMode.setDefault(text);\n-        defaultSchedulingMode \u003d SchedulingMode.getDefault();\n+        SchedulingPolicy.setDefault(text);\n+        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n-          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n+          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n-\n+ \n+      // Create all queus\n       for (String name: queueNamesInAllocFile) {\n-        FSLeafQueue queue \u003d getLeafQueue(name);\n-        if (queueModes.containsKey(name)) {\n-          queue.setSchedulingMode(queueModes.get(name));\n-        } else {\n-          queue.setSchedulingMode(defaultSchedulingMode);\n-        }\n+        getLeafQueue(name);\n+      }\n+      \n+      // Set custom policies as specified\n+      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n+        queues.get(entry.getKey()).setPolicy(entry.getValue());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingPolicy\u003e queuePolicies \u003d new HashMap\u003cString, SchedulingPolicy\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingPolicy defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;\n      } else if (\"defaultQueueSchedulingPolicy\".equals(element.getTagName())\n          || \"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingPolicy.setDefault(text);\n        defaultSchedPolicy \u003d SchedulingPolicy.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedPolicy, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n \n      // Create all queus\n      for (String name: queueNamesInAllocFile) {\n        getLeafQueue(name);\n      }\n      \n      // Set custom policies as specified\n      for (Map.Entry\u003cString, SchedulingPolicy\u003e entry : queuePolicies.entrySet()) {\n        queues.get(entry.getKey()).setPolicy(entry.getValue());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-469. Make scheduling mode in FS pluggable. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460961 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 8:25 PM",
      "commitName": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 75.93,
      "commitsBetweenForRepo": 364,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,115 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n-    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n+    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.getDefault();\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;}\n       else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n-        defaultSchedulingMode \u003d parseSchedulingMode(text);\n+        SchedulingMode.setDefault(text);\n+        defaultSchedulingMode \u003d SchedulingMode.getDefault();\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       \n       // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n       // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n       // neither allow nor prohibit more access to its children.\n       Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n           new HashMap\u003cQueueACL, AccessControlList\u003e();\n       rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n       rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n       queueAcls.put(ROOT_QUEUE, rootAcls);\n \n       for (String name: queueNamesInAllocFile) {\n         FSLeafQueue queue \u003d getLeafQueue(name);\n         if (queueModes.containsKey(name)) {\n           queue.setSchedulingMode(queueModes.get(name));\n         } else {\n           queue.setSchedulingMode(defaultSchedulingMode);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.getDefault();\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        SchedulingMode.setDefault(text);\n        defaultSchedulingMode \u003d SchedulingMode.getDefault();\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n\n      for (String name: queueNamesInAllocFile) {\n        FSLeafQueue queue \u003d getLeafQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "19a291a0d65b64e50571c3519414b9d54acbe28a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-288. Fair scheduler queue doesn\u0027t accept any jobs when ACLs are configured. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1428362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/01/13 6:32 AM",
      "commitName": "19a291a0d65b64e50571c3519414b9d54acbe28a",
      "commitAuthor": "Thomas White",
      "commitDateOld": "21/12/12 8:20 AM",
      "commitNameOld": "a276f68b9278a318aa7f45886402917ca802aa4f",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.92,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,114 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;}\n       else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         defaultSchedulingMode \u003d parseSchedulingMode(text);\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n+      \n+      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n+      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n+      // neither allow nor prohibit more access to its children.\n+      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n+          new HashMap\u003cQueueACL, AccessControlList\u003e();\n+      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n+      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n+      queueAcls.put(ROOT_QUEUE, rootAcls);\n+\n       for (String name: queueNamesInAllocFile) {\n         FSLeafQueue queue \u003d getLeafQueue(name);\n         if (queueModes.containsKey(name)) {\n           queue.setSchedulingMode(queueModes.get(name));\n         } else {\n           queue.setSchedulingMode(defaultSchedulingMode);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      \n      // Root queue should have empty ACLs.  As a queue\u0027s ACL is the union of\n      // its ACL and all its parents\u0027 ACLs, setting the roots\u0027 to empty will\n      // neither allow nor prohibit more access to its children.\n      Map\u003cQueueACL, AccessControlList\u003e rootAcls \u003d\n          new HashMap\u003cQueueACL, AccessControlList\u003e();\n      rootAcls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(\" \"));\n      rootAcls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(\" \"));\n      queueAcls.put(ROOT_QUEUE, rootAcls);\n\n      for (String name: queueNamesInAllocFile) {\n        FSLeafQueue queue \u003d getLeafQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Ybodychange",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "commitDateOld": "17/11/12 9:00 PM",
      "commitNameOld": "576f96f0ac79a2afe49948056498f2c06fe317c3",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.29,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,104 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n-        String queueName \u003d element.getAttribute(\"name\");\n-        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n-            new HashMap\u003cQueueACL, AccessControlList\u003e();\n-        queueNamesInAllocFile.add(queueName);\n-        NodeList fields \u003d element.getChildNodes();\n-        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n-          Node fieldNode \u003d fields.item(j);\n-          if (!(fieldNode instanceof Element))\n-            continue;\n-          Element field \u003d (Element) fieldNode;\n-          if (\"minResources\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            int val \u003d Integer.parseInt(text);\n-            minQueueResources.put(queueName, Resources.createResource(val));\n-          } else if (\"maxResources\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            int val \u003d Integer.parseInt(text);\n-            maxQueueResources.put(queueName, Resources.createResource(val));\n-          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            int val \u003d Integer.parseInt(text);\n-            queueMaxApps.put(queueName, val);\n-          } else if (\"weight\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            double val \u003d Double.parseDouble(text);\n-            queueWeights.put(queueName, val);\n-          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            long val \u003d Long.parseLong(text) * 1000L;\n-            minSharePreemptionTimeouts.put(queueName, val);\n-          } else if (\"schedulingMode\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            queueModes.put(queueName, parseSchedulingMode(text));\n-          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n-          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n-          }\n-        }\n-        queueAcls.put(queueName, acls);\n-        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n-            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n-                minQueueResources.get(queueName))) {\n-          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n-              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n-        }\n+        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n+            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n+            queueAcls, queueNamesInAllocFile);\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;}\n       else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         defaultSchedulingMode \u003d parseSchedulingMode(text);\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n       info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n           queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n           queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n           queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       for (String name: queueNamesInAllocFile) {\n-        FSQueue queue \u003d getQueue(name);\n+        FSLeafQueue queue \u003d getLeafQueue(name);\n         if (queueModes.containsKey(name)) {\n           queue.setSchedulingMode(queueModes.get(name));\n         } else {\n           queue.setSchedulingMode(defaultSchedulingMode);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        loadQueue(\"root\", element, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      for (String name: queueNamesInAllocFile) {\n        FSLeafQueue queue \u003d getLeafQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "576f96f0ac79a2afe49948056498f2c06fe317c3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-184. Remove unnecessary locking in fair scheduler, and address findbugs excludes. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1410826 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/11/12 9:00 PM",
      "commitName": "576f96f0ac79a2afe49948056498f2c06fe317c3",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/11/12 4:38 AM",
      "commitNameOld": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 8.68,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,149 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n+    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n+    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n     SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         String queueName \u003d element.getAttribute(\"name\");\n         Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n             new HashMap\u003cQueueACL, AccessControlList\u003e();\n         queueNamesInAllocFile.add(queueName);\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"minResources\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             minQueueResources.put(queueName, Resources.createResource(val));\n           } else if (\"maxResources\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             maxQueueResources.put(queueName, Resources.createResource(val));\n           } else if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             queueMaxApps.put(queueName, val);\n           } else if (\"weight\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             double val \u003d Double.parseDouble(text);\n             queueWeights.put(queueName, val);\n           } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             minSharePreemptionTimeouts.put(queueName, val);\n           } else if (\"schedulingMode\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             queueModes.put(queueName, parseSchedulingMode(text));\n           } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n           } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n           }\n         }\n         queueAcls.put(queueName, acls);\n         if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n             \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                 minQueueResources.get(queueName))) {\n           LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n               queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n         }\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;}\n       else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         defaultSchedulingMode \u003d parseSchedulingMode(text);\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized (this) {\n-      setMinResources(minQueueResources);\n-      setMaxResources(maxQueueResources);\n-      setQueueMaxApps(queueMaxApps);\n-      setUserMaxApps(userMaxApps);\n-      setQueueWeights(queueWeights);\n-      setUserMaxAppsDefault(userMaxAppsDefault);\n-      setQueueMaxAppsDefault(queueMaxAppsDefault);\n-      setDefaultSchedulingMode(defaultSchedulingMode);\n-      setMinSharePreemptionTimeouts(minSharePreemptionTimeouts);\n-      setQueueAcls(queueAcls);\n+      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n+          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n+          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n+          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n       for (String name: queueNamesInAllocFile) {\n         FSQueue queue \u003d getQueue(name);\n         if (queueModes.containsKey(name)) {\n           queue.setSchedulingMode(queueModes.get(name));\n         } else {\n           queue.setSchedulingMode(defaultSchedulingMode);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    long fairSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    long defaultMinSharePreemptionTimeout \u003d Long.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        String queueName \u003d element.getAttribute(\"name\");\n        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n            new HashMap\u003cQueueACL, AccessControlList\u003e();\n        queueNamesInAllocFile.add(queueName);\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"minResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            minQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            maxQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            queueMaxApps.put(queueName, val);\n          } else if (\"weight\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            double val \u003d Double.parseDouble(text);\n            queueWeights.put(queueName, val);\n          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            minSharePreemptionTimeouts.put(queueName, val);\n          } else if (\"schedulingMode\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            queueModes.put(queueName, parseSchedulingMode(text));\n          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n          }\n        }\n        queueAcls.put(queueName, acls);\n        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                minQueueResources.get(queueName))) {\n          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n        }\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized (this) {\n      info \u003d new QueueManagerInfo(minQueueResources, maxQueueResources,\n          queueMaxApps, userMaxApps, queueWeights, userMaxAppsDefault,\n          queueMaxAppsDefault, defaultSchedulingMode, minSharePreemptionTimeouts,\n          queueAcls, fairSharePreemptionTimeout, defaultMinSharePreemptionTimeout);\n      for (String name: queueNamesInAllocFile) {\n        FSQueue queue \u003d getQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "4920387b8ad95070ba7035d47a8bec9805a666f9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-12. Fix findbugs warnings in FairScheduler. Contributed by Junping Du.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370889 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/12 11:53 AM",
      "commitName": "4920387b8ad95070ba7035d47a8bec9805a666f9",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,153 @@\n   public void reloadAllocs() throws IOException, ParserConfigurationException,\n       SAXException, AllocationConfigurationException {\n     if (allocFile \u003d\u003d null) return;\n     // Create some temporary hashmaps to hold the new allocs, and we only save\n     // them in our fields if we have parsed the entire allocs file successfully.\n     Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n     Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n     Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n     Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n     Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n         new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n     int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n     int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n     SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n \n     // Remember all queue names so we can display them on web UI, etc.\n     List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n \n     // Read and parse the allocations file.\n     DocumentBuilderFactory docBuilderFactory \u003d\n       DocumentBuilderFactory.newInstance();\n     docBuilderFactory.setIgnoringComments(true);\n     DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n     Document doc;\n     if (allocFile instanceof String) {\n       doc \u003d builder.parse(new File((String) allocFile));\n     } else {\n       doc \u003d builder.parse(allocFile.toString());\n     }\n     Element root \u003d doc.getDocumentElement();\n     if (!\"allocations\".equals(root.getTagName()))\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n           \"file: top-level element not \u003callocations\u003e\");\n     NodeList elements \u003d root.getChildNodes();\n     for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n       Node node \u003d elements.item(i);\n       if (!(node instanceof Element))\n         continue;\n       Element element \u003d (Element)node;\n       if (\"queue\".equals(element.getTagName()) ||\n     \t  \"pool\".equals(element.getTagName())) {\n         String queueName \u003d element.getAttribute(\"name\");\n         Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n             new HashMap\u003cQueueACL, AccessControlList\u003e();\n         queueNamesInAllocFile.add(queueName);\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"minResources\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             minQueueResources.put(queueName, Resources.createResource(val));\n           } else if (\"maxResources\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             maxQueueResources.put(queueName, Resources.createResource(val));\n           } else if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             queueMaxApps.put(queueName, val);\n           } else if (\"weight\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             double val \u003d Double.parseDouble(text);\n             queueWeights.put(queueName, val);\n           } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             long val \u003d Long.parseLong(text) * 1000L;\n             minSharePreemptionTimeouts.put(queueName, val);\n           } else if (\"schedulingMode\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             queueModes.put(queueName, parseSchedulingMode(text));\n           } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n           } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n           }\n         }\n         queueAcls.put(queueName, acls);\n         if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n             \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                 minQueueResources.get(queueName))) {\n           LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n               queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n         }\n       } else if (\"user\".equals(element.getTagName())) {\n         String userName \u003d element.getAttribute(\"name\");\n         NodeList fields \u003d element.getChildNodes();\n         for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n           Node fieldNode \u003d fields.item(j);\n           if (!(fieldNode instanceof Element))\n             continue;\n           Element field \u003d (Element) fieldNode;\n           if (\"maxRunningApps\".equals(field.getTagName())) {\n             String text \u003d ((Text)field.getFirstChild()).getData().trim();\n             int val \u003d Integer.parseInt(text);\n             userMaxApps.put(userName, val);\n           }\n         }\n       } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         userMaxAppsDefault \u003d val;\n       } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeout \u003d val;\n       } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         defaultMinSharePreemptionTimeout \u003d val;\n       } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxAppsDefault \u003d val;}\n       else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n         String text \u003d ((Text)element.getFirstChild()).getData().trim();\n         defaultSchedulingMode \u003d parseSchedulingMode(text);\n       } else {\n         LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n       }\n     }\n \n     // Commit the reload; also create any queue defined in the alloc file\n     // if it does not already exist, so it can be displayed on the web UI.\n     synchronized(this) {\n-      this.minQueueResources \u003d minQueueResources;\n-      this.maxQueueResources \u003d maxQueueResources;\n-      this.queueMaxApps \u003d queueMaxApps;\n-      this.userMaxApps \u003d userMaxApps;\n-      this.queueWeights \u003d queueWeights;\n-      this.userMaxAppsDefault \u003d userMaxAppsDefault;\n-      this.queueMaxAppsDefault \u003d queueMaxAppsDefault;\n-      this.defaultSchedulingMode \u003d defaultSchedulingMode;\n-      this.minSharePreemptionTimeouts \u003d minSharePreemptionTimeouts;\n-      this.queueAcls \u003d queueAcls;\n+      setMinResources(minQueueResources);\n+      setMaxResources(maxQueueResources);\n+      setQueueMaxApps(queueMaxApps);\n+      setUserMaxApps(userMaxApps);\n+      setQueueWeights(queueWeights);\n+      setUserMaxAppsDefault(userMaxAppsDefault);\n+      setQueueMaxAppsDefault(queueMaxAppsDefault);\n+      setDefaultSchedulingMode(defaultSchedulingMode);\n+      setMinSharePreemptionTimeouts(minSharePreemptionTimeouts);\n+      setQueueAcls(queueAcls);\n       for (String name: queueNamesInAllocFile) {\n         FSQueue queue \u003d getQueue(name);\n         if (queueModes.containsKey(name)) {\n           queue.setSchedulingMode(queueModes.get(name));\n         } else {\n           queue.setSchedulingMode(defaultSchedulingMode);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        String queueName \u003d element.getAttribute(\"name\");\n        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n            new HashMap\u003cQueueACL, AccessControlList\u003e();\n        queueNamesInAllocFile.add(queueName);\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"minResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            minQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            maxQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            queueMaxApps.put(queueName, val);\n          } else if (\"weight\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            double val \u003d Double.parseDouble(text);\n            queueWeights.put(queueName, val);\n          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            minSharePreemptionTimeouts.put(queueName, val);\n          } else if (\"schedulingMode\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            queueModes.put(queueName, parseSchedulingMode(text));\n          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n          }\n        }\n        queueAcls.put(queueName, acls);\n        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                minQueueResources.get(queueName))) {\n          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n        }\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized(this) {\n      setMinResources(minQueueResources);\n      setMaxResources(maxQueueResources);\n      setQueueMaxApps(queueMaxApps);\n      setUserMaxApps(userMaxApps);\n      setQueueWeights(queueWeights);\n      setUserMaxAppsDefault(userMaxAppsDefault);\n      setQueueMaxAppsDefault(queueMaxAppsDefault);\n      setDefaultSchedulingMode(defaultSchedulingMode);\n      setMinSharePreemptionTimeouts(minSharePreemptionTimeouts);\n      setQueueAcls(queueAcls);\n      for (String name: queueNamesInAllocFile) {\n        FSQueue queue \u003d getQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        String queueName \u003d element.getAttribute(\"name\");\n        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n            new HashMap\u003cQueueACL, AccessControlList\u003e();\n        queueNamesInAllocFile.add(queueName);\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"minResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            minQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            maxQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            queueMaxApps.put(queueName, val);\n          } else if (\"weight\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            double val \u003d Double.parseDouble(text);\n            queueWeights.put(queueName, val);\n          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            minSharePreemptionTimeouts.put(queueName, val);\n          } else if (\"schedulingMode\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            queueModes.put(queueName, parseSchedulingMode(text));\n          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n          }\n        }\n        queueAcls.put(queueName, acls);\n        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                minQueueResources.get(queueName))) {\n          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n        }\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized(this) {\n      this.minQueueResources \u003d minQueueResources;\n      this.maxQueueResources \u003d maxQueueResources;\n      this.queueMaxApps \u003d queueMaxApps;\n      this.userMaxApps \u003d userMaxApps;\n      this.queueWeights \u003d queueWeights;\n      this.userMaxAppsDefault \u003d userMaxAppsDefault;\n      this.queueMaxAppsDefault \u003d queueMaxAppsDefault;\n      this.defaultSchedulingMode \u003d defaultSchedulingMode;\n      this.minSharePreemptionTimeouts \u003d minSharePreemptionTimeouts;\n      this.queueAcls \u003d queueAcls;\n      for (String name: queueNamesInAllocFile) {\n        FSQueue queue \u003d getQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,153 @@\n+  public void reloadAllocs() throws IOException, ParserConfigurationException,\n+      SAXException, AllocationConfigurationException {\n+    if (allocFile \u003d\u003d null) return;\n+    // Create some temporary hashmaps to hold the new allocs, and we only save\n+    // them in our fields if we have parsed the entire allocs file successfully.\n+    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n+    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n+    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n+    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n+    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n+    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n+    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n+    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n+        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n+    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n+    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n+    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n+\n+    // Remember all queue names so we can display them on web UI, etc.\n+    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n+\n+    // Read and parse the allocations file.\n+    DocumentBuilderFactory docBuilderFactory \u003d\n+      DocumentBuilderFactory.newInstance();\n+    docBuilderFactory.setIgnoringComments(true);\n+    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n+    Document doc;\n+    if (allocFile instanceof String) {\n+      doc \u003d builder.parse(new File((String) allocFile));\n+    } else {\n+      doc \u003d builder.parse(allocFile.toString());\n+    }\n+    Element root \u003d doc.getDocumentElement();\n+    if (!\"allocations\".equals(root.getTagName()))\n+      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n+          \"file: top-level element not \u003callocations\u003e\");\n+    NodeList elements \u003d root.getChildNodes();\n+    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n+      Node node \u003d elements.item(i);\n+      if (!(node instanceof Element))\n+        continue;\n+      Element element \u003d (Element)node;\n+      if (\"queue\".equals(element.getTagName()) ||\n+    \t  \"pool\".equals(element.getTagName())) {\n+        String queueName \u003d element.getAttribute(\"name\");\n+        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n+            new HashMap\u003cQueueACL, AccessControlList\u003e();\n+        queueNamesInAllocFile.add(queueName);\n+        NodeList fields \u003d element.getChildNodes();\n+        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n+          Node fieldNode \u003d fields.item(j);\n+          if (!(fieldNode instanceof Element))\n+            continue;\n+          Element field \u003d (Element) fieldNode;\n+          if (\"minResources\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            int val \u003d Integer.parseInt(text);\n+            minQueueResources.put(queueName, Resources.createResource(val));\n+          } else if (\"maxResources\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            int val \u003d Integer.parseInt(text);\n+            maxQueueResources.put(queueName, Resources.createResource(val));\n+          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            int val \u003d Integer.parseInt(text);\n+            queueMaxApps.put(queueName, val);\n+          } else if (\"weight\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            double val \u003d Double.parseDouble(text);\n+            queueWeights.put(queueName, val);\n+          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            long val \u003d Long.parseLong(text) * 1000L;\n+            minSharePreemptionTimeouts.put(queueName, val);\n+          } else if (\"schedulingMode\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            queueModes.put(queueName, parseSchedulingMode(text));\n+          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n+          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+          }\n+        }\n+        queueAcls.put(queueName, acls);\n+        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n+            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n+                minQueueResources.get(queueName))) {\n+          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n+              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n+        }\n+      } else if (\"user\".equals(element.getTagName())) {\n+        String userName \u003d element.getAttribute(\"name\");\n+        NodeList fields \u003d element.getChildNodes();\n+        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n+          Node fieldNode \u003d fields.item(j);\n+          if (!(fieldNode instanceof Element))\n+            continue;\n+          Element field \u003d (Element) fieldNode;\n+          if (\"maxRunningApps\".equals(field.getTagName())) {\n+            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+            int val \u003d Integer.parseInt(text);\n+            userMaxApps.put(userName, val);\n+          }\n+        }\n+      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n+        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+        int val \u003d Integer.parseInt(text);\n+        userMaxAppsDefault \u003d val;\n+      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n+        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+        long val \u003d Long.parseLong(text) * 1000L;\n+        fairSharePreemptionTimeout \u003d val;\n+      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n+        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+        long val \u003d Long.parseLong(text) * 1000L;\n+        defaultMinSharePreemptionTimeout \u003d val;\n+      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n+        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+        int val \u003d Integer.parseInt(text);\n+        queueMaxAppsDefault \u003d val;}\n+      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n+        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n+        defaultSchedulingMode \u003d parseSchedulingMode(text);\n+      } else {\n+        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n+      }\n+    }\n+\n+    // Commit the reload; also create any queue defined in the alloc file\n+    // if it does not already exist, so it can be displayed on the web UI.\n+    synchronized(this) {\n+      this.minQueueResources \u003d minQueueResources;\n+      this.maxQueueResources \u003d maxQueueResources;\n+      this.queueMaxApps \u003d queueMaxApps;\n+      this.userMaxApps \u003d userMaxApps;\n+      this.queueWeights \u003d queueWeights;\n+      this.userMaxAppsDefault \u003d userMaxAppsDefault;\n+      this.queueMaxAppsDefault \u003d queueMaxAppsDefault;\n+      this.defaultSchedulingMode \u003d defaultSchedulingMode;\n+      this.minSharePreemptionTimeouts \u003d minSharePreemptionTimeouts;\n+      this.queueAcls \u003d queueAcls;\n+      for (String name: queueNamesInAllocFile) {\n+        FSQueue queue \u003d getQueue(name);\n+        if (queueModes.containsKey(name)) {\n+          queue.setSchedulingMode(queueModes.get(name));\n+        } else {\n+          queue.setSchedulingMode(defaultSchedulingMode);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void reloadAllocs() throws IOException, ParserConfigurationException,\n      SAXException, AllocationConfigurationException {\n    if (allocFile \u003d\u003d null) return;\n    // Create some temporary hashmaps to hold the new allocs, and we only save\n    // them in our fields if we have parsed the entire allocs file successfully.\n    Map\u003cString, Resource\u003e minQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Resource\u003e maxQueueResources \u003d new HashMap\u003cString, Resource\u003e();\n    Map\u003cString, Integer\u003e queueMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Integer\u003e userMaxApps \u003d new HashMap\u003cString, Integer\u003e();\n    Map\u003cString, Double\u003e queueWeights \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, SchedulingMode\u003e queueModes \u003d new HashMap\u003cString, SchedulingMode\u003e();\n    Map\u003cString, Long\u003e minSharePreemptionTimeouts \u003d new HashMap\u003cString, Long\u003e();\n    Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls \u003d\n        new HashMap\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e();\n    int userMaxAppsDefault \u003d Integer.MAX_VALUE;\n    int queueMaxAppsDefault \u003d Integer.MAX_VALUE;\n    SchedulingMode defaultSchedulingMode \u003d SchedulingMode.FAIR;\n\n    // Remember all queue names so we can display them on web UI, etc.\n    List\u003cString\u003e queueNamesInAllocFile \u003d new ArrayList\u003cString\u003e();\n\n    // Read and parse the allocations file.\n    DocumentBuilderFactory docBuilderFactory \u003d\n      DocumentBuilderFactory.newInstance();\n    docBuilderFactory.setIgnoringComments(true);\n    DocumentBuilder builder \u003d docBuilderFactory.newDocumentBuilder();\n    Document doc;\n    if (allocFile instanceof String) {\n      doc \u003d builder.parse(new File((String) allocFile));\n    } else {\n      doc \u003d builder.parse(allocFile.toString());\n    }\n    Element root \u003d doc.getDocumentElement();\n    if (!\"allocations\".equals(root.getTagName()))\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \" +\n          \"file: top-level element not \u003callocations\u003e\");\n    NodeList elements \u003d root.getChildNodes();\n    for (int i \u003d 0; i \u003c elements.getLength(); i++) {\n      Node node \u003d elements.item(i);\n      if (!(node instanceof Element))\n        continue;\n      Element element \u003d (Element)node;\n      if (\"queue\".equals(element.getTagName()) ||\n    \t  \"pool\".equals(element.getTagName())) {\n        String queueName \u003d element.getAttribute(\"name\");\n        Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n            new HashMap\u003cQueueACL, AccessControlList\u003e();\n        queueNamesInAllocFile.add(queueName);\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"minResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            minQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxResources\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            maxQueueResources.put(queueName, Resources.createResource(val));\n          } else if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            queueMaxApps.put(queueName, val);\n          } else if (\"weight\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            double val \u003d Double.parseDouble(text);\n            queueWeights.put(queueName, val);\n          } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            long val \u003d Long.parseLong(text) * 1000L;\n            minSharePreemptionTimeouts.put(queueName, val);\n          } else if (\"schedulingMode\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            queueModes.put(queueName, parseSchedulingMode(text));\n          } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n          } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n          }\n        }\n        queueAcls.put(queueName, acls);\n        if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n            \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n                minQueueResources.get(queueName))) {\n          LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n              queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n        }\n      } else if (\"user\".equals(element.getTagName())) {\n        String userName \u003d element.getAttribute(\"name\");\n        NodeList fields \u003d element.getChildNodes();\n        for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n          Node fieldNode \u003d fields.item(j);\n          if (!(fieldNode instanceof Element))\n            continue;\n          Element field \u003d (Element) fieldNode;\n          if (\"maxRunningApps\".equals(field.getTagName())) {\n            String text \u003d ((Text)field.getFirstChild()).getData().trim();\n            int val \u003d Integer.parseInt(text);\n            userMaxApps.put(userName, val);\n          }\n        }\n      } else if (\"userMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        userMaxAppsDefault \u003d val;\n      } else if (\"fairSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeout \u003d val;\n      } else if (\"defaultMinSharePreemptionTimeout\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        defaultMinSharePreemptionTimeout \u003d val;\n      } else if (\"queueMaxAppsDefault\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxAppsDefault \u003d val;}\n      else if (\"defaultQueueSchedulingMode\".equals(element.getTagName())) {\n        String text \u003d ((Text)element.getFirstChild()).getData().trim();\n        defaultSchedulingMode \u003d parseSchedulingMode(text);\n      } else {\n        LOG.warn(\"Bad element in allocations file: \" + element.getTagName());\n      }\n    }\n\n    // Commit the reload; also create any queue defined in the alloc file\n    // if it does not already exist, so it can be displayed on the web UI.\n    synchronized(this) {\n      this.minQueueResources \u003d minQueueResources;\n      this.maxQueueResources \u003d maxQueueResources;\n      this.queueMaxApps \u003d queueMaxApps;\n      this.userMaxApps \u003d userMaxApps;\n      this.queueWeights \u003d queueWeights;\n      this.userMaxAppsDefault \u003d userMaxAppsDefault;\n      this.queueMaxAppsDefault \u003d queueMaxAppsDefault;\n      this.defaultSchedulingMode \u003d defaultSchedulingMode;\n      this.minSharePreemptionTimeouts \u003d minSharePreemptionTimeouts;\n      this.queueAcls \u003d queueAcls;\n      for (String name: queueNamesInAllocFile) {\n        FSQueue queue \u003d getQueue(name);\n        if (queueModes.containsKey(name)) {\n          queue.setSchedulingMode(queueModes.get(name));\n        } else {\n          queue.setSchedulingMode(defaultSchedulingMode);\n        }\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java"
    }
  }
}