{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LinuxContainerExecutor.java",
  "functionName": "launchContainer",
  "functionId": "launchContainer___ctx-ContainerStartContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
  "functionStartLine": 495,
  "functionEndLine": 499,
  "numCommitsSeen": 125,
  "timeTaken": 14826,
  "changeHistory": [
    "c467f311d0c7155c09052d93fac12045af925583",
    "e6b74164e9fc50518e03629c99525c2136c01593",
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd",
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
    "ebc048cc055d0f7d1b85bc0b6f56cd15673e837d",
    "0ffca5d347df0acb1979dff7a07ae88ea834adc7",
    "f76f5c0919cdb0b032edb309d137093952e77268",
    "74a61438ca01e2191b54000af73b654a2d0b8253",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
    "58e18508018081b5b5aa7c12cc5af386146cd26b",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
    "486d5cb803efec7b4db445ee65a3df83392940a3",
    "3e6fce91a471b4a5099de109582e7c6417e8a822",
    "c40bdb56a79fe1499c2284d493edc84620c0c078",
    "53fafcf061616516c24e2e2007a66a93d23d3e25",
    "a100be685cc4521e9949589948219231aa5d2733",
    "41a548a916d4248164cb9495320f123ec215d70e",
    "537c361f5bc888dd74fbe59afe18d08d0746894f",
    "752441434c99003595c67f22b3a526881e70156b",
    "80c5bffc4b6bd2aa54ed8d49a32fd2c2cb77bfcc",
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6",
    "5032a694ed250f65ade8c2b62c97b89ab45f53ea",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11",
    "a8190ce5c520fcb69399485231ef7c0b7fdc3df7",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "c467f311d0c7155c09052d93fac12045af925583": "Ybodychange",
    "e6b74164e9fc50518e03629c99525c2136c01593": "Ybodychange",
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd": "Ybodychange",
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4": "Ybodychange",
    "ebc048cc055d0f7d1b85bc0b6f56cd15673e837d": "Ybodychange",
    "0ffca5d347df0acb1979dff7a07ae88ea834adc7": "Ybodychange",
    "f76f5c0919cdb0b032edb309d137093952e77268": "Ybodychange",
    "74a61438ca01e2191b54000af73b654a2d0b8253": "Ybodychange",
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": "Ymultichange(Yexceptionschange,Ybodychange)",
    "58e18508018081b5b5aa7c12cc5af386146cd26b": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": "Ybodychange",
    "486d5cb803efec7b4db445ee65a3df83392940a3": "Ybodychange",
    "3e6fce91a471b4a5099de109582e7c6417e8a822": "Ybodychange",
    "c40bdb56a79fe1499c2284d493edc84620c0c078": "Ybodychange",
    "53fafcf061616516c24e2e2007a66a93d23d3e25": "Ymultichange(Yparameterchange,Ybodychange)",
    "a100be685cc4521e9949589948219231aa5d2733": "Ybodychange",
    "41a548a916d4248164cb9495320f123ec215d70e": "Ybodychange",
    "537c361f5bc888dd74fbe59afe18d08d0746894f": "Ybodychange",
    "752441434c99003595c67f22b3a526881e70156b": "Ybodychange",
    "80c5bffc4b6bd2aa54ed8d49a32fd2c2cb77bfcc": "Ybodychange",
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6": "Ybodychange",
    "5032a694ed250f65ade8c2b62c97b89ab45f53ea": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": "Ybodychange",
    "a8190ce5c520fcb69399485231ef7c0b7fdc3df7": "Ybodychange",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c467f311d0c7155c09052d93fac12045af925583": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7973. Added ContainerRelaunch feature for Docker containers.\n           Contributed by Shane Kumpf\n",
      "commitDate": "10/04/18 4:25 PM",
      "commitName": "c467f311d0c7155c09052d93fac12045af925583",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "26/03/18 10:21 AM",
      "commitNameOld": "e6b74164e9fc50518e03629c99525c2136c01593",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 15.25,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,5 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n-    Container container \u003d ctx.getContainer();\n-    String user \u003d ctx.getUser();\n-\n-    verifyUsernamePattern(user);\n-\n-    ContainerId containerId \u003d container.getContainerId();\n-\n-    resourcesHandler.preExecute(containerId,\n-            container.getResource());\n-    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n-    String tcCommandFile \u003d null;\n-    List\u003cString\u003e numaArgs \u003d null;\n-\n-    try {\n-      if (resourceHandlerChain !\u003d null) {\n-        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n-            .preStart(container);\n-\n-        if (ops !\u003d null) {\n-          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n-\n-          resourceOps.add(new PrivilegedOperation(\n-              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n-                  resourcesOptions));\n-\n-          for (PrivilegedOperation op : ops) {\n-            switch (op.getOperationType()) {\n-            case ADD_PID_TO_CGROUP:\n-              resourceOps.add(op);\n-              break;\n-            case TC_MODIFY_STATE:\n-              tcCommandFile \u003d op.getArguments().get(0);\n-              break;\n-            case ADD_NUMA_PARAMS:\n-              numaArgs \u003d op.getArguments();\n-              break;\n-            default:\n-              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n-                  + op.getOperationType());\n-            }\n-          }\n-\n-          if (resourceOps.size() \u003e 1) {\n-            //squash resource operations\n-            try {\n-              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n-                  .squashCGroupOperations(resourceOps);\n-              resourcesOptions \u003d operation.getArguments().get(0);\n-            } catch (PrivilegedOperationException e) {\n-              LOG.error(\"Failed to squash cgroup operations!\", e);\n-              throw new ResourceHandlerException(\n-                  \"Failed to squash cgroup operations!\");\n-            }\n-          }\n-        }\n-      }\n-    } catch (ResourceHandlerException e) {\n-      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n-      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n-    }\n-\n-    try {\n-      Path pidFilePath \u003d getPidFilePath(containerId);\n-      if (pidFilePath !\u003d null) {\n-\n-        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n-            ctx, pidFilePath, resourcesOptions, tcCommandFile, numaArgs);\n-\n-        linuxContainerRuntime.launchContainer(runtimeContext);\n-      } else {\n-        LOG.info(\n-            \"Container was marked as inactive. Returning terminated error\");\n-        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n-      }\n-    } catch (ContainerExecutionException e) {\n-      int exitCode \u003d e.getExitCode();\n-      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n-      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n-      // terminated/killed forcefully. In all other cases, log the\n-      // output\n-      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n-          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n-        LOG.warn(\"Exception from container-launch with container ID: \"\n-            + containerId + \" and exit code: \" + exitCode, e);\n-\n-        StringBuilder builder \u003d new StringBuilder();\n-        builder.append(\"Exception from container-launch.\\n\");\n-        builder.append(\"Container id: \" + containerId + \"\\n\");\n-        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n-        builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n-        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n-          builder.append(\"Shell error output: \" + e.getErrorOutput() + \"\\n\");\n-        }\n-        //Skip stack trace\n-        String output \u003d e.getOutput();\n-        if (output !\u003d null \u0026\u0026 !output.isEmpty()) {\n-          builder.append(\"Shell output: \" + output + \"\\n\");\n-        }\n-        String diagnostics \u003d builder.toString();\n-        logOutput(diagnostics);\n-        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n-            diagnostics));\n-        if (exitCode \u003d\u003d\n-                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n-            exitCode \u003d\u003d\n-                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n-          throw new ConfigurationException(\n-              \"Linux Container Executor reached unrecoverable exception\", e);\n-        }\n-      } else {\n-        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n-            \"Container killed on request. Exit code is \" + exitCode));\n-      }\n-      return exitCode;\n-    } finally {\n-      resourcesHandler.postExecute(containerId);\n-\n-      try {\n-        if (resourceHandlerChain !\u003d null) {\n-          resourceHandlerChain.postComplete(containerId);\n-        }\n-      } catch (ResourceHandlerException e) {\n-        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n-            \"containerId: \" + containerId + \". Exception: \" + e);\n-      }\n-    }\n-\n-    return 0;\n+    return handleLaunchForLaunchType(ctx,\n+        ApplicationConstants.ContainerLaunchType.LAUNCH);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    return handleLaunchForLaunchType(ctx,\n        ApplicationConstants.ContainerLaunchType.LAUNCH);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "e6b74164e9fc50518e03629c99525c2136c01593": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8043.  Added the exception message for failed launches running under LCE.\n            Contributed by Shane Kumpf\n",
      "commitDate": "26/03/18 10:21 AM",
      "commitName": "e6b74164e9fc50518e03629c99525c2136c01593",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "13/03/18 12:36 PM",
      "commitNameOld": "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd",
      "commitAuthorOld": "Miklos Szegedi",
      "daysBetweenCommits": 12.91,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,141 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n     List\u003cString\u003e numaArgs \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             case ADD_NUMA_PARAMS:\n               numaArgs \u003d op.getArguments();\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n             ctx, pidFilePath, resourcesOptions, tcCommandFile, numaArgs);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n+        builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n-          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n+          builder.append(\"Shell error output: \" + e.getErrorOutput() + \"\\n\");\n         }\n         //Skip stack trace\n         String output \u003d e.getOutput();\n-        if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n+        if (output !\u003d null \u0026\u0026 !output.isEmpty()) {\n           builder.append(\"Shell output: \" + output + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n    List\u003cString\u003e numaArgs \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            case ADD_NUMA_PARAMS:\n              numaArgs \u003d op.getArguments();\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile, numaArgs);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Shell error output: \" + e.getErrorOutput() + \"\\n\");\n        }\n        //Skip stack trace\n        String output \u003d e.getOutput();\n        if (output !\u003d null \u0026\u0026 !output.isEmpty()) {\n          builder.append(\"Shell output: \" + output + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5764. NUMA awareness support for launching containers. Contributed by Devaraj K.\n",
      "commitDate": "13/03/18 12:36 PM",
      "commitName": "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "07/03/18 7:20 AM",
      "commitNameOld": "d69b31f7f70f296ddd180e004fa0f827c2f737f2",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,140 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n+    List\u003cString\u003e numaArgs \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n+            case ADD_NUMA_PARAMS:\n+              numaArgs \u003d op.getArguments();\n+              break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n-            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n+            ctx, pidFilePath, resourcesOptions, tcCommandFile, numaArgs);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         //Skip stack trace\n         String output \u003d e.getOutput();\n         if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + output + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n    List\u003cString\u003e numaArgs \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            case ADD_NUMA_PARAMS:\n              numaArgs \u003d op.getArguments();\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile, numaArgs);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        //Skip stack trace\n        String output \u003d e.getOutput();\n        if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + output + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6550. Capture launch_container.sh logs to a separate log file. (Suma Shivaprasad via wangda)\n\nChange-Id: I0ee0b1bb459437432a22cf68861a6354f0decabb\n",
      "commitDate": "29/09/17 4:39 PM",
      "commitName": "febeead5f95c6fc245ea3735f5b538d4bb4dc8a4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/09/17 2:17 PM",
      "commitNameOld": "b0b535d9d5727cd84fd6368c6d1b38363616504e",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 22.1,
      "commitsBetweenForRepo": 223,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,136 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n             ctx, pidFilePath, resourcesOptions, tcCommandFile);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n-        builder.append(\"Stack trace: \"\n-            + StringUtils.stringifyException(e) + \"\\n\");\n+        //Skip stack trace\n         String output \u003d e.getOutput();\n         if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + output + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        //Skip stack trace\n        String output \u003d e.getOutput();\n        if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + output + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "ebc048cc055d0f7d1b85bc0b6f56cd15673e837d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6805. NPE in LinuxContainerExecutor due to null PrivilegedOperationException exit code. Contributed by Jason Lowe\n",
      "commitDate": "13/07/17 3:44 PM",
      "commitName": "ebc048cc055d0f7d1b85bc0b6f56cd15673e837d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "13/07/17 3:42 PM",
      "commitNameOld": "0ffca5d347df0acb1979dff7a07ae88ea834adc7",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n             ctx, pidFilePath, resourcesOptions, tcCommandFile);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n-        if (!e.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n+        String output \u003d e.getOutput();\n+        if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + output + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        String output \u003d e.getOutput();\n        if (output !\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + output + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "0ffca5d347df0acb1979dff7a07ae88ea834adc7": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-6805. NPE in LinuxContainerExecutor due to null PrivilegedOperationException exit code. Contributed by Jason Lowe\"\n\nThis reverts commit f76f5c0919cdb0b032edb309d137093952e77268.\n",
      "commitDate": "13/07/17 3:42 PM",
      "commitName": "0ffca5d347df0acb1979dff7a07ae88ea834adc7",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "13/07/17 3:38 PM",
      "commitNameOld": "f76f5c0919cdb0b032edb309d137093952e77268",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,136 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n             ctx, pidFilePath, resourcesOptions, tcCommandFile);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n-        String output \u003d e.getOutput();\n-        if (output!\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \" + output + \"\\n\");\n+        if (!e.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "f76f5c0919cdb0b032edb309d137093952e77268": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6805. NPE in LinuxContainerExecutor due to null PrivilegedOperationException exit code. Contributed by Jason Lowe\n",
      "commitDate": "13/07/17 3:38 PM",
      "commitName": "f76f5c0919cdb0b032edb309d137093952e77268",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "10/05/17 10:46 AM",
      "commitNameOld": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 64.2,
      "commitsBetweenForRepo": 304,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     String user \u003d ctx.getUser();\n \n     verifyUsernamePattern(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n \n         ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n             ctx, pidFilePath, resourcesOptions, tcCommandFile);\n \n         linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n-        if (!e.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n+        String output \u003d e.getOutput();\n+        if (output!\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + output + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        String output \u003d e.getOutput();\n        if (output!\u003d null \u0026\u0026 !e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + output + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "74a61438ca01e2191b54000af73b654a2d0b8253": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6475. Fix some long function checkstyle issues\n(Contributed by Soumabrata Chakraborty via Daniel Templeton)\n",
      "commitDate": "10/05/17 10:46 AM",
      "commitName": "74a61438ca01e2191b54000af73b654a2d0b8253",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "19/04/17 12:23 PM",
      "commitNameOld": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 20.93,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,177 +1,136 @@\n   public int launchContainer(ContainerStartContext ctx)\n       throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n-    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n-    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n-    String appId \u003d ctx.getAppId();\n-    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n-    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n-    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n-    List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n-    List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n-    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n-    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n-    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n-    String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n-    String containerIdStr \u003d containerId.toString();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n-        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n-        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n-            .Builder(container);\n \n-        addSchedPriorityCommand(prefixCommands);\n-        if (prefixCommands.size() \u003e 0) {\n-          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n-              prefixCommands);\n-        }\n+        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n+            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n \n-        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n-            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n-            .setExecutionAttribute(USER, user)\n-            .setExecutionAttribute(APPID, appId)\n-            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n-            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n-            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n-                nmPrivateContainerScriptPath)\n-            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n-            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n-            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n-            .setExecutionAttribute(LOG_DIRS, logDirs)\n-            .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n-            .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n-            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n-            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n-            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n-\n-        if (tcCommandFile !\u003d null) {\n-          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n-        }\n-\n-        linuxContainerRuntime.launchContainer(builder.build());\n+        linuxContainerRuntime.launchContainer(runtimeContext);\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n         if (exitCode \u003d\u003d\n                 ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n             exitCode \u003d\u003d\n                 ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n           throw new ConfigurationException(\n               \"Linux Container Executor reached unrecoverable exception\", e);\n         }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    String user \u003d ctx.getUser();\n\n    verifyUsernamePattern(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n\n        ContainerRuntimeContext runtimeContext \u003d buildContainerRuntimeContext(\n            ctx, pidFilePath, resourcesOptions, tcCommandFile);\n\n        linuxContainerRuntime.launchContainer(runtimeContext);\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "46940d92e2b17c627eb17a9d8fc6cec9c3715592": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-6302. Fail the node if Linux Container Executor is not configured properly\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
      "commitDate": "19/04/17 12:23 PM",
      "commitName": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
      "commitAuthor": "Daniel Templeton",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-6302. Fail the node if Linux Container Executor is not configured properly\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
          "commitDate": "19/04/17 12:23 PM",
          "commitName": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
          "commitAuthor": "Daniel Templeton",
          "commitDateOld": "01/03/17 2:53 PM",
          "commitNameOld": "6f6dfe0202249c129b36edfd145a2224140139cc",
          "commitAuthorOld": "Robert Kanter",
          "daysBetweenCommits": 48.85,
          "commitsBetweenForRepo": 295,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,159 +1,177 @@\n-  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+  public int launchContainer(ContainerStartContext ctx)\n+      throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n     List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n     List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n     List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n             .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n             .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n-        return ExitCode.TERMINATED.getExitCode();\n+        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n-      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n-          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n+      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n+          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n+        if (exitCode \u003d\u003d\n+                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n+          throw new ConfigurationException(\n+              \"Linux Container Executor reached unrecoverable exception\", e);\n+        }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n    List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n            .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, ConfigurationException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6302. Fail the node if Linux Container Executor is not configured properly\n(Contributed by Miklos Szegedi via Daniel Templeton)\n",
          "commitDate": "19/04/17 12:23 PM",
          "commitName": "46940d92e2b17c627eb17a9d8fc6cec9c3715592",
          "commitAuthor": "Daniel Templeton",
          "commitDateOld": "01/03/17 2:53 PM",
          "commitNameOld": "6f6dfe0202249c129b36edfd145a2224140139cc",
          "commitAuthorOld": "Robert Kanter",
          "daysBetweenCommits": 48.85,
          "commitsBetweenForRepo": 295,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,159 +1,177 @@\n-  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+  public int launchContainer(ContainerStartContext ctx)\n+      throws IOException, ConfigurationException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n     List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n     List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n     List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n             .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n             .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n-        return ExitCode.TERMINATED.getExitCode();\n+        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n-      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n-          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n+      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n+          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n+        if (exitCode \u003d\u003d\n+                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n+            exitCode \u003d\u003d\n+                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n+          throw new ConfigurationException(\n+              \"Linux Container Executor reached unrecoverable exception\", e);\n+        }\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx)\n      throws IOException, ConfigurationException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n    List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n            .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ContainerExecutor.ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ContainerExecutor.ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n        if (exitCode \u003d\u003d\n                ExitCode.INVALID_CONTAINER_EXEC_PERMISSIONS.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.INVALID_CONFIG_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_SCRIPT_COPY.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_CREDENTIALS_FILE.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_WORK_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_APP_LOG_DIRECTORIES.getExitCode() ||\n            exitCode \u003d\u003d\n                ExitCode.COULD_NOT_CREATE_TMP_DIRECTORIES.getExitCode()) {\n          throw new ConfigurationException(\n              \"Linux Container Executor reached unrecoverable exception\", e);\n        }\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "58e18508018081b5b5aa7c12cc5af386146cd26b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5298. Mount usercache and NM filecache directories into Docker container. Contributed by  Sidharta Seethana.\n",
      "commitDate": "14/07/16 3:41 AM",
      "commitName": "58e18508018081b5b5aa7c12cc5af386146cd26b",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 29.52,
      "commitsBetweenForRepo": 329,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,156 +1,160 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n+    List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n+    List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n     List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n+            .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n+            .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    List\u003cString\u003e filecacheDirs \u003d ctx.getFilecacheDirs();\n    List\u003cString\u003e userLocalDirs \u003d ctx.getUserLocalDirs();\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(FILECACHE_DIRS, filecacheDirs)\n            .setExecutionAttribute(USER_LOCAL_DIRS, userLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/04/16 9:25 AM",
      "commitNameOld": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 46.24,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,156 +1,156 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n     List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n     List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n-    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    String containerIdStr \u003d containerId.toString();\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n             .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n             .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "b41a7e89d1eb8650975ac7092532ed9563ac60f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4578. Directories that are mounted in docker containers need to be more restrictive/container-specific. Contributed by Sidharta Seethana.\n",
      "commitDate": "22/01/16 1:13 AM",
      "commitName": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/10/15 2:28 AM",
      "commitNameOld": "8d5929308998869933982bd425102c3a9488ee8f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 99.99,
      "commitsBetweenForRepo": 680,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,156 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n+    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n+    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation(\n               PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n             case ADD_PID_TO_CGROUP:\n               resourceOps.add(op);\n               break;\n             case TC_MODIFY_STATE:\n               tcCommandFile \u003d op.getArguments().get(0);\n               break;\n             default:\n               LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                   + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\n                   \"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n+            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n+            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\n             \"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode, e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    List\u003cString\u003e containerLocalDirs \u003d ctx.getContainerLocalDirs();\n    List\u003cString\u003e containerLogDirs \u003d ctx.getContainerLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation(\n              PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n            case ADD_PID_TO_CGROUP:\n              resourceOps.add(op);\n              break;\n            case TC_MODIFY_STATE:\n              tcCommandFile \u003d op.getArguments().get(0);\n              break;\n            default:\n              LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                  + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\n                  \"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands \u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(CONTAINER_LOCAL_DIRS, containerLocalDirs)\n            .setExecutionAttribute(CONTAINER_LOG_DIRS, containerLogDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\n            \"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode, e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "486d5cb803efec7b4db445ee65a3df83392940a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4136. LinuxContainerExecutor loses info when forwarding ResourceHandlerException. Contributed by Bibin A Chundatt.\n",
      "commitDate": "11/09/15 2:07 AM",
      "commitName": "486d5cb803efec7b4db445ee65a3df83392940a3",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "27/07/15 11:57 AM",
      "commitNameOld": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 45.59,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n     Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation\n               (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n               case ADD_PID_TO_CGROUP:\n                 resourceOps.add(op);\n                 break;\n               case TC_MODIFY_STATE:\n                 tcCommandFile \u003d op.getArguments().get(0);\n                 break;\n               default:\n                 LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                     + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n-      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n+      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n     }\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e prefixCommands\u003d new ArrayList\u003c\u003e();\n         ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n             .Builder(container);\n \n         addSchedPriorityCommand(prefixCommands);\n         if (prefixCommands.size() \u003e 0) {\n           builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n               prefixCommands);\n         }\n \n         builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n             .setExecutionAttribute(RUN_AS_USER, runAsUser)\n             .setExecutionAttribute(USER, user)\n             .setExecutionAttribute(APPID, appId)\n             .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n             .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n             .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                 nmPrivateContainerScriptPath)\n             .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n             .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n             .setExecutionAttribute(LOCAL_DIRS, localDirs)\n             .setExecutionAttribute(LOG_DIRS, logDirs)\n             .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n           builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n         linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ContainerExecutionException e) {\n       int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!e.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\", e);\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands\u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "3e6fce91a471b4a5099de109582e7c6417e8a822": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3853. Add docker container runtime support to LinuxContainterExecutor. Contributed by Sidharta Seethana.\n",
      "commitDate": "27/07/15 11:57 AM",
      "commitName": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "07/07/15 4:29 AM",
      "commitNameOld": "c40bdb56a79fe1499c2284d493edc84620c0c078",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 20.31,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,154 +1,150 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n+    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation\n               (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n               case ADD_PID_TO_CGROUP:\n                 resourceOps.add(op);\n                 break;\n               case TC_MODIFY_STATE:\n                 tcCommandFile \u003d op.getArguments().get(0);\n                 break;\n               default:\n                 LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                     + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n     }\n \n-    ShellCommandExecutor shExec \u003d null;\n-\n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n-        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n-        addSchedPriorityCommand(command);\n-        command.addAll(Arrays.asList(\n-            containerExecutorExe, runAsUser, user, Integer\n-                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n-            containerIdStr, containerWorkDir.toString(),\n-            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n-            nmPrivateTokensPath.toUri().getPath().toString(),\n-            pidFilePath.toString(),\n-            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n-                localDirs),\n-            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n-                logDirs),\n-            resourcesOptions));\n+        List\u003cString\u003e prefixCommands\u003d new ArrayList\u003c\u003e();\n+        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n+            .Builder(container);\n+\n+        addSchedPriorityCommand(prefixCommands);\n+        if (prefixCommands.size() \u003e 0) {\n+          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n+              prefixCommands);\n+        }\n+\n+        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n+            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n+            .setExecutionAttribute(USER, user)\n+            .setExecutionAttribute(APPID, appId)\n+            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n+            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n+            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n+                nmPrivateContainerScriptPath)\n+            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n+            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n+            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n+            .setExecutionAttribute(LOG_DIRS, logDirs)\n+            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n \n         if (tcCommandFile !\u003d null) {\n-            command.add(tcCommandFile);\n+          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n         }\n \n-        String[] commandArray \u003d command.toArray(new String[command.size()]);\n-        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n-            container.getLaunchContext().getEnvironment()); // sanitized env\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n-        }\n-        shExec.execute();\n-        if (LOG.isDebugEnabled()) {\n-          logOutput(shExec.getOutput());\n-        }\n+        linuxContainerRuntime.launchContainer(builder.build());\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n-    } catch (ExitCodeException e) {\n-      int exitCode \u003d shExec.getExitCode();\n+    } catch (ContainerExecutionException e) {\n+      int exitCode \u003d e.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n-      // container-executor\u0027s output\n+      // output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n-        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n-          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n+        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n+          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n-        if (!shExec.getOutput().isEmpty()) {\n-          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n+        if (!e.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n-      logOutput(shExec.getOutput());\n-    }\n+\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n    Map\u003cPath, List\u003cString\u003e\u003e localizedResources \u003d ctx.getLocalizedResources();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n    }\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e prefixCommands\u003d new ArrayList\u003c\u003e();\n        ContainerRuntimeContext.Builder builder \u003d new ContainerRuntimeContext\n            .Builder(container);\n\n        addSchedPriorityCommand(prefixCommands);\n        if (prefixCommands.size() \u003e 0) {\n          builder.setExecutionAttribute(CONTAINER_LAUNCH_PREFIX_COMMANDS,\n              prefixCommands);\n        }\n\n        builder.setExecutionAttribute(LOCALIZED_RESOURCES, localizedResources)\n            .setExecutionAttribute(RUN_AS_USER, runAsUser)\n            .setExecutionAttribute(USER, user)\n            .setExecutionAttribute(APPID, appId)\n            .setExecutionAttribute(CONTAINER_ID_STR, containerIdStr)\n            .setExecutionAttribute(CONTAINER_WORK_DIR, containerWorkDir)\n            .setExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH,\n                nmPrivateContainerScriptPath)\n            .setExecutionAttribute(NM_PRIVATE_TOKENS_PATH, nmPrivateTokensPath)\n            .setExecutionAttribute(PID_FILE_PATH, pidFilePath)\n            .setExecutionAttribute(LOCAL_DIRS, localDirs)\n            .setExecutionAttribute(LOG_DIRS, logDirs)\n            .setExecutionAttribute(RESOURCES_OPTIONS, resourcesOptions);\n\n        if (tcCommandFile !\u003d null) {\n          builder.setExecutionAttribute(TC_COMMAND_FILE, tcCommandFile);\n        }\n\n        linuxContainerRuntime.launchContainer(builder.build());\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ContainerExecutionException e) {\n      int exitCode \u003d e.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getErrorOutput()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getErrorOutput() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!e.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + e.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "c40bdb56a79fe1499c2284d493edc84620c0c078": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2194. Fix bug causing CGroups functionality to fail on RHEL7. Contributed by Wei Yan.\n",
      "commitDate": "07/07/15 4:29 AM",
      "commitName": "c40bdb56a79fe1499c2284d493edc84620c0c078",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "21/05/15 3:50 PM",
      "commitNameOld": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 46.53,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,154 @@\n   public int launchContainer(ContainerStartContext ctx) throws IOException {\n     Container container \u003d ctx.getContainer();\n     Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n     Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n     String user \u003d ctx.getUser();\n     String appId \u003d ctx.getAppId();\n     Path containerWorkDir \u003d ctx.getContainerWorkDir();\n     List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n     List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation\n               (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n               case ADD_PID_TO_CGROUP:\n                 resourceOps.add(op);\n                 break;\n               case TC_MODIFY_STATE:\n                 tcCommandFile \u003d op.getArguments().get(0);\n                 break;\n               default:\n                 LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                     + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n     }\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateContainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n-            StringUtils.join(\",\", localDirs),\n-            StringUtils.join(\",\", logDirs),\n+            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+                localDirs),\n+            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+                logDirs),\n             resourcesOptions));\n \n         if (tcCommandFile !\u003d null) {\n             command.add(tcCommandFile);\n         }\n \n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n    }\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n                localDirs),\n            StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n                logDirs),\n            resourcesOptions));\n\n        if (tcCommandFile !\u003d null) {\n            command.add(tcCommandFile);\n        }\n\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "53fafcf061616516c24e2e2007a66a93d23d3e25": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
      "commitDate": "21/05/15 3:50 PM",
      "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/15 8:01 PM",
          "commitNameOld": "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 12.83,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,147 +1,152 @@\n-  public int launchContainer(Container container,\n-      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir,\n-      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n+  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+    Container container \u003d ctx.getContainer();\n+    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n+    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n+    String user \u003d ctx.getUser();\n+    String appId \u003d ctx.getAppId();\n+    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n+    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation\n               (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n               case ADD_PID_TO_CGROUP:\n                 resourceOps.add(op);\n                 break;\n               case TC_MODIFY_STATE:\n                 tcCommandFile \u003d op.getArguments().get(0);\n                 break;\n               default:\n                 LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                     + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n     }\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n-            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n+            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n \n         if (tcCommandFile !\u003d null) {\n             command.add(tcCommandFile);\n         }\n \n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n    }\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n\n        if (tcCommandFile !\u003d null) {\n            command.add(tcCommandFile);\n        }\n\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[container-Container, nmPrivateCotainerScriptPath-Path, nmPrivateTokensPath-Path, user-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]",
            "newValue": "[ctx-ContainerStartContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
          "commitDate": "21/05/15 3:50 PM",
          "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "08/05/15 8:01 PM",
          "commitNameOld": "6471d18bc72bc6c83ce31a03b5c5f5737847bb6d",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 12.83,
          "commitsBetweenForRepo": 119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,147 +1,152 @@\n-  public int launchContainer(Container container,\n-      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir,\n-      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n+  public int launchContainer(ContainerStartContext ctx) throws IOException {\n+    Container container \u003d ctx.getContainer();\n+    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n+    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n+    String user \u003d ctx.getUser();\n+    String appId \u003d ctx.getAppId();\n+    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n+    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n+    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n     String tcCommandFile \u003d null;\n \n     try {\n       if (resourceHandlerChain !\u003d null) {\n         List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n             .preStart(container);\n \n         if (ops !\u003d null) {\n           List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n \n           resourceOps.add(new PrivilegedOperation\n               (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                   resourcesOptions));\n \n           for (PrivilegedOperation op : ops) {\n             switch (op.getOperationType()) {\n               case ADD_PID_TO_CGROUP:\n                 resourceOps.add(op);\n                 break;\n               case TC_MODIFY_STATE:\n                 tcCommandFile \u003d op.getArguments().get(0);\n                 break;\n               default:\n                 LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                     + op.getOperationType());\n             }\n           }\n \n           if (resourceOps.size() \u003e 1) {\n             //squash resource operations\n             try {\n               PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                   .squashCGroupOperations(resourceOps);\n               resourcesOptions \u003d operation.getArguments().get(0);\n             } catch (PrivilegedOperationException e) {\n               LOG.error(\"Failed to squash cgroup operations!\", e);\n               throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n             }\n           }\n         }\n       }\n     } catch (ResourceHandlerException e) {\n       LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n       throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n     }\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n-            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n+            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n \n         if (tcCommandFile !\u003d null) {\n             command.add(tcCommandFile);\n         }\n \n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n \n       try {\n         if (resourceHandlerChain !\u003d null) {\n           resourceHandlerChain.postComplete(containerId);\n         }\n       } catch (ResourceHandlerException e) {\n         LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n             \"containerId: \" + containerId + \". Exception: \" + e);\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(ContainerStartContext ctx) throws IOException {\n    Container container \u003d ctx.getContainer();\n    Path nmPrivateContainerScriptPath \u003d ctx.getNmPrivateContainerScriptPath();\n    Path nmPrivateTokensPath \u003d ctx.getNmPrivateTokensPath();\n    String user \u003d ctx.getUser();\n    String appId \u003d ctx.getAppId();\n    Path containerWorkDir \u003d ctx.getContainerWorkDir();\n    List\u003cString\u003e localDirs \u003d ctx.getLocalDirs();\n    List\u003cString\u003e logDirs \u003d ctx.getLogDirs();\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n    }\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateContainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n\n        if (tcCommandFile !\u003d null) {\n            command.add(tcCommandFile);\n        }\n\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "a100be685cc4521e9949589948219231aa5d2733": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3366. Enhanced NodeManager to support classifying/shaping outgoing network bandwidth traffic originating from YARN containers Contributed by Sidharta Seethana.\n",
      "commitDate": "22/04/15 5:26 PM",
      "commitName": "a100be685cc4521e9949589948219231aa5d2733",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/01/15 7:40 AM",
      "commitNameOld": "902c6ea7e4d3b49e49d9ce51ae9d12694ecfcf89",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 86.37,
      "commitsBetweenForRepo": 799,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,147 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n+    String tcCommandFile \u003d null;\n+\n+    try {\n+      if (resourceHandlerChain !\u003d null) {\n+        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n+            .preStart(container);\n+\n+        if (ops !\u003d null) {\n+          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n+\n+          resourceOps.add(new PrivilegedOperation\n+              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n+                  resourcesOptions));\n+\n+          for (PrivilegedOperation op : ops) {\n+            switch (op.getOperationType()) {\n+              case ADD_PID_TO_CGROUP:\n+                resourceOps.add(op);\n+                break;\n+              case TC_MODIFY_STATE:\n+                tcCommandFile \u003d op.getArguments().get(0);\n+                break;\n+              default:\n+                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n+                    + op.getOperationType());\n+            }\n+          }\n+\n+          if (resourceOps.size() \u003e 1) {\n+            //squash resource operations\n+            try {\n+              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n+                  .squashCGroupOperations(resourceOps);\n+              resourcesOptions \u003d operation.getArguments().get(0);\n+            } catch (PrivilegedOperationException e) {\n+              LOG.error(\"Failed to squash cgroup operations!\", e);\n+              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n+            }\n+          }\n+        }\n+      }\n+    } catch (ResourceHandlerException e) {\n+      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n+      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n+    }\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n+\n+        if (tcCommandFile !\u003d null) {\n+            command.add(tcCommandFile);\n+        }\n+\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n+\n+      try {\n+        if (resourceHandlerChain !\u003d null) {\n+          resourceHandlerChain.postComplete(containerId);\n+        }\n+      } catch (ResourceHandlerException e) {\n+        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n+            \"containerId: \" + containerId + \". Exception: \" + e);\n+      }\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n    String tcCommandFile \u003d null;\n\n    try {\n      if (resourceHandlerChain !\u003d null) {\n        List\u003cPrivilegedOperation\u003e ops \u003d resourceHandlerChain\n            .preStart(container);\n\n        if (ops !\u003d null) {\n          List\u003cPrivilegedOperation\u003e resourceOps \u003d new ArrayList\u003c\u003e();\n\n          resourceOps.add(new PrivilegedOperation\n              (PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP,\n                  resourcesOptions));\n\n          for (PrivilegedOperation op : ops) {\n            switch (op.getOperationType()) {\n              case ADD_PID_TO_CGROUP:\n                resourceOps.add(op);\n                break;\n              case TC_MODIFY_STATE:\n                tcCommandFile \u003d op.getArguments().get(0);\n                break;\n              default:\n                LOG.warn(\"PrivilegedOperation type unsupported in launch: \"\n                    + op.getOperationType());\n            }\n          }\n\n          if (resourceOps.size() \u003e 1) {\n            //squash resource operations\n            try {\n              PrivilegedOperation operation \u003d PrivilegedOperationExecutor\n                  .squashCGroupOperations(resourceOps);\n              resourcesOptions \u003d operation.getArguments().get(0);\n            } catch (PrivilegedOperationException e) {\n              LOG.error(\"Failed to squash cgroup operations!\", e);\n              throw new ResourceHandlerException(\"Failed to squash cgroup operations!\");\n            }\n          }\n        }\n      }\n    } catch (ResourceHandlerException e) {\n      LOG.error(\"ResourceHandlerChain.preStart() failed!\", e);\n      throw new IOException(\"ResourceHandlerChain.preStart() failed!\");\n    }\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n\n        if (tcCommandFile !\u003d null) {\n            command.add(tcCommandFile);\n        }\n\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n\n      try {\n        if (resourceHandlerChain !\u003d null) {\n          resourceHandlerChain.postComplete(containerId);\n        }\n      } catch (ResourceHandlerException e) {\n        LOG.warn(\"ResourceHandlerChain.postComplete failed for \" +\n            \"containerId: \" + containerId + \". Exception: \" + e);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "41a548a916d4248164cb9495320f123ec215d70e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2937. Fixed new findbugs warnings in hadoop-yarn-nodemanager. Contributed by Varun Saxena.\n",
      "commitDate": "23/12/14 8:32 PM",
      "commitName": "41a548a916d4248164cb9495320f123ec215d70e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "13/11/14 8:11 AM",
      "commitNameOld": "33ea5ae92b9dd3abace104903d9a94d17dd75af5",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 40.51,
      "commitsBetweenForRepo": 283,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,88 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n-      if (null \u003d\u003d shExec) {\n-        return -1;\n-      }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n \n         StringBuilder builder \u003d new StringBuilder();\n         builder.append(\"Exception from container-launch.\\n\");\n         builder.append(\"Container id: \" + containerId + \"\\n\");\n         builder.append(\"Exit code: \" + exitCode + \"\\n\");\n         if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n           builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n         }\n         builder.append(\"Stack trace: \"\n             + StringUtils.stringifyException(e) + \"\\n\");\n         if (!shExec.getOutput().isEmpty()) {\n           builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n         }\n         String diagnostics \u003d builder.toString();\n         logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "537c361f5bc888dd74fbe59afe18d08d0746894f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2013. The diagnostics is always the ExitCodeException stack when the container crashes. (Contributed by Tsuyoshi OZAWA)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612449 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 8:01 PM",
      "commitName": "537c361f5bc888dd74fbe59afe18d08d0746894f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "16/01/14 10:42 AM",
      "commitNameOld": "752441434c99003595c67f22b3a526881e70156b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 186.35,
      "commitsBetweenForRepo": 1318,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,91 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n         }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n-        logOutput(shExec.getOutput());\n-        String diagnostics \u003d \"Exception from container-launch: \\n\"\n-            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n+\n+        StringBuilder builder \u003d new StringBuilder();\n+        builder.append(\"Exception from container-launch.\\n\");\n+        builder.append(\"Container id: \" + containerId + \"\\n\");\n+        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n+        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n+          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n+        }\n+        builder.append(\"Stack trace: \"\n+            + StringUtils.stringifyException(e) + \"\\n\");\n+        if (!shExec.getOutput().isEmpty()) {\n+          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n+        }\n+        String diagnostics \u003d builder.toString();\n+        logOutput(diagnostics);\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n\n        StringBuilder builder \u003d new StringBuilder();\n        builder.append(\"Exception from container-launch.\\n\");\n        builder.append(\"Container id: \" + containerId + \"\\n\");\n        builder.append(\"Exit code: \" + exitCode + \"\\n\");\n        if (!Optional.fromNullable(e.getMessage()).or(\"\").isEmpty()) {\n          builder.append(\"Exception message: \" + e.getMessage() + \"\\n\");\n        }\n        builder.append(\"Stack trace: \"\n            + StringUtils.stringifyException(e) + \"\\n\");\n        if (!shExec.getOutput().isEmpty()) {\n          builder.append(\"Shell output: \" + shExec.getOutput() + \"\\n\");\n        }\n        String diagnostics \u003d builder.toString();\n        logOutput(diagnostics);\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "752441434c99003595c67f22b3a526881e70156b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1608. LinuxContainerExecutor has a few DEBUG messages at INFO level (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1558874 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/01/14 10:42 AM",
      "commitName": "752441434c99003595c67f22b3a526881e70156b",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/10/13 2:59 PM",
      "commitNameOld": "80c5bffc4b6bd2aa54ed8d49a32fd2c2cb77bfcc",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 103.86,
      "commitsBetweenForRepo": 600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     verifyUsernamePattern(user);\n     String runAsUser \u003d getRunAsUser(user);\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n-        // DEBUG\n-        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n+        }\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"launchContainer: \" + Arrays.toString(commandArray));\n        }\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "80c5bffc4b6bd2aa54ed8d49a32fd2c2cb77bfcc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1253. Changes to LinuxContainerExecutor to run containers as a single dedicated user in non-secure mode. (rvs via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529325 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/13 2:59 PM",
      "commitName": "80c5bffc4b6bd2aa54ed8d49a32fd2c2cb77bfcc",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/07/13 5:28 PM",
      "commitNameOld": "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 77.9,
      "commitsBetweenForRepo": 467,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,78 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n+    verifyUsernamePattern(user);\n+    String runAsUser \u003d getRunAsUser(user);\n+\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n-            containerExecutorExe, user, Integer\n+            containerExecutorExe, runAsUser, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch with container ID: \"\n             + containerId + \" and exit code: \" + exitCode , e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    verifyUsernamePattern(user);\n    String runAsUser \u003d getRunAsUser(user);\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, runAsUser, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "7a29bccd7aaf2eb33adac937379ba6be43a1031d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-814. Improving diagnostics when containers fail during launch due to various reasons like invalid env etc. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504732 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 5:28 PM",
      "commitName": "7a29bccd7aaf2eb33adac937379ba6be43a1031d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/05/13 9:13 PM",
      "commitNameOld": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 48.84,
      "commitsBetweenForRepo": 322,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n-\n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n-\n       int exitCode \u003d shExec.getExitCode();\n-      LOG.warn(\"Exit code from container is : \" + exitCode);\n+      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n-        LOG.warn(\"Exception from container-launch : \", e);\n+        LOG.warn(\"Exception from container-launch with container ID: \"\n+            + containerId + \" and exit code: \" + exitCode , e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container \" + containerId + \" is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch with container ID: \"\n            + containerId + \" and exit code: \" + exitCode , e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 37.27,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n-    ContainerId containerId \u003d container.getContainer().getId();\n+    ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n-            container.getContainer().getResource());\n+            container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.09,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n-    ContainerId containerId \u003d container.getContainerID();\n+    ContainerId containerId \u003d container.getContainer().getId();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n-            container.getResource());\n+            container.getContainer().getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainer().getId();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getContainer().getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/03/13 6:46 AM",
      "commitNameOld": "5f2c518c95b2186b784877a5f41c7b71f8abc2f6",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 34.2,
      "commitsBetweenForRepo": 187,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n-            container.getLaunchContext().getResource());\n+            container.getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n         addSchedPriorityCommand(command);\n         command.addAll(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "5f2c518c95b2186b784877a5f41c7b71f8abc2f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-443. allow OS scheduling priority of NM to be different than the containers it launches (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1454411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/13 6:46 AM",
      "commitName": "5f2c518c95b2186b784877a5f41c7b71f8abc2f6",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "18/12/12 2:58 PM",
      "commitNameOld": "5032a694ed250f65ade8c2b62c97b89ab45f53ea",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 79.66,
      "commitsBetweenForRepo": 346,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,76 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     \n     resourcesHandler.preExecute(containerId,\n             container.getLaunchContext().getResource());\n     String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n             containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n-        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n+        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n+        addSchedPriorityCommand(command);\n+        command.addAll(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n             StringUtils.join(\",\", logDirs),\n             resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getLaunchContext().getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e();\n        addSchedPriorityCommand(command);\n        command.addAll(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "5032a694ed250f65ade8c2b62c97b89ab45f53ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3. Add support for CPU isolation/monitoring of containers. (adferguson via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423706 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/12 2:58 PM",
      "commitName": "5032a694ed250f65ade8c2b62c97b89ab45f53ea",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "25/09/12 4:37 PM",
      "commitNameOld": "8912aac81e37a8f49fc21e0e367cd8cb96eea583",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 83.97,
      "commitsBetweenForRepo": 423,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,74 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir,\n       List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    \n+    resourcesHandler.preExecute(containerId,\n+            container.getLaunchContext().getResource());\n+    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n+            containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n             nmPrivateTokensPath.toUri().getPath().toString(),\n             pidFilePath.toString(),\n             StringUtils.join(\",\", localDirs),\n-            StringUtils.join(\",\", logDirs)));\n+            StringUtils.join(\",\", logDirs),\n+            resourcesOptions));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n-      ; //\n+      resourcesHandler.postExecute(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    \n    resourcesHandler.preExecute(containerId,\n            container.getLaunchContext().getResource());\n    String resourcesOptions \u003d resourcesHandler.getResourcesOption(\n            containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs),\n            resourcesOptions));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      resourcesHandler.postExecute(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs)));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java"
      }
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/11/11 3:17 PM",
          "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "15/11/11 2:30 AM",
          "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.53,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,68 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir) throws IOException {\n+      String user, String appId, Path containerWorkDir,\n+      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n-            nmPrivateTokensPath.toUri().getPath().toString(), pidFilePath\n-                .toString()));\n+            nmPrivateTokensPath.toUri().getPath().toString(),\n+            pidFilePath.toString(),\n+            StringUtils.join(\",\", localDirs),\n+            StringUtils.join(\",\", logDirs)));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs)));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {
            "oldValue": "[container-Container, nmPrivateCotainerScriptPath-Path, nmPrivateTokensPath-Path, user-String, appId-String, containerWorkDir-Path]",
            "newValue": "[container-Container, nmPrivateCotainerScriptPath-Path, nmPrivateTokensPath-Path, user-String, appId-String, containerWorkDir-Path, localDirs-List\u003cString\u003e, logDirs-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/11/11 3:17 PM",
          "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "15/11/11 2:30 AM",
          "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.53,
          "commitsBetweenForRepo": 77,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,68 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n-      String user, String appId, Path containerWorkDir) throws IOException {\n+      String user, String appId, Path containerWorkDir,\n+      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     ShellCommandExecutor shExec \u003d null;\n \n     try {\n       Path pidFilePath \u003d getPidFilePath(containerId);\n       if (pidFilePath !\u003d null) {\n         List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n             containerExecutorExe, user, Integer\n                 .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n             containerIdStr, containerWorkDir.toString(),\n             nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n-            nmPrivateTokensPath.toUri().getPath().toString(), pidFilePath\n-                .toString()));\n+            nmPrivateTokensPath.toUri().getPath().toString(),\n+            pidFilePath.toString(),\n+            StringUtils.join(\",\", localDirs),\n+            StringUtils.join(\",\", logDirs)));\n         String[] commandArray \u003d command.toArray(new String[command.size()]);\n         shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment()); // sanitized env\n         // DEBUG\n         LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n         shExec.execute();\n         if (LOG.isDebugEnabled()) {\n           logOutput(shExec.getOutput());\n         }\n       } else {\n         LOG.info(\"Container was marked as inactive. Returning terminated error\");\n         return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n \n       if (null \u003d\u003d shExec) {\n         return -1;\n       }\n \n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n           \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       ; //\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir,\n      List\u003cString\u003e localDirs, List\u003cString\u003e logDirs) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(),\n            pidFilePath.toString(),\n            StringUtils.join(\",\", localDirs),\n            StringUtils.join(\",\", logDirs)));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
          "extendedDetails": {}
        }
      ]
    },
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3240. Fixed NodeManager to be able to forcefully cleanup its containers (process-trees) irrespective of whether the container succeeded, or killed. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189711 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 5:03 AM",
      "commitName": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 1:28 AM",
      "commitNameOld": "fc74b5a25cdb5e5c6145d3c60a36f9f8e0acc9ef",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,65 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n-    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n-      Arrays.asList(containerExecutorExe, \n-                    user, \n-                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n-                    appId,\n-                    containerIdStr,\n-                    containerWorkDir.toString(),\n-                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n-                    nmPrivateTokensPath.toUri().getPath().toString()));\n-    String[] commandArray \u003d command.toArray(new String[command.size()]);\n-    ShellCommandExecutor shExec \u003d \n-        new ShellCommandExecutor(\n-            commandArray,\n-            null,                                              // NM\u0027s cwd\n-            container.getLaunchContext().getEnvironment());    // sanitized env\n-    launchCommandObjs.put(containerId, shExec);\n-    // DEBUG\n-    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n+\n+    ShellCommandExecutor shExec \u003d null;\n+\n     try {\n-      shExec.execute();\n-      if (LOG.isDebugEnabled()) {\n-        logOutput(shExec.getOutput());\n+      Path pidFilePath \u003d getPidFilePath(containerId);\n+      if (pidFilePath !\u003d null) {\n+        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n+            containerExecutorExe, user, Integer\n+                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n+            containerIdStr, containerWorkDir.toString(),\n+            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n+            nmPrivateTokensPath.toUri().getPath().toString(), pidFilePath\n+                .toString()));\n+        String[] commandArray \u003d command.toArray(new String[command.size()]);\n+        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n+            container.getLaunchContext().getEnvironment()); // sanitized env\n+        // DEBUG\n+        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n+        shExec.execute();\n+        if (LOG.isDebugEnabled()) {\n+          logOutput(shExec.getOutput());\n+        }\n+      } else {\n+        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n+        return ExitCode.TERMINATED.getExitCode();\n       }\n     } catch (ExitCodeException e) {\n+\n+      if (null \u003d\u003d shExec) {\n+        return -1;\n+      }\n+\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n-      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n+      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n+          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n-      launchCommandObjs.remove(containerId);\n+      ; //\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    ShellCommandExecutor shExec \u003d null;\n\n    try {\n      Path pidFilePath \u003d getPidFilePath(containerId);\n      if (pidFilePath !\u003d null) {\n        List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(Arrays.asList(\n            containerExecutorExe, user, Integer\n                .toString(Commands.LAUNCH_CONTAINER.getValue()), appId,\n            containerIdStr, containerWorkDir.toString(),\n            nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n            nmPrivateTokensPath.toUri().getPath().toString(), pidFilePath\n                .toString()));\n        String[] commandArray \u003d command.toArray(new String[command.size()]);\n        shExec \u003d new ShellCommandExecutor(commandArray, null, // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment()); // sanitized env\n        // DEBUG\n        LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n        shExec.execute();\n        if (LOG.isDebugEnabled()) {\n          logOutput(shExec.getOutput());\n        }\n      } else {\n        LOG.info(\"Container was marked as inactive. Returning terminated error\");\n        return ExitCode.TERMINATED.getExitCode();\n      }\n    } catch (ExitCodeException e) {\n\n      if (null \u003d\u003d shExec) {\n        return -1;\n      }\n\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d ExitCode.FORCE_KILLED.getExitCode()\n          \u0026\u0026 exitCode !\u003d ExitCode.TERMINATED.getExitCode()) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      ; //\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "a8190ce5c520fcb69399485231ef7c0b7fdc3df7": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2988. Reenabled TestLinuxContainerExecutor reflecting the current NodeManager code. Contributed by Robert Joseph Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1180833 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/11 2:18 AM",
      "commitName": "a8190ce5c520fcb69399485231ef7c0b7fdc3df7",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/09/11 11:28 AM",
      "commitNameOld": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.62,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n       Arrays.asList(containerExecutorExe, \n                     user, \n                     Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                     appId,\n                     containerIdStr,\n                     containerWorkDir.toString(),\n                     nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                     nmPrivateTokensPath.toUri().getPath().toString()));\n     String[] commandArray \u003d command.toArray(new String[command.size()]);\n     ShellCommandExecutor shExec \u003d \n         new ShellCommandExecutor(\n             commandArray,\n             null,                                              // NM\u0027s cwd\n             container.getLaunchContext().getEnvironment());    // sanitized env\n     launchCommandObjs.put(containerId, shExec);\n     // DEBUG\n     LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n-    String output \u003d shExec.getOutput();\n     try {\n       shExec.execute();\n       if (LOG.isDebugEnabled()) {\n-        logOutput(output);\n+        logOutput(shExec.getOutput());\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n         LOG.warn(\"Exception from container-launch : \", e);\n-        logOutput(output);\n+        logOutput(shExec.getOutput());\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n-            + StringUtils.stringifyException(e) + \"\\n\" + output;\n+            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       launchCommandObjs.remove(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n-      logOutput(output);\n+      logOutput(shExec.getOutput());\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n      Arrays.asList(containerExecutorExe, \n                    user, \n                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                    appId,\n                    containerIdStr,\n                    containerWorkDir.toString(),\n                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                    nmPrivateTokensPath.toUri().getPath().toString()));\n    String[] commandArray \u003d command.toArray(new String[command.size()]);\n    ShellCommandExecutor shExec \u003d \n        new ShellCommandExecutor(\n            commandArray,\n            null,                                              // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment());    // sanitized env\n    launchCommandObjs.put(containerId, shExec);\n    // DEBUG\n    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n    try {\n      shExec.execute();\n      if (LOG.isDebugEnabled()) {\n        logOutput(shExec.getOutput());\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(shExec.getOutput());\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + shExec.getOutput();\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(shExec.getOutput());\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2880. Improved classpath-construction for mapreduce AM and containers. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1173783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/11 11:28 AM",
      "commitName": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 12.7,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,57 @@\n   public int launchContainer(Container container,\n       Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n       String user, String appId, Path containerWorkDir) throws IOException {\n \n     ContainerId containerId \u003d container.getContainerID();\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n     List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n       Arrays.asList(containerExecutorExe, \n                     user, \n                     Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                     appId,\n                     containerIdStr,\n                     containerWorkDir.toString(),\n                     nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                     nmPrivateTokensPath.toUri().getPath().toString()));\n     String[] commandArray \u003d command.toArray(new String[command.size()]);\n-    ShellCommandExecutor shExec \u003d new ShellCommandExecutor(commandArray);\n+    ShellCommandExecutor shExec \u003d \n+        new ShellCommandExecutor(\n+            commandArray,\n+            null,                                              // NM\u0027s cwd\n+            container.getLaunchContext().getEnvironment());    // sanitized env\n     launchCommandObjs.put(containerId, shExec);\n     // DEBUG\n     LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n     String output \u003d shExec.getOutput();\n     try {\n       shExec.execute();\n       if (LOG.isDebugEnabled()) {\n         logOutput(output);\n       }\n     } catch (ExitCodeException e) {\n       int exitCode \u003d shExec.getExitCode();\n       LOG.warn(\"Exit code from container is : \" + exitCode);\n       // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n       // terminated/killed forcefully. In all other cases, log the\n       // container-executor\u0027s output\n       if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n         LOG.warn(\"Exception from container-launch : \", e);\n         logOutput(output);\n         String diagnostics \u003d \"Exception from container-launch: \\n\"\n             + StringUtils.stringifyException(e) + \"\\n\" + output;\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             diagnostics));\n       } else {\n         container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n             \"Container killed on request. Exit code is \" + exitCode));\n       }\n       return exitCode;\n     } finally {\n       launchCommandObjs.remove(containerId);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n       logOutput(output);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n      Arrays.asList(containerExecutorExe, \n                    user, \n                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                    appId,\n                    containerIdStr,\n                    containerWorkDir.toString(),\n                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                    nmPrivateTokensPath.toUri().getPath().toString()));\n    String[] commandArray \u003d command.toArray(new String[command.size()]);\n    ShellCommandExecutor shExec \u003d \n        new ShellCommandExecutor(\n            commandArray,\n            null,                                              // NM\u0027s cwd\n            container.getLaunchContext().getEnvironment());    // sanitized env\n    launchCommandObjs.put(containerId, shExec);\n    // DEBUG\n    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n    String output \u003d shExec.getOutput();\n    try {\n      shExec.execute();\n      if (LOG.isDebugEnabled()) {\n        logOutput(output);\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(output);\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + output;\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(output);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n      Arrays.asList(containerExecutorExe, \n                    user, \n                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                    appId,\n                    containerIdStr,\n                    containerWorkDir.toString(),\n                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                    nmPrivateTokensPath.toUri().getPath().toString()));\n    String[] commandArray \u003d command.toArray(new String[command.size()]);\n    ShellCommandExecutor shExec \u003d new ShellCommandExecutor(commandArray);\n    launchCommandObjs.put(containerId, shExec);\n    // DEBUG\n    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n    String output \u003d shExec.getOutput();\n    try {\n      shExec.execute();\n      if (LOG.isDebugEnabled()) {\n        logOutput(output);\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(output);\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + output;\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(output);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,53 @@\n+  public int launchContainer(Container container,\n+      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n+      String user, String appId, Path containerWorkDir) throws IOException {\n+\n+    ContainerId containerId \u003d container.getContainerID();\n+    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n+      Arrays.asList(containerExecutorExe, \n+                    user, \n+                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n+                    appId,\n+                    containerIdStr,\n+                    containerWorkDir.toString(),\n+                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n+                    nmPrivateTokensPath.toUri().getPath().toString()));\n+    String[] commandArray \u003d command.toArray(new String[command.size()]);\n+    ShellCommandExecutor shExec \u003d new ShellCommandExecutor(commandArray);\n+    launchCommandObjs.put(containerId, shExec);\n+    // DEBUG\n+    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n+    String output \u003d shExec.getOutput();\n+    try {\n+      shExec.execute();\n+      if (LOG.isDebugEnabled()) {\n+        logOutput(output);\n+      }\n+    } catch (ExitCodeException e) {\n+      int exitCode \u003d shExec.getExitCode();\n+      LOG.warn(\"Exit code from container is : \" + exitCode);\n+      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n+      // terminated/killed forcefully. In all other cases, log the\n+      // container-executor\u0027s output\n+      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n+        LOG.warn(\"Exception from container-launch : \", e);\n+        logOutput(output);\n+        String diagnostics \u003d \"Exception from container-launch: \\n\"\n+            + StringUtils.stringifyException(e) + \"\\n\" + output;\n+        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n+            diagnostics));\n+      } else {\n+        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n+            \"Container killed on request. Exit code is \" + exitCode));\n+      }\n+      return exitCode;\n+    } finally {\n+      launchCommandObjs.remove(containerId);\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n+      logOutput(output);\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int launchContainer(Container container,\n      Path nmPrivateCotainerScriptPath, Path nmPrivateTokensPath,\n      String user, String appId, Path containerWorkDir) throws IOException {\n\n    ContainerId containerId \u003d container.getContainerID();\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n    List\u003cString\u003e command \u003d new ArrayList\u003cString\u003e(\n      Arrays.asList(containerExecutorExe, \n                    user, \n                    Integer.toString(Commands.LAUNCH_CONTAINER.getValue()),\n                    appId,\n                    containerIdStr,\n                    containerWorkDir.toString(),\n                    nmPrivateCotainerScriptPath.toUri().getPath().toString(),\n                    nmPrivateTokensPath.toUri().getPath().toString()));\n    String[] commandArray \u003d command.toArray(new String[command.size()]);\n    ShellCommandExecutor shExec \u003d new ShellCommandExecutor(commandArray);\n    launchCommandObjs.put(containerId, shExec);\n    // DEBUG\n    LOG.info(\"launchContainer: \" + Arrays.toString(commandArray));\n    String output \u003d shExec.getOutput();\n    try {\n      shExec.execute();\n      if (LOG.isDebugEnabled()) {\n        logOutput(output);\n      }\n    } catch (ExitCodeException e) {\n      int exitCode \u003d shExec.getExitCode();\n      LOG.warn(\"Exit code from container is : \" + exitCode);\n      // 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was\n      // terminated/killed forcefully. In all other cases, log the\n      // container-executor\u0027s output\n      if (exitCode !\u003d 143 \u0026\u0026 exitCode !\u003d 137) {\n        LOG.warn(\"Exception from container-launch : \", e);\n        logOutput(output);\n        String diagnostics \u003d \"Exception from container-launch: \\n\"\n            + StringUtils.stringifyException(e) + \"\\n\" + output;\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            diagnostics));\n      } else {\n        container.handle(new ContainerDiagnosticsUpdateEvent(containerId,\n            \"Container killed on request. Exit code is \" + exitCode));\n      }\n      return exitCode;\n    } finally {\n      launchCommandObjs.remove(containerId);\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Output from LinuxContainerExecutor\u0027s launchContainer follows:\");\n      logOutput(output);\n    }\n    return 0;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/LinuxContainerExecutor.java"
    }
  }
}