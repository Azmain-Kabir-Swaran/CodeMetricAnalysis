{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractFileSystem.java",
  "functionName": "checkPath",
  "functionId": "checkPath___path-Path",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
  "functionStartLine": 369,
  "functionEndLine": 413,
  "numCommitsSeen": 53,
  "timeTaken": 3008,
  "changeHistory": [
    "6d0bffe17eadedd60d4599427248b0db4a7c5502",
    "7f783970364930cc461d1a73833bc58cdd10553e",
    "d7152332b32a575c3a92e3f4c44b95e58462528d",
    "51e520c68aafb73b784bf690a8a42de3af0f229c",
    "4b62c682927a25c09a3b580f2fa62345f4693e06",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "946eac3dac02b8a84a9ae91ac7482b4224d0728b",
    "1ab5aa5279fc0ee9c27c859b57f6b017c27459bc",
    "3f371a0a644181b204111ee4e12c995fc7b5e5f5"
  ],
  "changeHistoryShort": {
    "6d0bffe17eadedd60d4599427248b0db4a7c5502": "Ybodychange",
    "7f783970364930cc461d1a73833bc58cdd10553e": "Ybodychange",
    "d7152332b32a575c3a92e3f4c44b95e58462528d": "Ybodychange",
    "51e520c68aafb73b784bf690a8a42de3af0f229c": "Ybodychange",
    "4b62c682927a25c09a3b580f2fa62345f4693e06": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "946eac3dac02b8a84a9ae91ac7482b4224d0728b": "Ymodifierchange",
    "1ab5aa5279fc0ee9c27c859b57f6b017c27459bc": "Ybodychange",
    "3f371a0a644181b204111ee4e12c995fc7b5e5f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6d0bffe17eadedd60d4599427248b0db4a7c5502": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14556. S3A to support Delegation Tokens.\n\nContributed by Steve Loughran and Daryn Sharp.\n",
      "commitDate": "14/01/19 9:59 AM",
      "commitName": "6d0bffe17eadedd60d4599427248b0db4a7c5502",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/01/19 9:51 PM",
      "commitNameOld": "7f783970364930cc461d1a73833bc58cdd10553e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.51,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,45 @@\n   public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n             \"Path without scheme with non-null authority:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisHost \u003d this.getUri().getHost();\n     String thatHost \u003d uri.getHost();\n     \n     // Schemes and hosts must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisHost !\u003d null \u0026\u0026 \n             !thisHost.equalsIgnoreCase(thatHost)) ||\n        (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n     // Ports must match, unless this FS instance is using the default port, in\n     // which case the port may be omitted from the given URI\n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d uri.getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n-      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n-          + this.getUri());\n+      throw new InvalidPathException(\"Wrong FS: \" + path\n+          + \" and port\u003d\" + thatPort\n+          + \", expected: \"\n+          + this.getUri()\n+          + \" with port\u003d\" + thisPort);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null authority:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisHost \u003d this.getUri().getHost();\n    String thatHost \u003d uri.getHost();\n    \n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost !\u003d null \u0026\u0026 \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d uri.getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path\n          + \" and port\u003d\" + thatPort\n          + \", expected: \"\n          + this.getUri()\n          + \" with port\u003d\" + thisPort);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "7f783970364930cc461d1a73833bc58cdd10553e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14556. S3A to support Delegation Tokens.\"\n\nThis reverts commit d7152332b32a575c3a92e3f4c44b95e58462528d.\n",
      "commitDate": "07/01/19 9:51 PM",
      "commitName": "7f783970364930cc461d1a73833bc58cdd10553e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "07/01/19 5:18 AM",
      "commitNameOld": "d7152332b32a575c3a92e3f4c44b95e58462528d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,42 @@\n   public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n             \"Path without scheme with non-null authority:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisHost \u003d this.getUri().getHost();\n     String thatHost \u003d uri.getHost();\n     \n     // Schemes and hosts must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisHost !\u003d null \u0026\u0026 \n             !thisHost.equalsIgnoreCase(thatHost)) ||\n        (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n     // Ports must match, unless this FS instance is using the default port, in\n     // which case the port may be omitted from the given URI\n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d uri.getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n-      throw new InvalidPathException(\"Wrong FS: \" + path\n-          + \" and port\u003d\" + thatPort\n-          + \", expected: \"\n-          + this.getUri()\n-          + \" with port\u003d\" + thisPort);\n+      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n+          + this.getUri());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null authority:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisHost \u003d this.getUri().getHost();\n    String thatHost \u003d uri.getHost();\n    \n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost !\u003d null \u0026\u0026 \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d uri.getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "d7152332b32a575c3a92e3f4c44b95e58462528d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14556. S3A to support Delegation Tokens.\n\nContributed by Steve Loughran.\n",
      "commitDate": "07/01/19 5:18 AM",
      "commitName": "d7152332b32a575c3a92e3f4c44b95e58462528d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/12/18 9:54 PM",
      "commitNameOld": "788e7473a404fa074b3af522416ee3d2fae865a0",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,45 @@\n   public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n             \"Path without scheme with non-null authority:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisHost \u003d this.getUri().getHost();\n     String thatHost \u003d uri.getHost();\n     \n     // Schemes and hosts must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisHost !\u003d null \u0026\u0026 \n             !thisHost.equalsIgnoreCase(thatHost)) ||\n        (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n     // Ports must match, unless this FS instance is using the default port, in\n     // which case the port may be omitted from the given URI\n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d uri.getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n-      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n-          + this.getUri());\n+      throw new InvalidPathException(\"Wrong FS: \" + path\n+          + \" and port\u003d\" + thatPort\n+          + \", expected: \"\n+          + this.getUri()\n+          + \" with port\u003d\" + thisPort);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null authority:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisHost \u003d this.getUri().getHost();\n    String thatHost \u003d uri.getHost();\n    \n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost !\u003d null \u0026\u0026 \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d uri.getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path\n          + \" and port\u003d\" + thatPort\n          + \", expected: \"\n          + this.getUri()\n          + \" with port\u003d\" + thisPort);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "51e520c68aafb73b784bf690a8a42de3af0f229c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8349. ViewFS doesn\u0027t work when the root of a file system is mounted. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334231 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 3:14 PM",
      "commitName": "51e520c68aafb73b784bf690a8a42de3af0f229c",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "26/04/12 11:19 AM",
      "commitNameOld": "4b62c682927a25c09a3b580f2fa62345f4693e06",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 8.16,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n-            \"Path without scheme with non-null autorhrity:\" + path);\n+            \"Path without scheme with non-null authority:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisHost \u003d this.getUri().getHost();\n     String thatHost \u003d uri.getHost();\n     \n     // Schemes and hosts must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisHost !\u003d null \u0026\u0026 \n             !thisHost.equalsIgnoreCase(thatHost)) ||\n        (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n     // Ports must match, unless this FS instance is using the default port, in\n     // which case the port may be omitted from the given URI\n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d uri.getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null authority:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisHost \u003d this.getUri().getHost();\n    String thatHost \u003d uri.getHost();\n    \n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost !\u003d null \u0026\u0026 \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d uri.getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "4b62c682927a25c09a3b580f2fa62345f4693e06": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8310. FileContext#checkPath should handle URIs with no port. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1331007 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/04/12 11:19 AM",
      "commitName": "4b62c682927a25c09a3b580f2fa62345f4693e06",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "20/11/11 11:11 PM",
      "commitNameOld": "d4306d4bd115d8db294a61f88f3a432f98e79556",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 157.46,
      "commitsBetweenForRepo": 1128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,42 @@\n   public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n             \"Path without scheme with non-null autorhrity:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n-    String thisAuthority \u003d this.getUri().getAuthority();\n+    String thisHost \u003d this.getUri().getHost();\n+    String thatHost \u003d uri.getHost();\n     \n-    // Schemes and authorities must match.\n+    // Schemes and hosts must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n-       (thisAuthority !\u003d null \u0026\u0026 \n-            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n-       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n+       (thisHost !\u003d null \u0026\u0026 \n+            !thisHost.equalsIgnoreCase(thatHost)) ||\n+       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n+    // Ports must match, unless this FS instance is using the default port, in\n+    // which case the port may be omitted from the given URI\n     int thisPort \u003d this.getUri().getPort();\n-    int thatPort \u003d path.toUri().getPort();\n+    int thatPort \u003d uri.getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisHost \u003d this.getUri().getHost();\n    String thatHost \u003d uri.getHost();\n    \n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost !\u003d null \u0026\u0026 \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost \u003d\u003d null \u0026\u0026 thatHost !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d uri.getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/fs/AbstractFileSystem.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/AbstractFileSystem.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/fs/AbstractFileSystem.java",
        "newPath": "common/src/java/org/apache/hadoop/fs/AbstractFileSystem.java"
      }
    },
    "946eac3dac02b8a84a9ae91ac7482b4224d0728b": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-6903 Make AbstractFSileSystem methods and some FileContext methods to be public\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1034480 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/11/10 9:23 AM",
      "commitName": "946eac3dac02b8a84a9ae91ac7482b4224d0728b",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "10/08/10 9:43 PM",
      "commitNameOld": "dc2a3d1ca33102b30a7c2eea67df1ba447813081",
      "commitAuthorOld": "Hairong Kuang",
      "daysBetweenCommits": 93.53,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n-  protected void checkPath(Path path) {\n+  public void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n         throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n         throw new InvalidPathException(\n             \"Path without scheme with non-null autorhrity:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisAuthority \u003d this.getUri().getAuthority();\n     \n     // Schemes and authorities must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisAuthority !\u003d null \u0026\u0026 \n             !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n        (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n     \n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d path.toUri().getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n       throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n           + this.getUri());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "src/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[public]"
      }
    },
    "1ab5aa5279fc0ee9c27c859b57f6b017c27459bc": {
      "type": "Ybodychange",
      "commitMessage": "   HADOOP-6537 Declare more detailed exceptions in FileContext and AbstractFileSystem\n   (Suresh Srinivas via Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@918309 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/10 6:48 PM",
      "commitName": "1ab5aa5279fc0ee9c27c859b57f6b017c27459bc",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "16/02/10 1:43 PM",
      "commitNameOld": "ea605b8cd79163444feead75d7b55dbd4ab537a0",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 14.21,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   protected void checkPath(Path path) {\n     URI uri \u003d path.toUri();\n     String thatScheme \u003d uri.getScheme();\n     String thatAuthority \u003d uri.getAuthority();\n     if (thatScheme \u003d\u003d null) {\n       if (thatAuthority \u003d\u003d null) {\n         if (path.isUriPathAbsolute()) {\n           return;\n         }\n-        throw new IllegalArgumentException(\"relative paths not allowed:\" + \n+        throw new InvalidPathException(\"relative paths not allowed:\" + \n             path);\n       } else {\n-        throw new IllegalArgumentException(\n+        throw new InvalidPathException(\n             \"Path without scheme with non-null autorhrity:\" + path);\n       }\n     }\n     String thisScheme \u003d this.getUri().getScheme();\n     String thisAuthority \u003d this.getUri().getAuthority();\n     \n     // Schemes and authorities must match.\n     // Allow for null Authority for file:///\n     if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n        (thisAuthority !\u003d null \u0026\u0026 \n             !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n        (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n-      throw new IllegalArgumentException(\"Wrong FS: \" + path + \n-                                    \", expected: \"+this.getUri());\n+      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n+          + this.getUri());\n     }\n     \n     int thisPort \u003d this.getUri().getPort();\n     int thatPort \u003d path.toUri().getPort();\n     if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n       thatPort \u003d this.getUriDefaultPort();\n     }\n     if (thisPort !\u003d thatPort) {\n-      throw new IllegalArgumentException(\"Wrong FS: \"+path+\n-                                       \", expected: \"+this.getUri());\n+      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n+          + this.getUri());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n  }",
      "path": "src/java/org/apache/hadoop/fs/AbstractFileSystem.java",
      "extendedDetails": {}
    },
    "3f371a0a644181b204111ee4e12c995fc7b5e5f5": {
      "type": "Yintroduced",
      "commitMessage": "Hadoop-6223. Add new file system interface AbstractFileSystem with implementation of some file systems that delegate to old FileSystem. Contributed by Sanjay Radia.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@831475 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/09 3:24 PM",
      "commitName": "3f371a0a644181b204111ee4e12c995fc7b5e5f5",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,39 @@\n+  protected void checkPath(Path path) {\n+    URI uri \u003d path.toUri();\n+    String thatScheme \u003d uri.getScheme();\n+    String thatAuthority \u003d uri.getAuthority();\n+    if (thatScheme \u003d\u003d null) {\n+      if (thatAuthority \u003d\u003d null) {\n+        if (path.isUriPathAbsolute()) {\n+          return;\n+        }\n+        throw new IllegalArgumentException(\"relative paths not allowed:\" + \n+            path);\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Path without scheme with non-null autorhrity:\" + path);\n+      }\n+    }\n+    String thisScheme \u003d this.getUri().getScheme();\n+    String thisAuthority \u003d this.getUri().getAuthority();\n+    \n+    // Schemes and authorities must match.\n+    // Allow for null Authority for file:///\n+    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n+       (thisAuthority !\u003d null \u0026\u0026 \n+            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n+       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n+      throw new IllegalArgumentException(\"Wrong FS: \" + path + \n+                                    \", expected: \"+this.getUri());\n+    }\n+    \n+    int thisPort \u003d this.getUri().getPort();\n+    int thatPort \u003d path.toUri().getPort();\n+    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n+      thatPort \u003d this.getUriDefaultPort();\n+    }\n+    if (thisPort !\u003d thatPort) {\n+      throw new IllegalArgumentException(\"Wrong FS: \"+path+\n+                                       \", expected: \"+this.getUri());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void checkPath(Path path) {\n    URI uri \u003d path.toUri();\n    String thatScheme \u003d uri.getScheme();\n    String thatAuthority \u003d uri.getAuthority();\n    if (thatScheme \u003d\u003d null) {\n      if (thatAuthority \u003d\u003d null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new IllegalArgumentException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new IllegalArgumentException(\n            \"Path without scheme with non-null autorhrity:\" + path);\n      }\n    }\n    String thisScheme \u003d this.getUri().getScheme();\n    String thisAuthority \u003d this.getUri().getAuthority();\n    \n    // Schemes and authorities must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisAuthority !\u003d null \u0026\u0026 \n            !thisAuthority.equalsIgnoreCase(thatAuthority)) ||\n       (thisAuthority \u003d\u003d null \u0026\u0026 thatAuthority !\u003d null)) {\n      throw new IllegalArgumentException(\"Wrong FS: \" + path + \n                                    \", expected: \"+this.getUri());\n    }\n    \n    int thisPort \u003d this.getUri().getPort();\n    int thatPort \u003d path.toUri().getPort();\n    if (thatPort \u003d\u003d -1) { // -1 \u003d\u003e defaultPort of Uri scheme\n      thatPort \u003d this.getUriDefaultPort();\n    }\n    if (thisPort !\u003d thatPort) {\n      throw new IllegalArgumentException(\"Wrong FS: \"+path+\n                                       \", expected: \"+this.getUri());\n    }\n  }",
      "path": "src/java/org/apache/hadoop/fs/AbstractFileSystem.java"
    }
  }
}