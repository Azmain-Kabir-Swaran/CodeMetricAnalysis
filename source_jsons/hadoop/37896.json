{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UserGroupMappingPlacementRule.java",
  "functionName": "getPlacementForUser",
  "functionId": "getPlacementForUser___user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
  "functionStartLine": 100,
  "functionEndLine": 153,
  "numCommitsSeen": 118,
  "timeTaken": 11531,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "d312991ead37a5f840577a39420a18f0621b09dc",
    "7c5cecc3b3c00886a5bc39a9a8cad6ca1088b095",
    "621c5eac38697755cf29aa8618869c09092b6a80",
    "b7ef8a333f6717735caeee09ae4ce67bff7285e3",
    "d842dfffa53c8b565f3d65af44ccd7e1cc706733",
    "cf68857631fe12d3e3cabb53ab3029beab9457b7",
    "30b93f914b7015d4567e199c51a2ebe727fee320",
    "f0699a740666fef907db80d5ce9d06e0a9fd0e08",
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8",
    "b167d60763f4b9ac69976df2da5d988e5faa85e0",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "5468baa80aa2a3e2a02e9a902deebafd734daf23",
    "519c4be95a091a072302e9ae52c2d221d80037a8"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "d312991ead37a5f840577a39420a18f0621b09dc": "Ybodychange",
    "7c5cecc3b3c00886a5bc39a9a8cad6ca1088b095": "Ybodychange",
    "621c5eac38697755cf29aa8618869c09092b6a80": "Ybodychange",
    "b7ef8a333f6717735caeee09ae4ce67bff7285e3": "Ybodychange",
    "d842dfffa53c8b565f3d65af44ccd7e1cc706733": "Ybodychange",
    "cf68857631fe12d3e3cabb53ab3029beab9457b7": "Ybodychange",
    "30b93f914b7015d4567e199c51a2ebe727fee320": "Ybodychange",
    "f0699a740666fef907db80d5ce9d06e0a9fd0e08": "Ybodychange",
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8": "Ybodychange",
    "b167d60763f4b9ac69976df2da5d988e5faa85e0": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "5468baa80aa2a3e2a02e9a902deebafd734daf23": "Ymovefromfile",
    "519c4be95a091a072302e9ae52c2d221d80037a8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "23/03/20 5:31 AM",
      "commitNameOld": "d312991ead37a5f840577a39420a18f0621b09dc",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 1.95,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n-      if (mapping.getType() \u003d\u003d MappingType.USER) {\n+      if (mapping.getType().equals(MappingType.USER)) {\n         if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getContextForGroupParent(user, mapping,\n                 getPrimaryGroup(user));\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getContextForGroupParent(user, mapping,\n                 getSecondaryGroup(user));\n           } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n             return getContextForPrimaryGroup(user, mapping);\n           } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n             return getContextForSecondaryGroup(user, mapping);\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n \n         if (user.equals(mapping.getSource())) {\n           if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, getPrimaryGroup(user));\n           } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n-      if (mapping.getType() \u003d\u003d MappingType.GROUP) {\n+      if (mapping.getType().equals(MappingType.GROUP)) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.getSource())) {\n             if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.getType().equals(MappingType.USER)) {\n        if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getContextForGroupParent(user, mapping,\n                getPrimaryGroup(user));\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getContextForGroupParent(user, mapping,\n                getSecondaryGroup(user));\n          } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            return getContextForPrimaryGroup(user, mapping);\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            return getContextForSecondaryGroup(user, mapping);\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n\n        if (user.equals(mapping.getSource())) {\n          if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, getPrimaryGroup(user));\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.getType().equals(MappingType.GROUP)) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.getSource())) {\n            if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "d312991ead37a5f840577a39420a18f0621b09dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10198. Remove Validation of Queue Exist under Managed Parent Queue\n\nContributed by Peter Bacsko. Reviewed by Manikandan R.\n",
      "commitDate": "23/03/20 5:31 AM",
      "commitName": "d312991ead37a5f840577a39420a18f0621b09dc",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "15/01/20 12:55 AM",
      "commitNameOld": "7c5cecc3b3c00886a5bc39a9a8cad6ca1088b095",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 68.15,
      "commitsBetweenForRepo": 216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,54 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.getType() \u003d\u003d MappingType.USER) {\n         if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n-            if (this.queueManager\n-                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n-              QueueMapping queueMapping \u003d \n-                                QueueMappingBuilder.create()\n-                                    .type(mapping.getType())\n-                                    .source(mapping.getSource()).queue(user)\n-                                    .parentQueue(groups.getGroups(user).get(0))\n-                                    .build();\n-              validateQueueMapping(queueMapping);\n-              return getPlacementContext(queueMapping, user);\n-            } else {\n-              return null;\n-            }\n+            return getContextForGroupParent(user, mapping,\n+                getPrimaryGroup(user));\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n-            String secondaryGroup \u003d getSecondaryGroup(user);\n-            if (secondaryGroup !\u003d null) {\n-              QueueMapping queueMapping \u003d \n-                                QueueMappingBuilder.create()\n-                                    .type(mapping.getType())\n-                                    .source(mapping.getSource())\n-                                    .queue(user)\n-                                    .parentQueue(secondaryGroup)\n-                                    .build();\n-              validateQueueMapping(queueMapping);\n-              return getPlacementContext(queueMapping, user);\n-            } else {\n-              return null;\n-            }\n+            return getContextForGroupParent(user, mapping,\n+                getSecondaryGroup(user));\n           } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n-            if (this.queueManager\n-                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n-              return getPlacementContext(mapping,\n-                  groups.getGroups(user).get(0));\n-            } else {\n-              return null;\n-            }\n+            return getContextForPrimaryGroup(user, mapping);\n           } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n-            String secondaryGroup \u003d getSecondaryGroup(user);\n-            if (secondaryGroup !\u003d null) {\n-              return getPlacementContext(mapping, secondaryGroup);\n-            } else {\n-              return null;\n-            }\n+            return getContextForSecondaryGroup(user, mapping);\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n+\n         if (user.equals(mapping.getSource())) {\n           if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n-            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n+            return getPlacementContext(mapping, getPrimaryGroup(user));\n           } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n       if (mapping.getType() \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.getSource())) {\n             if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.getType() \u003d\u003d MappingType.USER) {\n        if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getContextForGroupParent(user, mapping,\n                getPrimaryGroup(user));\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getContextForGroupParent(user, mapping,\n                getSecondaryGroup(user));\n          } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            return getContextForPrimaryGroup(user, mapping);\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            return getContextForSecondaryGroup(user, mapping);\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n\n        if (user.equals(mapping.getSource())) {\n          if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, getPrimaryGroup(user));\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.getType() \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.getSource())) {\n            if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "7c5cecc3b3c00886a5bc39a9a8cad6ca1088b095": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9970. Refactor TestUserGroupMappingPlacementRule#verifyQueueMapping. Contributed by Manikandan R\n",
      "commitDate": "15/01/20 12:55 AM",
      "commitName": "7c5cecc3b3c00886a5bc39a9a8cad6ca1088b095",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "13/01/20 8:23 AM",
      "commitNameOld": "621c5eac38697755cf29aa8618869c09092b6a80",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,87 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n-      if (mapping.type \u003d\u003d MappingType.USER) {\n-        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n+      if (mapping.getType() \u003d\u003d MappingType.USER) {\n+        if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             if (this.queueManager\n                 .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n-              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n-                  mapping.getSource(), user, groups.getGroups(user).get(0));\n+              QueueMapping queueMapping \u003d \n+                                QueueMappingBuilder.create()\n+                                    .type(mapping.getType())\n+                                    .source(mapping.getSource()).queue(user)\n+                                    .parentQueue(groups.getGroups(user).get(0))\n+                                    .build();\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n               return null;\n             }\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n-              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n-                  mapping.getSource(), user, secondaryGroup);\n+              QueueMapping queueMapping \u003d \n+                                QueueMappingBuilder.create()\n+                                    .type(mapping.getType())\n+                                    .source(mapping.getSource())\n+                                    .queue(user)\n+                                    .parentQueue(secondaryGroup)\n+                                    .build();\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n               return null;\n             }\n-          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n+          } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n-          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n+          } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n             if (this.queueManager\n                 .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n               return getPlacementContext(mapping,\n                   groups.getGroups(user).get(0));\n             } else {\n               return null;\n             }\n-          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n+          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n-        if (user.equals(mapping.source)) {\n-          if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n+        if (user.equals(mapping.getSource())) {\n+          if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n-          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n+          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n-      if (mapping.type \u003d\u003d MappingType.GROUP) {\n+      if (mapping.getType() \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n-          if (userGroups.equals(mapping.source)) {\n-            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n+          if (userGroups.equals(mapping.getSource())) {\n+            if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.getType() \u003d\u003d MappingType.USER) {\n        if (mapping.getSource().equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              QueueMapping queueMapping \u003d \n                                QueueMappingBuilder.create()\n                                    .type(mapping.getType())\n                                    .source(mapping.getSource()).queue(user)\n                                    .parentQueue(groups.getGroups(user).get(0))\n                                    .build();\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              return null;\n            }\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              QueueMapping queueMapping \u003d \n                                QueueMappingBuilder.create()\n                                    .type(mapping.getType())\n                                    .source(mapping.getSource())\n                                    .queue(user)\n                                    .parentQueue(secondaryGroup)\n                                    .build();\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              return null;\n            }\n          } else if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              return getPlacementContext(mapping,\n                  groups.getGroups(user).get(0));\n            } else {\n              return null;\n            }\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.getSource())) {\n          if (mapping.getQueue().equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.getQueue().equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.getType() \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.getSource())) {\n            if (mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "621c5eac38697755cf29aa8618869c09092b6a80": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9912. Capacity scheduler: support u:user2:%secondary_group queue mapping. Contributed by Manikandan R\n",
      "commitDate": "13/01/20 8:23 AM",
      "commitName": "621c5eac38697755cf29aa8618869c09092b6a80",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "13/01/20 8:15 AM",
      "commitNameOld": "b7ef8a333f6717735caeee09ae4ce67bff7285e3",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,78 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             if (this.queueManager\n                 .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n               QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                   mapping.getSource(), user, groups.getGroups(user).get(0));\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n               return null;\n             }\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                   mapping.getSource(), user, secondaryGroup);\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n-                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n-              }\n               return null;\n             }\n           } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             if (this.queueManager\n                 .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n               return getPlacementContext(mapping,\n                   groups.getGroups(user).get(0));\n             } else {\n               return null;\n             }\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n-              if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"User {} is not associated with any Secondary \"\n-                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n-              }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n+          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n+            String secondaryGroup \u003d getSecondaryGroup(user);\n+            if (secondaryGroup !\u003d null) {\n+              return getPlacementContext(mapping, secondaryGroup);\n+            } else {\n+              return null;\n+            }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, groups.getGroups(user).get(0));\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              return null;\n            }\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, secondaryGroup);\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              return null;\n            }\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              return getPlacementContext(mapping,\n                  groups.getGroups(user).get(0));\n            } else {\n              return null;\n            }\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "b7ef8a333f6717735caeee09ae4ce67bff7285e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9868. Validate %primary_group queue in CS queue manager. Contributed by Manikandan R\n",
      "commitDate": "13/01/20 8:15 AM",
      "commitName": "b7ef8a333f6717735caeee09ae4ce67bff7285e3",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "12/01/20 5:04 AM",
      "commitNameOld": "d842dfffa53c8b565f3d65af44ccd7e1cc706733",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,79 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n-            QueueMapping queueMapping \u003d\n-                new QueueMapping(mapping.getType(), mapping.getSource(),\n-                    user, groups.getGroups(user).get(0));\n-            validateQueueMapping(queueMapping);\n-            return getPlacementContext(queueMapping, user);\n+            if (this.queueManager\n+                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n+              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n+                  mapping.getSource(), user, groups.getGroups(user).get(0));\n+              validateQueueMapping(queueMapping);\n+              return getPlacementContext(queueMapping, user);\n+            } else {\n+              return null;\n+            }\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                   mapping.getSource(), user, secondaryGroup);\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                     + \"Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n-            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n+            if (this.queueManager\n+                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n+              return getPlacementContext(mapping,\n+                  groups.getGroups(user).get(0));\n+            } else {\n+              return null;\n+            }\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary \"\n                     + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, groups.getGroups(user).get(0));\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              return null;\n            }\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, secondaryGroup);\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            if (this.queueManager\n                .getQueue(groups.getGroups(user).get(0)) !\u003d null) {\n              return getPlacementContext(mapping,\n                  groups.getGroups(user).get(0));\n            } else {\n              return null;\n            }\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "d842dfffa53c8b565f3d65af44ccd7e1cc706733": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9866. u:user2:%primary_group is not working as expected. Contributed by Manikandan R\n",
      "commitDate": "12/01/20 5:04 AM",
      "commitName": "d842dfffa53c8b565f3d65af44ccd7e1cc706733",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "02/01/20 12:43 AM",
      "commitNameOld": "eca7e14c2fa95ded5ae47c149f9feb953138cd5b",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.18,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,69 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             QueueMapping queueMapping \u003d\n                 new QueueMapping(mapping.getType(), mapping.getSource(),\n                     user, groups.getGroups(user).get(0));\n             validateQueueMapping(queueMapping);\n             return getPlacementContext(queueMapping, user);\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                   mapping.getSource(), user, secondaryGroup);\n               validateQueueMapping(queueMapping);\n               return getPlacementContext(queueMapping, user);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                     + \"Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary \"\n                     + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n-          return getPlacementContext(mapping);\n+          if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n+            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n+          } else {\n+            return getPlacementContext(mapping);\n+          }\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            QueueMapping queueMapping \u003d\n                new QueueMapping(mapping.getType(), mapping.getSource(),\n                    user, groups.getGroups(user).get(0));\n            validateQueueMapping(queueMapping);\n            return getPlacementContext(queueMapping, user);\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, secondaryGroup);\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "cf68857631fe12d3e3cabb53ab3029beab9457b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9938. Validate Parent Queue for QueueMapping contains dynamic group as parent queue. Contributed by Manikandan R\n",
      "commitDate": "05/12/19 12:04 PM",
      "commitName": "cf68857631fe12d3e3cabb53ab3029beab9457b7",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "24/11/19 10:28 PM",
      "commitNameOld": "f8e36e03b4e65f173bf2330715dceafdb6111190",
      "commitAuthorOld": "HUAN-PING SU",
      "daysBetweenCommits": 10.57,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n-            return getPlacementContext(\n+            QueueMapping queueMapping \u003d\n                 new QueueMapping(mapping.getType(), mapping.getSource(),\n-                    CURRENT_USER_MAPPING, groups.getGroups(user).get(0)),\n-                user);\n+                    user, groups.getGroups(user).get(0));\n+            validateQueueMapping(queueMapping);\n+            return getPlacementContext(queueMapping, user);\n           } else if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n-              return getPlacementContext(new QueueMapping(mapping.getType(),\n-                  mapping.getSource(), CURRENT_USER_MAPPING, secondaryGroup),\n-                  user);\n+              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n+                  mapping.getSource(), user, secondaryGroup);\n+              validateQueueMapping(queueMapping);\n+              return getPlacementContext(queueMapping, user);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                     + \"Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n             String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary \"\n                     + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            QueueMapping queueMapping \u003d\n                new QueueMapping(mapping.getType(), mapping.getSource(),\n                    user, groups.getGroups(user).get(0));\n            validateQueueMapping(queueMapping);\n            return getPlacementContext(queueMapping, user);\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              QueueMapping queueMapping \u003d new QueueMapping(mapping.getType(),\n                  mapping.getSource(), user, secondaryGroup);\n              validateQueueMapping(queueMapping);\n              return getPlacementContext(queueMapping, user);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "30b93f914b7015d4567e199c51a2ebe727fee320": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9865. Capacity scheduler: add support for combined %user + %secondary_group mapping. Contributed by Manikandan R\n",
      "commitDate": "11/11/19 4:28 AM",
      "commitName": "30b93f914b7015d4567e199c51a2ebe727fee320",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "18/10/19 2:19 AM",
      "commitNameOld": "f0699a740666fef907db80d5ce9d06e0a9fd0e08",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 24.13,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,63 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.getParentQueue() !\u003d null\n               \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n               \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(\n                 new QueueMapping(mapping.getType(), mapping.getSource(),\n                     CURRENT_USER_MAPPING, groups.getGroups(user).get(0)),\n                 user);\n+          } else if (mapping.getParentQueue() !\u003d null\n+              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n+              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n+            String secondaryGroup \u003d getSecondaryGroup(user);\n+            if (secondaryGroup !\u003d null) {\n+              return getPlacementContext(new QueueMapping(mapping.getType(),\n+                  mapping.getSource(), CURRENT_USER_MAPPING, secondaryGroup),\n+                  user);\n+            } else {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n+                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n+              }\n+              return null;\n+            }\n           } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n-            List\u003cString\u003e groupsList \u003d groups.getGroups(user);\n-            String secondaryGroup \u003d null;\n-            // Traverse all secondary groups (as there could be more than one\n-            // and position is not guaranteed) and ensure there is queue with\n-            // the same name\n-            for (int i \u003d 1; i \u003c groupsList.size(); i++) {\n-              if (this.queueManager.getQueue(groupsList.get(i)) !\u003d null) {\n-                secondaryGroup \u003d groupsList.get(i);\n-                break;\n-              }\n-            }\n+            String secondaryGroup \u003d getSecondaryGroup(user);\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary \"\n                     + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(\n                new QueueMapping(mapping.getType(), mapping.getSource(),\n                    CURRENT_USER_MAPPING, groups.getGroups(user).get(0)),\n                user);\n          } else if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(SECONDARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(new QueueMapping(mapping.getType(),\n                  mapping.getSource(), CURRENT_USER_MAPPING, secondaryGroup),\n                  user);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary Group. \"\n                    + \"Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            String secondaryGroup \u003d getSecondaryGroup(user);\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "f0699a740666fef907db80d5ce9d06e0a9fd0e08": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9841. Capacity scheduler: add support for combined %user + %primary_group mapping. Contributed by Manikandan R\n",
      "commitDate": "18/10/19 2:19 AM",
      "commitName": "f0699a740666fef907db80d5ce9d06e0a9fd0e08",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/10/19 8:22 AM",
      "commitNameOld": "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 2.75,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,58 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n-          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n+          if (mapping.getParentQueue() !\u003d null\n+              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n+              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n+            return getPlacementContext(\n+                new QueueMapping(mapping.getType(), mapping.getSource(),\n+                    CURRENT_USER_MAPPING, groups.getGroups(user).get(0)),\n+                user);\n+          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n             List\u003cString\u003e groupsList \u003d groups.getGroups(user);\n             String secondaryGroup \u003d null;\n             // Traverse all secondary groups (as there could be more than one\n             // and position is not guaranteed) and ensure there is queue with\n             // the same name\n             for (int i \u003d 1; i \u003c groupsList.size(); i++) {\n               if (this.queueManager.getQueue(groupsList.get(i)) !\u003d null) {\n                 secondaryGroup \u003d groupsList.get(i);\n                 break;\n               }\n             }\n             if (secondaryGroup !\u003d null) {\n               return getPlacementContext(mapping, secondaryGroup);\n             } else {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"User {} is not associated with any Secondary \"\n                     + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n               }\n               return null;\n             }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.getParentQueue() !\u003d null\n              \u0026\u0026 mapping.getParentQueue().equals(PRIMARY_GROUP_MAPPING)\n              \u0026\u0026 mapping.getQueue().equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(\n                new QueueMapping(mapping.getType(), mapping.getSource(),\n                    CURRENT_USER_MAPPING, groups.getGroups(user).get(0)),\n                user);\n          } else if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            List\u003cString\u003e groupsList \u003d groups.getGroups(user);\n            String secondaryGroup \u003d null;\n            // Traverse all secondary groups (as there could be more than one\n            // and position is not guaranteed) and ensure there is queue with\n            // the same name\n            for (int i \u003d 1; i \u003c groupsList.size(); i++) {\n              if (this.queueManager.getQueue(groupsList.get(i)) !\u003d null) {\n                secondaryGroup \u003d groupsList.get(i);\n                break;\n              }\n            }\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9840. Capacity scheduler: add support for Secondary Group rule mapping. Contributed by Manikandan R\n",
      "commitDate": "15/10/19 8:22 AM",
      "commitName": "a8ef03e96183fad0ecc53b89f1f58aaa83a92ad8",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "11/08/19 10:14 PM",
      "commitNameOld": "8fbf8b2eb09448e49297c0e93a6e10ae489e8745",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 64.42,
      "commitsBetweenForRepo": 564,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,51 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n+          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n+            List\u003cString\u003e groupsList \u003d groups.getGroups(user);\n+            String secondaryGroup \u003d null;\n+            // Traverse all secondary groups (as there could be more than one\n+            // and position is not guaranteed) and ensure there is queue with\n+            // the same name\n+            for (int i \u003d 1; i \u003c groupsList.size(); i++) {\n+              if (this.queueManager.getQueue(groupsList.get(i)) !\u003d null) {\n+                secondaryGroup \u003d groupsList.get(i);\n+                break;\n+              }\n+            }\n+            if (secondaryGroup !\u003d null) {\n+              return getPlacementContext(mapping, secondaryGroup);\n+            } else {\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"User {} is not associated with any Secondary \"\n+                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n+              }\n+              return null;\n+            }\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n               return getPlacementContext(mapping, user);\n             }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else if (mapping.queue.equals(SECONDARY_GROUP_MAPPING)) {\n            List\u003cString\u003e groupsList \u003d groups.getGroups(user);\n            String secondaryGroup \u003d null;\n            // Traverse all secondary groups (as there could be more than one\n            // and position is not guaranteed) and ensure there is queue with\n            // the same name\n            for (int i \u003d 1; i \u003c groupsList.size(); i++) {\n              if (this.queueManager.getQueue(groupsList.get(i)) !\u003d null) {\n                secondaryGroup \u003d groupsList.get(i);\n                break;\n              }\n            }\n            if (secondaryGroup !\u003d null) {\n              return getPlacementContext(mapping, secondaryGroup);\n            } else {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"User {} is not associated with any Secondary \"\n                    + \"Group. Hence it may use the \u0027default\u0027 queue\", user);\n              }\n              return null;\n            }\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "b167d60763f4b9ac69976df2da5d988e5faa85e0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7657. Queue Mapping could provide options to provide \u0027user\u0027 specific auto-created queues under a specified group parent queue. (Suma Shivaprasad via wangda)\n\nChange-Id: I32d566e8727840e43c0d66e39a77edef017e3a83\n",
      "commitDate": "13/03/18 5:55 PM",
      "commitName": "b167d60763f4b9ac69976df2da5d988e5faa85e0",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/12/17 9:19 AM",
      "commitNameOld": "cb87e4dc927731e32b0bbcf678bb5600835ff28d",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 90.32,
      "commitsBetweenForRepo": 559,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,30 @@\n   private ApplicationPlacementContext getPlacementForUser(String user)\n       throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else {\n             return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n+            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n+              return getPlacementContext(mapping, user);\n+            }\n             return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n              return getPlacementContext(mapping, user);\n            }\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
          "commitDate": "16/11/17 11:25 AM",
          "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/09/15 12:39 AM",
          "commitNameOld": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 793.49,
          "commitsBetweenForRepo": 5440,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,27 @@\n-  private String getMappedQueue(String user) throws IOException {\n+  private ApplicationPlacementContext getPlacementForUser(String user)\n+      throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n-            return user;\n+            return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n-            return groups.getGroups(user).get(0);\n+            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n-          return mapping.queue;\n+          return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "getMappedQueue",
            "newValue": "getPlacementForUser"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
          "commitDate": "16/11/17 11:25 AM",
          "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/09/15 12:39 AM",
          "commitNameOld": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 793.49,
          "commitsBetweenForRepo": 5440,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,27 @@\n-  private String getMappedQueue(String user) throws IOException {\n+  private ApplicationPlacementContext getPlacementForUser(String user)\n+      throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n-            return user;\n+            return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n-            return groups.getGroups(user).get(0);\n+            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n-          return mapping.queue;\n+          return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {
            "oldValue": "String",
            "newValue": "ApplicationPlacementContext"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
          "commitDate": "16/11/17 11:25 AM",
          "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/09/15 12:39 AM",
          "commitNameOld": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 793.49,
          "commitsBetweenForRepo": 5440,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,26 +1,27 @@\n-  private String getMappedQueue(String user) throws IOException {\n+  private ApplicationPlacementContext getPlacementForUser(String user)\n+      throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n-            return user;\n+            return getPlacementContext(mapping, user);\n           } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n-            return groups.getGroups(user).get(0);\n+            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n           } else {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n         if (user.equals(mapping.source)) {\n-          return mapping.queue;\n+          return getPlacementContext(mapping);\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n-            return mapping.queue;\n+            return getPlacementContext(mapping);\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ApplicationPlacementContext getPlacementForUser(String user)\n      throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return getPlacementContext(mapping, user);\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return getPlacementContext(mapping, groups.getGroups(user).get(0));\n          } else {\n            return getPlacementContext(mapping);\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return getPlacementContext(mapping);\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            return getPlacementContext(mapping);\n          }\n        }\n      }\n    }\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
          "extendedDetails": {}
        }
      ]
    },
    "5468baa80aa2a3e2a02e9a902deebafd734daf23": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-3635. Refactored current queue mapping implementation in CapacityScheduler to use a generic PlacementManager framework. Contributed by Wangda Tan\n",
      "commitDate": "15/09/15 12:39 AM",
      "commitName": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
      "commitAuthor": "Jian He",
      "commitDateOld": "14/09/15 8:26 PM",
      "commitNameOld": "d777757d21c15942275bff6bb98876637950d73f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,26 @@\n   private String getMappedQueue(String user) throws IOException {\n     for (QueueMapping mapping : mappings) {\n       if (mapping.type \u003d\u003d MappingType.USER) {\n         if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n           if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n             return user;\n-          }\n-          else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n+          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n             return groups.getGroups(user).get(0);\n-          }\n-          else {\n+          } else {\n             return mapping.queue;\n           }\n         }\n         if (user.equals(mapping.source)) {\n           return mapping.queue;\n         }\n       }\n       if (mapping.type \u003d\u003d MappingType.GROUP) {\n         for (String userGroups : groups.getGroups(user)) {\n           if (userGroups.equals(mapping.source)) {\n             return mapping.queue;\n           }\n         }\n       }\n     }\n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String getMappedQueue(String user) throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return user;\n          } else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return groups.getGroups(user).get(0);\n          } else {\n            return mapping.queue;\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return mapping.queue;\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            return mapping.queue;\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/placement/UserGroupMappingPlacementRule.java",
        "oldMethodName": "getMappedQueue",
        "newMethodName": "getMappedQueue"
      }
    },
    "519c4be95a091a072302e9ae52c2d221d80037a8": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2411. Support simple user and group mappings to queues. Contributed by Ram Venkatesh\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/14 11:08 PM",
      "commitName": "519c4be95a091a072302e9ae52c2d221d80037a8",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,28 @@\n+  private String getMappedQueue(String user) throws IOException {\n+    for (QueueMapping mapping : mappings) {\n+      if (mapping.type \u003d\u003d MappingType.USER) {\n+        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n+          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n+            return user;\n+          }\n+          else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n+            return groups.getGroups(user).get(0);\n+          }\n+          else {\n+            return mapping.queue;\n+          }\n+        }\n+        if (user.equals(mapping.source)) {\n+          return mapping.queue;\n+        }\n+      }\n+      if (mapping.type \u003d\u003d MappingType.GROUP) {\n+        for (String userGroups : groups.getGroups(user)) {\n+          if (userGroups.equals(mapping.source)) {\n+            return mapping.queue;\n+          }\n+        }\n+      }\n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private String getMappedQueue(String user) throws IOException {\n    for (QueueMapping mapping : mappings) {\n      if (mapping.type \u003d\u003d MappingType.USER) {\n        if (mapping.source.equals(CURRENT_USER_MAPPING)) {\n          if (mapping.queue.equals(CURRENT_USER_MAPPING)) {\n            return user;\n          }\n          else if (mapping.queue.equals(PRIMARY_GROUP_MAPPING)) {\n            return groups.getGroups(user).get(0);\n          }\n          else {\n            return mapping.queue;\n          }\n        }\n        if (user.equals(mapping.source)) {\n          return mapping.queue;\n        }\n      }\n      if (mapping.type \u003d\u003d MappingType.GROUP) {\n        for (String userGroups : groups.getGroups(user)) {\n          if (userGroups.equals(mapping.source)) {\n            return mapping.queue;\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}