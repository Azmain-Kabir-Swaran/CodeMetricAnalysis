{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationCLI.java",
  "functionName": "run",
  "functionId": "run___args-String[]",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
  "functionStartLine": 146,
  "functionEndLine": 227,
  "numCommitsSeen": 72,
  "timeTaken": 9755,
  "changeHistory": [
    "206e6339469ca6d362382efbb488089ece830e98",
    "ca90b2480ecb9a627914e7a463b6293024ad6e4d",
    "7dc272199ffea28c8597151e17d4606928a7f9f3",
    "27ffec7ba77ba3d0b88b97b34aca5356e2e258f4",
    "4c465f5535054dad2ef0b18128fb115129f6939e",
    "913f87dada27776c539dfb352400ecf8d40e7943",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
    "121865c3f96166e2190ed54b433ebcf8d053b91c",
    "8d3b39de89809f5eed06f85f00ab223e2f75e49c",
    "4a7369b09547a78f532af66c763c6994a38b5d68",
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
    "a72cdcc47a1b3a4fcadbc9e12bd1bae2bbf04d83",
    "53f2768926700d2a27ce6223f1ccbfd3be49fc29",
    "ba7ed7b66a48c61086ea837f39ff0f22ffe31eca",
    "e297be74ed4c4334bf48dd01d3b10e302147041d",
    "eb0a483ed07399c7a06ed9db4bfbec382de470da",
    "143c59e4c5a811eb2c12cf6626d558f9b8796e03",
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
    "e91e8b711c68273460b36557fc37fdfc86be097b",
    "8f58f742aea87b2b46b9741ffeaebfa36af3573f",
    "a0bca2b5ad2344fda5411d910a3730c85f12a0df",
    "8f08532bde153811368e1b8336446fba4743f9d2",
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "fae3e8614f4f9a42904e39c51ca68b0d1e67469f",
    "874cc955e0f501e8093c82e09fc0e44eb1a48908",
    "240b4e9a7f16ccd309967771108a671d16dbc1aa",
    "c79cc3a3140e390eb40eb4b3ba89fff5d4ecd5ee",
    "a8c780d378df86aafba09751c0c43dd4e0d54c0a",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
    "6d100eb79409cbca70a22ada705dedf6658545e3",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
    "331b1123fbb892524ecb58e551c20befd26c9ea9"
  ],
  "changeHistoryShort": {
    "206e6339469ca6d362382efbb488089ece830e98": "Ybodychange",
    "ca90b2480ecb9a627914e7a463b6293024ad6e4d": "Ybodychange",
    "7dc272199ffea28c8597151e17d4606928a7f9f3": "Ybodychange",
    "27ffec7ba77ba3d0b88b97b34aca5356e2e258f4": "Ybodychange",
    "4c465f5535054dad2ef0b18128fb115129f6939e": "Ybodychange",
    "913f87dada27776c539dfb352400ecf8d40e7943": "Ybodychange",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": "Ybodychange",
    "121865c3f96166e2190ed54b433ebcf8d053b91c": "Ybodychange",
    "8d3b39de89809f5eed06f85f00ab223e2f75e49c": "Ybodychange",
    "4a7369b09547a78f532af66c763c6994a38b5d68": "Ybodychange",
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d": "Ybodychange",
    "a72cdcc47a1b3a4fcadbc9e12bd1bae2bbf04d83": "Ybodychange",
    "53f2768926700d2a27ce6223f1ccbfd3be49fc29": "Ybodychange",
    "ba7ed7b66a48c61086ea837f39ff0f22ffe31eca": "Ybodychange",
    "e297be74ed4c4334bf48dd01d3b10e302147041d": "Ybodychange",
    "eb0a483ed07399c7a06ed9db4bfbec382de470da": "Ybodychange",
    "143c59e4c5a811eb2c12cf6626d558f9b8796e03": "Ybodychange",
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": "Ybodychange",
    "e91e8b711c68273460b36557fc37fdfc86be097b": "Ybodychange",
    "8f58f742aea87b2b46b9741ffeaebfa36af3573f": "Ybodychange",
    "a0bca2b5ad2344fda5411d910a3730c85f12a0df": "Ybodychange",
    "8f08532bde153811368e1b8336446fba4743f9d2": "Ybodychange",
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1": "Ybodychange",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "fae3e8614f4f9a42904e39c51ca68b0d1e67469f": "Ybodychange",
    "874cc955e0f501e8093c82e09fc0e44eb1a48908": "Ybodychange",
    "240b4e9a7f16ccd309967771108a671d16dbc1aa": "Ybodychange",
    "c79cc3a3140e390eb40eb4b3ba89fff5d4ecd5ee": "Ybodychange",
    "a8c780d378df86aafba09751c0c43dd4e0d54c0a": "Ybodychange",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": "Ybodychange",
    "6d100eb79409cbca70a22ada705dedf6658545e3": "Ybodychange",
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": "Ybodychange",
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae": "Ybodychange",
    "331b1123fbb892524ecb58e551c20befd26c9ea9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "206e6339469ca6d362382efbb488089ece830e98": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9453. Clean up code long if-else chain in ApplicationCLI#run. Contributed by Wanqiang Ji.\n",
      "commitDate": "13/05/19 11:11 AM",
      "commitName": "206e6339469ca6d362382efbb488089ece830e98",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "25/02/19 11:45 AM",
      "commitNameOld": "95372657fc25c02399b01793833021ccf88dada2",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 76.93,
      "commitsBetweenForRepo": 525,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,630 +1,82 @@\n   public int run(String[] args) throws Exception {\n+    int exitCode \u003d -1;\n+\n+    // Prepare the command\u0027s title and options\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n-    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n-        .equalsIgnoreCase(APP))) {\n+    if (APPLICATION.equalsIgnoreCase(title) || APP.equalsIgnoreCase(title)) {\n       title \u003d APPLICATION;\n-      opts.addOption(STATUS_CMD, true,\n-          \"Prints the status of the application. If app ID is\"\n-              + \" provided, it prints the generic YARN application status.\"\n-              + \" If name is provided, it prints the application specific\"\n-              + \" status based on app\u0027s own implementation, and -appTypes\"\n-              + \" option must be specified unless it is the default\"\n-              + \" yarn-service type.\");\n-      opts.addOption(LIST_CMD, false, \"List applications. \"\n-          + \"Supports optional use of -appTypes to filter applications \"\n-          + \"based on application type, -appStates to filter applications \"\n-          + \"based on application state and -appTags to filter applications \"\n-          + \"based on application tag.\");\n-      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n-          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n-      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n-          + \" specify which queue to move an application to.\");\n-      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n-          + \"filter applications based on \"\n-          + \"input comma-separated list of application types.\");\n-      appTypeOpt.setValueSeparator(\u0027,\u0027);\n-      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n-      appTypeOpt.setArgName(\"Types\");\n-      opts.addOption(appTypeOpt);\n-      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n-          + \"to filter applications based on input comma-separated list of \"\n-          + \"application states. \" + getAllValidApplicationStates());\n-      appStateOpt.setValueSeparator(\u0027,\u0027);\n-      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n-      appStateOpt.setArgName(\"States\");\n-      opts.addOption(appStateOpt);\n-      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n-          + \"filter applications based on input comma-separated list of \"\n-          + \"application tags.\");\n-      appTagOpt.setValueSeparator(\u0027,\u0027);\n-      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n-      appTagOpt.setArgName(\"Tags\");\n-      opts.addOption(appTagOpt);\n-      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n-      opts.addOption(UPDATE_PRIORITY, true,\n-          \"update priority of an application. ApplicationId can be\"\n-              + \" passed using \u0027appId\u0027 option.\");\n-      opts.addOption(UPDATE_LIFETIME, true,\n-          \"update timeout of an application from NOW. ApplicationId can be\"\n-              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n-      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n-          \"Moves application to a new queue. ApplicationId can be\"\n-              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n-              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n-              + \" functionality.\");\n-      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n-          + \"Set of applications can be provided separated with space\");\n-      killOpt.setValueSeparator(\u0027 \u0027);\n-      killOpt.setArgs(Option.UNLIMITED_VALUES);\n-      killOpt.setArgName(\"Application ID\");\n-      opts.addOption(killOpt);\n-      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n-      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n-      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n-      opts.getOption(APP_ID).setArgName(\"Application ID\");\n-      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n-      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n-      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n-      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n-          \"specification file (saves specification and starts application). \" +\n-          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n-          \" the values provided in the file. Supports -appTypes option to \" +\n-          \"specify which client implementation to use.\");\n-      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n-          \"started again later). If name is provided, appType must be \" +\n-          \"provided unless it is the default yarn-service. If ID is provided,\" +\n-          \" the appType will be looked up. Supports -appTypes option to \" +\n-          \"specify which client implementation to use.\");\n-      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n-          \"application. Supports -appTypes option to specify which client \" +\n-          \"implementation to use.\");\n-      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n-          \"an application. Options -updateLifetime and -changeQueue can be \" +\n-          \"specified to alter the values provided in the file. Supports \" +\n-          \"-appTypes option to specify which client implementation to use.\");\n-      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n-          \"specification and removes all application data permanently. \" +\n-          \"Supports -appTypes option to specify which client implementation \" +\n-          \"to use.\");\n-      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n-          \"running containers for a component of an application / \" +\n-          \"long-running service. Requires -component option. If name is \" +\n-          \"provided, appType must be provided unless it is the default \" +\n-          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n-          \"Supports -appTypes option to specify which client implementation \" +\n-          \"to use.\");\n-      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n-          \"instances for an application / long-running service. Requires \" +\n-          \"-instances option. Supports -appTypes option to specify which \" +\n-          \"client implementation to use.\");\n-      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n-          \"the number of components/containers running for an application / \" +\n-          \"long-running service. Supports absolute or relative changes, such \" +\n-          \"as +1, 2, or -3.\");\n-      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n-          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n-          \"to specify which client implementation to use. Optionally a \" +\n-          \"destination folder for the tarball can be specified.\");\n-      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n-          \"running service. It requires either -initiate, -instances, or \" +\n-          \"-finalize options.\");\n-      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n-          \"perform express upgrade.  It requires the upgraded application \" +\n-          \"specification file.\");\n-      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n-          \"initiate the application upgrade. It requires the upgraded \" +\n-          \"application specification file.\");\n-      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n-          \"trigger the upgrade of specified component instances of the \" +\n-          \"application. Also works with -decommission option to decommission \" +\n-          \"specified component instances. Multiple instances should be \" +\n-          \"separated by commas.\");\n-      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n-          \"trigger the upgrade of specified components of the application. \" +\n-          \"Multiple components should be separated by commas.\");\n-      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n-          \"finalize the upgrade.\");\n-      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n-          \"-initiate options to initiate the upgrade of the application with \" +\n-          \"the ability to finalize the upgrade automatically.\");\n-      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n-          \"cancel current upgrade.\");\n-      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n-          + \"By default, it will take default cluster id from the RM\");\n-      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n-      opts.getOption(LAUNCH_CMD).setArgs(2);\n-      opts.getOption(START_CMD).setArgName(\"Application Name\");\n-      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n-      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n-      opts.getOption(SAVE_CMD).setArgs(2);\n-      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n-      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n-      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n-      opts.getOption(COMPONENT).setArgs(2);\n-      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n-      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n-      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n-      opts.getOption(UPGRADE_CMD).setArgs(1);\n-      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n-      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n-      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n-      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n-      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n-      opts.getOption(COMPONENTS).setArgName(\"Components\");\n-      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n-      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n-      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n-      opts.getOption(DECOMMISSION).setArgs(1);\n-      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n-    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-      opts.addOption(STATUS_CMD, true,\n-          \"Prints the status of the application attempt.\");\n-      opts.addOption(LIST_CMD, true,\n-          \"List application attempts for application.\");\n-      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n-      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n-          + \"By default, it will take default cluster id from the RM\");\n-      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n-      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n-      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n-      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n-    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n-      opts.addOption(SHELL_CMD, true,\n-          \"Run a shell in the container.\");\n-      opts.addOption(STATUS_CMD, true,\n-          \"Prints the status of the container.\");\n-      opts.addOption(LIST_CMD, true,\n-          \"List containers for application attempt when application \" +\n-          \"attempt ID is provided. When application name is provided, \" +\n-          \"then it finds the instances of the application based on app\u0027s \" +\n-          \"own implementation, and -appTypes option must be specified \" +\n-          \"unless it is the default yarn-service type. With app name, it \" +\n-          \"supports optional use of -version to filter instances based on \" +\n-          \"app version, -components to filter instances based on component \" +\n-          \"names, -states to filter instances based on instance state.\");\n-      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-      opts.getOption(SHELL_CMD).setArgName(\"Container ID [bash|sh]\");\n-      opts.getOption(SHELL_CMD).setArgs(3);\n-      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n-      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n-      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n-          \"specify the app type when application name is provided.\");\n-      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n-      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n-      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n-\n-      opts.addOption(VERSION, true, \"Works with -list \"\n-          + \"to filter instances based on input application version.\");\n-      opts.getOption(VERSION).setArgs(1);\n-\n-      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n-          \"filter instances based on input comma-separated list of \" +\n-          \"component names.\");\n-      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n-      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n-\n-      opts.addOption(STATES, true, \"Works with -list to \" +\n-          \"filter instances based on input comma-separated list of \" +\n-          \"instance states.\");\n-      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n-      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n-\n-      opts.addOption(SIGNAL_CMD, true,\n-          \"Signal the container. The available signal commands are \" +\n-          java.util.Arrays.asList(SignalContainerCommand.values()) +\n-          \" Default command is OUTPUT_THREAD_DUMP.\");\n-      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n-      opts.getOption(SIGNAL_CMD).setArgs(3);\n-      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n-          + \"By default, it will take default cluster id from the RM\");\n-      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n+      addApplicationOptions(opts);\n+    } else if (APPLICATION_ATTEMPT.equalsIgnoreCase(title)) {\n+      addApplicationAttemptOptions(opts);\n+    } else if (CONTAINER.equalsIgnoreCase(title)) {\n+      addContainerOptions(opts);\n     }\n \n-    int exitCode \u003d -1;\n-    CommandLine cliParser \u003d null;\n-    try {\n-      cliParser \u003d new GnuParser().parse(opts, args);\n-    } catch (MissingArgumentException ex) {\n-      sysout.println(\"Missing argument for options\");\n+    // Create CLI Parser\n+    CommandLine cliParser \u003d createCLIParser(opts, args);\n+    if (cliParser \u003d\u003d null) {\n       printUsage(title, opts);\n       return exitCode;\n     }\n-    String[] unparsedArgs \u003d cliParser.getArgs();\n-    if (firstArg \u003d\u003d null) {\n-      if (unparsedArgs.length !\u003d 1) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-    } else {\n-      if (unparsedArgs.length !\u003d 0) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-    }\n \n+    // Create and start YarnClient\n     if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n       String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n       getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n     }\n     createAndStartYarnClient();\n \n+    // Execute command\n     if (cliParser.hasOption(STATUS_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      if (title.equalsIgnoreCase(APPLICATION) ||\n-          title.equalsIgnoreCase(APP)) {\n-        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n-        try {\n-          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n-          ApplicationId.fromString(appIdOrName);\n-          exitCode \u003d printApplicationReport(appIdOrName);\n-        } catch (IllegalArgumentException e) {\n-          // not appId format, it could be appName.\n-          // Print app specific report, if app-type is not provided,\n-          // assume it is yarn-service type.\n-          AppAdminClient client \u003d AppAdminClient\n-              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n-                  getConf());\n-          try {\n-            sysout.println(client.getStatusString(appIdOrName));\n-            exitCode \u003d 0;\n-          } catch (ApplicationNotFoundException exception) {\n-            System.err.println(\"Application with name \u0027\" + appIdOrName\n-                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n-            return -1;\n-          } catch (Exception ie) {\n-            System.err.println(ie.getMessage());\n-            return -1;\n-          }\n-        }\n-      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-        exitCode \u003d printApplicationAttemptReport(cliParser\n-            .getOptionValue(STATUS_CMD));\n-      } else if (title.equalsIgnoreCase(CONTAINER)) {\n-        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n-      }\n-      return exitCode;\n+      return executeStatusCommand(cliParser, title, opts);\n     } else if (cliParser.hasOption(LIST_CMD)) {\n-      if (title.equalsIgnoreCase(APPLICATION) ||\n-          title.equalsIgnoreCase(APP)) {\n-        allAppStates \u003d false;\n-        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n-        if (cliParser.hasOption(APP_TYPE_CMD)) {\n-          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n-          if (types !\u003d null) {\n-            for (String type : types) {\n-              if (!type.trim().isEmpty()) {\n-                appTypes.add(StringUtils.toUpperCase(type).trim());\n-              }\n-            }\n-          }\n-        }\n-\n-        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n-            .noneOf(YarnApplicationState.class);\n-        if (cliParser.hasOption(APP_STATE_CMD)) {\n-          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n-          if (states !\u003d null) {\n-            for (String state : states) {\n-              if (!state.trim().isEmpty()) {\n-                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n-                  allAppStates \u003d true;\n-                  break;\n-                }\n-                try {\n-                  appStates.add(YarnApplicationState.valueOf(\n-                      StringUtils.toUpperCase(state).trim()));\n-                } catch (IllegalArgumentException ex) {\n-                  sysout.println(\"The application state \" + state\n-                      + \" is invalid.\");\n-                  sysout.println(getAllValidApplicationStates());\n-                  return exitCode;\n-                }\n-              }\n-            }\n-          }\n-        }\n-\n-        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n-        if (cliParser.hasOption(APP_TAG_CMD)) {\n-          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n-          if (tags !\u003d null) {\n-            for (String tag : tags) {\n-              if (!tag.trim().isEmpty()) {\n-                appTags.add(tag.trim());\n-              }\n-            }\n-          }\n-        }\n-        listApplications(appTypes, appStates, appTags);\n-      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n-      } else if (title.equalsIgnoreCase(CONTAINER)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n-            VERSION, COMPONENTS, STATES)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n-        try {\n-          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n-          ApplicationAttemptId.fromString(appAttemptIdOrName);\n-          listContainers(appAttemptIdOrName);\n-        } catch (IllegalArgumentException e) {\n-          // not appAttemptId format, it could be appName. If app-type is not\n-          // provided, assume it is yarn-service type.\n-          AppAdminClient client \u003d AppAdminClient\n-              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n-                  getConf());\n-          String version \u003d cliParser.getOptionValue(VERSION);\n-          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n-          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n-          try {\n-            sysout.println(client.getInstances(appAttemptIdOrName,\n-                components \u003d\u003d null ? null : Arrays.asList(components),\n-                version, instanceStates \u003d\u003d null ? null :\n-                    Arrays.asList(instanceStates)));\n-            return 0;\n-          } catch (ApplicationNotFoundException exception) {\n-            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n-                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n-            return -1;\n-          } catch (Exception ex) {\n-            System.err.println(ex.getMessage());\n-            return -1;\n-          }\n-        }\n-      }\n+      return executeListCommand(cliParser, title, opts);\n     } else if (cliParser.hasOption(KILL_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      return killApplication(cliParser.getOptionValues(KILL_CMD));\n+      return executeKillCommand(cliParser, title, opts);\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n-      if (!cliParser.hasOption(QUEUE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n-          cliParser.getOptionValue(QUEUE_CMD));\n+      return executeMoveToQueueCommand(cliParser, title, opts);\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n-      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n+      return executeFailCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n+      return executeUpdatePriorityCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n+      return executeSignalCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(SHELL_CMD)) {\n+      return executeShellCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n+      return executeLaunchCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(STOP_CMD)) {\n+      return executeStopCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(START_CMD)) {\n+      return executeStartCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(SAVE_CMD)) {\n+      return executeSaveCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(DESTROY_CMD)) {\n+      return executeDestroyCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(FLEX_CMD)) {\n+      return executeFlexCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n+      return executeEnableFastLaunchCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n+      return executeUpdateLifeTimeCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n+      return executeChangeApplicationQueueCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n+      return executeUpgradeCommand(cliParser, title, opts);\n+    } else if (cliParser.hasOption(DECOMMISSION)) {\n+      return executeDecommissionCommand(cliParser, title, opts);\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n-    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n-      if (!cliParser.hasOption(APP_ID)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n-          cliParser.getOptionValue(UPDATE_PRIORITY));\n-    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n-      final String containerId \u003d signalArgs[0];\n-      SignalContainerCommand command \u003d\n-          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n-      if (signalArgs.length \u003d\u003d 2) {\n-        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n-      }\n-      signalToContainer(containerId, command);\n-    } else if (cliParser.hasOption(SHELL_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n-      final String containerId \u003d shellArgs[0];\n-      ShellContainerCommand command \u003d\n-          ShellContainerCommand.BASH;\n-      if (shellArgs.length \u003d\u003d 2) {\n-        command \u003d ShellContainerCommand.valueOf(shellArgs[1].toUpperCase());\n-      }\n-      shellToContainer(containerId, command);\n-    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n-          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      Long lifetime \u003d null;\n-      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n-        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n-      }\n-      String queue \u003d null;\n-      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n-        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n-      }\n-      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n-      return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n-    } else if (cliParser.hasOption(STOP_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n-      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n-          .actionStop(appNameAndType[0]);\n-    } else if (cliParser.hasOption(START_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .actionStart(cliParser.getOptionValue(START_CMD));\n-    } else if (cliParser.hasOption(SAVE_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n-          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      Long lifetime \u003d null;\n-      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n-        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n-      }\n-      String queue \u003d null;\n-      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n-        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n-      }\n-      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n-      return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n-    } else if (cliParser.hasOption(DESTROY_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n-    } else if (cliParser.hasOption(FLEX_CMD)) {\n-      if (!cliParser.hasOption(COMPONENT) ||\n-          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n-              APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n-      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n-      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n-        counts.put(rawCounts[i], rawCounts[i+1]);\n-      }\n-      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n-      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n-          .actionFlex(appNameAndType[0], counts);\n-    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      String uploadDestinationFolder \u003d cliParser\n-          .getOptionValue(ENABLE_FAST_LAUNCH);\n-      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n-          APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .enableFastLaunch(uploadDestinationFolder);\n-    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n-      if (!cliParser.hasOption(APP_ID)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-\n-      long timeoutInSec \u003d\n-          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n-\n-      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n-          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n-    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n-      if (!cliParser.hasOption(APP_ID)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n-          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n-    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n-          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n-          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n-      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n-          getConf());\n-      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n-      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n-        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n-        if (!file.exists()) {\n-          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n-          return exitCode;\n-        }\n-        return client.actionUpgradeExpress(appName, file);\n-      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n-            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n-        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n-          return client.initiateUpgrade(appName, fileName, true);\n-        } else {\n-          return client.initiateUpgrade(appName, fileName, false);\n-        }\n-      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n-            COMPONENT_INSTS, APP_TYPE_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n-        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n-      } else if (cliParser.hasOption(COMPONENTS)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n-            COMPONENTS, APP_TYPE_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n-        return client.actionUpgradeComponents(appName,\n-            Arrays.asList(components));\n-      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n-            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        return client.actionStart(appName);\n-      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n-            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n-          printUsage(title, opts);\n-          return exitCode;\n-        }\n-        return client.actionCancelUpgrade(appName);\n-      }\n-    } else if (cliParser.hasOption(DECOMMISSION)) {\n-      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n-          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n-              APP_TYPE_CMD)) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n-      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n-      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n-          .actionDecommissionInstances(appNameAndType[0],\n-              Arrays.asList(instances));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    int exitCode \u003d -1;\n\n    // Prepare the command\u0027s title and options\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (APPLICATION.equalsIgnoreCase(title) || APP.equalsIgnoreCase(title)) {\n      title \u003d APPLICATION;\n      addApplicationOptions(opts);\n    } else if (APPLICATION_ATTEMPT.equalsIgnoreCase(title)) {\n      addApplicationAttemptOptions(opts);\n    } else if (CONTAINER.equalsIgnoreCase(title)) {\n      addContainerOptions(opts);\n    }\n\n    // Create CLI Parser\n    CommandLine cliParser \u003d createCLIParser(opts, args);\n    if (cliParser \u003d\u003d null) {\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    // Create and start YarnClient\n    if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n      String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n      getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n    }\n    createAndStartYarnClient();\n\n    // Execute command\n    if (cliParser.hasOption(STATUS_CMD)) {\n      return executeStatusCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      return executeListCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      return executeKillCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      return executeMoveToQueueCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      return executeFailCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      return executeUpdatePriorityCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      return executeSignalCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(SHELL_CMD)) {\n      return executeShellCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      return executeLaunchCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      return executeStopCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(START_CMD)) {\n      return executeStartCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      return executeSaveCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      return executeDestroyCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      return executeFlexCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      return executeEnableFastLaunchCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      return executeUpdateLifeTimeCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      return executeChangeApplicationQueueCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      return executeUpgradeCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(DECOMMISSION)) {\n      return executeDecommissionCommand(cliParser, title, opts);\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "ca90b2480ecb9a627914e7a463b6293024ad6e4d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9032. Support sh shell for interactive container shell at command line. Contributed by Eric Yang\n",
      "commitDate": "14/12/18 2:08 PM",
      "commitName": "ca90b2480ecb9a627914e7a463b6293024ad6e4d",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "28/11/18 12:42 AM",
      "commitNameOld": "7dc272199ffea28c8597151e17d4606928a7f9f3",
      "commitAuthorOld": "Suma Shivaprasad",
      "daysBetweenCommits": 16.56,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,629 +1,630 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n           \"instances for an application / long-running service. Requires \" +\n           \"-instances option. Supports -appTypes option to specify which \" +\n           \"client implementation to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n           \"perform express upgrade.  It requires the upgraded application \" +\n           \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application. Also works with -decommission option to decommission \" +\n           \"specified component instances. Multiple instances should be \" +\n           \"separated by commas.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application. \" +\n           \"Multiple components should be separated by commas.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n           \"cancel current upgrade.\");\n       opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n           + \"By default, it will take default cluster id from the RM\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n       opts.getOption(DECOMMISSION).setArgs(1);\n       opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n           + \"By default, it will take default cluster id from the RM\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(SHELL_CMD, true,\n           \"Run a shell in the container.\");\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-      opts.getOption(SHELL_CMD).setArgName(\"Container ID\");\n+      opts.getOption(SHELL_CMD).setArgName(\"Container ID [bash|sh]\");\n+      opts.getOption(SHELL_CMD).setArgs(3);\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n       opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n           + \"By default, it will take default cluster id from the RM\");\n       opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n       String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n       getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n     }\n     createAndStartYarnClient();\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(SHELL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n       final String containerId \u003d shellArgs[0];\n       ShellContainerCommand command \u003d\n           ShellContainerCommand.BASH;\n       if (shellArgs.length \u003d\u003d 2) {\n-        command \u003d ShellContainerCommand.valueOf(shellArgs[1]);\n+        command \u003d ShellContainerCommand.valueOf(shellArgs[1].toUpperCase());\n       }\n       shellToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n           UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n           UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n         File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n         if (!file.exists()) {\n           System.err.println(file.getAbsolutePath() + \" does not exist.\");\n           return exitCode;\n         }\n         return client.actionUpgradeExpress(appName, file);\n       } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_CANCEL, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionCancelUpgrade(appName);\n       }\n     } else if (cliParser.hasOption(DECOMMISSION)) {\n       if (!cliParser.hasOption(COMPONENT_INSTS) ||\n           hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionDecommissionInstances(appNameAndType[0],\n               Arrays.asList(instances));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n          \"instances for an application / long-running service. Requires \" +\n          \"-instances option. Supports -appTypes option to specify which \" +\n          \"client implementation to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application. Also works with -decommission option to decommission \" +\n          \"specified component instances. Multiple instances should be \" +\n          \"separated by commas.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application. \" +\n          \"Multiple components should be separated by commas.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n          \"cancel current upgrade.\");\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n      opts.getOption(DECOMMISSION).setArgs(1);\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(SHELL_CMD, true,\n          \"Run a shell in the container.\");\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(SHELL_CMD).setArgName(\"Container ID [bash|sh]\");\n      opts.getOption(SHELL_CMD).setArgs(3);\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n      String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n      getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n    }\n    createAndStartYarnClient();\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(SHELL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n      final String containerId \u003d shellArgs[0];\n      ShellContainerCommand command \u003d\n          ShellContainerCommand.BASH;\n      if (shellArgs.length \u003d\u003d 2) {\n        command \u003d ShellContainerCommand.valueOf(shellArgs[1].toUpperCase());\n      }\n      shellToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionCancelUpgrade(appName);\n      }\n    } else if (cliParser.hasOption(DECOMMISSION)) {\n      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionDecommissionInstances(appNameAndType[0],\n              Arrays.asList(instances));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "7dc272199ffea28c8597151e17d4606928a7f9f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9034. ApplicationCLI should have option to take clusterId. Contributed by Rohith Sharma K S.\n",
      "commitDate": "28/11/18 12:42 AM",
      "commitName": "7dc272199ffea28c8597151e17d4606928a7f9f3",
      "commitAuthor": "Suma Shivaprasad",
      "commitDateOld": "19/11/18 5:59 PM",
      "commitNameOld": "27ffec7ba77ba3d0b88b97b34aca5356e2e258f4",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 8.28,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,614 +1,629 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n           \"instances for an application / long-running service. Requires \" +\n           \"-instances option. Supports -appTypes option to specify which \" +\n           \"client implementation to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n           \"perform express upgrade.  It requires the upgraded application \" +\n           \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application. Also works with -decommission option to decommission \" +\n           \"specified component instances. Multiple instances should be \" +\n           \"separated by commas.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application. \" +\n           \"Multiple components should be separated by commas.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n           \"cancel current upgrade.\");\n+      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n+          + \"By default, it will take default cluster id from the RM\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n       opts.getOption(DECOMMISSION).setArgs(1);\n+      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n+          + \"By default, it will take default cluster id from the RM\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n+      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(SHELL_CMD, true,\n           \"Run a shell in the container.\");\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(SHELL_CMD).setArgName(\"Container ID\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n+      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n+          + \"By default, it will take default cluster id from the RM\");\n+      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n+    if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n+      String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n+      getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n+    }\n+    createAndStartYarnClient();\n+\n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(SHELL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n       final String containerId \u003d shellArgs[0];\n       ShellContainerCommand command \u003d\n           ShellContainerCommand.BASH;\n       if (shellArgs.length \u003d\u003d 2) {\n         command \u003d ShellContainerCommand.valueOf(shellArgs[1]);\n       }\n       shellToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n           UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n           UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n         File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n         if (!file.exists()) {\n           System.err.println(file.getAbsolutePath() + \" does not exist.\");\n           return exitCode;\n         }\n         return client.actionUpgradeExpress(appName, file);\n       } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_CANCEL, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionCancelUpgrade(appName);\n       }\n     } else if (cliParser.hasOption(DECOMMISSION)) {\n       if (!cliParser.hasOption(COMPONENT_INSTS) ||\n           hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionDecommissionInstances(appNameAndType[0],\n               Arrays.asList(instances));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n          \"instances for an application / long-running service. Requires \" +\n          \"-instances option. Supports -appTypes option to specify which \" +\n          \"client implementation to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application. Also works with -decommission option to decommission \" +\n          \"specified component instances. Multiple instances should be \" +\n          \"separated by commas.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application. \" +\n          \"Multiple components should be separated by commas.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n          \"cancel current upgrade.\");\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n      opts.getOption(DECOMMISSION).setArgs(1);\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(SHELL_CMD, true,\n          \"Run a shell in the container.\");\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(SHELL_CMD).setArgName(\"Container ID\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n      opts.addOption(CLUSTER_ID_OPTION, true, \"ClusterId. \"\n          + \"By default, it will take default cluster id from the RM\");\n      opts.getOption(CLUSTER_ID_OPTION).setArgName(\"Cluster ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(CLUSTER_ID_OPTION)) {\n      String clusterIdStr \u003d cliParser.getOptionValue(CLUSTER_ID_OPTION);\n      getConf().set(YarnConfiguration.RM_CLUSTER_ID, clusterIdStr);\n    }\n    createAndStartYarnClient();\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(SHELL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n      final String containerId \u003d shellArgs[0];\n      ShellContainerCommand command \u003d\n          ShellContainerCommand.BASH;\n      if (shellArgs.length \u003d\u003d 2) {\n        command \u003d ShellContainerCommand.valueOf(shellArgs[1]);\n      }\n      shellToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionCancelUpgrade(appName);\n      }\n    } else if (cliParser.hasOption(DECOMMISSION)) {\n      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionDecommissionInstances(appNameAndType[0],\n              Arrays.asList(instances));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "27ffec7ba77ba3d0b88b97b34aca5356e2e258f4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8778. Add command line interface to invoke interactive docker shell. Contributed by Eric Yang\n",
      "commitDate": "19/11/18 5:59 PM",
      "commitName": "27ffec7ba77ba3d0b88b97b34aca5356e2e258f4",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "12/11/18 4:53 PM",
      "commitNameOld": "4c465f5535054dad2ef0b18128fb115129f6939e",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,598 +1,614 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n           \"instances for an application / long-running service. Requires \" +\n           \"-instances option. Supports -appTypes option to specify which \" +\n           \"client implementation to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n           \"perform express upgrade.  It requires the upgraded application \" +\n           \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application. Also works with -decommission option to decommission \" +\n           \"specified component instances. Multiple instances should be \" +\n           \"separated by commas.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application. \" +\n           \"Multiple components should be separated by commas.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n           \"cancel current upgrade.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n       opts.getOption(DECOMMISSION).setArgs(1);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n+      opts.addOption(SHELL_CMD, true,\n+          \"Run a shell in the container.\");\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+      opts.getOption(SHELL_CMD).setArgName(\"Container ID\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n+    } else if (cliParser.hasOption(SHELL_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n+      final String containerId \u003d shellArgs[0];\n+      ShellContainerCommand command \u003d\n+          ShellContainerCommand.BASH;\n+      if (shellArgs.length \u003d\u003d 2) {\n+        command \u003d ShellContainerCommand.valueOf(shellArgs[1]);\n+      }\n+      shellToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n           UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n           UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n         File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n         if (!file.exists()) {\n           System.err.println(file.getAbsolutePath() + \" does not exist.\");\n           return exitCode;\n         }\n         return client.actionUpgradeExpress(appName, file);\n       } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_CANCEL, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionCancelUpgrade(appName);\n       }\n     } else if (cliParser.hasOption(DECOMMISSION)) {\n       if (!cliParser.hasOption(COMPONENT_INSTS) ||\n           hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionDecommissionInstances(appNameAndType[0],\n               Arrays.asList(instances));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n          \"instances for an application / long-running service. Requires \" +\n          \"-instances option. Supports -appTypes option to specify which \" +\n          \"client implementation to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application. Also works with -decommission option to decommission \" +\n          \"specified component instances. Multiple instances should be \" +\n          \"separated by commas.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application. \" +\n          \"Multiple components should be separated by commas.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n          \"cancel current upgrade.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n      opts.getOption(DECOMMISSION).setArgs(1);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(SHELL_CMD, true,\n          \"Run a shell in the container.\");\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(SHELL_CMD).setArgName(\"Container ID\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(SHELL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SHELL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] shellArgs \u003d cliParser.getOptionValues(SHELL_CMD);\n      final String containerId \u003d shellArgs[0];\n      ShellContainerCommand command \u003d\n          ShellContainerCommand.BASH;\n      if (shellArgs.length \u003d\u003d 2) {\n        command \u003d ShellContainerCommand.valueOf(shellArgs[1]);\n      }\n      shellToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionCancelUpgrade(appName);\n      }\n    } else if (cliParser.hasOption(DECOMMISSION)) {\n      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionDecommissionInstances(appNameAndType[0],\n              Arrays.asList(instances));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "4c465f5535054dad2ef0b18128fb115129f6939e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8761. Service AM support for decommissioning component instances.\n           Contributed by Billie Rinaldi\n",
      "commitDate": "12/11/18 4:53 PM",
      "commitName": "4c465f5535054dad2ef0b18128fb115129f6939e",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "26/09/18 11:51 AM",
      "commitNameOld": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 47.25,
      "commitsBetweenForRepo": 418,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,577 +1,598 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n+      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n+          \"instances for an application / long-running service. Requires \" +\n+          \"-instances option. Supports -appTypes option to specify which \" +\n+          \"client implementation to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n           \"perform express upgrade.  It requires the upgraded application \" +\n           \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n-          \"application.\");\n+          \"application. Also works with -decommission option to decommission \" +\n+          \"specified component instances. Multiple instances should be \" +\n+          \"separated by commas.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n-          \"trigger the upgrade of specified components of the application.\");\n+          \"trigger the upgrade of specified components of the application. \" +\n+          \"Multiple components should be separated by commas.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n           \"cancel current upgrade.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n+      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n+      opts.getOption(DECOMMISSION).setArgs(1);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n           UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n           UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n         File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n         if (!file.exists()) {\n           System.err.println(file.getAbsolutePath() + \" does not exist.\");\n           return exitCode;\n         }\n         return client.actionUpgradeExpress(appName, file);\n       } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_CANCEL, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionCancelUpgrade(appName);\n       }\n+    } else if (cliParser.hasOption(DECOMMISSION)) {\n+      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n+          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n+              APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n+      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n+      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n+          .actionDecommissionInstances(appNameAndType[0],\n+              Arrays.asList(instances));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(DECOMMISSION, true, \"Decommissions component \" +\n          \"instances for an application / long-running service. Requires \" +\n          \"-instances option. Supports -appTypes option to specify which \" +\n          \"client implementation to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application. Also works with -decommission option to decommission \" +\n          \"specified component instances. Multiple instances should be \" +\n          \"separated by commas.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application. \" +\n          \"Multiple components should be separated by commas.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n          \"cancel current upgrade.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(DECOMMISSION).setArgName(\"Application Name\");\n      opts.getOption(DECOMMISSION).setArgs(1);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionCancelUpgrade(appName);\n      }\n    } else if (cliParser.hasOption(DECOMMISSION)) {\n      if (!cliParser.hasOption(COMPONENT_INSTS) ||\n          hasAnyOtherCLIOptions(cliParser, opts, DECOMMISSION, COMPONENT_INSTS,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, DECOMMISSION);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionDecommissionInstances(appNameAndType[0],\n              Arrays.asList(instances));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "913f87dada27776c539dfb352400ecf8d40e7943": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8665.  Added Yarn service cancel upgrade option.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/09/18 11:51 AM",
      "commitName": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "21/08/18 4:49 PM",
      "commitNameOld": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 35.79,
      "commitsBetweenForRepo": 332,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,568 +1,577 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n           \"perform express upgrade.  It requires the upgraded application \" +\n           \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n+      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n+          \"cancel current upgrade.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n           UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n-          COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n+          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n         File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n         if (!file.exists()) {\n           System.err.println(file.getAbsolutePath() + \" does not exist.\");\n           return exitCode;\n         }\n         return client.actionUpgradeExpress(appName, file);\n       } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n+      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n+            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        return client.actionCancelUpgrade(appName);\n       }\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.addOption(UPGRADE_CANCEL, false, \"Works with -upgrade option to \" +\n          \"cancel current upgrade.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          UPGRADE_CANCEL, COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      } else if (cliParser.hasOption(UPGRADE_CANCEL)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_CANCEL, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionCancelUpgrade(appName);\n      }\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8298.  Added express upgrade for YARN service.\n            Contributed by Chandni Singh\n",
      "commitDate": "21/08/18 4:49 PM",
      "commitName": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "08/08/18 10:12 AM",
      "commitNameOld": "ff06bd1be83a2a6d2ee39cb002e91499720a7243",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,558 +1,568 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n+      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n+          \"perform express upgrade.  It requires the upgraded application \" +\n+          \"specification file.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt when application \" +\n           \"attempt ID is provided. When application name is provided, \" +\n           \"then it finds the instances of the application based on app\u0027s \" +\n           \"own implementation, and -appTypes option must be specified \" +\n           \"unless it is the default yarn-service type. With app name, it \" +\n           \"supports optional use of -version to filter instances based on \" +\n           \"app version, -components to filter instances based on component \" +\n           \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n       opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n           \"specify the app type when application name is provided.\");\n       opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n       opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n \n       opts.addOption(VERSION, true, \"Works with -list \"\n           + \"to filter instances based on input application version.\");\n       opts.getOption(VERSION).setArgs(1);\n \n       opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"component names.\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(STATES, true, \"Works with -list to \" +\n           \"filter instances based on input comma-separated list of \" +\n           \"instance states.\");\n       opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n       opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n \n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n             VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n         try {\n           // try parsing attempt id, if it succeeds, it means it\u0027s appId\n           ApplicationAttemptId.fromString(appAttemptIdOrName);\n           listContainers(appAttemptIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appAttemptId format, it could be appName. If app-type is not\n           // provided, assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           String version \u003d cliParser.getOptionValue(VERSION);\n           String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n           String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n           try {\n             sysout.println(client.getInstances(appAttemptIdOrName,\n                 components \u003d\u003d null ? null : Arrays.asList(components),\n                 version, instanceStates \u003d\u003d null ? null :\n                     Arrays.asList(instanceStates)));\n             return 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ex) {\n             System.err.println(ex.getMessage());\n             return -1;\n           }\n         }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n-          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS, COMPONENTS,\n-          APP_TYPE_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n+          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n+          COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n-      if (cliParser.hasOption(UPGRADE_INITIATE)) {\n+      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n+        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n+        if (!file.exists()) {\n+          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n+          return exitCode;\n+        }\n+        return client.actionUpgradeExpress(appName, file);\n+      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       }\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_EXPRESS, true, \"Works with -upgrade option to \" +\n          \"perform express upgrade.  It requires the upgraded application \" +\n          \"specification file.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_EXPRESS,\n          UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE,\n          COMPONENT_INSTS, COMPONENTS, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_EXPRESS)) {\n        File file \u003d new File(cliParser.getOptionValue(UPGRADE_EXPRESS));\n        if (!file.exists()) {\n          System.err.println(file.getAbsolutePath() + \" does not exist.\");\n          return exitCode;\n        }\n        return client.actionUpgradeExpress(appName, file);\n      } else if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      }\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "121865c3f96166e2190ed54b433ebcf8d053b91c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8299.  Added CLI and REST API for query container status.\n            Contributed by Chandni Singh\n",
      "commitDate": "16/07/18 2:41 PM",
      "commitName": "121865c3f96166e2190ed54b433ebcf8d053b91c",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "15/05/18 5:40 PM",
      "commitNameOld": "8d3b39de89809f5eed06f85f00ab223e2f75e49c",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 61.88,
      "commitsBetweenForRepo": 439,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,500 +1,558 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application.\");\n       opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified components of the application.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n       opts.getOption(COMPONENTS).setArgName(\"Components\");\n       opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n-          \"List containers for application attempt.\");\n+          \"List containers for application attempt when application \" +\n+          \"attempt ID is provided. When application name is provided, \" +\n+          \"then it finds the instances of the application based on app\u0027s \" +\n+          \"own implementation, and -appTypes option must be specified \" +\n+          \"unless it is the default yarn-service type. With app name, it \" +\n+          \"supports optional use of -version to filter instances based on \" +\n+          \"app version, -components to filter instances based on component \" +\n+          \"names, -states to filter instances based on instance state.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n-      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n+      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n+      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n+          \"specify the app type when application name is provided.\");\n+      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n+      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n+      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n+\n+      opts.addOption(VERSION, true, \"Works with -list \"\n+          + \"to filter instances based on input application version.\");\n+      opts.getOption(VERSION).setArgs(1);\n+\n+      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n+          \"filter instances based on input comma-separated list of \" +\n+          \"component names.\");\n+      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n+      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n+\n+      opts.addOption(STATES, true, \"Works with -list to \" +\n+          \"filter instances based on input comma-separated list of \" +\n+          \"instance states.\");\n+      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n+      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n+\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n-        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n+            VERSION, COMPONENTS, STATES)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n-        listContainers(cliParser.getOptionValue(LIST_CMD));\n+        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n+        try {\n+          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n+          ApplicationAttemptId.fromString(appAttemptIdOrName);\n+          listContainers(appAttemptIdOrName);\n+        } catch (IllegalArgumentException e) {\n+          // not appAttemptId format, it could be appName. If app-type is not\n+          // provided, assume it is yarn-service type.\n+          AppAdminClient client \u003d AppAdminClient\n+              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n+                  getConf());\n+          String version \u003d cliParser.getOptionValue(VERSION);\n+          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n+          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n+          try {\n+            sysout.println(client.getInstances(appAttemptIdOrName,\n+                components \u003d\u003d null ? null : Arrays.asList(components),\n+                version, instanceStates \u003d\u003d null ? null :\n+                    Arrays.asList(instanceStates)));\n+            return 0;\n+          } catch (ApplicationNotFoundException exception) {\n+            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n+                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n+            return -1;\n+          } catch (Exception ex) {\n+            System.err.println(ex.getMessage());\n+            return -1;\n+          }\n+        }\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n           UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS, COMPONENTS,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n       } else if (cliParser.hasOption(COMPONENTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n         return client.actionUpgradeComponents(appName,\n             Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       }\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt when application \" +\n          \"attempt ID is provided. When application name is provided, \" +\n          \"then it finds the instances of the application based on app\u0027s \" +\n          \"own implementation, and -appTypes option must be specified \" +\n          \"unless it is the default yarn-service type. With app name, it \" +\n          \"supports optional use of -version to filter instances based on \" +\n          \"app version, -components to filter instances based on component \" +\n          \"names, -states to filter instances based on instance state.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Name or Attempt ID\");\n      opts.addOption(APP_TYPE_CMD, true, \"Works with -list to \" +\n          \"specify the app type when application name is provided.\");\n      opts.getOption(APP_TYPE_CMD).setValueSeparator(\u0027,\u0027);\n      opts.getOption(APP_TYPE_CMD).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(APP_TYPE_CMD).setArgName(\"Types\");\n\n      opts.addOption(VERSION, true, \"Works with -list \"\n          + \"to filter instances based on input application version.\");\n      opts.getOption(VERSION).setArgs(1);\n\n      opts.addOption(COMPONENTS, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"component names.\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(STATES, true, \"Works with -list to \" +\n          \"filter instances based on input comma-separated list of \" +\n          \"instance states.\");\n      opts.getOption(STATES).setValueSeparator(\u0027,\u0027);\n      opts.getOption(STATES).setArgs(Option.UNLIMITED_VALUES);\n\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD, APP_TYPE_CMD,\n            VERSION, COMPONENTS, STATES)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String appAttemptIdOrName \u003d cliParser.getOptionValue(LIST_CMD);\n        try {\n          // try parsing attempt id, if it succeeds, it means it\u0027s appId\n          ApplicationAttemptId.fromString(appAttemptIdOrName);\n          listContainers(appAttemptIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appAttemptId format, it could be appName. If app-type is not\n          // provided, assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          String version \u003d cliParser.getOptionValue(VERSION);\n          String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n          String[] instanceStates \u003d cliParser.getOptionValues(STATES);\n          try {\n            sysout.println(client.getInstances(appAttemptIdOrName,\n                components \u003d\u003d null ? null : Arrays.asList(components),\n                version, instanceStates \u003d\u003d null ? null :\n                    Arrays.asList(instanceStates)));\n            return 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appAttemptIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n            return -1;\n          }\n        }\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS, COMPONENTS,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      }\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "8d3b39de89809f5eed06f85f00ab223e2f75e49c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8081.  Add support to upgrade a component.\n            Contributed by Chandni Singh\n",
      "commitDate": "15/05/18 5:40 PM",
      "commitName": "8d3b39de89809f5eed06f85f00ab223e2f75e49c",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "26/04/18 1:54 PM",
      "commitNameOld": "4a7369b09547a78f532af66c763c6994a38b5d68",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 19.16,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,486 +1,500 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n           \"running service. It requires either -initiate, -instances, or \" +\n           \"-finalize options.\");\n       opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n           \"initiate the application upgrade. It requires the upgraded \" +\n           \"application specification file.\");\n       opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n           \"trigger the upgrade of specified component instances of the \" +\n           \"application.\");\n+      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n+          \"trigger the upgrade of specified components of the application.\");\n       opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n           \"finalize the upgrade.\");\n       opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n           \"-initiate options to initiate the upgrade of the application with \" +\n           \"the ability to finalize the upgrade automatically.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n       opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n       opts.getOption(UPGRADE_CMD).setArgs(1);\n       opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n       opts.getOption(UPGRADE_INITIATE).setArgs(1);\n       opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n       opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n       opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n+      opts.getOption(COMPONENTS).setArgName(\"Components\");\n+      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n+      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(UPGRADE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n-          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS,\n+          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS, COMPONENTS,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n           getConf());\n       String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n       if (cliParser.hasOption(UPGRADE_INITIATE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n         if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n           return client.initiateUpgrade(appName, fileName, true);\n         } else {\n           return client.initiateUpgrade(appName, fileName, false);\n         }\n       } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             COMPONENT_INSTS, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n         return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n+      } else if (cliParser.hasOption(COMPONENTS)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n+            COMPONENTS, APP_TYPE_CMD)) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n+        return client.actionUpgradeComponents(appName,\n+            Arrays.asList(components));\n       } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n             UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         return client.actionStart(appName);\n       }\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application.\");\n      opts.addOption(COMPONENTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified components of the application.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n      opts.getOption(COMPONENTS).setArgName(\"Components\");\n      opts.getOption(COMPONENTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENTS).setArgs(Option.UNLIMITED_VALUES);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS, COMPONENTS,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(COMPONENTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] components \u003d cliParser.getOptionValues(COMPONENTS);\n        return client.actionUpgradeComponents(appName,\n            Arrays.asList(components));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      }\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "4a7369b09547a78f532af66c763c6994a38b5d68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7939.  Added support to upgrade a component instance.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "4a7369b09547a78f532af66c763c6994a38b5d68",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "23/01/18 5:54 PM",
      "commitNameOld": "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 92.79,
      "commitsBetweenForRepo": 1260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,426 +1,486 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n+      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n+          \"running service. It requires either -initiate, -instances, or \" +\n+          \"-finalize options.\");\n+      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n+          \"initiate the application upgrade. It requires the upgraded \" +\n+          \"application specification file.\");\n+      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n+          \"trigger the upgrade of specified component instances of the \" +\n+          \"application.\");\n+      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n+          \"finalize the upgrade.\");\n+      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n+          \"-initiate options to initiate the upgrade of the application with \" +\n+          \"the ability to finalize the upgrade automatically.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n+      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n+      opts.getOption(UPGRADE_CMD).setArgs(1);\n+      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n+      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n+      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n+      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n+      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           } catch (Exception ie) {\n             System.err.println(ie.getMessage());\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n+    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n+          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS,\n+          APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n+          getConf());\n+      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n+      if (cliParser.hasOption(UPGRADE_INITIATE)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n+            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n+        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n+          return client.initiateUpgrade(appName, fileName, true);\n+        } else {\n+          return client.initiateUpgrade(appName, fileName, false);\n+        }\n+      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n+            COMPONENT_INSTS, APP_TYPE_CMD)) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n+        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n+      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n+            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        return client.actionStart(appName);\n+      }\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.addOption(UPGRADE_CMD, true, \"Upgrades an application/long-\" +\n          \"running service. It requires either -initiate, -instances, or \" +\n          \"-finalize options.\");\n      opts.addOption(UPGRADE_INITIATE, true, \"Works with -upgrade option to \" +\n          \"initiate the application upgrade. It requires the upgraded \" +\n          \"application specification file.\");\n      opts.addOption(COMPONENT_INSTS, true, \"Works with -upgrade option to \" +\n          \"trigger the upgrade of specified component instances of the \" +\n          \"application.\");\n      opts.addOption(UPGRADE_FINALIZE, false, \"Works with -upgrade option to \" +\n          \"finalize the upgrade.\");\n      opts.addOption(UPGRADE_AUTO_FINALIZE, false, \"Works with -upgrade and \" +\n          \"-initiate options to initiate the upgrade of the application with \" +\n          \"the ability to finalize the upgrade automatically.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n      opts.getOption(UPGRADE_CMD).setArgName(\"Application Name\");\n      opts.getOption(UPGRADE_CMD).setArgs(1);\n      opts.getOption(UPGRADE_INITIATE).setArgName(\"File Name\");\n      opts.getOption(UPGRADE_INITIATE).setArgs(1);\n      opts.getOption(COMPONENT_INSTS).setArgName(\"Component Instances\");\n      opts.getOption(COMPONENT_INSTS).setValueSeparator(\u0027,\u0027);\n      opts.getOption(COMPONENT_INSTS).setArgs(Option.UNLIMITED_VALUES);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(UPGRADE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD, UPGRADE_INITIATE,\n          UPGRADE_AUTO_FINALIZE, UPGRADE_FINALIZE, COMPONENT_INSTS,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      AppAdminClient client \u003d  AppAdminClient.createAppAdminClient(appType,\n          getConf());\n      String appName \u003d cliParser.getOptionValue(UPGRADE_CMD);\n      if (cliParser.hasOption(UPGRADE_INITIATE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_INITIATE, UPGRADE_AUTO_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String fileName \u003d cliParser.getOptionValue(UPGRADE_INITIATE);\n        if (cliParser.hasOption(UPGRADE_AUTO_FINALIZE)) {\n          return client.initiateUpgrade(appName, fileName, true);\n        } else {\n          return client.initiateUpgrade(appName, fileName, false);\n        }\n      } else if (cliParser.hasOption(COMPONENT_INSTS)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            COMPONENT_INSTS, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        String[] instances \u003d cliParser.getOptionValues(COMPONENT_INSTS);\n        return client.actionUpgradeInstances(appName, Arrays.asList(instances));\n      } else if (cliParser.hasOption(UPGRADE_FINALIZE)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, UPGRADE_CMD,\n            UPGRADE_FINALIZE, APP_TYPE_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        return client.actionStart(appName);\n      }\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7540 and YARN-7605. Convert yarn app cli to call yarn api services and implement doAs for Api Service REST API. Contributed by Eric Yang and Jian He\n",
      "commitDate": "23/01/18 5:54 PM",
      "commitName": "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "23/01/18 10:53 AM",
      "commitNameOld": "a72cdcc47a1b3a4fcadbc9e12bd1bae2bbf04d83",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,423 +1,426 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster. Supports -appTypes option \" +\n           \"to specify which client implementation to use. Optionally a \" +\n           \"destination folder for the tarball can be specified.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n       opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n       opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n+          } catch (Exception ie) {\n+            System.err.println(ie.getMessage());\n+            return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       String uploadDestinationFolder \u003d cliParser\n           .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          } catch (Exception ie) {\n            System.err.println(ie.getMessage());\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "a72cdcc47a1b3a4fcadbc9e12bd1bae2bbf04d83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7766. Introduce a new config property for YARN Service dependency tarball location. Contributed by Gour Saha\n",
      "commitDate": "23/01/18 10:53 AM",
      "commitName": "a72cdcc47a1b3a4fcadbc9e12bd1bae2bbf04d83",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/01/18 3:33 PM",
      "commitNameOld": "53f2768926700d2a27ce6223f1ccbfd3be49fc29",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 10.81,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,418 +1,423 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application. If app ID is\"\n               + \" provided, it prints the generic YARN application status.\"\n               + \" If name is provided, it prints the application specific\"\n               + \" status based on app\u0027s own implementation, and -appTypes\"\n               + \" option must be specified unless it is the default\"\n               + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n-      opts.addOption(ENABLE_FAST_LAUNCH, false, \"Uploads AM dependencies \" +\n-          \"to HDFS to make future launches faster.  Supports -appTypes option\" +\n-          \" to specify which client implementation to use.\");\n+      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n+          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n+          \"to specify which client implementation to use. Optionally a \" +\n+          \"destination folder for the tarball can be specified.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n+      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n+      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n         try {\n           // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n           ApplicationId.fromString(appIdOrName);\n           exitCode \u003d printApplicationReport(appIdOrName);\n         } catch (IllegalArgumentException e) {\n           // not appId format, it could be appName.\n           // Print app specific report, if app-type is not provided,\n           // assume it is yarn-service type.\n           AppAdminClient client \u003d AppAdminClient\n               .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                   getConf());\n           try {\n             sysout.println(client.getStatusString(appIdOrName));\n             exitCode \u003d 0;\n           } catch (ApplicationNotFoundException exception) {\n             System.err.println(\"Application with name \u0027\" + appIdOrName\n                 + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n             return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      String uploadDestinationFolder \u003d cliParser\n+          .getOptionValue(ENABLE_FAST_LAUNCH);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n-          .enableFastLaunch();\n+          .enableFastLaunch(uploadDestinationFolder);\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, true, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster. Supports -appTypes option \" +\n          \"to specify which client implementation to use. Optionally a \" +\n          \"destination folder for the tarball can be specified.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n      opts.getOption(ENABLE_FAST_LAUNCH).setOptionalArg(true);\n      opts.getOption(ENABLE_FAST_LAUNCH).setArgName(\"Destination Folder\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      String uploadDestinationFolder \u003d cliParser\n          .getOptionValue(ENABLE_FAST_LAUNCH);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch(uploadDestinationFolder);\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "53f2768926700d2a27ce6223f1ccbfd3be49fc29": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7724. yarn application status should support application name. Contributed by Jian He\n",
      "commitDate": "12/01/18 3:33 PM",
      "commitName": "53f2768926700d2a27ce6223f1ccbfd3be49fc29",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "ba7ed7b66a48c61086ea837f39ff0f22ffe31eca",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 67.09,
      "commitsBetweenForRepo": 364,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,409 +1,418 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (firstArg !\u003d null) {\n       title \u003d firstArg;\n     } else if (args.length \u003e 0) {\n       title \u003d args[0];\n     }\n     if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n         .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n-          \"Prints the status of the application.\");\n+          \"Prints the status of the application. If app ID is\"\n+              + \" provided, it prints the generic YARN application status.\"\n+              + \" If name is provided, it prints the application specific\"\n+              + \" status based on app\u0027s own implementation, and -appTypes\"\n+              + \" option must be specified unless it is the default\"\n+              + \" yarn-service type.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n-      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n+      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n       opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n           \"specification file (saves specification and starts application). \" +\n           \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n           \" the values provided in the file. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n           \"started again later). If name is provided, appType must be \" +\n           \"provided unless it is the default yarn-service. If ID is provided,\" +\n           \" the appType will be looked up. Supports -appTypes option to \" +\n           \"specify which client implementation to use.\");\n       opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n           \"application. Supports -appTypes option to specify which client \" +\n           \"implementation to use.\");\n       opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n           \"an application. Options -updateLifetime and -changeQueue can be \" +\n           \"specified to alter the values provided in the file. Supports \" +\n           \"-appTypes option to specify which client implementation to use.\");\n       opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n           \"specification and removes all application data permanently. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n           \"running containers for a component of an application / \" +\n           \"long-running service. Requires -component option. If name is \" +\n           \"provided, appType must be provided unless it is the default \" +\n           \"yarn-service. If ID is provided, the appType will be looked up. \" +\n           \"Supports -appTypes option to specify which client implementation \" +\n           \"to use.\");\n       opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n           \"the number of components/containers running for an application / \" +\n           \"long-running service. Supports absolute or relative changes, such \" +\n           \"as +1, 2, or -3.\");\n       opts.addOption(ENABLE_FAST_LAUNCH, false, \"Uploads AM dependencies \" +\n           \"to HDFS to make future launches faster.  Supports -appTypes option\" +\n           \" to specify which client implementation to use.\");\n       opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(LAUNCH_CMD).setArgs(2);\n       opts.getOption(START_CMD).setArgName(\"Application Name\");\n       opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n       opts.getOption(SAVE_CMD).setArgs(2);\n       opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n       opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n       opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n       opts.getOption(COMPONENT).setArgs(2);\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n     String[] unparsedArgs \u003d cliParser.getArgs();\n     if (firstArg \u003d\u003d null) {\n       if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     } else {\n       if (unparsedArgs.length !\u003d 0) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n-      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n-        ApplicationReport report \u003d printApplicationReport(cliParser\n-            .getOptionValue(STATUS_CMD));\n-        if (report \u003d\u003d null) {\n-          exitCode \u003d -1;\n-        } else {\n-          exitCode \u003d 0;\n-          String appType \u003d report.getApplicationType();\n+        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n+        try {\n+          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n+          ApplicationId.fromString(appIdOrName);\n+          exitCode \u003d printApplicationReport(appIdOrName);\n+        } catch (IllegalArgumentException e) {\n+          // not appId format, it could be appName.\n+          // Print app specific report, if app-type is not provided,\n+          // assume it is yarn-service type.\n+          AppAdminClient client \u003d AppAdminClient\n+              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n+                  getConf());\n           try {\n-            AppAdminClient client \u003d AppAdminClient.createAppAdminClient(appType,\n-                getConf());\n-            sysout.println(\"Detailed Application Status :\");\n-            sysout.println(client.getStatusString(cliParser.getOptionValue(\n-                STATUS_CMD)));\n-          } catch (IllegalArgumentException e) {\n-            // app type does not have app admin client implementation\n+            sysout.println(client.getStatusString(appIdOrName));\n+            exitCode \u003d 0;\n+          } catch (ApplicationNotFoundException exception) {\n+            System.err.println(\"Application with name \u0027\" + appIdOrName\n+                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n+            return -1;\n           }\n         }\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (title.equalsIgnoreCase(APPLICATION) ||\n           title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (title.equalsIgnoreCase(CONTAINER)) {\n         if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else if (cliParser.hasOption(LAUNCH_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(STOP_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionStop(appNameAndType[0]);\n     } else if (cliParser.hasOption(START_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionStart(cliParser.getOptionValue(START_CMD));\n     } else if (cliParser.hasOption(SAVE_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n           UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       Long lifetime \u003d null;\n       if (cliParser.hasOption(UPDATE_LIFETIME)) {\n         lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n       }\n       String queue \u003d null;\n       if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n         queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n       }\n       String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n     } else if (cliParser.hasOption(DESTROY_CMD)) {\n       if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n     } else if (cliParser.hasOption(FLEX_CMD)) {\n       if (!cliParser.hasOption(COMPONENT) ||\n           hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n               APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n       Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n       for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n         counts.put(rawCounts[i], rawCounts[i+1]);\n       }\n       String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n       return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n           .actionFlex(appNameAndType[0], counts);\n     } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n       String appType \u003d getSingleAppTypeFromCLI(cliParser);\n       if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n           APP_TYPE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return AppAdminClient.createAppAdminClient(appType, getConf())\n           .enableFastLaunch();\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application. If app ID is\"\n              + \" provided, it prints the generic YARN application status.\"\n              + \" If name is provided, it prints the application specific\"\n              + \" status based on app\u0027s own implementation, and -appTypes\"\n              + \" option must be specified unless it is the default\"\n              + \" yarn-service type.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, false, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster.  Supports -appTypes option\" +\n          \" to specify which client implementation to use.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        String appIdOrName \u003d cliParser.getOptionValue(STATUS_CMD);\n        try {\n          // try parsing appIdOrName, if it succeeds, it means it\u0027s appId\n          ApplicationId.fromString(appIdOrName);\n          exitCode \u003d printApplicationReport(appIdOrName);\n        } catch (IllegalArgumentException e) {\n          // not appId format, it could be appName.\n          // Print app specific report, if app-type is not provided,\n          // assume it is yarn-service type.\n          AppAdminClient client \u003d AppAdminClient\n              .createAppAdminClient(getSingleAppTypeFromCLI(cliParser),\n                  getConf());\n          try {\n            sysout.println(client.getStatusString(appIdOrName));\n            exitCode \u003d 0;\n          } catch (ApplicationNotFoundException exception) {\n            System.err.println(\"Application with name \u0027\" + appIdOrName\n                + \"\u0027 doesn\u0027t exist in RM or Timeline Server.\");\n            return -1;\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch();\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "ba7ed7b66a48c61086ea837f39ff0f22ffe31eca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7384. Remove apiserver cmd and merge service cmd into application cmd. Contributed by Billie Rinaldi\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "ba7ed7b66a48c61086ea837f39ff0f22ffe31eca",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 55.22,
      "commitsBetweenForRepo": 540,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,246 +1,409 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n-    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n+    if (firstArg !\u003d null) {\n+      title \u003d firstArg;\n+    } else if (args.length \u003e 0) {\n+      title \u003d args[0];\n+    }\n+    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n+        .equalsIgnoreCase(APP))) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n           \"Moves application to a new queue. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n               + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n               + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n       opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n-    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-      title \u003d APPLICATION_ATTEMPT;\n+      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n+          \"specification file (saves specification and starts application). \" +\n+          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n+          \" the values provided in the file. Supports -appTypes option to \" +\n+          \"specify which client implementation to use.\");\n+      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n+          \"started again later). If name is provided, appType must be \" +\n+          \"provided unless it is the default yarn-service. If ID is provided,\" +\n+          \" the appType will be looked up. Supports -appTypes option to \" +\n+          \"specify which client implementation to use.\");\n+      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n+          \"application. Supports -appTypes option to specify which client \" +\n+          \"implementation to use.\");\n+      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n+          \"an application. Options -updateLifetime and -changeQueue can be \" +\n+          \"specified to alter the values provided in the file. Supports \" +\n+          \"-appTypes option to specify which client implementation to use.\");\n+      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n+          \"specification and removes all application data permanently. \" +\n+          \"Supports -appTypes option to specify which client implementation \" +\n+          \"to use.\");\n+      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n+          \"running containers for a component of an application / \" +\n+          \"long-running service. Requires -component option. If name is \" +\n+          \"provided, appType must be provided unless it is the default \" +\n+          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n+          \"Supports -appTypes option to specify which client implementation \" +\n+          \"to use.\");\n+      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n+          \"the number of components/containers running for an application / \" +\n+          \"long-running service. Supports absolute or relative changes, such \" +\n+          \"as +1, 2, or -3.\");\n+      opts.addOption(ENABLE_FAST_LAUNCH, false, \"Uploads AM dependencies \" +\n+          \"to HDFS to make future launches faster.  Supports -appTypes option\" +\n+          \" to specify which client implementation to use.\");\n+      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n+      opts.getOption(LAUNCH_CMD).setArgs(2);\n+      opts.getOption(START_CMD).setArgName(\"Application Name\");\n+      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n+      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n+      opts.getOption(SAVE_CMD).setArgs(2);\n+      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n+      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n+      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n+      opts.getOption(COMPONENT).setArgs(2);\n+    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n-    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n-      title \u003d CONTAINER;\n+    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n-\n-    if (cliParser.hasOption(STATUS_CMD)) {\n-      if (args.length !\u003d 3) {\n+    String[] unparsedArgs \u003d cliParser.getArgs();\n+    if (firstArg \u003d\u003d null) {\n+      if (unparsedArgs.length !\u003d 1) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n-      if (args[0].equalsIgnoreCase(APPLICATION)) {\n-        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n-      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+    } else {\n+      if (unparsedArgs.length !\u003d 0) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+    }\n+\n+    if (cliParser.hasOption(STATUS_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      if (title.equalsIgnoreCase(APPLICATION) ||\n+          title.equalsIgnoreCase(APP)) {\n+        ApplicationReport report \u003d printApplicationReport(cliParser\n+            .getOptionValue(STATUS_CMD));\n+        if (report \u003d\u003d null) {\n+          exitCode \u003d -1;\n+        } else {\n+          exitCode \u003d 0;\n+          String appType \u003d report.getApplicationType();\n+          try {\n+            AppAdminClient client \u003d AppAdminClient.createAppAdminClient(appType,\n+                getConf());\n+            sysout.println(\"Detailed Application Status :\");\n+            sysout.println(client.getStatusString(cliParser.getOptionValue(\n+                STATUS_CMD)));\n+          } catch (IllegalArgumentException e) {\n+            // app type does not have app admin client implementation\n+          }\n+        }\n+      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n-      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n+      } else if (title.equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n-      if (args[0].equalsIgnoreCase(APPLICATION)) {\n+      if (title.equalsIgnoreCase(APPLICATION) ||\n+          title.equalsIgnoreCase(APP)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n-      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-        if (args.length !\u003d 3) {\n+      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n-      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n-        if (args.length !\u003d 3) {\n+      } else if (title.equalsIgnoreCase(CONTAINER)) {\n+        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n-      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n-      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n+    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n+      final String containerId \u003d signalArgs[0];\n+      SignalContainerCommand command \u003d\n+          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n+      if (signalArgs.length \u003d\u003d 2) {\n+        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n+      }\n+      signalToContainer(containerId, command);\n+    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n+          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      Long lifetime \u003d null;\n+      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n+        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n+      }\n+      String queue \u003d null;\n+      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n+        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n+      }\n+      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n+      return AppAdminClient.createAppAdminClient(appType, getConf())\n+          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n+    } else if (cliParser.hasOption(STOP_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n+      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n+          .actionStop(appNameAndType[0]);\n+    } else if (cliParser.hasOption(START_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      return AppAdminClient.createAppAdminClient(appType, getConf())\n+          .actionStart(cliParser.getOptionValue(START_CMD));\n+    } else if (cliParser.hasOption(SAVE_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n+          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      Long lifetime \u003d null;\n+      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n+        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n+      }\n+      String queue \u003d null;\n+      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n+        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n+      }\n+      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n+      return AppAdminClient.createAppAdminClient(appType, getConf())\n+          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n+    } else if (cliParser.hasOption(DESTROY_CMD)) {\n+      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      return AppAdminClient.createAppAdminClient(appType, getConf())\n+          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n+    } else if (cliParser.hasOption(FLEX_CMD)) {\n+      if (!cliParser.hasOption(COMPONENT) ||\n+          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n+              APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n+      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n+      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n+        counts.put(rawCounts[i], rawCounts[i+1]);\n+      }\n+      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n+      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n+          .actionFlex(appNameAndType[0], counts);\n+    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n+      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n+      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n+          APP_TYPE_CMD)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      return AppAdminClient.createAppAdminClient(appType, getConf())\n+          .enableFastLaunch();\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n-    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n-      if (args.length \u003c 3 || args.length \u003e 4) {\n-        printUsage(title, opts);\n-        return exitCode;\n-      }\n-      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n-      final String containerId \u003d signalArgs[0];\n-      SignalContainerCommand command \u003d\n-          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n-      if (signalArgs.length \u003d\u003d 2) {\n-        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n-      }\n-      signalToContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (firstArg !\u003d null) {\n      title \u003d firstArg;\n    } else if (args.length \u003e 0) {\n      title \u003d args[0];\n    }\n    if (title !\u003d null \u0026\u0026 (title.equalsIgnoreCase(APPLICATION) || title\n        .equalsIgnoreCase(APP))) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n      opts.addOption(LAUNCH_CMD, true, \"Launches application from \" +\n          \"specification file (saves specification and starts application). \" +\n          \"Options -updateLifetime and -changeQueue can be specified to alter\" +\n          \" the values provided in the file. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(STOP_CMD, true, \"Stops application gracefully (may be \" +\n          \"started again later). If name is provided, appType must be \" +\n          \"provided unless it is the default yarn-service. If ID is provided,\" +\n          \" the appType will be looked up. Supports -appTypes option to \" +\n          \"specify which client implementation to use.\");\n      opts.addOption(START_CMD, true, \"Starts a previously saved \" +\n          \"application. Supports -appTypes option to specify which client \" +\n          \"implementation to use.\");\n      opts.addOption(SAVE_CMD, true, \"Saves specification file for \" +\n          \"an application. Options -updateLifetime and -changeQueue can be \" +\n          \"specified to alter the values provided in the file. Supports \" +\n          \"-appTypes option to specify which client implementation to use.\");\n      opts.addOption(DESTROY_CMD, true, \"Destroys a saved application \" +\n          \"specification and removes all application data permanently. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(FLEX_CMD, true, \"Changes number of \" +\n          \"running containers for a component of an application / \" +\n          \"long-running service. Requires -component option. If name is \" +\n          \"provided, appType must be provided unless it is the default \" +\n          \"yarn-service. If ID is provided, the appType will be looked up. \" +\n          \"Supports -appTypes option to specify which client implementation \" +\n          \"to use.\");\n      opts.addOption(COMPONENT, true, \"Works with -flex option to change \" +\n          \"the number of components/containers running for an application / \" +\n          \"long-running service. Supports absolute or relative changes, such \" +\n          \"as +1, 2, or -3.\");\n      opts.addOption(ENABLE_FAST_LAUNCH, false, \"Uploads AM dependencies \" +\n          \"to HDFS to make future launches faster.  Supports -appTypes option\" +\n          \" to specify which client implementation to use.\");\n      opts.getOption(LAUNCH_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(LAUNCH_CMD).setArgs(2);\n      opts.getOption(START_CMD).setArgName(\"Application Name\");\n      opts.getOption(STOP_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(SAVE_CMD).setArgName(\"Application Name\u003e \u003cFile Name\");\n      opts.getOption(SAVE_CMD).setArgs(2);\n      opts.getOption(DESTROY_CMD).setArgName(\"Application Name\");\n      opts.getOption(FLEX_CMD).setArgName(\"Application Name or ID\");\n      opts.getOption(COMPONENT).setArgName(\"Component Name\u003e \u003cCount\");\n      opts.getOption(COMPONENT).setArgs(2);\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (title !\u003d null \u0026\u0026 title.equalsIgnoreCase(CONTAINER)) {\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n    String[] unparsedArgs \u003d cliParser.getArgs();\n    if (firstArg \u003d\u003d null) {\n      if (unparsedArgs.length !\u003d 1) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    } else {\n      if (unparsedArgs.length !\u003d 0) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STATUS_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        ApplicationReport report \u003d printApplicationReport(cliParser\n            .getOptionValue(STATUS_CMD));\n        if (report \u003d\u003d null) {\n          exitCode \u003d -1;\n        } else {\n          exitCode \u003d 0;\n          String appType \u003d report.getApplicationType();\n          try {\n            AppAdminClient client \u003d AppAdminClient.createAppAdminClient(appType,\n                getConf());\n            sysout.println(\"Detailed Application Status :\");\n            sysout.println(client.getStatusString(cliParser.getOptionValue(\n                STATUS_CMD)));\n          } catch (IllegalArgumentException e) {\n            // app type does not have app admin client implementation\n          }\n        }\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (title.equalsIgnoreCase(APPLICATION) ||\n          title.equalsIgnoreCase(APP)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (title.equalsIgnoreCase(CONTAINER)) {\n        if (hasAnyOtherCLIOptions(cliParser, opts, LIST_CMD)) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!title.equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SIGNAL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else if (cliParser.hasOption(LAUNCH_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, LAUNCH_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(LAUNCH_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionLaunch(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(STOP_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, STOP_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, STOP_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionStop(appNameAndType[0]);\n    } else if (cliParser.hasOption(START_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, START_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionStart(cliParser.getOptionValue(START_CMD));\n    } else if (cliParser.hasOption(SAVE_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, SAVE_CMD, APP_TYPE_CMD,\n          UPDATE_LIFETIME, CHANGE_APPLICATION_QUEUE)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      Long lifetime \u003d null;\n      if (cliParser.hasOption(UPDATE_LIFETIME)) {\n        lifetime \u003d Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n      }\n      String queue \u003d null;\n      if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n        queue \u003d cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE);\n      }\n      String[] nameAndFile \u003d cliParser.getOptionValues(SAVE_CMD);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionSave(nameAndFile[1], nameAndFile[0], lifetime, queue);\n    } else if (cliParser.hasOption(DESTROY_CMD)) {\n      if (hasAnyOtherCLIOptions(cliParser, opts, DESTROY_CMD, APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .actionDestroy(cliParser.getOptionValue(DESTROY_CMD));\n    } else if (cliParser.hasOption(FLEX_CMD)) {\n      if (!cliParser.hasOption(COMPONENT) ||\n          hasAnyOtherCLIOptions(cliParser, opts, FLEX_CMD, COMPONENT,\n              APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      String[] rawCounts \u003d cliParser.getOptionValues(COMPONENT);\n      Map\u003cString, String\u003e counts \u003d new HashMap\u003c\u003e(rawCounts.length/2);\n      for (int i \u003d 0; i \u003c rawCounts.length - 1; i+\u003d2) {\n        counts.put(rawCounts[i], rawCounts[i+1]);\n      }\n      String[] appNameAndType \u003d getAppNameAndType(cliParser, FLEX_CMD);\n      return AppAdminClient.createAppAdminClient(appNameAndType[1], getConf())\n          .actionFlex(appNameAndType[0], counts);\n    } else if (cliParser.hasOption(ENABLE_FAST_LAUNCH)) {\n      String appType \u003d getSingleAppTypeFromCLI(cliParser);\n      if (hasAnyOtherCLIOptions(cliParser, opts, ENABLE_FAST_LAUNCH,\n          APP_TYPE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return AppAdminClient.createAppAdminClient(appType, getConf())\n          .enableFastLaunch();\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "e297be74ed4c4334bf48dd01d3b10e302147041d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6001. Improve moveApplicationQueues command line. Contributed by Sunil G.\n",
      "commitDate": "27/12/16 10:46 PM",
      "commitName": "e297be74ed4c4334bf48dd01d3b10e302147041d",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "07/12/16 10:57 AM",
      "commitNameOld": "ab923a53fcf55d4d75aa027d46e3c4a659015325",
      "commitAuthorOld": "Sunil",
      "daysBetweenCommits": 20.49,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,233 +1,246 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n-          + \"different queue.\");\n+          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.addOption(UPDATE_LIFETIME, true,\n           \"update timeout of an application from NOW. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n+      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n+          \"Moves application to a new queue. ApplicationId can be\"\n+              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n+              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n+              + \" functionality.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n       opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n+      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n \n       long timeoutInSec \u003d\n           Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n \n       updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n           ApplicationTimeoutType.LIFETIME, timeoutInSec);\n+    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n+      if (!cliParser.hasOption(APP_ID)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n+          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue. Deprecated command. Use \u0027changeQueue\u0027 instead.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      opts.addOption(CHANGE_APPLICATION_QUEUE, true,\n          \"Moves application to a new queue. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. \u0027movetoqueue\u0027 command is\"\n              + \" deprecated, this new command \u0027changeQueue\u0027 performs same\"\n              + \" functionality.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n      opts.getOption(CHANGE_APPLICATION_QUEUE).setArgName(\"Queue Name\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(CHANGE_APPLICATION_QUEUE)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(CHANGE_APPLICATION_QUEUE));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "eb0a483ed07399c7a06ed9db4bfbec382de470da": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4206. Add Application timeouts in Application report and CLI. Contributed by Rohith Sharma K S.\n",
      "commitDate": "24/11/16 4:48 AM",
      "commitName": "eb0a483ed07399c7a06ed9db4bfbec382de470da",
      "commitAuthor": "Sunil",
      "commitDateOld": "10/11/16 2:35 PM",
      "commitNameOld": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 13.59,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,218 +1,233 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, -appStates to filter applications \"\n           + \"based on application state and -appTags to filter applications \"\n           + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n           + \"filter applications based on input comma-separated list of \"\n           + \"application tags.\");\n       appTagOpt.setValueSeparator(\u0027,\u0027);\n       appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTagOpt.setArgName(\"Tags\");\n       opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n+      opts.addOption(UPDATE_LIFETIME, true,\n+          \"update timeout of an application from NOW. ApplicationId can be\"\n+              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n+      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n \n         Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TAG_CMD)) {\n           String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n           if (tags !\u003d null) {\n             for (String tag : tags) {\n               if (!tag.trim().isEmpty()) {\n                 appTags.add(tag.trim());\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates, appTags);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n+    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n+      if (!cliParser.hasOption(APP_ID)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+\n+      long timeoutInSec \u003d\n+          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n+\n+      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n+          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.addOption(UPDATE_LIFETIME, true,\n          \"update timeout of an application from NOW. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option. Timeout value is in seconds.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n      opts.getOption(UPDATE_LIFETIME).setArgName(\"Timeout\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(UPDATE_LIFETIME)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n\n      long timeoutInSec \u003d\n          Long.parseLong(cliParser.getOptionValue(UPDATE_LIFETIME));\n\n      updateApplicationTimeout(cliParser.getOptionValue(APP_ID),\n          ApplicationTimeoutType.LIFETIME, timeoutInSec);\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "143c59e4c5a811eb2c12cf6626d558f9b8796e03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4491. yarn list command to support filtering by tags. Contributed by Varun Saxena\n",
      "commitDate": "23/08/16 1:23 PM",
      "commitName": "143c59e4c5a811eb2c12cf6626d558f9b8796e03",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 69.93,
      "commitsBetweenForRepo": 607,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,218 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n-          + \"based on application type, \"\n-          + \"and -appStates to filter applications based on application state.\");\n+          + \"based on application type, -appStates to filter applications \"\n+          + \"based on application state and -appTags to filter applications \"\n+          + \"based on application tag.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n+      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n+          + \"filter applications based on input comma-separated list of \"\n+          + \"application tags.\");\n+      appTagOpt.setValueSeparator(\u0027,\u0027);\n+      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n+      appTagOpt.setArgName(\"Tags\");\n+      opts.addOption(appTagOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n-        listApplications(appTypes, appStates);\n+\n+        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n+        if (cliParser.hasOption(APP_TAG_CMD)) {\n+          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n+          if (tags !\u003d null) {\n+            for (String tag : tags) {\n+              if (!tag.trim().isEmpty()) {\n+                appTags.add(tag.trim());\n+              }\n+            }\n+          }\n+        }\n+        listApplications(appTypes, appStates, appTags);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalToContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, -appStates to filter applications \"\n          + \"based on application state and -appTags to filter applications \"\n          + \"based on application tag.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      Option appTagOpt \u003d new Option(APP_TAG_CMD, true, \"Works with -list to \"\n          + \"filter applications based on input comma-separated list of \"\n          + \"application tags.\");\n      appTagOpt.setValueSeparator(\u0027,\u0027);\n      appTagOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTagOpt.setArgName(\"Tags\");\n      opts.addOption(appTagOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n\n        Set\u003cString\u003e appTags \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TAG_CMD)) {\n          String[] tags \u003d cliParser.getOptionValues(APP_TAG_CMD);\n          if (tags !\u003d null) {\n            for (String tag : tags) {\n              if (!tag.trim().isEmpty()) {\n                appTags.add(tag.trim());\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates, appTags);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5044. Have AM trigger jstack on task attempts that timeout before killing them. (Eric Payne and Gera Shegalov via mingma)\n",
      "commitDate": "06/06/16 2:30 PM",
      "commitName": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "22/01/16 1:36 PM",
      "commitNameOld": "e91e8b711c68273460b36557fc37fdfc86be097b",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 136.0,
      "commitsBetweenForRepo": 871,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,198 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n           + \"Set of applications can be provided separated with space\");\n       killOpt.setValueSeparator(\u0027 \u0027);\n       killOpt.setArgs(Option.UNLIMITED_VALUES);\n       killOpt.setArgName(\"Application ID\");\n       opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n-      signalContainer(containerId, command);\n+      signalToContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalToContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "e91e8b711c68273460b36557fc37fdfc86be097b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4371. \"yarn application -kill\" should take multiple application ids. Contributed by Sunil G\n",
      "commitDate": "22/01/16 1:36 PM",
      "commitName": "e91e8b711c68273460b36557fc37fdfc86be097b",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/01/16 2:43 AM",
      "commitNameOld": "8f58f742aea87b2b46b9741ffeaebfa36af3573f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,198 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n-      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n-      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n+      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n+          + \"Set of applications can be provided separated with space\");\n+      killOpt.setValueSeparator(\u0027 \u0027);\n+      killOpt.setArgs(Option.UNLIMITED_VALUES);\n+      killOpt.setArgName(\"Application ID\");\n+      opts.addOption(killOpt);\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n-      if (args.length !\u003d 3) {\n+      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n-      try{\n-        killApplication(cliParser.getOptionValue(KILL_CMD));\n-      } catch (ApplicationNotFoundException e) {\n-        return exitCode;\n-      }\n+      return killApplication(cliParser.getOptionValues(KILL_CMD));\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      Option killOpt \u003d new Option(KILL_CMD, true, \"Kills the application. \"\n          + \"Set of applications can be provided separated with space\");\n      killOpt.setValueSeparator(\u0027 \u0027);\n      killOpt.setArgs(Option.UNLIMITED_VALUES);\n      killOpt.setArgName(\"Application ID\");\n      opts.addOption(killOpt);\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length \u003c 3 || hasAnyOtherCLIOptions(cliParser, opts, KILL_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      return killApplication(cliParser.getOptionValues(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "8f58f742aea87b2b46b9741ffeaebfa36af3573f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4605. Spelling mistake in the help message of \"yarn applicationattempt\" command. Contributed by Weiwei Yang.\n",
      "commitDate": "22/01/16 2:43 AM",
      "commitName": "8f58f742aea87b2b46b9741ffeaebfa36af3573f",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "18/12/15 2:13 PM",
      "commitNameOld": "85c24660481f33684a42a7f6d665d3117577c780",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 34.52,
      "commitsBetweenForRepo": 189,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,198 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n-          \"List application attempts for aplication.\");\n+          \"List application attempts for application.\");\n       opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n       opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(FAIL_CMD)) {\n       if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for application.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "a0bca2b5ad2344fda5411d910a3730c85f12a0df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-261. Ability to fail AM attempts. Contributed by Andrey Klochkov and Rohith Sharma K S\n",
      "commitDate": "09/10/15 7:17 AM",
      "commitName": "a0bca2b5ad2344fda5411d910a3730c85f12a0df",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "02/10/15 6:50 PM",
      "commitNameOld": "8f08532bde153811368e1b8336446fba4743f9d2",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 6.52,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,190 +1,198 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n+      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n+      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n       opts.addOption(SIGNAL_CMD, true,\n           \"Signal the container. The available signal commands are \" +\n           java.util.Arrays.asList(SignalContainerCommand.values()) +\n           \" Default command is OUTPUT_THREAD_DUMP.\");\n       opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n       opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n+    } else if (cliParser.hasOption(FAIL_CMD)) {\n+      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else if (cliParser.hasOption(SIGNAL_CMD)) {\n       if (args.length \u003c 3 || args.length \u003e 4) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n       final String containerId \u003d signalArgs[0];\n       SignalContainerCommand command \u003d\n           SignalContainerCommand.OUTPUT_THREAD_DUMP;\n       if (signalArgs.length \u003d\u003d 2) {\n         command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n       }\n       signalContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(FAIL_CMD, true, \"Fails application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n      opts.getOption(FAIL_CMD).setArgName(\"Application Attempt ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(FAIL_CMD)) {\n      if (!args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      failApplicationAttempt(cliParser.getOptionValue(FAIL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "8f08532bde153811368e1b8336446fba4743f9d2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1897. CLI and core support for signal container functionality. Contributed by Ming Ma\n",
      "commitDate": "02/10/15 6:50 PM",
      "commitName": "8f08532bde153811368e1b8336446fba4743f9d2",
      "commitAuthor": "Xuan",
      "commitDateOld": "15/09/15 11:40 AM",
      "commitNameOld": "ae5308fe1d08479da0f3929cc6a57816411e9121",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 17.3,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,190 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n       opts.addOption(UPDATE_PRIORITY, true,\n           \"update priority of an application. ApplicationId can be\"\n               + \" passed using \u0027appId\u0027 option.\");\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n       opts.getOption(APP_ID).setArgName(\"Application ID\");\n       opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n+      opts.addOption(SIGNAL_CMD, true,\n+          \"Signal the container. The available signal commands are \" +\n+          java.util.Arrays.asList(SignalContainerCommand.values()) +\n+          \" Default command is OUTPUT_THREAD_DUMP.\");\n+      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n+      opts.getOption(SIGNAL_CMD).setArgs(3);\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n       if (!cliParser.hasOption(APP_ID)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n           cliParser.getOptionValue(UPDATE_PRIORITY));\n+    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n+      if (args.length \u003c 3 || args.length \u003e 4) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n+      final String containerId \u003d signalArgs[0];\n+      SignalContainerCommand command \u003d\n+          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n+      if (signalArgs.length \u003d\u003d 2) {\n+        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n+      }\n+      signalContainer(containerId, command);\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n      opts.addOption(SIGNAL_CMD, true,\n          \"Signal the container. The available signal commands are \" +\n          java.util.Arrays.asList(SignalContainerCommand.values()) +\n          \" Default command is OUTPUT_THREAD_DUMP.\");\n      opts.getOption(SIGNAL_CMD).setArgName(\"container ID [signal command]\");\n      opts.getOption(SIGNAL_CMD).setArgs(3);\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else if (cliParser.hasOption(SIGNAL_CMD)) {\n      if (args.length \u003c 3 || args.length \u003e 4) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      final String[] signalArgs \u003d cliParser.getOptionValues(SIGNAL_CMD);\n      final String containerId \u003d signalArgs[0];\n      SignalContainerCommand command \u003d\n          SignalContainerCommand.OUTPUT_THREAD_DUMP;\n      if (signalArgs.length \u003d\u003d 2) {\n        command \u003d SignalContainerCommand.valueOf(signalArgs[1]);\n      }\n      signalContainer(containerId, command);\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4014. Support user cli interface in for Application Priority. Contributed by Rohith Sharma K S\n",
      "commitDate": "24/08/15 8:36 PM",
      "commitName": "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/08/15 10:13 PM",
      "commitNameOld": "b6265d39c5d0fda21dfe55273f193d8a6a20c6a8",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 17.93,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,171 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n+      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n+      opts.addOption(UPDATE_PRIORITY, true,\n+          \"update priority of an application. ApplicationId can be\"\n+              + \" passed using \u0027appId\u0027 option.\");\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n+      opts.getOption(APP_ID).setArgName(\"Application ID\");\n+      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(\n                       StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n+    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n+      if (!cliParser.hasOption(APP_ID)) {\n+        printUsage(title, opts);\n+        return exitCode;\n+      }\n+      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n+          cliParser.getOptionValue(UPDATE_PRIORITY));\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.addOption(APP_ID, true, \"Specify Application Id to be operated\");\n      opts.addOption(UPDATE_PRIORITY, true,\n          \"update priority of an application. ApplicationId can be\"\n              + \" passed using \u0027appId\u0027 option.\");\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n      opts.getOption(APP_ID).setArgName(\"Application ID\");\n      opts.getOption(UPDATE_PRIORITY).setArgName(\"Priority\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else if (cliParser.hasOption(UPDATE_PRIORITY)) {\n      if (!cliParser.hasOption(APP_ID)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      updateApplicationPriority(cliParser.getOptionValue(APP_ID),\n          cliParser.getOptionValue(UPDATE_PRIORITY));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,158 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n-                appTypes.add(type.toUpperCase().trim());\n+                appTypes.add(StringUtils.toUpperCase(type).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n-                  appStates.add(YarnApplicationState.valueOf(state\n-                      .toUpperCase().trim()));\n+                  appStates.add(YarnApplicationState.valueOf(\n+                      StringUtils.toUpperCase(state).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(StringUtils.toUpperCase(type).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(\n                      StringUtils.toUpperCase(state).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,158 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n-                appTypes.add(type.toUpperCase(Locale.ENGLISH).trim());\n+                appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n-                      .toUpperCase(Locale.ENGLISH).trim()));\n+                      .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "23/12/14 8:04 PM",
      "commitNameOld": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 57.0,
      "commitsBetweenForRepo": 432,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,158 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         exitCode \u003d printApplicationAttemptReport(cliParser\n             .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n       return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n-                appTypes.add(type.toUpperCase().trim());\n+                appTypes.add(type.toUpperCase(Locale.ENGLISH).trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n-                      .toUpperCase().trim()));\n+                      .toUpperCase(Locale.ENGLISH).trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase(Locale.ENGLISH).trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase(Locale.ENGLISH).trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "fae3e8614f4f9a42904e39c51ca68b0d1e67469f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2356. yarn status command for non-existent application/application\nattempt/container is too verbose. Contributed by Sunil G.\n",
      "commitDate": "15/12/14 1:13 AM",
      "commitName": "fae3e8614f4f9a42904e39c51ca68b0d1e67469f",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "04/12/14 12:53 PM",
      "commitNameOld": "258623ff8bb1a1057ae3501d4f20982d5a59ea34",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 10.51,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,156 +1,158 @@\n   public int run(String[] args) throws Exception {\n     Options opts \u003d new Options();\n     String title \u003d null;\n     if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n       title \u003d APPLICATION;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application.\");\n       opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state.\");\n       opts.addOption(KILL_CMD, true, \"Kills the application.\");\n       opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n           + \"different queue.\");\n       opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n           + \" specify which queue to move an application to.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n           + \"filter applications based on \"\n           + \"input comma-separated list of application types.\");\n       appTypeOpt.setValueSeparator(\u0027,\u0027);\n       appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n       appTypeOpt.setArgName(\"Types\");\n       opts.addOption(appTypeOpt);\n       Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n           + \"to filter applications based on input comma-separated list of \"\n           + \"application states. \" + getAllValidApplicationStates());\n       appStateOpt.setValueSeparator(\u0027,\u0027);\n       appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n       appStateOpt.setArgName(\"States\");\n       opts.addOption(appStateOpt);\n       opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n       opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n       opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n       title \u003d APPLICATION_ATTEMPT;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the application attempt.\");\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n       title \u003d CONTAINER;\n       opts.addOption(STATUS_CMD, true,\n           \"Prints the status of the container.\");\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempt.\");\n       opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n       opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n       opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n-        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n+        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n-        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n+        exitCode \u003d printApplicationAttemptReport(cliParser\n+            .getOptionValue(STATUS_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n-        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n+        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n+      return exitCode;\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n                       .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n         if (args.length !\u003d 3) {\n           printUsage(title, opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(title, opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        exitCode \u003d printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        exitCode \u003d printApplicationAttemptReport(cliParser\n            .getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        exitCode \u003d printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n      return exitCode;\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "874cc955e0f501e8093c82e09fc0e44eb1a48908": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1787. Fixed help messages for applicationattempt and container sub-commands in bin/yarn. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575482 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 8:49 PM",
      "commitName": "874cc955e0f501e8093c82e09fc0e44eb1a48908",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/03/14 1:29 AM",
      "commitNameOld": "240b4e9a7f16ccd309967771108a671d16dbc1aa",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 2.81,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,156 @@\n   public int run(String[] args) throws Exception {\n-\n     Options opts \u003d new Options();\n-    opts.addOption(STATUS_CMD, true,\n-        \"Prints the status of the application.\");\n-    if (args.length \u003e 0\n-        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n-      opts.addOption(LIST_CMD, true,\n-          \"List application attempts for aplication from AHS. \");\n-    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n-      opts.addOption(LIST_CMD, true,\n-          \"List containers for application attempts from AHS. \");\n-    } else {\n-      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n+    String title \u003d null;\n+    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n+      title \u003d APPLICATION;\n+      opts.addOption(STATUS_CMD, true,\n+          \"Prints the status of the application.\");\n+      opts.addOption(LIST_CMD, false, \"List applications. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n-          + \"and -appStates to filter applications based on application state\");\n+          + \"and -appStates to filter applications based on application state.\");\n+      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n+      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n+          + \"different queue.\");\n+      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n+          + \" specify which queue to move an application to.\");\n+      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n+          + \"filter applications based on \"\n+          + \"input comma-separated list of application types.\");\n+      appTypeOpt.setValueSeparator(\u0027,\u0027);\n+      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n+      appTypeOpt.setArgName(\"Types\");\n+      opts.addOption(appTypeOpt);\n+      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n+          + \"to filter applications based on input comma-separated list of \"\n+          + \"application states. \" + getAllValidApplicationStates());\n+      appStateOpt.setValueSeparator(\u0027,\u0027);\n+      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n+      appStateOpt.setArgName(\"States\");\n+      opts.addOption(appStateOpt);\n+      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n+      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n+      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n+      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n+    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+      title \u003d APPLICATION_ATTEMPT;\n+      opts.addOption(STATUS_CMD, true,\n+          \"Prints the status of the application attempt.\");\n+      opts.addOption(LIST_CMD, true,\n+          \"List application attempts for aplication.\");\n+      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n+      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n+    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n+      title \u003d CONTAINER;\n+      opts.addOption(STATUS_CMD, true,\n+          \"Prints the status of the container.\");\n+      opts.addOption(LIST_CMD, true,\n+          \"List containers for application attempt.\");\n+      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n+      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n     }\n-    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n-    opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n-        + \"different queue.\");\n-    opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n-        + \" specify which queue to move an application to.\");\n-    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n-        + \"filter applications based on \"\n-        + \"input comma-separated list of application types.\");\n-    appTypeOpt.setValueSeparator(\u0027,\u0027);\n-    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n-    appTypeOpt.setArgName(\"Types\");\n-    opts.addOption(appTypeOpt);\n-    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n-        + \"to filter applications based on input comma-separated list of \"\n-        + \"application states. \" + getAllValidApplicationStates());\n-    appStateOpt.setValueSeparator(\u0027,\u0027);\n-    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n-    appStateOpt.setArgName(\"States\");\n-    opts.addOption(appStateOpt);\n-    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n-    opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n-    opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n-    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n-      printUsage(opts);\n+      printUsage(title, opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n-      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n-          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n-          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n-        if (args.length !\u003d 3) {\n-          printUsage(opts);\n-          return exitCode;\n-        }\n-      } else if (args.length !\u003d 2) {\n-        printUsage(opts);\n+      if (args.length !\u003d 3) {\n+        printUsage(title, opts);\n         return exitCode;\n       }\n-      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n-        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n-      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n-        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n-      } else {\n+      if (args[0].equalsIgnoreCase(APPLICATION)) {\n         printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n+      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n+      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n+        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n     } else if (cliParser.hasOption(LIST_CMD)) {\n-      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n-        if (args.length !\u003d 3) {\n-          printUsage(opts);\n-          return exitCode;\n-        }\n-        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n-      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n-        if (args.length !\u003d 3) {\n-          printUsage(opts);\n-          return exitCode;\n-        }\n-        listContainers(cliParser.getOptionValue(LIST_CMD));\n-      } else {\n+      if (args[0].equalsIgnoreCase(APPLICATION)) {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n                       .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n+      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n+        if (args.length !\u003d 3) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n+      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n+        if (args.length !\u003d 3) {\n+          printUsage(title, opts);\n+          return exitCode;\n+        }\n+        listContainers(cliParser.getOptionValue(LIST_CMD));\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n-        printUsage(opts);\n+        printUsage(title, opts);\n         return exitCode;\n       }\n       try{\n         killApplication(cliParser.getOptionValue(KILL_CMD));\n       } catch (ApplicationNotFoundException e) {\n         return exitCode;\n       }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n-        printUsage(opts);\n+        printUsage(title, opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n-      printUsage(opts);\n+      printUsage(title, opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n-      printUsage(opts);\n+      printUsage(title, opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n    Options opts \u003d new Options();\n    String title \u003d null;\n    if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION)) {\n      title \u003d APPLICATION;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application.\");\n      opts.addOption(LIST_CMD, false, \"List applications. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state.\");\n      opts.addOption(KILL_CMD, true, \"Kills the application.\");\n      opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n          + \"different queue.\");\n      opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n          + \" specify which queue to move an application to.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n          + \"filter applications based on \"\n          + \"input comma-separated list of application types.\");\n      appTypeOpt.setValueSeparator(\u0027,\u0027);\n      appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n      appTypeOpt.setArgName(\"Types\");\n      opts.addOption(appTypeOpt);\n      Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n          + \"to filter applications based on input comma-separated list of \"\n          + \"application states. \" + getAllValidApplicationStates());\n      appStateOpt.setValueSeparator(\u0027,\u0027);\n      appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n      appStateOpt.setArgName(\"States\");\n      opts.addOption(appStateOpt);\n      opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n      opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n      opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n      title \u003d APPLICATION_ATTEMPT;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the application attempt.\");\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Application Attempt ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application ID\");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].equalsIgnoreCase(CONTAINER)) {\n      title \u003d CONTAINER;\n      opts.addOption(STATUS_CMD, true,\n          \"Prints the status of the container.\");\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempt.\");\n      opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n      opts.getOption(STATUS_CMD).setArgName(\"Container ID\");\n      opts.getOption(LIST_CMD).setArgName(\"Application Attempt ID\");\n    }\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(title, opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].equalsIgnoreCase(APPLICATION)) {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      } else if (args[0].equalsIgnoreCase(APPLICATION_ATTEMPT)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].equalsIgnoreCase(CONTAINER)) {\n        if (args.length !\u003d 3) {\n          printUsage(title, opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(title, opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(title, opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(title, opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "240b4e9a7f16ccd309967771108a671d16dbc1aa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1768. Fixed error message being too verbose when killing a non-existent application. Contributed by Tsuyoshi Ozawa\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574401 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/14 1:29 AM",
      "commitName": "240b4e9a7f16ccd309967771108a671d16dbc1aa",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "10/02/14 1:19 AM",
      "commitNameOld": "1c151c31faca77b67b7f4d50d682e76bc519d79a",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 23.01,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,151 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true,\n         \"Prints the status of the application.\");\n     if (args.length \u003e 0\n         \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication from AHS. \");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempts from AHS. \");\n     } else {\n       opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state\");\n     }\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n     opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n         + \"different queue.\");\n     opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n         + \" specify which queue to move an application to.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n         + \"filter applications based on \"\n         + \"input comma-separated list of application types.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n     appTypeOpt.setArgName(\"Types\");\n     opts.addOption(appTypeOpt);\n     Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n         + \"to filter applications based on input comma-separated list of \"\n         + \"application states. \" + getAllValidApplicationStates());\n     appStateOpt.setValueSeparator(\u0027,\u0027);\n     appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n     appStateOpt.setArgName(\"States\");\n     opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n     opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n     opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n       } else if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       } else {\n         printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       } else {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n                       .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(opts);\n         return exitCode;\n       }\n-      killApplication(cliParser.getOptionValue(KILL_CMD));\n+      try{\n+        killApplication(cliParser.getOptionValue(KILL_CMD));\n+      } catch (ApplicationNotFoundException e) {\n+        return exitCode;\n+      }\n     } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n       if (!cliParser.hasOption(QUEUE_CMD)) {\n         printUsage(opts);\n         return exitCode;\n       }\n       moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n           cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true,\n        \"Prints the status of the application.\");\n    if (args.length \u003e 0\n        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication from AHS. \");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempts from AHS. \");\n    } else {\n      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state\");\n    }\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n        + \"different queue.\");\n    opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n        + \" specify which queue to move an application to.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n        + \"filter applications based on \"\n        + \"input comma-separated list of application types.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n        + \"to filter applications based on input comma-separated list of \"\n        + \"application states. \" + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"States\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n    opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n      } else if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      } else {\n        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      } else {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(opts);\n        return exitCode;\n      }\n      try{\n        killApplication(cliParser.getOptionValue(KILL_CMD));\n      } catch (ApplicationNotFoundException e) {\n        return exitCode;\n      }\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "c79cc3a3140e390eb40eb4b3ba89fff5d4ecd5ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1497. Command line additions for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1565754 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/14 10:35 AM",
      "commitName": "c79cc3a3140e390eb40eb4b3ba89fff5d4ecd5ee",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "03/02/14 8:08 PM",
      "commitNameOld": "a8c780d378df86aafba09751c0c43dd4e0d54c0a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.6,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,147 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true,\n         \"Prints the status of the application.\");\n     if (args.length \u003e 0\n         \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication from AHS. \");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempts from AHS. \");\n     } else {\n       opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state\");\n     }\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n+    opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n+        + \"different queue.\");\n+    opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n+        + \" specify which queue to move an application to.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n         + \"filter applications based on \"\n         + \"input comma-separated list of application types.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n     appTypeOpt.setArgName(\"Types\");\n     opts.addOption(appTypeOpt);\n     Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n         + \"to filter applications based on input comma-separated list of \"\n         + \"application states. \" + getAllValidApplicationStates());\n     appStateOpt.setValueSeparator(\u0027,\u0027);\n     appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n     appStateOpt.setArgName(\"States\");\n     opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n+    opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n+    opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n       } else if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       } else {\n         printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       } else {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n                       .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 3) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n+    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n+      if (!cliParser.hasOption(QUEUE_CMD)) {\n+        printUsage(opts);\n+        return exitCode;\n+      }\n+      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n+          cliParser.getOptionValue(QUEUE_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true,\n        \"Prints the status of the application.\");\n    if (args.length \u003e 0\n        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication from AHS. \");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempts from AHS. \");\n    } else {\n      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state\");\n    }\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(MOVE_TO_QUEUE_CMD, true, \"Moves the application to a \"\n        + \"different queue.\");\n    opts.addOption(QUEUE_CMD, true, \"Works with the movetoqueue command to\"\n        + \" specify which queue to move an application to.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n        + \"filter applications based on \"\n        + \"input comma-separated list of application types.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n        + \"to filter applications based on input comma-separated list of \"\n        + \"application states. \" + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"States\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(MOVE_TO_QUEUE_CMD).setArgName(\"Application ID\");\n    opts.getOption(QUEUE_CMD).setArgName(\"Queue Name\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n      } else if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      } else {\n        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      } else {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(MOVE_TO_QUEUE_CMD)) {\n      if (!cliParser.hasOption(QUEUE_CMD)) {\n        printUsage(opts);\n        return exitCode;\n      }\n      moveApplicationAcrossQueues(cliParser.getOptionValue(MOVE_TO_QUEUE_CMD),\n          cliParser.getOptionValue(QUEUE_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "a8c780d378df86aafba09751c0c43dd4e0d54c0a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1673. Fix option parsing in YARN\u0027s application CLI after it is broken by YARN-967. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564188 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/02/14 8:08 PM",
      "commitName": "a8c780d378df86aafba09751c0c43dd4e0d54c0a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/01/14 8:51 PM",
      "commitNameOld": "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.97,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true,\n         \"Prints the status of the application.\");\n     if (args.length \u003e 0\n         \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List application attempts for aplication from AHS. \");\n     } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n       opts.addOption(LIST_CMD, true,\n           \"List containers for application attempts from AHS. \");\n     } else {\n       opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n           + \"Supports optional use of -appTypes to filter applications \"\n           + \"based on application type, \"\n           + \"and -appStates to filter applications based on application state\");\n     }\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n         + \"filter applications based on \"\n         + \"input comma-separated list of application types.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n     appTypeOpt.setArgName(\"Types\");\n     opts.addOption(appTypeOpt);\n     Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n         + \"to filter applications based on input comma-separated list of \"\n         + \"application states. \" + getAllValidApplicationStates());\n     appStateOpt.setValueSeparator(\u0027,\u0027);\n     appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n     appStateOpt.setArgName(\"States\");\n     opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n       if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n           || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n       } else if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n       } else {\n         printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n       }\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n       } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n         if (args.length !\u003d 3) {\n           printUsage(opts);\n           return exitCode;\n         }\n         listContainers(cliParser.getOptionValue(LIST_CMD));\n       } else {\n         allAppStates \u003d false;\n         Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n         if (cliParser.hasOption(APP_TYPE_CMD)) {\n           String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n           if (types !\u003d null) {\n             for (String type : types) {\n               if (!type.trim().isEmpty()) {\n                 appTypes.add(type.toUpperCase().trim());\n               }\n             }\n           }\n         }\n \n         EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n             .noneOf(YarnApplicationState.class);\n         if (cliParser.hasOption(APP_STATE_CMD)) {\n           String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n           if (states !\u003d null) {\n             for (String state : states) {\n               if (!state.trim().isEmpty()) {\n                 if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                   allAppStates \u003d true;\n                   break;\n                 }\n                 try {\n                   appStates.add(YarnApplicationState.valueOf(state\n                       .toUpperCase().trim()));\n                 } catch (IllegalArgumentException ex) {\n                   sysout.println(\"The application state \" + state\n                       + \" is invalid.\");\n                   sysout.println(getAllValidApplicationStates());\n                   return exitCode;\n                 }\n               }\n             }\n           }\n         }\n         listApplications(appTypes, appStates);\n       }\n     } else if (cliParser.hasOption(KILL_CMD)) {\n-      if (args.length !\u003d 2) {\n+      if (args.length !\u003d 3) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true,\n        \"Prints the status of the application.\");\n    if (args.length \u003e 0\n        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication from AHS. \");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempts from AHS. \");\n    } else {\n      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state\");\n    }\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n        + \"filter applications based on \"\n        + \"input comma-separated list of application types.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n        + \"to filter applications based on input comma-separated list of \"\n        + \"application states. \" + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"States\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n      } else if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      } else {\n        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      } else {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 3) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-321. Merging YARN-321 branch to trunk.\nsvn merge ../branches/YARN-321\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561452 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 8:51 PM",
      "commitName": "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/09/13 3:18 PM",
      "commitNameOld": "2d525510b42457dd4b519a0d4e49cac4ffe48a6f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 144.27,
      "commitsBetweenForRepo": 860,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,134 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n-    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n-    opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n-        \"Supports optional use of -appTypes to filter applications \" +\n-        \"based on application type, \" +\n-        \"and -appStates to filter applications based on application state\");\n+    opts.addOption(STATUS_CMD, true,\n+        \"Prints the status of the application.\");\n+    if (args.length \u003e 0\n+        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n+      opts.addOption(LIST_CMD, true,\n+          \"List application attempts for aplication from AHS. \");\n+    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n+      opts.addOption(LIST_CMD, true,\n+          \"List containers for application attempts from AHS. \");\n+    } else {\n+      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n+          + \"Supports optional use of -appTypes to filter applications \"\n+          + \"based on application type, \"\n+          + \"and -appStates to filter applications based on application state\");\n+    }\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \" +\n-        \"filter applications based on \" +\n-        \"input comma-separated list of application types.\");\n+    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n+        + \"filter applications based on \"\n+        + \"input comma-separated list of application types.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n     appTypeOpt.setArgName(\"Types\");\n     opts.addOption(appTypeOpt);\n-    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \" +\n-        \"to filter applications based on input comma-separated list of \" +\n-        \"application states. \" + getAllValidApplicationStates());\n+    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n+        + \"to filter applications based on input comma-separated list of \"\n+        + \"application states. \" + getAllValidApplicationStates());\n     appStateOpt.setValueSeparator(\u0027,\u0027);\n     appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n     appStateOpt.setArgName(\"States\");\n     opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n \n     int exitCode \u003d -1;\n     CommandLine cliParser \u003d null;\n     try {\n       cliParser \u003d new GnuParser().parse(opts, args);\n     } catch (MissingArgumentException ex) {\n       sysout.println(\"Missing argument for options\");\n       printUsage(opts);\n       return exitCode;\n     }\n \n     if (cliParser.hasOption(STATUS_CMD)) {\n-      if (args.length !\u003d 2) {\n+      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n+          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n+          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n+        if (args.length !\u003d 3) {\n+          printUsage(opts);\n+          return exitCode;\n+        }\n+      } else if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n-      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n+      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n+        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n+      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n+        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n+      } else {\n+        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n+      }\n     } else if (cliParser.hasOption(LIST_CMD)) {\n-      allAppStates \u003d false;\n-      Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n-      if(cliParser.hasOption(APP_TYPE_CMD)) {\n-        String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n-        if (types !\u003d null) {\n-          for (String type : types) {\n-            if (!type.trim().isEmpty()) {\n-              appTypes.add(type.toUpperCase().trim());\n+      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n+        if (args.length !\u003d 3) {\n+          printUsage(opts);\n+          return exitCode;\n+        }\n+        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n+      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n+        if (args.length !\u003d 3) {\n+          printUsage(opts);\n+          return exitCode;\n+        }\n+        listContainers(cliParser.getOptionValue(LIST_CMD));\n+      } else {\n+        allAppStates \u003d false;\n+        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n+        if (cliParser.hasOption(APP_TYPE_CMD)) {\n+          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n+          if (types !\u003d null) {\n+            for (String type : types) {\n+              if (!type.trim().isEmpty()) {\n+                appTypes.add(type.toUpperCase().trim());\n+              }\n             }\n           }\n         }\n-      }\n \n-      EnumSet\u003cYarnApplicationState\u003e appStates \u003d\n-          EnumSet.noneOf(YarnApplicationState.class);\n-      if (cliParser.hasOption(APP_STATE_CMD)) {\n-        String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n-        if (states !\u003d null) {\n-          for (String state : states) {\n-            if (!state.trim().isEmpty()) {\n-              if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n-                allAppStates \u003d true;\n-                break;\n-              }\n-              try {\n-                appStates.add(YarnApplicationState.valueOf(state.toUpperCase()\n-                    .trim()));\n-              } catch (IllegalArgumentException ex) {\n-                sysout.println(\"The application state \" + state\n-                    + \" is invalid.\");\n-                sysout.println(getAllValidApplicationStates());\n-                return exitCode;\n+        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n+            .noneOf(YarnApplicationState.class);\n+        if (cliParser.hasOption(APP_STATE_CMD)) {\n+          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n+          if (states !\u003d null) {\n+            for (String state : states) {\n+              if (!state.trim().isEmpty()) {\n+                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n+                  allAppStates \u003d true;\n+                  break;\n+                }\n+                try {\n+                  appStates.add(YarnApplicationState.valueOf(state\n+                      .toUpperCase().trim()));\n+                } catch (IllegalArgumentException ex) {\n+                  sysout.println(\"The application state \" + state\n+                      + \" is invalid.\");\n+                  sysout.println(getAllValidApplicationStates());\n+                  return exitCode;\n+                }\n               }\n             }\n           }\n         }\n+        listApplications(appTypes, appStates);\n       }\n-      listApplications(appTypes, appStates);\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true,\n        \"Prints the status of the application.\");\n    if (args.length \u003e 0\n        \u0026\u0026 args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List application attempts for aplication from AHS. \");\n    } else if (args.length \u003e 0 \u0026\u0026 args[0].compareToIgnoreCase(\"container\") \u003d\u003d 0) {\n      opts.addOption(LIST_CMD, true,\n          \"List containers for application attempts from AHS. \");\n    } else {\n      opts.addOption(LIST_CMD, false, \"List applications from the RM. \"\n          + \"Supports optional use of -appTypes to filter applications \"\n          + \"based on application type, \"\n          + \"and -appStates to filter applications based on application state\");\n    }\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \"\n        + \"filter applications based on \"\n        + \"input comma-separated list of application types.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \"\n        + \"to filter applications based on input comma-separated list of \"\n        + \"application states. \" + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"States\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if ((args[0].compareToIgnoreCase(APPLICATION) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0)\n          || (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0)) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n      } else if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        printApplicationAttemptReport(cliParser.getOptionValue(STATUS_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        printContainerReport(cliParser.getOptionValue(STATUS_CMD));\n      } else {\n        printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n      }\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      if (args[0].compareToIgnoreCase(APPLICATION_ATTEMPT) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listApplicationAttempts(cliParser.getOptionValue(LIST_CMD));\n      } else if (args[0].compareToIgnoreCase(CONTAINER) \u003d\u003d 0) {\n        if (args.length !\u003d 3) {\n          printUsage(opts);\n          return exitCode;\n        }\n        listContainers(cliParser.getOptionValue(LIST_CMD));\n      } else {\n        allAppStates \u003d false;\n        Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n        if (cliParser.hasOption(APP_TYPE_CMD)) {\n          String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n          if (types !\u003d null) {\n            for (String type : types) {\n              if (!type.trim().isEmpty()) {\n                appTypes.add(type.toUpperCase().trim());\n              }\n            }\n          }\n        }\n\n        EnumSet\u003cYarnApplicationState\u003e appStates \u003d EnumSet\n            .noneOf(YarnApplicationState.class);\n        if (cliParser.hasOption(APP_STATE_CMD)) {\n          String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n          if (states !\u003d null) {\n            for (String state : states) {\n              if (!state.trim().isEmpty()) {\n                if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                  allAppStates \u003d true;\n                  break;\n                }\n                try {\n                  appStates.add(YarnApplicationState.valueOf(state\n                      .toUpperCase().trim()));\n                } catch (IllegalArgumentException ex) {\n                  sysout.println(\"The application state \" + state\n                      + \" is invalid.\");\n                  sysout.println(getAllValidApplicationStates());\n                  return exitCode;\n                }\n              }\n            }\n          }\n        }\n        listApplications(appTypes, appStates);\n      }\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "6d100eb79409cbca70a22ada705dedf6658545e3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1117. Improved help messages for \"yarn application\" and \"yarn node\" commands. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519117 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/08/13 4:26 PM",
      "commitName": "6d100eb79409cbca70a22ada705dedf6658545e3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/13 2:16 PM",
      "commitNameOld": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,97 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n     opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n-        \"Supports optional use of --appTypes to filter applications \" +\n+        \"Supports optional use of -appTypes to filter applications \" +\n         \"based on application type, \" +\n-        \"and --appStates to filter applications based on application state\");\n+        \"and -appStates to filter applications based on application state\");\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n-    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true,\n-        \"Works with --list to filter applications based on their type.\");\n+    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \" +\n+        \"filter applications based on \" +\n+        \"input comma-separated list of application types.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n-    appTypeOpt.setArgName(\"Comma-separated list of application types\");\n+    appTypeOpt.setArgName(\"Types\");\n     opts.addOption(appTypeOpt);\n-    Option appStateOpt \u003d\n-        new Option(\n-            APP_STATE_CMD,\n-            true,\n-            \"Works with --list to filter applications based on their state. \"\n-                + getAllValidApplicationStates());\n+    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \" +\n+        \"to filter applications based on input comma-separated list of \" +\n+        \"application states. \" + getAllValidApplicationStates());\n     appStateOpt.setValueSeparator(\u0027,\u0027);\n     appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n-    appStateOpt.setArgName(\"Comma-separated list of application states\");\n+    appStateOpt.setArgName(\"States\");\n     opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n-    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     int exitCode \u003d -1;\n+    CommandLine cliParser \u003d null;\n+    try {\n+      cliParser \u003d new GnuParser().parse(opts, args);\n+    } catch (MissingArgumentException ex) {\n+      sysout.println(\"Missing argument for options\");\n+      printUsage(opts);\n+      return exitCode;\n+    }\n+\n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n     } else if (cliParser.hasOption(LIST_CMD)) {\n       allAppStates \u003d false;\n       Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n       if(cliParser.hasOption(APP_TYPE_CMD)) {\n         String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n         if (types !\u003d null) {\n           for (String type : types) {\n             if (!type.trim().isEmpty()) {\n               appTypes.add(type.toUpperCase().trim());\n             }\n           }\n         }\n       }\n \n       EnumSet\u003cYarnApplicationState\u003e appStates \u003d\n           EnumSet.noneOf(YarnApplicationState.class);\n       if (cliParser.hasOption(APP_STATE_CMD)) {\n         String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n         if (states !\u003d null) {\n           for (String state : states) {\n             if (!state.trim().isEmpty()) {\n               if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                 allAppStates \u003d true;\n                 break;\n               }\n               try {\n                 appStates.add(YarnApplicationState.valueOf(state.toUpperCase()\n                     .trim()));\n               } catch (IllegalArgumentException ex) {\n                 sysout.println(\"The application state \" + state\n                     + \" is invalid.\");\n                 sysout.println(getAllValidApplicationStates());\n                 return exitCode;\n               }\n             }\n           }\n         }\n       }\n       listApplications(appTypes, appStates);\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n    opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n        \"Supports optional use of -appTypes to filter applications \" +\n        \"based on application type, \" +\n        \"and -appStates to filter applications based on application state\");\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true, \"Works with -list to \" +\n        \"filter applications based on \" +\n        \"input comma-separated list of application types.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d new Option(APP_STATE_CMD, true, \"Works with -list \" +\n        \"to filter applications based on input comma-separated list of \" +\n        \"application states. \" + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"States\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n\n    int exitCode \u003d -1;\n    CommandLine cliParser \u003d null;\n    try {\n      cliParser \u003d new GnuParser().parse(opts, args);\n    } catch (MissingArgumentException ex) {\n      sysout.println(\"Missing argument for options\");\n      printUsage(opts);\n      return exitCode;\n    }\n\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      allAppStates \u003d false;\n      Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n      if(cliParser.hasOption(APP_TYPE_CMD)) {\n        String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n        if (types !\u003d null) {\n          for (String type : types) {\n            if (!type.trim().isEmpty()) {\n              appTypes.add(type.toUpperCase().trim());\n            }\n          }\n        }\n      }\n\n      EnumSet\u003cYarnApplicationState\u003e appStates \u003d\n          EnumSet.noneOf(YarnApplicationState.class);\n      if (cliParser.hasOption(APP_STATE_CMD)) {\n        String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n        if (states !\u003d null) {\n          for (String state : states) {\n            if (!state.trim().isEmpty()) {\n              if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                allAppStates \u003d true;\n                break;\n              }\n              try {\n                appStates.add(YarnApplicationState.valueOf(state.toUpperCase()\n                    .trim()));\n              } catch (IllegalArgumentException ex) {\n                sysout.println(\"The application state \" + state\n                    + \" is invalid.\");\n                sysout.println(getAllValidApplicationStates());\n                return exitCode;\n              }\n            }\n          }\n        }\n      }\n      listApplications(appTypes, appStates);\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1074. Cleaned up YARN CLI application list to only display running applications by default. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1517196 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/13 2:16 PM",
      "commitName": "962da4dcc74d23c7ce78164dcde38ea5aaf3dd68",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/08/13 4:00 PM",
      "commitNameOld": "1ad3fe46332586cea73c47ba06342f91359db561",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.93,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,91 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n     opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n         \"Supports optional use of --appTypes to filter applications \" +\n-        \"based on application type.\");\n+        \"based on application type, \" +\n+        \"and --appStates to filter applications based on application state\");\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n     opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n     Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true,\n         \"Works with --list to filter applications based on their type.\");\n     appTypeOpt.setValueSeparator(\u0027,\u0027);\n     appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n     appTypeOpt.setArgName(\"Comma-separated list of application types\");\n     opts.addOption(appTypeOpt);\n+    Option appStateOpt \u003d\n+        new Option(\n+            APP_STATE_CMD,\n+            true,\n+            \"Works with --list to filter applications based on their state. \"\n+                + getAllValidApplicationStates());\n+    appStateOpt.setValueSeparator(\u0027,\u0027);\n+    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n+    appStateOpt.setArgName(\"Comma-separated list of application states\");\n+    opts.addOption(appStateOpt);\n     opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n     opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     int exitCode \u003d -1;\n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n     } else if (cliParser.hasOption(LIST_CMD)) {\n+      allAppStates \u003d false;\n       Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n       if(cliParser.hasOption(APP_TYPE_CMD)) {\n         String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n         if (types !\u003d null) {\n           for (String type : types) {\n             if (!type.trim().isEmpty()) {\n-              appTypes.add(type.trim());\n+              appTypes.add(type.toUpperCase().trim());\n             }\n           }\n         }\n       }\n-      listApplications(appTypes);\n+\n+      EnumSet\u003cYarnApplicationState\u003e appStates \u003d\n+          EnumSet.noneOf(YarnApplicationState.class);\n+      if (cliParser.hasOption(APP_STATE_CMD)) {\n+        String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n+        if (states !\u003d null) {\n+          for (String state : states) {\n+            if (!state.trim().isEmpty()) {\n+              if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n+                allAppStates \u003d true;\n+                break;\n+              }\n+              try {\n+                appStates.add(YarnApplicationState.valueOf(state.toUpperCase()\n+                    .trim()));\n+              } catch (IllegalArgumentException ex) {\n+                sysout.println(\"The application state \" + state\n+                    + \" is invalid.\");\n+                sysout.println(getAllValidApplicationStates());\n+                return exitCode;\n+              }\n+            }\n+          }\n+        }\n+      }\n+      listApplications(appTypes, appStates);\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n     } else if (cliParser.hasOption(HELP_CMD)) {\n       printUsage(opts);\n       return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n    opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n        \"Supports optional use of --appTypes to filter applications \" +\n        \"based on application type, \" +\n        \"and --appStates to filter applications based on application state\");\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true,\n        \"Works with --list to filter applications based on their type.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Comma-separated list of application types\");\n    opts.addOption(appTypeOpt);\n    Option appStateOpt \u003d\n        new Option(\n            APP_STATE_CMD,\n            true,\n            \"Works with --list to filter applications based on their state. \"\n                + getAllValidApplicationStates());\n    appStateOpt.setValueSeparator(\u0027,\u0027);\n    appStateOpt.setArgs(Option.UNLIMITED_VALUES);\n    appStateOpt.setArgName(\"Comma-separated list of application states\");\n    opts.addOption(appStateOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    int exitCode \u003d -1;\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      allAppStates \u003d false;\n      Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n      if(cliParser.hasOption(APP_TYPE_CMD)) {\n        String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n        if (types !\u003d null) {\n          for (String type : types) {\n            if (!type.trim().isEmpty()) {\n              appTypes.add(type.toUpperCase().trim());\n            }\n          }\n        }\n      }\n\n      EnumSet\u003cYarnApplicationState\u003e appStates \u003d\n          EnumSet.noneOf(YarnApplicationState.class);\n      if (cliParser.hasOption(APP_STATE_CMD)) {\n        String[] states \u003d cliParser.getOptionValues(APP_STATE_CMD);\n        if (states !\u003d null) {\n          for (String state : states) {\n            if (!state.trim().isEmpty()) {\n              if (state.trim().equalsIgnoreCase(ALLSTATES_OPTION)) {\n                allAppStates \u003d true;\n                break;\n              }\n              try {\n                appStates.add(YarnApplicationState.valueOf(state.toUpperCase()\n                    .trim()));\n              } catch (IllegalArgumentException ex) {\n                sysout.println(\"The application state \" + state\n                    + \" is invalid.\");\n                sysout.println(getAllValidApplicationStates());\n                return exitCode;\n              }\n            }\n          }\n        }\n      }\n      listApplications(appTypes, appStates);\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-727, MAPREDUCE-5325. ClientRMProtocol.getAllApplications should accept ApplicationType as a parameter. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/13 4:01 PM",
      "commitName": "e2cce7bd26cb943225a0d4ffb6f674e1b8ee39ae",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "17/06/13 9:02 PM",
      "commitNameOld": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 21.79,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,54 @@\n   public int run(String[] args) throws Exception {\n \n     Options opts \u003d new Options();\n     opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n-    opts.addOption(LIST_CMD, false, \"Lists all the Applications from RM.\");\n+    opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n+        \"Supports optional use of --appTypes to filter applications \" +\n+        \"based on application type.\");\n     opts.addOption(KILL_CMD, true, \"Kills the application.\");\n+    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n+    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true,\n+        \"Works with --list to filter applications based on their type.\");\n+    appTypeOpt.setValueSeparator(\u0027,\u0027);\n+    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n+    appTypeOpt.setArgName(\"Comma-separated list of application types\");\n+    opts.addOption(appTypeOpt);\n+    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n+    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     int exitCode \u003d -1;\n     if (cliParser.hasOption(STATUS_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n     } else if (cliParser.hasOption(LIST_CMD)) {\n-      listAllApplications();\n+      Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n+      if(cliParser.hasOption(APP_TYPE_CMD)) {\n+        String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n+        if (types !\u003d null) {\n+          for (String type : types) {\n+            if (!type.trim().isEmpty()) {\n+              appTypes.add(type.trim());\n+            }\n+          }\n+        }\n+      }\n+      listApplications(appTypes);\n     } else if (cliParser.hasOption(KILL_CMD)) {\n       if (args.length !\u003d 2) {\n         printUsage(opts);\n         return exitCode;\n       }\n       killApplication(cliParser.getOptionValue(KILL_CMD));\n+    } else if (cliParser.hasOption(HELP_CMD)) {\n+      printUsage(opts);\n+      return 0;\n     } else {\n       syserr.println(\"Invalid Command Usage : \");\n       printUsage(opts);\n     }\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n    opts.addOption(LIST_CMD, false, \"List applications from the RM. \" +\n        \"Supports optional use of --appTypes to filter applications \" +\n        \"based on application type.\");\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    opts.addOption(HELP_CMD, false, \"Displays help for all commands.\");\n    Option appTypeOpt \u003d new Option(APP_TYPE_CMD, true,\n        \"Works with --list to filter applications based on their type.\");\n    appTypeOpt.setValueSeparator(\u0027,\u0027);\n    appTypeOpt.setArgs(Option.UNLIMITED_VALUES);\n    appTypeOpt.setArgName(\"Comma-separated list of application types\");\n    opts.addOption(appTypeOpt);\n    opts.getOption(KILL_CMD).setArgName(\"Application ID\");\n    opts.getOption(STATUS_CMD).setArgName(\"Application ID\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    int exitCode \u003d -1;\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      Set\u003cString\u003e appTypes \u003d new HashSet\u003cString\u003e();\n      if(cliParser.hasOption(APP_TYPE_CMD)) {\n        String[] types \u003d cliParser.getOptionValues(APP_TYPE_CMD);\n        if (types !\u003d null) {\n          for (String type : types) {\n            if (!type.trim().isEmpty()) {\n              appTypes.add(type.trim());\n            }\n          }\n        }\n      }\n      listApplications(appTypes);\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else if (cliParser.hasOption(HELP_CMD)) {\n      printUsage(opts);\n      return 0;\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java",
      "extendedDetails": {}
    },
    "331b1123fbb892524ecb58e551c20befd26c9ea9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-40. Provided support for missing YARN commands Contributed by Devaraj K and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1395793 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/12 3:18 PM",
      "commitName": "331b1123fbb892524ecb58e551c20befd26c9ea9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,29 @@\n+  public int run(String[] args) throws Exception {\n+\n+    Options opts \u003d new Options();\n+    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n+    opts.addOption(LIST_CMD, false, \"Lists all the Applications from RM.\");\n+    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n+    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n+\n+    int exitCode \u003d -1;\n+    if (cliParser.hasOption(STATUS_CMD)) {\n+      if (args.length !\u003d 2) {\n+        printUsage(opts);\n+        return exitCode;\n+      }\n+      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n+    } else if (cliParser.hasOption(LIST_CMD)) {\n+      listAllApplications();\n+    } else if (cliParser.hasOption(KILL_CMD)) {\n+      if (args.length !\u003d 2) {\n+        printUsage(opts);\n+        return exitCode;\n+      }\n+      killApplication(cliParser.getOptionValue(KILL_CMD));\n+    } else {\n+      syserr.println(\"Invalid Command Usage : \");\n+      printUsage(opts);\n+    }\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args) throws Exception {\n\n    Options opts \u003d new Options();\n    opts.addOption(STATUS_CMD, true, \"Prints the status of the application.\");\n    opts.addOption(LIST_CMD, false, \"Lists all the Applications from RM.\");\n    opts.addOption(KILL_CMD, true, \"Kills the application.\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    int exitCode \u003d -1;\n    if (cliParser.hasOption(STATUS_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      printApplicationReport(cliParser.getOptionValue(STATUS_CMD));\n    } else if (cliParser.hasOption(LIST_CMD)) {\n      listAllApplications();\n    } else if (cliParser.hasOption(KILL_CMD)) {\n      if (args.length !\u003d 2) {\n        printUsage(opts);\n        return exitCode;\n      }\n      killApplication(cliParser.getOptionValue(KILL_CMD));\n    } else {\n      syserr.println(\"Invalid Command Usage : \");\n      printUsage(opts);\n    }\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/ApplicationCLI.java"
    }
  }
}