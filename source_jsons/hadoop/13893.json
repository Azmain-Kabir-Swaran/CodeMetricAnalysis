{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "countLiveAndDecommissioningReplicas",
  "functionId": "countLiveAndDecommissioningReplicas___counters-NumberReplicas__state-StoredReplicaState__liveBitSet-BitSet__decommissioningBitSet-BitSet__blockIndex-byte",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 4425,
  "functionEndLine": 4446,
  "numCommitsSeen": 477,
  "timeTaken": 1965,
  "changeHistory": [
    "9d25ae7669eed1a047578b574f42bd121b445a3c"
  ],
  "changeHistoryShort": {
    "9d25ae7669eed1a047578b574f42bd121b445a3c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d25ae7669eed1a047578b574f42bd121b445a3c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-14920. Erasure Coding: Decommission may hang If one or more datanodes are out of service during decommission. Contributed by Fei Hui.\n",
      "commitDate": "31/10/19 11:19 AM",
      "commitName": "9d25ae7669eed1a047578b574f42bd121b445a3c",
      "commitAuthor": "Ayush Saxena",
      "diff": "@@ -0,0 +1,22 @@\n+  private void countLiveAndDecommissioningReplicas(NumberReplicas counters,\n+      StoredReplicaState state, BitSet liveBitSet,\n+      BitSet decommissioningBitSet, byte blockIndex) {\n+    if (state \u003d\u003d StoredReplicaState.LIVE) {\n+      if (!liveBitSet.get(blockIndex)) {\n+        liveBitSet.set(blockIndex);\n+        // Sub decommissioning because the index replica is live.\n+        if (decommissioningBitSet.get(blockIndex)) {\n+          counters.subtract(StoredReplicaState.DECOMMISSIONING, 1);\n+        }\n+      } else {\n+        counters.subtract(StoredReplicaState.LIVE, 1);\n+        counters.add(StoredReplicaState.REDUNDANT, 1);\n+      }\n+    } else if (state \u003d\u003d StoredReplicaState.DECOMMISSIONING) {\n+      if (liveBitSet.get(blockIndex) || decommissioningBitSet.get(blockIndex)) {\n+        counters.subtract(StoredReplicaState.DECOMMISSIONING, 1);\n+      } else {\n+        decommissioningBitSet.set(blockIndex);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void countLiveAndDecommissioningReplicas(NumberReplicas counters,\n      StoredReplicaState state, BitSet liveBitSet,\n      BitSet decommissioningBitSet, byte blockIndex) {\n    if (state \u003d\u003d StoredReplicaState.LIVE) {\n      if (!liveBitSet.get(blockIndex)) {\n        liveBitSet.set(blockIndex);\n        // Sub decommissioning because the index replica is live.\n        if (decommissioningBitSet.get(blockIndex)) {\n          counters.subtract(StoredReplicaState.DECOMMISSIONING, 1);\n        }\n      } else {\n        counters.subtract(StoredReplicaState.LIVE, 1);\n        counters.add(StoredReplicaState.REDUNDANT, 1);\n      }\n    } else if (state \u003d\u003d StoredReplicaState.DECOMMISSIONING) {\n      if (liveBitSet.get(blockIndex) || decommissioningBitSet.get(blockIndex)) {\n        counters.subtract(StoredReplicaState.DECOMMISSIONING, 1);\n      } else {\n        decommissioningBitSet.set(blockIndex);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java"
    }
  }
}