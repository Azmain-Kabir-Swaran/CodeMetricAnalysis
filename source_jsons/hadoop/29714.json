{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineAuthenticationFilterInitializer.java",
  "functionName": "initFilter",
  "functionId": "initFilter___container-FilterContainer__conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
  "functionStartLine": 92,
  "functionEndLine": 109,
  "numCommitsSeen": 13,
  "timeTaken": 2409,
  "changeHistory": [
    "d3f11e3f13ed5efc7f0b7f19567d142e554c35ed",
    "879de51206ddef132c092ee21e8b6c6e5976a56e",
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674",
    "39063cd36f96e351e4a6bf0bc2b6185711d4b059",
    "08b4aa699a40e6095736f344d3ff59bec37c7e6e",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
    "b867b695565c588e8f86c867cba76397cab62848"
  ],
  "changeHistoryShort": {
    "d3f11e3f13ed5efc7f0b7f19567d142e554c35ed": "Ybodychange",
    "879de51206ddef132c092ee21e8b6c6e5976a56e": "Yfilerename",
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9": "Ybodychange",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": "Ybodychange",
    "39063cd36f96e351e4a6bf0bc2b6185711d4b059": "Ybodychange",
    "08b4aa699a40e6095736f344d3ff59bec37c7e6e": "Ybodychange",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": "Yfilerename",
    "b867b695565c588e8f86c867cba76397cab62848": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d3f11e3f13ed5efc7f0b7f19567d142e554c35ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6638. [ATSv2 Security] Timeline reader side changes for loading auth filters and principals. Contributed by Varun Saxena\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "d3f11e3f13ed5efc7f0b7f19567d142e554c35ed",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "879de51206ddef132c092ee21e8b6c6e5976a56e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,18 @@\n   public void initFilter(FilterContainer container, Configuration conf) {\n-    filterConfig \u003d new HashMap\u003cString, String\u003e();\n-\n-    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n-    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n-\n-    for (Map.Entry\u003cString, String\u003e entry : conf) {\n-      String name \u003d entry.getKey();\n-      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n-        String value \u003d conf.get(name);\n-        name \u003d name.substring(\"hadoop.\".length());\n-        filterConfig.put(name, value);\n-      }\n-    }\n-    for (Map.Entry\u003cString, String\u003e entry : conf) {\n-      String name \u003d entry.getKey();\n-      if (name.startsWith(PREFIX)) {\n-        // yarn.timeline-service.http-authentication.proxyuser will override\n-        // hadoop.proxyuser\n-        String value \u003d conf.get(name);\n-        name \u003d name.substring(PREFIX.length());\n-        filterConfig.put(name, value);\n-      }\n-    }\n+    setAuthFilterConfig(conf);\n \n     String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n     if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           PseudoDelegationTokenAuthenticationHandler.class.getName());\n     } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           KerberosDelegationTokenAuthenticationHandler.class.getName());\n-\n-      // Resolve _HOST into bind address\n-      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n-      String principal \u003d\n-          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n-      if (principal !\u003d null) {\n-        try {\n-          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n-        } catch (IOException ex) {\n-          throw new RuntimeException(\n-              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n-        }\n-        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n-            principal);\n-      }\n     }\n-\n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n \n     container.addGlobalFilter(\"Timeline Authentication Filter\",\n         TimelineAuthenticationFilter.class.getName(),\n         filterConfig);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    setAuthFilterConfig(conf);\n\n    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          PseudoDelegationTokenAuthenticationHandler.class.getName());\n    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          KerberosDelegationTokenAuthenticationHandler.class.getName());\n    }\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "879de51206ddef132c092ee21e8b6c6e5976a56e": {
      "type": "Yfilerename",
      "commitMessage": "YARN-5647. [ATSv2 Security] Collector side changes for loading auth filters and principals. Contributed by Varun Saxena\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "879de51206ddef132c092ee21e8b6c6e5976a56e",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "24447b36260f930acec60b9306f7e381f816a99e",
      "commitAuthorOld": "vrushali",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        // yarn.timeline-service.http-authentication.proxyuser will override\n        // hadoop.proxyuser\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          PseudoDelegationTokenAuthenticationHandler.class.getName());\n    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          KerberosDelegationTokenAuthenticationHandler.class.getName());\n\n      // Resolve _HOST into bind address\n      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n      String principal \u003d\n          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n      if (principal !\u003d null) {\n        try {\n          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n        } catch (IOException ex) {\n          throw new RuntimeException(\n              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n        }\n        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n            principal);\n      }\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java"
      }
    },
    "e4b8d9e72d54d4725bf2a902452459b6b243b2e9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10670. Allow AuthenticationFilters to load secret from signature secret files. Contributed by Kai Zheng.\n",
      "commitDate": "25/03/15 11:12 AM",
      "commitName": "e4b8d9e72d54d4725bf2a902452459b6b243b2e9",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "16/03/15 7:19 AM",
      "commitNameOld": "3da9a97cfbcc3a1c50aaf85b1a129d4d269cd5fd",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 9.16,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,56 @@\n   public void initFilter(FilterContainer container, Configuration conf) {\n     filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n \n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n       if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n         String value \u003d conf.get(name);\n         name \u003d name.substring(\"hadoop.\".length());\n         filterConfig.put(name, value);\n       }\n     }\n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n       if (name.startsWith(PREFIX)) {\n         // yarn.timeline-service.http-authentication.proxyuser will override\n         // hadoop.proxyuser\n         String value \u003d conf.get(name);\n         name \u003d name.substring(PREFIX.length());\n         filterConfig.put(name, value);\n       }\n     }\n \n-    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n-    if (signatureSecretFile !\u003d null) {\n-      Reader reader \u003d null;\n-      try {\n-        StringBuilder secret \u003d new StringBuilder();\n-        reader \u003d new InputStreamReader(new FileInputStream(new File(signatureSecretFile)),\n-                                      Charset.forName(\"UTF-8\"));\n-\n-        int c \u003d reader.read();\n-        while (c \u003e -1) {\n-          secret.append((char) c);\n-          c \u003d reader.read();\n-        }\n-        filterConfig\n-            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n-                secret.toString());\n-      } catch (IOException ex) {\n-        throw new RuntimeException(\n-            \"Could not read HTTP signature secret file: \"\n-                + signatureSecretFile);\n-      } finally {\n-        IOUtils.closeStream(reader);\n-      }\n-    }\n-\n     String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n     if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           PseudoDelegationTokenAuthenticationHandler.class.getName());\n     } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           KerberosDelegationTokenAuthenticationHandler.class.getName());\n \n       // Resolve _HOST into bind address\n       String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n       String principal \u003d\n           filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n       if (principal !\u003d null) {\n         try {\n           principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n         } catch (IOException ex) {\n           throw new RuntimeException(\n               \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n         }\n         filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n             principal);\n       }\n     }\n \n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n \n     container.addGlobalFilter(\"Timeline Authentication Filter\",\n         TimelineAuthenticationFilter.class.getName(),\n         filterConfig);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        // yarn.timeline-service.http-authentication.proxyuser will override\n        // hadoop.proxyuser\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          PseudoDelegationTokenAuthenticationHandler.class.getName());\n    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          KerberosDelegationTokenAuthenticationHandler.class.getName());\n\n      // Resolve _HOST into bind address\n      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n      String principal \u003d\n          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n      if (principal !\u003d null) {\n        try {\n          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n        } catch (IOException ex) {\n          throw new RuntimeException(\n              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n        }\n        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n            principal);\n      }\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2938. Fixed new findbugs warnings in hadoop-yarn-resourcemanager and hadoop-yarn-applicationhistoryservice. Contributed by Varun Saxena.\n",
      "commitDate": "29/12/14 9:59 AM",
      "commitName": "241d3b3a50c6af92f023d8b2c24598f4813f4674",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "17/10/14 10:02 PM",
      "commitNameOld": "39063cd36f96e351e4a6bf0bc2b6185711d4b059",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 72.54,
      "commitsBetweenForRepo": 557,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,81 @@\n   public void initFilter(FilterContainer container, Configuration conf) {\n     filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n \n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n       if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n         String value \u003d conf.get(name);\n         name \u003d name.substring(\"hadoop.\".length());\n         filterConfig.put(name, value);\n       }\n     }\n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n       if (name.startsWith(PREFIX)) {\n         // yarn.timeline-service.http-authentication.proxyuser will override\n         // hadoop.proxyuser\n         String value \u003d conf.get(name);\n         name \u003d name.substring(PREFIX.length());\n         filterConfig.put(name, value);\n       }\n     }\n \n     String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n     if (signatureSecretFile !\u003d null) {\n       Reader reader \u003d null;\n       try {\n         StringBuilder secret \u003d new StringBuilder();\n-        reader \u003d new FileReader(signatureSecretFile);\n+        reader \u003d new InputStreamReader(new FileInputStream(new File(signatureSecretFile)),\n+                                      Charset.forName(\"UTF-8\"));\n+\n         int c \u003d reader.read();\n         while (c \u003e -1) {\n           secret.append((char) c);\n           c \u003d reader.read();\n         }\n         filterConfig\n             .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                 secret.toString());\n       } catch (IOException ex) {\n         throw new RuntimeException(\n             \"Could not read HTTP signature secret file: \"\n                 + signatureSecretFile);\n       } finally {\n         IOUtils.closeStream(reader);\n       }\n     }\n \n     String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n     if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           PseudoDelegationTokenAuthenticationHandler.class.getName());\n     } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n       filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n           KerberosDelegationTokenAuthenticationHandler.class.getName());\n \n       // Resolve _HOST into bind address\n       String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n       String principal \u003d\n           filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n       if (principal !\u003d null) {\n         try {\n           principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n         } catch (IOException ex) {\n           throw new RuntimeException(\n               \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n         }\n         filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n             principal);\n       }\n     }\n \n     filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n         TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n \n     container.addGlobalFilter(\"Timeline Authentication Filter\",\n         TimelineAuthenticationFilter.class.getName(),\n         filterConfig);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        // yarn.timeline-service.http-authentication.proxyuser will override\n        // hadoop.proxyuser\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d new InputStreamReader(new FileInputStream(new File(signatureSecretFile)),\n                                      Charset.forName(\"UTF-8\"));\n\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig\n            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                secret.toString());\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \"\n                + signatureSecretFile);\n      } finally {\n        IOUtils.closeStream(reader);\n      }\n    }\n\n    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          PseudoDelegationTokenAuthenticationHandler.class.getName());\n    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          KerberosDelegationTokenAuthenticationHandler.class.getName());\n\n      // Resolve _HOST into bind address\n      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n      String principal \u003d\n          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n      if (principal !\u003d null) {\n        try {\n          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n        } catch (IOException ex) {\n          throw new RuntimeException(\n              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n        }\n        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n            principal);\n      }\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "39063cd36f96e351e4a6bf0bc2b6185711d4b059": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2676. Enhanced Timeline auth-filter to support proxy users. Contributed by Zhijie Shen.\n",
      "commitDate": "17/10/14 10:02 PM",
      "commitName": "39063cd36f96e351e4a6bf0bc2b6185711d4b059",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/07/14 9:33 PM",
      "commitNameOld": "a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 95.02,
      "commitsBetweenForRepo": 946,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,79 @@\n   public void initFilter(FilterContainer container, Configuration conf) {\n-    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n+    filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n \n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n+      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n+        String value \u003d conf.get(name);\n+        name \u003d name.substring(\"hadoop.\".length());\n+        filterConfig.put(name, value);\n+      }\n+    }\n+    for (Map.Entry\u003cString, String\u003e entry : conf) {\n+      String name \u003d entry.getKey();\n       if (name.startsWith(PREFIX)) {\n+        // yarn.timeline-service.http-authentication.proxyuser will override\n+        // hadoop.proxyuser\n         String value \u003d conf.get(name);\n         name \u003d name.substring(PREFIX.length());\n         filterConfig.put(name, value);\n       }\n     }\n \n     String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n     if (signatureSecretFile !\u003d null) {\n       Reader reader \u003d null;\n       try {\n         StringBuilder secret \u003d new StringBuilder();\n         reader \u003d new FileReader(signatureSecretFile);\n         int c \u003d reader.read();\n         while (c \u003e -1) {\n           secret.append((char) c);\n           c \u003d reader.read();\n         }\n         filterConfig\n             .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                 secret.toString());\n       } catch (IOException ex) {\n         throw new RuntimeException(\n             \"Could not read HTTP signature secret file: \"\n                 + signatureSecretFile);\n       } finally {\n         IOUtils.closeStream(reader);\n       }\n     }\n \n-    // Resolve _HOST into bind address\n-    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n-    String principal \u003d\n-        filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n-    if (principal !\u003d null) {\n-      try {\n-        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n-      } catch (IOException ex) {\n-        throw new RuntimeException(\n-            \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n+    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n+    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n+      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n+          PseudoDelegationTokenAuthenticationHandler.class.getName());\n+    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n+      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n+          KerberosDelegationTokenAuthenticationHandler.class.getName());\n+\n+      // Resolve _HOST into bind address\n+      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n+      String principal \u003d\n+          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n+      if (principal !\u003d null) {\n+        try {\n+          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n+        } catch (IOException ex) {\n+          throw new RuntimeException(\n+              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n+        }\n+        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n+            principal);\n       }\n-      filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n-          principal);\n     }\n \n+    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n+        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n+\n     container.addGlobalFilter(\"Timeline Authentication Filter\",\n         TimelineAuthenticationFilter.class.getName(),\n         filterConfig);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(ProxyUsers.CONF_HADOOP_PROXYUSER)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(\"hadoop.\".length());\n        filterConfig.put(name, value);\n      }\n    }\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        // yarn.timeline-service.http-authentication.proxyuser will override\n        // hadoop.proxyuser\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d new FileReader(signatureSecretFile);\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig\n            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                secret.toString());\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \"\n                + signatureSecretFile);\n      } finally {\n        IOUtils.closeStream(reader);\n      }\n    }\n\n    String authType \u003d filterConfig.get(AuthenticationFilter.AUTH_TYPE);\n    if (authType.equals(PseudoAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          PseudoDelegationTokenAuthenticationHandler.class.getName());\n    } else if (authType.equals(KerberosAuthenticationHandler.TYPE)) {\n      filterConfig.put(AuthenticationFilter.AUTH_TYPE,\n          KerberosDelegationTokenAuthenticationHandler.class.getName());\n\n      // Resolve _HOST into bind address\n      String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n      String principal \u003d\n          filterConfig.get(KerberosAuthenticationHandler.PRINCIPAL);\n      if (principal !\u003d null) {\n        try {\n          principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n        } catch (IOException ex) {\n          throw new RuntimeException(\n              \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n        }\n        filterConfig.put(KerberosAuthenticationHandler.PRINCIPAL,\n            principal);\n      }\n    }\n\n    filterConfig.put(DelegationTokenAuthenticationHandler.TOKEN_KIND,\n        TimelineDelegationTokenIdentifier.KIND_NAME.toString());\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "08b4aa699a40e6095736f344d3ff59bec37c7e6e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2117. Fixed the issue that secret file reader is potentially not closed in TimelineAuthenticationFilterInitializer. Contributed by Chen He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 1:07 PM",
      "commitName": "08b4aa699a40e6095736f344d3ff59bec37c7e6e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 11:09 AM",
      "commitNameOld": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 9.08,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,57 @@\n   public void initFilter(FilterContainer container, Configuration conf) {\n     Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n \n     // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n     filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n \n     for (Map.Entry\u003cString, String\u003e entry : conf) {\n       String name \u003d entry.getKey();\n       if (name.startsWith(PREFIX)) {\n         String value \u003d conf.get(name);\n         name \u003d name.substring(PREFIX.length());\n         filterConfig.put(name, value);\n       }\n     }\n \n     String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n     if (signatureSecretFile !\u003d null) {\n+      Reader reader \u003d null;\n       try {\n         StringBuilder secret \u003d new StringBuilder();\n-        Reader reader \u003d new FileReader(signatureSecretFile);\n+        reader \u003d new FileReader(signatureSecretFile);\n         int c \u003d reader.read();\n         while (c \u003e -1) {\n           secret.append((char) c);\n           c \u003d reader.read();\n         }\n-        reader.close();\n         filterConfig\n             .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                 secret.toString());\n       } catch (IOException ex) {\n         throw new RuntimeException(\n             \"Could not read HTTP signature secret file: \"\n                 + signatureSecretFile);\n+      } finally {\n+        IOUtils.closeStream(reader);\n       }\n     }\n \n     // Resolve _HOST into bind address\n     String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n     String principal \u003d\n         filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n     if (principal !\u003d null) {\n       try {\n         principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n       } catch (IOException ex) {\n         throw new RuntimeException(\n             \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n       }\n       filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n           principal);\n     }\n \n     container.addGlobalFilter(\"Timeline Authentication Filter\",\n         TimelineAuthenticationFilter.class.getName(),\n         filterConfig);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n    if (signatureSecretFile !\u003d null) {\n      Reader reader \u003d null;\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        reader \u003d new FileReader(signatureSecretFile);\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        filterConfig\n            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                secret.toString());\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \"\n                + signatureSecretFile);\n      } finally {\n        IOUtils.closeStream(reader);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d\n        filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n          principal);\n    }\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {}
    },
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": {
      "type": "Yfilerename",
      "commitMessage": "YARN-2107. Refactored timeline classes into o.a.h.y.s.timeline package. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/14 11:09 AM",
      "commitName": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 10:44 AM",
      "commitNameOld": "cfd8647d0f20c08761f908be1f5b718c1c372498",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n    if (signatureSecretFile !\u003d null) {\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        Reader reader \u003d new FileReader(signatureSecretFile);\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        reader.close();\n        filterConfig\n            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                secret.toString());\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \"\n                + signatureSecretFile);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d\n        filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n          principal);\n    }\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/security/TimelineAuthenticationFilterInitializer.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/security/TimelineAuthenticationFilterInitializer.java"
      }
    },
    "b867b695565c588e8f86c867cba76397cab62848": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2049. Added delegation-token support for the Timeline Server. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597130 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/14 10:09 AM",
      "commitName": "b867b695565c588e8f86c867cba76397cab62848",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,55 @@\n+  public void initFilter(FilterContainer container, Configuration conf) {\n+    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n+\n+    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n+    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n+\n+    for (Map.Entry\u003cString, String\u003e entry : conf) {\n+      String name \u003d entry.getKey();\n+      if (name.startsWith(PREFIX)) {\n+        String value \u003d conf.get(name);\n+        name \u003d name.substring(PREFIX.length());\n+        filterConfig.put(name, value);\n+      }\n+    }\n+\n+    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n+    if (signatureSecretFile !\u003d null) {\n+      try {\n+        StringBuilder secret \u003d new StringBuilder();\n+        Reader reader \u003d new FileReader(signatureSecretFile);\n+        int c \u003d reader.read();\n+        while (c \u003e -1) {\n+          secret.append((char) c);\n+          c \u003d reader.read();\n+        }\n+        reader.close();\n+        filterConfig\n+            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n+                secret.toString());\n+      } catch (IOException ex) {\n+        throw new RuntimeException(\n+            \"Could not read HTTP signature secret file: \"\n+                + signatureSecretFile);\n+      }\n+    }\n+\n+    // Resolve _HOST into bind address\n+    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n+    String principal \u003d\n+        filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n+    if (principal !\u003d null) {\n+      try {\n+        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n+      } catch (IOException ex) {\n+        throw new RuntimeException(\n+            \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n+      }\n+      filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n+          principal);\n+    }\n+\n+    container.addGlobalFilter(\"Timeline Authentication Filter\",\n+        TimelineAuthenticationFilter.class.getName(),\n+        filterConfig);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void initFilter(FilterContainer container, Configuration conf) {\n    Map\u003cString, String\u003e filterConfig \u003d new HashMap\u003cString, String\u003e();\n\n    // setting the cookie path to root \u0027/\u0027 so it is used for all resources.\n    filterConfig.put(TimelineAuthenticationFilter.COOKIE_PATH, \"/\");\n\n    for (Map.Entry\u003cString, String\u003e entry : conf) {\n      String name \u003d entry.getKey();\n      if (name.startsWith(PREFIX)) {\n        String value \u003d conf.get(name);\n        name \u003d name.substring(PREFIX.length());\n        filterConfig.put(name, value);\n      }\n    }\n\n    String signatureSecretFile \u003d filterConfig.get(SIGNATURE_SECRET_FILE);\n    if (signatureSecretFile !\u003d null) {\n      try {\n        StringBuilder secret \u003d new StringBuilder();\n        Reader reader \u003d new FileReader(signatureSecretFile);\n        int c \u003d reader.read();\n        while (c \u003e -1) {\n          secret.append((char) c);\n          c \u003d reader.read();\n        }\n        reader.close();\n        filterConfig\n            .put(TimelineAuthenticationFilter.SIGNATURE_SECRET,\n                secret.toString());\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not read HTTP signature secret file: \"\n                + signatureSecretFile);\n      }\n    }\n\n    // Resolve _HOST into bind address\n    String bindAddress \u003d conf.get(HttpServer2.BIND_ADDRESS);\n    String principal \u003d\n        filterConfig.get(TimelineClientAuthenticationService.PRINCIPAL);\n    if (principal !\u003d null) {\n      try {\n        principal \u003d SecurityUtil.getServerPrincipal(principal, bindAddress);\n      } catch (IOException ex) {\n        throw new RuntimeException(\n            \"Could not resolve Kerberos principal name: \" + ex.toString(), ex);\n      }\n      filterConfig.put(TimelineClientAuthenticationService.PRINCIPAL,\n          principal);\n    }\n\n    container.addGlobalFilter(\"Timeline Authentication Filter\",\n        TimelineAuthenticationFilter.class.getName(),\n        filterConfig);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/security/TimelineAuthenticationFilterInitializer.java"
    }
  }
}