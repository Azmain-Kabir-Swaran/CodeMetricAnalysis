{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "isGoodDatanode",
  "functionId": "isGoodDatanode___node-DatanodeDescriptor__maxTargetPerRack-int__considerLoad-boolean__results-List__DatanodeStorageInfo____avoidStaleNodes-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 1003,
  "functionEndLine": 1042,
  "numCommitsSeen": 198,
  "timeTaken": 6328,
  "changeHistory": [
    "27978bcb66a9130cbf26d37ec454c0b7fcdc2530",
    "5bf7e594d7d54e5295fe4240c3d60c08d4755ab7",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
    "bf6aa30a156b3c5cac5469014a5989e0dfdc7256",
    "80a29906bcd718bbba223fa099e523281d9f3369",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "41980c56d3c01d7a0ddc7deea2d89b7f28026722",
    "22a41dce4af4d5b533ba875b322551db1c152878",
    "551024915d487957d9e829493ab319c8e31dfa81",
    "2f341414dd4a052bee3907ff4a6db283a15f9d53",
    "204704a92df407c06951cca9a47e85f1e3ef5ba7",
    "26a1fda51e325377734c90399850ff3aa44b5bc1"
  ],
  "changeHistoryShort": {
    "27978bcb66a9130cbf26d37ec454c0b7fcdc2530": "Ybodychange",
    "5bf7e594d7d54e5295fe4240c3d60c08d4755ab7": "Ybodychange",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": "Ybodychange",
    "bf6aa30a156b3c5cac5469014a5989e0dfdc7256": "Ybodychange",
    "80a29906bcd718bbba223fa099e523281d9f3369": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "41980c56d3c01d7a0ddc7deea2d89b7f28026722": "Ybodychange",
    "22a41dce4af4d5b533ba875b322551db1c152878": "Ymultichange(Yparameterchange,Ybodychange)",
    "551024915d487957d9e829493ab319c8e31dfa81": "Ybodychange",
    "2f341414dd4a052bee3907ff4a6db283a15f9d53": "Ybodychange",
    "204704a92df407c06951cca9a47e85f1e3ef5ba7": "Ybodychange",
    "26a1fda51e325377734c90399850ff3aa44b5bc1": "Ybodychange"
  },
  "changeHistoryDetails": {
    "27978bcb66a9130cbf26d37ec454c0b7fcdc2530": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13833. Improve BlockPlacementPolicyDefault\u0027s consider load logic. Contributed by Shweta.\n\nSigned-off-by: Xiao Chen \u003cxiao@apache.org\u003e\n",
      "commitDate": "18/09/18 8:23 PM",
      "commitName": "27978bcb66a9130cbf26d37ec454c0b7fcdc2530",
      "commitAuthor": "Shweta",
      "commitDateOld": "08/08/18 8:31 AM",
      "commitNameOld": "36c0d742d484f8bf01d7cb01c7b1c9e3627625dc",
      "commitAuthorOld": "MÃ¡rton Elek",
      "daysBetweenCommits": 41.49,
      "commitsBetweenForRepo": 396,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,40 @@\n   boolean isGoodDatanode(DatanodeDescriptor node,\n                          int maxTargetPerRack, boolean considerLoad,\n                          List\u003cDatanodeStorageInfo\u003e results,\n                          boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (!node.isInService()) {\n       logNodeIsNotChosen(node, NodeNotChosenReason.NOT_IN_SERVICE);\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(node, NodeNotChosenReason.NODE_STALE);\n         return false;\n       }\n     }\n \n     // check the communication traffic of the target machine\n-    if (considerLoad) {\n-      final double maxLoad \u003d considerLoadFactor *\n-          stats.getInServiceXceiverAverage();\n-      final int nodeLoad \u003d node.getXceiverCount();\n-      if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_TOO_BUSY,\n-            \"(load: \" + nodeLoad + \" \u003e \" + maxLoad + \")\");\n+    if(considerLoad){\n+      if(excludeNodeByLoad(node)){\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter \u003e maxTargetPerRack) {\n       logNodeIsNotChosen(node, NodeNotChosenReason.TOO_MANY_NODES_ON_RACK);\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (!node.isInService()) {\n      logNodeIsNotChosen(node, NodeNotChosenReason.NOT_IN_SERVICE);\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_STALE);\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if(considerLoad){\n      if(excludeNodeByLoad(node)){\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, NodeNotChosenReason.TOO_MANY_NODES_ON_RACK);\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "5bf7e594d7d54e5295fe4240c3d60c08d4755ab7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9023. When NN is not able to identify DN for replication, reason behind it can be logged.\n",
      "commitDate": "28/12/17 11:54 AM",
      "commitName": "5bf7e594d7d54e5295fe4240c3d60c08d4755ab7",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "08/11/17 10:14 PM",
      "commitNameOld": "3a3566e1d1ab5f78cfb734796b41802fe039196d",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 49.57,
      "commitsBetweenForRepo": 278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   boolean isGoodDatanode(DatanodeDescriptor node,\n                          int maxTargetPerRack, boolean considerLoad,\n                          List\u003cDatanodeStorageInfo\u003e results,\n                          boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (!node.isInService()) {\n-      logNodeIsNotChosen(node, \"the node isn\u0027t in service.\");\n+      logNodeIsNotChosen(node, NodeNotChosenReason.NOT_IN_SERVICE);\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n-        logNodeIsNotChosen(node, \"the node is stale \");\n+        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_STALE);\n         return false;\n       }\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d considerLoadFactor *\n           stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n-            + \" \u003e \" + maxLoad + \") \");\n+        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_TOO_BUSY,\n+            \"(load: \" + nodeLoad + \" \u003e \" + maxLoad + \")\");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter \u003e maxTargetPerRack) {\n-      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n+      logNodeIsNotChosen(node, NodeNotChosenReason.TOO_MANY_NODES_ON_RACK);\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (!node.isInService()) {\n      logNodeIsNotChosen(node, NodeNotChosenReason.NOT_IN_SERVICE);\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_STALE);\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d considerLoadFactor *\n          stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, NodeNotChosenReason.NODE_TOO_BUSY,\n            \"(load: \" + nodeLoad + \" \u003e \" + maxLoad + \")\");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, NodeNotChosenReason.TOO_MANY_NODES_ON_RACK);\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9390. Block management for maintenance states.\n",
      "commitDate": "17/10/16 5:45 PM",
      "commitName": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "06/10/16 5:17 AM",
      "commitNameOld": "b90fc70d671481564e468550c770c925f25d7db0",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 11.52,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   boolean isGoodDatanode(DatanodeDescriptor node,\n                          int maxTargetPerRack, boolean considerLoad,\n                          List\u003cDatanodeStorageInfo\u003e results,\n                          boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n-    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n-      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n+    if (!node.isInService()) {\n+      logNodeIsNotChosen(node, \"the node isn\u0027t in service.\");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d considerLoadFactor *\n           stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n         logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter \u003e maxTargetPerRack) {\n       logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (!node.isInService()) {\n      logNodeIsNotChosen(node, \"the node isn\u0027t in service.\");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d considerLoadFactor *\n          stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "bf6aa30a156b3c5cac5469014a5989e0dfdc7256": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9318. considerLoad factor can be improved. Contributed by Kuhu Shukla.\n",
      "commitDate": "06/11/15 11:30 AM",
      "commitName": "bf6aa30a156b3c5cac5469014a5989e0dfdc7256",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "05/11/15 7:25 AM",
      "commitNameOld": "ff47f35deed14ba6463cba76f0e6a6c15abb3eca",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   boolean isGoodDatanode(DatanodeDescriptor node,\n                          int maxTargetPerRack, boolean considerLoad,\n                          List\u003cDatanodeStorageInfo\u003e results,\n                          boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n-      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n+      final double maxLoad \u003d considerLoadFactor *\n+          stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n         logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter \u003e maxTargetPerRack) {\n       logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d considerLoadFactor *\n          stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "80a29906bcd718bbba223fa099e523281d9f3369": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
      "commitDate": "20/08/15 5:07 AM",
      "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
      "commitAuthor": "yliu",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
          "commitDate": "20/08/15 5:07 AM",
          "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
          "commitAuthor": "yliu",
          "commitDateOld": "29/06/15 2:55 AM",
          "commitNameOld": "88ceb382ef45bd09cf004cf44aedbabaf3976759",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 52.09,
          "commitsBetweenForRepo": 309,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,44 @@\n-  private boolean isGoodTarget(DatanodeStorageInfo storage,\n-                               long blockSize, int maxTargetPerRack,\n-                               boolean considerLoad,\n-                               List\u003cDatanodeStorageInfo\u003e results,\n-                               boolean avoidStaleNodes,\n-                               StorageType requiredStorageType) {\n-    if (storage.getStorageType() !\u003d requiredStorageType) {\n-      logNodeIsNotChosen(storage, \"storage types do not match,\"\n-          + \" where the required storage type is \" + requiredStorageType);\n-      return false;\n-    }\n-    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n-      logNodeIsNotChosen(storage, \"storage is read-only\");\n-      return false;\n-    }\n-\n-    if (storage.getState() \u003d\u003d State.FAILED) {\n-      logNodeIsNotChosen(storage, \"storage has failed\");\n-      return false;\n-    }\n-\n-    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n+  boolean isGoodDatanode(DatanodeDescriptor node,\n+                         int maxTargetPerRack, boolean considerLoad,\n+                         List\u003cDatanodeStorageInfo\u003e results,\n+                         boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n-      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n+      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n-        logNodeIsNotChosen(storage, \"the node is stale \");\n+        logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n-    \n-    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n-    final long remaining \u003d node.getRemaining(storage.getStorageType());\n-    if (requiredSize \u003e remaining - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough \"\n-          + storage.getStorageType() + \" space\"\n-          + \" (required\u003d\" + requiredSize\n-          + \", scheduled\u003d\" + scheduledSize\n-          + \", remaining\u003d\" + remaining + \")\");\n-      return false;\n-    }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n-    if (counter\u003emaxTargetPerRack) {\n-      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n+    if (counter \u003e maxTargetPerRack) {\n+      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "isGoodTarget",
            "newValue": "isGoodDatanode"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
          "commitDate": "20/08/15 5:07 AM",
          "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
          "commitAuthor": "yliu",
          "commitDateOld": "29/06/15 2:55 AM",
          "commitNameOld": "88ceb382ef45bd09cf004cf44aedbabaf3976759",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 52.09,
          "commitsBetweenForRepo": 309,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,44 @@\n-  private boolean isGoodTarget(DatanodeStorageInfo storage,\n-                               long blockSize, int maxTargetPerRack,\n-                               boolean considerLoad,\n-                               List\u003cDatanodeStorageInfo\u003e results,\n-                               boolean avoidStaleNodes,\n-                               StorageType requiredStorageType) {\n-    if (storage.getStorageType() !\u003d requiredStorageType) {\n-      logNodeIsNotChosen(storage, \"storage types do not match,\"\n-          + \" where the required storage type is \" + requiredStorageType);\n-      return false;\n-    }\n-    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n-      logNodeIsNotChosen(storage, \"storage is read-only\");\n-      return false;\n-    }\n-\n-    if (storage.getState() \u003d\u003d State.FAILED) {\n-      logNodeIsNotChosen(storage, \"storage has failed\");\n-      return false;\n-    }\n-\n-    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n+  boolean isGoodDatanode(DatanodeDescriptor node,\n+                         int maxTargetPerRack, boolean considerLoad,\n+                         List\u003cDatanodeStorageInfo\u003e results,\n+                         boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n-      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n+      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n-        logNodeIsNotChosen(storage, \"the node is stale \");\n+        logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n-    \n-    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n-    final long remaining \u003d node.getRemaining(storage.getStorageType());\n-    if (requiredSize \u003e remaining - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough \"\n-          + storage.getStorageType() + \" space\"\n-          + \" (required\u003d\" + requiredSize\n-          + \", scheduled\u003d\" + scheduledSize\n-          + \", remaining\u003d\" + remaining + \")\");\n-      return false;\n-    }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n-    if (counter\u003emaxTargetPerRack) {\n-      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n+    if (counter \u003e maxTargetPerRack) {\n+      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[storage-DatanodeStorageInfo, blockSize-long, maxTargetPerRack-int, considerLoad-boolean, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean, requiredStorageType-StorageType]",
            "newValue": "[node-DatanodeDescriptor, maxTargetPerRack-int, considerLoad-boolean, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
          "commitDate": "20/08/15 5:07 AM",
          "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
          "commitAuthor": "yliu",
          "commitDateOld": "29/06/15 2:55 AM",
          "commitNameOld": "88ceb382ef45bd09cf004cf44aedbabaf3976759",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 52.09,
          "commitsBetweenForRepo": 309,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,44 @@\n-  private boolean isGoodTarget(DatanodeStorageInfo storage,\n-                               long blockSize, int maxTargetPerRack,\n-                               boolean considerLoad,\n-                               List\u003cDatanodeStorageInfo\u003e results,\n-                               boolean avoidStaleNodes,\n-                               StorageType requiredStorageType) {\n-    if (storage.getStorageType() !\u003d requiredStorageType) {\n-      logNodeIsNotChosen(storage, \"storage types do not match,\"\n-          + \" where the required storage type is \" + requiredStorageType);\n-      return false;\n-    }\n-    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n-      logNodeIsNotChosen(storage, \"storage is read-only\");\n-      return false;\n-    }\n-\n-    if (storage.getState() \u003d\u003d State.FAILED) {\n-      logNodeIsNotChosen(storage, \"storage has failed\");\n-      return false;\n-    }\n-\n-    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n+  boolean isGoodDatanode(DatanodeDescriptor node,\n+                         int maxTargetPerRack, boolean considerLoad,\n+                         List\u003cDatanodeStorageInfo\u003e results,\n+                         boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n-      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n+      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n-        logNodeIsNotChosen(storage, \"the node is stale \");\n+        logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n-    \n-    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n-    final long remaining \u003d node.getRemaining(storage.getStorageType());\n-    if (requiredSize \u003e remaining - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough \"\n-          + storage.getStorageType() + \" space\"\n-          + \" (required\u003d\" + requiredSize\n-          + \", scheduled\u003d\" + scheduledSize\n-          + \", remaining\u003d\" + remaining + \")\");\n-      return false;\n-    }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n-    if (counter\u003emaxTargetPerRack) {\n-      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n+    if (counter \u003e maxTargetPerRack) {\n+      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8884. Fail-fast check in BlockPlacementPolicyDefault#chooseTarget. (yliu)\n",
          "commitDate": "20/08/15 5:07 AM",
          "commitName": "80a29906bcd718bbba223fa099e523281d9f3369",
          "commitAuthor": "yliu",
          "commitDateOld": "29/06/15 2:55 AM",
          "commitNameOld": "88ceb382ef45bd09cf004cf44aedbabaf3976759",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 52.09,
          "commitsBetweenForRepo": 309,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,44 @@\n-  private boolean isGoodTarget(DatanodeStorageInfo storage,\n-                               long blockSize, int maxTargetPerRack,\n-                               boolean considerLoad,\n-                               List\u003cDatanodeStorageInfo\u003e results,\n-                               boolean avoidStaleNodes,\n-                               StorageType requiredStorageType) {\n-    if (storage.getStorageType() !\u003d requiredStorageType) {\n-      logNodeIsNotChosen(storage, \"storage types do not match,\"\n-          + \" where the required storage type is \" + requiredStorageType);\n-      return false;\n-    }\n-    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n-      logNodeIsNotChosen(storage, \"storage is read-only\");\n-      return false;\n-    }\n-\n-    if (storage.getState() \u003d\u003d State.FAILED) {\n-      logNodeIsNotChosen(storage, \"storage has failed\");\n-      return false;\n-    }\n-\n-    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n+  boolean isGoodDatanode(DatanodeDescriptor node,\n+                         int maxTargetPerRack, boolean considerLoad,\n+                         List\u003cDatanodeStorageInfo\u003e results,\n+                         boolean avoidStaleNodes) {\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n-      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n+      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n-        logNodeIsNotChosen(storage, \"the node is stale \");\n+        logNodeIsNotChosen(node, \"the node is stale \");\n         return false;\n       }\n     }\n-    \n-    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n-    final long remaining \u003d node.getRemaining(storage.getStorageType());\n-    if (requiredSize \u003e remaining - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough \"\n-          + storage.getStorageType() + \" space\"\n-          + \" (required\u003d\" + requiredSize\n-          + \", scheduled\u003d\" + scheduledSize\n-          + \", remaining\u003d\" + remaining + \")\");\n-      return false;\n-    }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n-    if (counter\u003emaxTargetPerRack) {\n-      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n+    if (counter \u003e maxTargetPerRack) {\n+      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n       return false;\n     }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  boolean isGoodDatanode(DatanodeDescriptor node,\n                         int maxTargetPerRack, boolean considerLoad,\n                         List\u003cDatanodeStorageInfo\u003e results,\n                         boolean avoidStaleNodes) {\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(node, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(node, \"the node is stale \");\n        return false;\n      }\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(node, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter \u003e maxTargetPerRack) {\n      logNodeIsNotChosen(node, \"the rack has too many chosen nodes \");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "16/04/15 6:25 PM",
      "commitNameOld": "9595cc003ca5ed3d59b6942056a4fcb9080f79c9",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 15.65,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType requiredStorageType) {\n     if (storage.getStorageType() !\u003d requiredStorageType) {\n       logNodeIsNotChosen(storage, \"storage types do not match,\"\n           + \" where the required storage type is \" + requiredStorageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n \n     if (storage.getState() \u003d\u003d State.FAILED) {\n       logNodeIsNotChosen(storage, \"storage has failed\");\n       return false;\n     }\n \n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n-    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n+    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n     final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n     final long remaining \u003d node.getRemaining(storage.getStorageType());\n     if (requiredSize \u003e remaining - scheduledSize) {\n       logNodeIsNotChosen(storage, \"the node does not have enough \"\n           + storage.getStorageType() + \" space\"\n           + \" (required\u003d\" + requiredSize\n           + \", scheduled\u003d\" + scheduledSize\n           + \", remaining\u003d\" + remaining + \")\");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n         logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType requiredStorageType) {\n    if (storage.getStorageType() !\u003d requiredStorageType) {\n      logNodeIsNotChosen(storage, \"storage types do not match,\"\n          + \" where the required storage type is \" + requiredStorageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n\n    if (storage.getState() \u003d\u003d State.FAILED) {\n      logNodeIsNotChosen(storage, \"storage has failed\");\n      return false;\n    }\n\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsServerConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n    final long remaining \u003d node.getRemaining(storage.getStorageType());\n    if (requiredSize \u003e remaining - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough \"\n          + storage.getStorageType() + \" space\"\n          + \" (required\u003d\" + requiredSize\n          + \", scheduled\u003d\" + scheduledSize\n          + \", remaining\u003d\" + remaining + \")\");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "41980c56d3c01d7a0ddc7deea2d89b7f28026722": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7208. NN doesn\u0027t schedule replication when a DN storage fails.  Contributed by Ming Ma\n",
      "commitDate": "15/10/14 8:44 PM",
      "commitName": "41980c56d3c01d7a0ddc7deea2d89b7f28026722",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/10/14 2:01 AM",
      "commitNameOld": "ed841dd9a96e54cb84d9cae5507e47ff1c8cdf6e",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 9.78,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,73 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType requiredStorageType) {\n     if (storage.getStorageType() !\u003d requiredStorageType) {\n       logNodeIsNotChosen(storage, \"storage types do not match,\"\n           + \" where the required storage type is \" + requiredStorageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n+\n+    if (storage.getState() \u003d\u003d State.FAILED) {\n+      logNodeIsNotChosen(storage, \"storage has failed\");\n+      return false;\n+    }\n+\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n     final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n     final long remaining \u003d node.getRemaining(storage.getStorageType());\n     if (requiredSize \u003e remaining - scheduledSize) {\n       logNodeIsNotChosen(storage, \"the node does not have enough \"\n           + storage.getStorageType() + \" space\"\n           + \" (required\u003d\" + requiredSize\n           + \", scheduled\u003d\" + scheduledSize\n           + \", remaining\u003d\" + remaining + \")\");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n         logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n             + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType requiredStorageType) {\n    if (storage.getStorageType() !\u003d requiredStorageType) {\n      logNodeIsNotChosen(storage, \"storage types do not match,\"\n          + \" where the required storage type is \" + requiredStorageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n\n    if (storage.getState() \u003d\u003d State.FAILED) {\n      logNodeIsNotChosen(storage, \"storage has failed\");\n      return false;\n    }\n\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n    final long remaining \u003d node.getRemaining(storage.getStorageType());\n    if (requiredSize \u003e remaining - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough \"\n          + storage.getStorageType() + \" space\"\n          + \" (required\u003d\" + requiredSize\n          + \", scheduled\u003d\" + scheduledSize\n          + \", remaining\u003d\" + remaining + \")\");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "22a41dce4af4d5b533ba875b322551db1c152878": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6997: add more tests for data migration and replicaion.\n",
      "commitDate": "06/09/14 4:44 PM",
      "commitName": "22a41dce4af4d5b533ba875b322551db1c152878",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6997: add more tests for data migration and replicaion.\n",
          "commitDate": "06/09/14 4:44 PM",
          "commitName": "22a41dce4af4d5b533ba875b322551db1c152878",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "04/09/14 2:19 PM",
          "commitNameOld": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 2.1,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,67 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n-                               StorageType storageType) {\n-    if (storage.getStorageType() !\u003d storageType) {\n-      logNodeIsNotChosen(storage,\n-          \"storage types do not match, where the expected storage type is \"\n-              + storageType);\n+                               StorageType requiredStorageType) {\n+    if (storage.getStorageType() !\u003d requiredStorageType) {\n+      logNodeIsNotChosen(storage, \"storage types do not match,\"\n+          + \" where the required storage type is \" + requiredStorageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n-    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n+    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n+    final long remaining \u003d node.getRemaining(storage.getStorageType());\n+    if (requiredSize \u003e remaining - scheduledSize) {\n+      logNodeIsNotChosen(storage, \"the node does not have enough \"\n+          + storage.getStorageType() + \" space\"\n+          + \" (required\u003d\" + requiredSize\n+          + \", scheduled\u003d\" + scheduledSize\n+          + \", remaining\u003d\" + remaining + \")\");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage,\n-            \"the node is too busy (load:\"+nodeLoad+\" \u003e \"+maxLoad+\") \");\n+        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+            + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType requiredStorageType) {\n    if (storage.getStorageType() !\u003d requiredStorageType) {\n      logNodeIsNotChosen(storage, \"storage types do not match,\"\n          + \" where the required storage type is \" + requiredStorageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n    final long remaining \u003d node.getRemaining(storage.getStorageType());\n    if (requiredSize \u003e remaining - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough \"\n          + storage.getStorageType() + \" space\"\n          + \" (required\u003d\" + requiredSize\n          + \", scheduled\u003d\" + scheduledSize\n          + \", remaining\u003d\" + remaining + \")\");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[storage-DatanodeStorageInfo, blockSize-long, maxTargetPerRack-int, considerLoad-boolean, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean, storageType-StorageType]",
            "newValue": "[storage-DatanodeStorageInfo, blockSize-long, maxTargetPerRack-int, considerLoad-boolean, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean, requiredStorageType-StorageType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6997: add more tests for data migration and replicaion.\n",
          "commitDate": "06/09/14 4:44 PM",
          "commitName": "22a41dce4af4d5b533ba875b322551db1c152878",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "04/09/14 2:19 PM",
          "commitNameOld": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 2.1,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,67 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n-                               StorageType storageType) {\n-    if (storage.getStorageType() !\u003d storageType) {\n-      logNodeIsNotChosen(storage,\n-          \"storage types do not match, where the expected storage type is \"\n-              + storageType);\n+                               StorageType requiredStorageType) {\n+    if (storage.getStorageType() !\u003d requiredStorageType) {\n+      logNodeIsNotChosen(storage, \"storage types do not match,\"\n+          + \" where the required storage type is \" + requiredStorageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n-    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n+    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n+    final long remaining \u003d node.getRemaining(storage.getStorageType());\n+    if (requiredSize \u003e remaining - scheduledSize) {\n+      logNodeIsNotChosen(storage, \"the node does not have enough \"\n+          + storage.getStorageType() + \" space\"\n+          + \" (required\u003d\" + requiredSize\n+          + \", scheduled\u003d\" + scheduledSize\n+          + \", remaining\u003d\" + remaining + \")\");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n       final int nodeLoad \u003d node.getXceiverCount();\n       if (nodeLoad \u003e maxLoad) {\n-        logNodeIsNotChosen(storage,\n-            \"the node is too busy (load:\"+nodeLoad+\" \u003e \"+maxLoad+\") \");\n+        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n+            + \" \u003e \" + maxLoad + \") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType requiredStorageType) {\n    if (storage.getStorageType() !\u003d requiredStorageType) {\n      logNodeIsNotChosen(storage, \"storage types do not match,\"\n          + \" where the required storage type is \" + requiredStorageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled(storage.getStorageType());\n    final long remaining \u003d node.getRemaining(storage.getStorageType());\n    if (requiredSize \u003e remaining - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough \"\n          + storage.getStorageType() + \" space\"\n          + \" (required\u003d\" + requiredSize\n          + \", scheduled\u003d\" + scheduledSize\n          + \", remaining\u003d\" + remaining + \")\");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(storage, \"the node is too busy (load: \" + nodeLoad\n            + \" \u003e \" + maxLoad + \") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "551024915d487957d9e829493ab319c8e31dfa81": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6599. 2.4 addBlock is 10 to 20 times slower compared to 0.23 (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611737 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 10:58 AM",
      "commitName": "551024915d487957d9e829493ab319c8e31dfa81",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "18/07/14 10:40 AM",
      "commitNameOld": "08466eaa0045658fa7919a634e48f2d0669f8414",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,63 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType storageType) {\n     if (storage.getStorageType() !\u003d storageType) {\n       logNodeIsNotChosen(storage,\n           \"storage types do not match, where the expected storage type is \"\n               + storageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n     final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n     if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n       logNodeIsNotChosen(storage, \"the node does not have enough space \");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n-      double avgLoad \u003d 0;\n-      if (stats !\u003d null) {\n-        int size \u003d stats.getNumDatanodesInService();\n-        if (size !\u003d 0) {\n-          avgLoad \u003d (double)stats.getTotalLoad()/size;\n-        }\n-      }\n-      if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n-        logNodeIsNotChosen(storage, \"the node is too busy \");\n+      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n+      final int nodeLoad \u003d node.getXceiverCount();\n+      if (nodeLoad \u003e maxLoad) {\n+        logNodeIsNotChosen(storage,\n+            \"the node is too busy (load:\"+nodeLoad+\" \u003e \"+maxLoad+\") \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType storageType) {\n    if (storage.getStorageType() !\u003d storageType) {\n      logNodeIsNotChosen(storage,\n          \"storage types do not match, where the expected storage type is \"\n              + storageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      final double maxLoad \u003d 2.0 * stats.getInServiceXceiverAverage();\n      final int nodeLoad \u003d node.getXceiverCount();\n      if (nodeLoad \u003e maxLoad) {\n        logNodeIsNotChosen(storage,\n            \"the node is too busy (load:\"+nodeLoad+\" \u003e \"+maxLoad+\") \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "2f341414dd4a052bee3907ff4a6db283a15f9d53": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5318. Support read-only and read-write paths to shared replicas. (Contributed by Eric Sirianni)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569951 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/02/14 2:59 PM",
      "commitName": "2f341414dd4a052bee3907ff4a6db283a15f9d53",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "09/02/14 12:49 PM",
      "commitNameOld": "204704a92df407c06951cca9a47e85f1e3ef5ba7",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 10.09,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType storageType) {\n     if (storage.getStorageType() !\u003d storageType) {\n       logNodeIsNotChosen(storage,\n           \"storage types do not match, where the expected storage type is \"\n               + storageType);\n       return false;\n     }\n-    if (storage.getState() \u003d\u003d State.READ_ONLY) {\n+    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n     final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n     if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n       logNodeIsNotChosen(storage, \"the node does not have enough space \");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       double avgLoad \u003d 0;\n       if (stats !\u003d null) {\n         int size \u003d stats.getNumDatanodesInService();\n         if (size !\u003d 0) {\n           avgLoad \u003d (double)stats.getTotalLoad()/size;\n         }\n       }\n       if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n         logNodeIsNotChosen(storage, \"the node is too busy \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType storageType) {\n    if (storage.getStorageType() !\u003d storageType) {\n      logNodeIsNotChosen(storage,\n          \"storage types do not match, where the expected storage type is \"\n              + storageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY_SHARED) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      double avgLoad \u003d 0;\n      if (stats !\u003d null) {\n        int size \u003d stats.getNumDatanodesInService();\n        if (size !\u003d 0) {\n          avgLoad \u003d (double)stats.getTotalLoad()/size;\n        }\n      }\n      if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n        logNodeIsNotChosen(storage, \"the node is too busy \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "204704a92df407c06951cca9a47e85f1e3ef5ba7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5837. dfs.namenode.replication.considerLoad should consider decommissioned nodes. Contributed by Tao Luo.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566410 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/14 12:49 PM",
      "commitName": "204704a92df407c06951cca9a47e85f1e3ef5ba7",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "02/02/14 7:39 AM",
      "commitNameOld": "94b512bc51ecb5f4eafcf17676a340a6033aefe4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.22,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType storageType) {\n     if (storage.getStorageType() !\u003d storageType) {\n       logNodeIsNotChosen(storage,\n           \"storage types do not match, where the expected storage type is \"\n               + storageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n     final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n     if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n       logNodeIsNotChosen(storage, \"the node does not have enough space \");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       double avgLoad \u003d 0;\n-      int size \u003d clusterMap.getNumOfLeaves();\n-      if (size !\u003d 0 \u0026\u0026 stats !\u003d null) {\n-        avgLoad \u003d (double)stats.getTotalLoad()/size;\n+      if (stats !\u003d null) {\n+        int size \u003d stats.getNumDatanodesInService();\n+        if (size !\u003d 0) {\n+          avgLoad \u003d (double)stats.getTotalLoad()/size;\n+        }\n       }\n       if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n         logNodeIsNotChosen(storage, \"the node is too busy \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType storageType) {\n    if (storage.getStorageType() !\u003d storageType) {\n      logNodeIsNotChosen(storage,\n          \"storage types do not match, where the expected storage type is \"\n              + storageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      double avgLoad \u003d 0;\n      if (stats !\u003d null) {\n        int size \u003d stats.getNumDatanodesInService();\n        if (size !\u003d 0) {\n          avgLoad \u003d (double)stats.getTotalLoad()/size;\n        }\n      }\n      if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n        logNodeIsNotChosen(storage, \"the node is too busy \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "26a1fda51e325377734c90399850ff3aa44b5bc1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5452. Fix TestReplicationPolicy and TestBlocksScheduledCounter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1538407 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/11/13 9:49 AM",
      "commitName": "26a1fda51e325377734c90399850ff3aa44b5bc1",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/10/13 10:24 AM",
      "commitNameOld": "ef17685f796866ffbcda9f9a0844e65d918ad07c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 12.02,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   private boolean isGoodTarget(DatanodeStorageInfo storage,\n                                long blockSize, int maxTargetPerRack,\n                                boolean considerLoad,\n                                List\u003cDatanodeStorageInfo\u003e results,\n                                boolean avoidStaleNodes,\n                                StorageType storageType) {\n     if (storage.getStorageType() !\u003d storageType) {\n       logNodeIsNotChosen(storage,\n           \"storage types do not match, where the expected storage type is \"\n               + storageType);\n       return false;\n     }\n     if (storage.getState() \u003d\u003d State.READ_ONLY) {\n       logNodeIsNotChosen(storage, \"storage is read-only\");\n       return false;\n     }\n     DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n     // check if the node is (being) decommissioned\n     if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n       logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n       return false;\n     }\n \n     if (avoidStaleNodes) {\n       if (node.isStale(this.staleInterval)) {\n         logNodeIsNotChosen(storage, \"the node is stale \");\n         return false;\n       }\n     }\n     \n     final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n-    final long scheduledSize \u003d blockSize \u003d storage.getBlocksScheduled();\n-    if (requiredSize \u003e storage.getRemaining() - scheduledSize) {\n-      logNodeIsNotChosen(storage, \"the storage does not have enough space \");\n+    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n+    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n+      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n       return false;\n     }\n \n     // check the communication traffic of the target machine\n     if (considerLoad) {\n       double avgLoad \u003d 0;\n       int size \u003d clusterMap.getNumOfLeaves();\n       if (size !\u003d 0 \u0026\u0026 stats !\u003d null) {\n         avgLoad \u003d (double)stats.getTotalLoad()/size;\n       }\n       if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n         logNodeIsNotChosen(storage, \"the node is too busy \");\n         return false;\n       }\n     }\n       \n     // check if the target rack has chosen too many nodes\n     String rackname \u003d node.getNetworkLocation();\n     int counter\u003d1;\n     for(DatanodeStorageInfo resultStorage : results) {\n       if (rackname.equals(\n           resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n         counter++;\n       }\n     }\n     if (counter\u003emaxTargetPerRack) {\n       logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n       return false;\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean isGoodTarget(DatanodeStorageInfo storage,\n                               long blockSize, int maxTargetPerRack,\n                               boolean considerLoad,\n                               List\u003cDatanodeStorageInfo\u003e results,\n                               boolean avoidStaleNodes,\n                               StorageType storageType) {\n    if (storage.getStorageType() !\u003d storageType) {\n      logNodeIsNotChosen(storage,\n          \"storage types do not match, where the expected storage type is \"\n              + storageType);\n      return false;\n    }\n    if (storage.getState() \u003d\u003d State.READ_ONLY) {\n      logNodeIsNotChosen(storage, \"storage is read-only\");\n      return false;\n    }\n    DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n    // check if the node is (being) decommissioned\n    if (node.isDecommissionInProgress() || node.isDecommissioned()) {\n      logNodeIsNotChosen(storage, \"the node is (being) decommissioned \");\n      return false;\n    }\n\n    if (avoidStaleNodes) {\n      if (node.isStale(this.staleInterval)) {\n        logNodeIsNotChosen(storage, \"the node is stale \");\n        return false;\n      }\n    }\n    \n    final long requiredSize \u003d blockSize * HdfsConstants.MIN_BLOCKS_FOR_WRITE;\n    final long scheduledSize \u003d blockSize * node.getBlocksScheduled();\n    if (requiredSize \u003e node.getRemaining() - scheduledSize) {\n      logNodeIsNotChosen(storage, \"the node does not have enough space \");\n      return false;\n    }\n\n    // check the communication traffic of the target machine\n    if (considerLoad) {\n      double avgLoad \u003d 0;\n      int size \u003d clusterMap.getNumOfLeaves();\n      if (size !\u003d 0 \u0026\u0026 stats !\u003d null) {\n        avgLoad \u003d (double)stats.getTotalLoad()/size;\n      }\n      if (node.getXceiverCount() \u003e (2.0 * avgLoad)) {\n        logNodeIsNotChosen(storage, \"the node is too busy \");\n        return false;\n      }\n    }\n      \n    // check if the target rack has chosen too many nodes\n    String rackname \u003d node.getNetworkLocation();\n    int counter\u003d1;\n    for(DatanodeStorageInfo resultStorage : results) {\n      if (rackname.equals(\n          resultStorage.getDatanodeDescriptor().getNetworkLocation())) {\n        counter++;\n      }\n    }\n    if (counter\u003emaxTargetPerRack) {\n      logNodeIsNotChosen(storage, \"the rack has too many chosen nodes \");\n      return false;\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    }
  }
}