{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineV2ClientImpl.java",
  "functionName": "createRunnable",
  "functionId": "createRunnable",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
  "functionStartLine": 446,
  "functionEndLine": 544,
  "numCommitsSeen": 56,
  "timeTaken": 2414,
  "changeHistory": [
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "0d02ab8729630ad3cfb4300702927333b1d349e3"
  ],
  "changeHistoryShort": {
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ymovefromfile",
    "0d02ab8729630ad3cfb4300702927333b1d349e3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6342. Make TimelineV2Client\u0027s drain timeout after stop configurable (Haibo Chen via Varun Saxena)\n",
      "commitDate": "30/03/17 1:32 PM",
      "commitName": "7c2bc444b3d6750aafeed9b530c8e5b1bf95c1f4",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "16/02/17 11:41 AM",
      "commitNameOld": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 42.04,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n     Runnable createRunnable() {\n       return new Runnable() {\n         @Override\n         public void run() {\n           try {\n             EntitiesHolder entitiesHolder;\n             while (!Thread.currentThread().isInterrupted()) {\n               // Merge all the async calls and make one push, but if its sync\n               // call push immediately\n               try {\n                 entitiesHolder \u003d timelineEntityQueue.take();\n               } catch (InterruptedException ie) {\n                 LOG.info(\"Timeline dispatcher thread was interrupted \");\n                 Thread.currentThread().interrupt();\n                 return;\n               }\n               if (entitiesHolder !\u003d null) {\n                 publishWithoutBlockingOnQueue(entitiesHolder);\n               }\n             }\n           } finally {\n             if (!timelineEntityQueue.isEmpty()) {\n               LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                   + \" timelineEntities, draining them now. \");\n             }\n             // Try to drain the remaining entities to be published @ the max for\n             // 2 seconds\n             long timeTillweDrain \u003d\n-                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n+                System.currentTimeMillis() + drainTimeoutPeriod;\n             while (!timelineEntityQueue.isEmpty()) {\n               publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n               if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                 // time elapsed stop publishing further....\n                 if (!timelineEntityQueue.isEmpty()) {\n                   LOG.warn(\"Time to drain elapsed! Remaining \"\n                       + timelineEntityQueue.size() + \"timelineEntities will not\"\n                       + \" be published\");\n                   // if some entities were not drained then we need interrupt\n                   // the threads which had put sync EntityHolders to the queue.\n                   EntitiesHolder nextEntityInTheQueue \u003d null;\n                   while ((nextEntityInTheQueue \u003d\n                       timelineEntityQueue.poll()) !\u003d null) {\n                     nextEntityInTheQueue.cancel(true);\n                   }\n                 }\n                 break;\n               }\n             }\n           }\n         }\n \n         /**\n          * Publishes the given EntitiesHolder and return immediately if sync\n          * call, else tries to fetch the EntitiesHolder from the queue in non\n          * blocking fashion and collate the Entities if possible before\n          * publishing through REST.\n          *\n          * @param entitiesHolder\n          */\n         private void publishWithoutBlockingOnQueue(\n             EntitiesHolder entitiesHolder) {\n           if (entitiesHolder.isSync()) {\n             entitiesHolder.run();\n             return;\n           }\n           int count \u003d 1;\n           while (true) {\n             // loop till we find a sync put Entities or there is nothing\n             // to take\n             EntitiesHolder nextEntityInTheQueue \u003d timelineEntityQueue.poll();\n             if (nextEntityInTheQueue \u003d\u003d null) {\n               // Nothing in the queue just publish and get back to the\n               // blocked wait state\n               entitiesHolder.run();\n               break;\n             } else if (nextEntityInTheQueue.isSync()) {\n               // flush all the prev async entities first\n               entitiesHolder.run();\n               // and then flush the sync entity\n               nextEntityInTheQueue.run();\n               break;\n             } else {\n               // append all async entities together and then flush\n               entitiesHolder.getEntities().addEntities(\n                   nextEntityInTheQueue.getEntities().getEntities());\n               count++;\n               if (count \u003d\u003d numberOfAsyncsToMerge) {\n                 // Flush the entities if the number of the async\n                 // putEntites merged reaches the desired limit. To avoid\n                 // collecting multiple entities and delaying for a long\n                 // time.\n                 entitiesHolder.run();\n                 break;\n               }\n             }\n           }\n         }\n       };\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Runnable createRunnable() {\n      return new Runnable() {\n        @Override\n        public void run() {\n          try {\n            EntitiesHolder entitiesHolder;\n            while (!Thread.currentThread().isInterrupted()) {\n              // Merge all the async calls and make one push, but if its sync\n              // call push immediately\n              try {\n                entitiesHolder \u003d timelineEntityQueue.take();\n              } catch (InterruptedException ie) {\n                LOG.info(\"Timeline dispatcher thread was interrupted \");\n                Thread.currentThread().interrupt();\n                return;\n              }\n              if (entitiesHolder !\u003d null) {\n                publishWithoutBlockingOnQueue(entitiesHolder);\n              }\n            }\n          } finally {\n            if (!timelineEntityQueue.isEmpty()) {\n              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                  + \" timelineEntities, draining them now. \");\n            }\n            // Try to drain the remaining entities to be published @ the max for\n            // 2 seconds\n            long timeTillweDrain \u003d\n                System.currentTimeMillis() + drainTimeoutPeriod;\n            while (!timelineEntityQueue.isEmpty()) {\n              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                // time elapsed stop publishing further....\n                if (!timelineEntityQueue.isEmpty()) {\n                  LOG.warn(\"Time to drain elapsed! Remaining \"\n                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n                      + \" be published\");\n                  // if some entities were not drained then we need interrupt\n                  // the threads which had put sync EntityHolders to the queue.\n                  EntitiesHolder nextEntityInTheQueue \u003d null;\n                  while ((nextEntityInTheQueue \u003d\n                      timelineEntityQueue.poll()) !\u003d null) {\n                    nextEntityInTheQueue.cancel(true);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        /**\n         * Publishes the given EntitiesHolder and return immediately if sync\n         * call, else tries to fetch the EntitiesHolder from the queue in non\n         * blocking fashion and collate the Entities if possible before\n         * publishing through REST.\n         *\n         * @param entitiesHolder\n         */\n        private void publishWithoutBlockingOnQueue(\n            EntitiesHolder entitiesHolder) {\n          if (entitiesHolder.isSync()) {\n            entitiesHolder.run();\n            return;\n          }\n          int count \u003d 1;\n          while (true) {\n            // loop till we find a sync put Entities or there is nothing\n            // to take\n            EntitiesHolder nextEntityInTheQueue \u003d timelineEntityQueue.poll();\n            if (nextEntityInTheQueue \u003d\u003d null) {\n              // Nothing in the queue just publish and get back to the\n              // blocked wait state\n              entitiesHolder.run();\n              break;\n            } else if (nextEntityInTheQueue.isSync()) {\n              // flush all the prev async entities first\n              entitiesHolder.run();\n              // and then flush the sync entity\n              nextEntityInTheQueue.run();\n              break;\n            } else {\n              // append all async entities together and then flush\n              entitiesHolder.getEntities().addEntities(\n                  nextEntityInTheQueue.getEntities().getEntities());\n              count++;\n              if (count \u003d\u003d numberOfAsyncsToMerge) {\n                // Flush the entities if the number of the async\n                // putEntites merged reaches the desired limit. To avoid\n                // collecting multiple entities and delaying for a long\n                // time.\n                entitiesHolder.run();\n                break;\n              }\n            }\n          }\n        }\n      };\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "16/02/17 5:39 AM",
      "commitNameOld": "5690b51ef7c708c0a71162ddaff04466bc71cdcc",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    Runnable createRunnable() {\n      return new Runnable() {\n        @Override\n        public void run() {\n          try {\n            EntitiesHolder entitiesHolder;\n            while (!Thread.currentThread().isInterrupted()) {\n              // Merge all the async calls and make one push, but if its sync\n              // call push immediately\n              try {\n                entitiesHolder \u003d timelineEntityQueue.take();\n              } catch (InterruptedException ie) {\n                LOG.info(\"Timeline dispatcher thread was interrupted \");\n                Thread.currentThread().interrupt();\n                return;\n              }\n              if (entitiesHolder !\u003d null) {\n                publishWithoutBlockingOnQueue(entitiesHolder);\n              }\n            }\n          } finally {\n            if (!timelineEntityQueue.isEmpty()) {\n              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                  + \" timelineEntities, draining them now. \");\n            }\n            // Try to drain the remaining entities to be published @ the max for\n            // 2 seconds\n            long timeTillweDrain \u003d\n                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n            while (!timelineEntityQueue.isEmpty()) {\n              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                // time elapsed stop publishing further....\n                if (!timelineEntityQueue.isEmpty()) {\n                  LOG.warn(\"Time to drain elapsed! Remaining \"\n                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n                      + \" be published\");\n                  // if some entities were not drained then we need interrupt\n                  // the threads which had put sync EntityHolders to the queue.\n                  EntitiesHolder nextEntityInTheQueue \u003d null;\n                  while ((nextEntityInTheQueue \u003d\n                      timelineEntityQueue.poll()) !\u003d null) {\n                    nextEntityInTheQueue.cancel(true);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        /**\n         * Publishes the given EntitiesHolder and return immediately if sync\n         * call, else tries to fetch the EntitiesHolder from the queue in non\n         * blocking fashion and collate the Entities if possible before\n         * publishing through REST.\n         *\n         * @param entitiesHolder\n         */\n        private void publishWithoutBlockingOnQueue(\n            EntitiesHolder entitiesHolder) {\n          if (entitiesHolder.isSync()) {\n            entitiesHolder.run();\n            return;\n          }\n          int count \u003d 1;\n          while (true) {\n            // loop till we find a sync put Entities or there is nothing\n            // to take\n            EntitiesHolder nextEntityInTheQueue \u003d timelineEntityQueue.poll();\n            if (nextEntityInTheQueue \u003d\u003d null) {\n              // Nothing in the queue just publish and get back to the\n              // blocked wait state\n              entitiesHolder.run();\n              break;\n            } else if (nextEntityInTheQueue.isSync()) {\n              // flush all the prev async entities first\n              entitiesHolder.run();\n              // and then flush the sync entity\n              nextEntityInTheQueue.run();\n              break;\n            } else {\n              // append all async entities together and then flush\n              entitiesHolder.getEntities().addEntities(\n                  nextEntityInTheQueue.getEntities().getEntities());\n              count++;\n              if (count \u003d\u003d numberOfAsyncsToMerge) {\n                // Flush the entities if the number of the async\n                // putEntites merged reaches the desired limit. To avoid\n                // collecting multiple entities and delaying for a long\n                // time.\n                entitiesHolder.run();\n                break;\n              }\n            }\n          }\n        }\n      };\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineClientImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineV2ClientImpl.java",
        "oldMethodName": "createRunnable",
        "newMethodName": "createRunnable"
      }
    },
    "0d02ab8729630ad3cfb4300702927333b1d349e3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3367. Replace starting a separate thread for post entity with event loop in TimelineClient (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "0d02ab8729630ad3cfb4300702927333b1d349e3",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,99 @@\n+    Runnable createRunnable() {\n+      return new Runnable() {\n+        @Override\n+        public void run() {\n+          try {\n+            EntitiesHolder entitiesHolder;\n+            while (!Thread.currentThread().isInterrupted()) {\n+              // Merge all the async calls and make one push, but if its sync\n+              // call push immediately\n+              try {\n+                entitiesHolder \u003d timelineEntityQueue.take();\n+              } catch (InterruptedException ie) {\n+                LOG.info(\"Timeline dispatcher thread was interrupted \");\n+                Thread.currentThread().interrupt();\n+                return;\n+              }\n+              if (entitiesHolder !\u003d null) {\n+                publishWithoutBlockingOnQueue(entitiesHolder);\n+              }\n+            }\n+          } finally {\n+            if (!timelineEntityQueue.isEmpty()) {\n+              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n+                  + \" timelineEntities, draining them now. \");\n+            }\n+            // Try to drain the remaining entities to be published @ the max for\n+            // 2 seconds\n+            long timeTillweDrain \u003d\n+                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n+            while (!timelineEntityQueue.isEmpty()) {\n+              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n+              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n+                // time elapsed stop publishing further....\n+                if (!timelineEntityQueue.isEmpty()) {\n+                  LOG.warn(\"Time to drain elapsed! Remaining \"\n+                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n+                      + \" be published\");\n+                  // if some entities were not drained then we need interrupt\n+                  // the threads which had put sync EntityHolders to the queue.\n+                  EntitiesHolder nextEntityInTheQueue \u003d null;\n+                  while ((nextEntityInTheQueue \u003d\n+                      timelineEntityQueue.poll()) !\u003d null) {\n+                    nextEntityInTheQueue.cancel(true);\n+                  }\n+                }\n+                break;\n+              }\n+            }\n+          }\n+        }\n+\n+        /**\n+         * Publishes the given EntitiesHolder and return immediately if sync\n+         * call, else tries to fetch the EntitiesHolder from the queue in non\n+         * blocking fashion and collate the Entities if possible before\n+         * publishing through REST.\n+         *\n+         * @param entitiesHolder\n+         */\n+        private void publishWithoutBlockingOnQueue(\n+            EntitiesHolder entitiesHolder) {\n+          if (entitiesHolder.isSync()) {\n+            entitiesHolder.run();\n+            return;\n+          }\n+          int count \u003d 1;\n+          while (true) {\n+            // loop till we find a sync put Entities or there is nothing\n+            // to take\n+            EntitiesHolder nextEntityInTheQueue \u003d timelineEntityQueue.poll();\n+            if (nextEntityInTheQueue \u003d\u003d null) {\n+              // Nothing in the queue just publish and get back to the\n+              // blocked wait state\n+              entitiesHolder.run();\n+              break;\n+            } else if (nextEntityInTheQueue.isSync()) {\n+              // flush all the prev async entities first\n+              entitiesHolder.run();\n+              // and then flush the sync entity\n+              nextEntityInTheQueue.run();\n+              break;\n+            } else {\n+              // append all async entities together and then flush\n+              entitiesHolder.getEntities().addEntities(\n+                  nextEntityInTheQueue.getEntities().getEntities());\n+              count++;\n+              if (count \u003d\u003d numberOfAsyncsToMerge) {\n+                // Flush the entities if the number of the async\n+                // putEntites merged reaches the desired limit. To avoid\n+                // collecting multiple entities and delaying for a long\n+                // time.\n+                entitiesHolder.run();\n+                break;\n+              }\n+            }\n+          }\n+        }\n+      };\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    Runnable createRunnable() {\n      return new Runnable() {\n        @Override\n        public void run() {\n          try {\n            EntitiesHolder entitiesHolder;\n            while (!Thread.currentThread().isInterrupted()) {\n              // Merge all the async calls and make one push, but if its sync\n              // call push immediately\n              try {\n                entitiesHolder \u003d timelineEntityQueue.take();\n              } catch (InterruptedException ie) {\n                LOG.info(\"Timeline dispatcher thread was interrupted \");\n                Thread.currentThread().interrupt();\n                return;\n              }\n              if (entitiesHolder !\u003d null) {\n                publishWithoutBlockingOnQueue(entitiesHolder);\n              }\n            }\n          } finally {\n            if (!timelineEntityQueue.isEmpty()) {\n              LOG.info(\"Yet to publish \" + timelineEntityQueue.size()\n                  + \" timelineEntities, draining them now. \");\n            }\n            // Try to drain the remaining entities to be published @ the max for\n            // 2 seconds\n            long timeTillweDrain \u003d\n                System.currentTimeMillis() + DRAIN_TIME_PERIOD;\n            while (!timelineEntityQueue.isEmpty()) {\n              publishWithoutBlockingOnQueue(timelineEntityQueue.poll());\n              if (System.currentTimeMillis() \u003e timeTillweDrain) {\n                // time elapsed stop publishing further....\n                if (!timelineEntityQueue.isEmpty()) {\n                  LOG.warn(\"Time to drain elapsed! Remaining \"\n                      + timelineEntityQueue.size() + \"timelineEntities will not\"\n                      + \" be published\");\n                  // if some entities were not drained then we need interrupt\n                  // the threads which had put sync EntityHolders to the queue.\n                  EntitiesHolder nextEntityInTheQueue \u003d null;\n                  while ((nextEntityInTheQueue \u003d\n                      timelineEntityQueue.poll()) !\u003d null) {\n                    nextEntityInTheQueue.cancel(true);\n                  }\n                }\n                break;\n              }\n            }\n          }\n        }\n\n        /**\n         * Publishes the given EntitiesHolder and return immediately if sync\n         * call, else tries to fetch the EntitiesHolder from the queue in non\n         * blocking fashion and collate the Entities if possible before\n         * publishing through REST.\n         *\n         * @param entitiesHolder\n         */\n        private void publishWithoutBlockingOnQueue(\n            EntitiesHolder entitiesHolder) {\n          if (entitiesHolder.isSync()) {\n            entitiesHolder.run();\n            return;\n          }\n          int count \u003d 1;\n          while (true) {\n            // loop till we find a sync put Entities or there is nothing\n            // to take\n            EntitiesHolder nextEntityInTheQueue \u003d timelineEntityQueue.poll();\n            if (nextEntityInTheQueue \u003d\u003d null) {\n              // Nothing in the queue just publish and get back to the\n              // blocked wait state\n              entitiesHolder.run();\n              break;\n            } else if (nextEntityInTheQueue.isSync()) {\n              // flush all the prev async entities first\n              entitiesHolder.run();\n              // and then flush the sync entity\n              nextEntityInTheQueue.run();\n              break;\n            } else {\n              // append all async entities together and then flush\n              entitiesHolder.getEntities().addEntities(\n                  nextEntityInTheQueue.getEntities().getEntities());\n              count++;\n              if (count \u003d\u003d numberOfAsyncsToMerge) {\n                // Flush the entities if the number of the async\n                // putEntites merged reaches the desired limit. To avoid\n                // collecting multiple entities and delaying for a long\n                // time.\n                entitiesHolder.run();\n                break;\n              }\n            }\n          }\n        }\n      };\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/api/impl/TimelineClientImpl.java"
    }
  }
}