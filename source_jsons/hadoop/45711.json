{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationIndexedFileController.java",
  "functionName": "readAggregatedLogsMeta",
  "functionId": "readAggregatedLogsMeta___logRequest-ContainerLogsRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
  "functionStartLine": 615,
  "functionEndLine": 703,
  "numCommitsSeen": 18,
  "timeTaken": 4566,
  "changeHistory": [
    "4af2556b48e01150851c7f273a254a16324ba843",
    "71b2c2ffe962ff4f5799e1f55961db687cb55842",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "583f4594314b3db25b57b1e46ea8026eab21f932",
    "e718ac597f2225cb4946e1ac4b3986c336645643",
    "4d53ef7eefb14661d824924e503a910de1ae997f",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511",
    "280080fad01304c85a9ede4d4f7b707eb36c0155",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc"
  ],
  "changeHistoryShort": {
    "4af2556b48e01150851c7f273a254a16324ba843": "Ybodychange",
    "71b2c2ffe962ff4f5799e1f55961db687cb55842": "Ybodychange",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "583f4594314b3db25b57b1e46ea8026eab21f932": "Ybodychange",
    "e718ac597f2225cb4946e1ac4b3986c336645643": "Ybodychange",
    "4d53ef7eefb14661d824924e503a910de1ae997f": "Ybodychange",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": "Ybodychange",
    "280080fad01304c85a9ede4d4f7b707eb36c0155": "Ybodychange",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4af2556b48e01150851c7f273a254a16324ba843": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10143. YARN-10101 broke Yarn logs CLI. Contributed by Adam Antal\n",
      "commitDate": "20/02/20 6:27 AM",
      "commitName": "4af2556b48e01150851c7f273a254a16324ba843",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "06/02/20 3:25 AM",
      "commitNameOld": "71b2c2ffe962ff4f5799e1f55961db687cb55842",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 14.13,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n-    boolean getAllContainers \u003d ((containerIdStr \u003d\u003d null ||\n-        containerIdStr.isEmpty()) \u0026\u0026 appAttemptId !\u003d null);\n+    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n+        containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n     if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n     if (allFiles.isEmpty()) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         allFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             String currentContainerIdStr \u003d log.getKey();\n-            if (!belongsToAppAttempt(appAttemptId, currentContainerIdStr)) {\n+            if (appAttemptId !\u003d null \u0026\u0026\n+                !belongsToAppAttempt(appAttemptId, currentContainerIdStr)) {\n               continue;\n             }\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModifiedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModifiedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            String currentContainerIdStr \u003d log.getKey();\n            if (appAttemptId !\u003d null \u0026\u0026\n                !belongsToAppAttempt(appAttemptId, currentContainerIdStr)) {\n              continue;\n            }\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModifiedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModifiedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "71b2c2ffe962ff4f5799e1f55961db687cb55842": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10101. Support listing of aggregated logs for containers belonging to an application attempt. Contributed by Adam Antal\n",
      "commitDate": "06/02/20 3:25 AM",
      "commitName": "71b2c2ffe962ff4f5799e1f55961db687cb55842",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "20/01/20 3:36 AM",
      "commitNameOld": "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 16.99,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,88 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n-    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n-        containerIdStr.isEmpty());\n+    ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n+    boolean getAllContainers \u003d ((containerIdStr \u003d\u003d null ||\n+        containerIdStr.isEmpty()) \u0026\u0026 appAttemptId !\u003d null);\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n     if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n     if (allFiles.isEmpty()) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         allFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n+            String currentContainerIdStr \u003d log.getKey();\n+            if (!belongsToAppAttempt(appAttemptId, currentContainerIdStr)) {\n+              continue;\n+            }\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n-                log.getKey().toString(), curNodeId);\n+                log.getKey(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModifiedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModifiedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n    boolean getAllContainers \u003d ((containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty()) \u0026\u0026 appAttemptId !\u003d null);\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            String currentContainerIdStr \u003d log.getKey();\n            if (!belongsToAppAttempt(appAttemptId, currentContainerIdStr)) {\n              continue;\n            }\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModifiedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModifiedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 48.1,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n     if (!nodeFiles.hasNext()) {\n-      throw new IOException(\"There is no available log fils for \"\n+      throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n     if (allFiles.isEmpty()) {\n-      throw new IOException(\"There is no available log fils for \"\n+      throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         allFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n-                  Times.format(aMeta.getLastModificatedTime()));\n+                  Times.format(aMeta.getLastModifiedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n-                Times.format(log.getLastModificatedTime()));\n+                Times.format(log.getLastModifiedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModifiedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModifiedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "583f4594314b3db25b57b1e46ea8026eab21f932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\n\nChange-Id: I16e081f21c5f80160564c49cc49d103bd8eb7e16\n",
      "commitDate": "07/03/18 3:46 PM",
      "commitName": "583f4594314b3db25b57b1e46ea8026eab21f932",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 3:46 PM",
      "commitNameOld": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,83 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n-    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n-    if (nodeFiles.isEmpty()) {\n+    if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n+    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n+    if (allFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        nodeFiles, nodeIdStr, appId);\n+        allFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModificatedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModificatedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "e718ac597f2225cb4946e1ac4b3986c336645643": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\"\n\nThis reverts commit 4d53ef7eefb14661d824924e503a910de1ae997f.\n",
      "commitDate": "07/03/18 3:46 PM",
      "commitName": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 11:30 AM",
      "commitNameOld": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,78 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n-    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n+    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n-    if (!nodeFiles.hasNext()) {\n+    if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n-    if (allFiles.isEmpty()) {\n-      throw new IOException(\"There is no available log fils for \"\n-          + \"application:\" + appId);\n-    }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        allFiles, nodeIdStr, appId);\n+        nodeFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModificatedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModificatedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "4d53ef7eefb14661d824924e503a910de1ae997f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\n\nChange-Id: Ie16e34039d57df50128c73b37516ad0bc7c9590e\n",
      "commitDate": "07/03/18 11:30 AM",
      "commitName": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "11/02/18 6:28 PM",
      "commitNameOld": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 23.71,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,83 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n-    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n-    if (nodeFiles.isEmpty()) {\n+    if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n+    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n+    if (allFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        nodeFiles, nodeIdStr, appId);\n+        allFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModificatedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModificatedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
      "commitDate": "11/02/18 6:28 PM",
      "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/10/17 3:30 PM",
      "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 132.17,
      "commitsBetweenForRepo": 906,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n     if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         nodeFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n         Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n         if (checkSumIndex !\u003d null) {\n           endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n-            thisNodeFile.getPath(), endIndex);\n+            thisNodeFile.getPath(), endIndex, appId);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n-            + thisNodeFile.getPath());\n+            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModificatedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModificatedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex, appId);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "280080fad01304c85a9ede4d4f7b707eb36c0155": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7259. Add size-based rolling policy to LogAggregationIndexedFileController. (xgong via wangda)\n\nChange-Id: Ifaf82c0aee6b73b9b6ebf103aa72e131e3942f31\n",
      "commitDate": "02/10/17 3:30 PM",
      "commitName": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/09/17 10:16 PM",
      "commitNameOld": "c92c1d521eadfd8a4cd8205cc6aee74816f353f4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 18.72,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,78 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n         containerIdStr.isEmpty());\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n         this.remoteRootLogDirSuffix);\n     if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n-        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         nodeFiles, nodeIdStr, appId);\n     for(FileStatus thisNodeFile : fileToRead) {\n       try {\n-        FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n+        Long checkSumIndex \u003d checkSumFiles.get(\n             thisNodeFile.getPath().getName());\n         long endIndex \u003d -1;\n-        if (checkSum !\u003d null) {\n-          endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n+        if (checkSumIndex !\u003d null) {\n+          endIndex \u003d checkSumIndex.longValue();\n         }\n         IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n             thisNodeFile.getPath(), endIndex);\n         if (current !\u003d null) {\n           listOfLogsMeta.add(current);\n         }\n       } catch (IOException ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not get log meta from the log file:\"\n             + thisNodeFile.getPath());\n       }\n     }\n     for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n       String curNodeId \u003d indexedLogMeta.getNodeId();\n       for (IndexedPerAggregationLogMeta logMeta :\n           indexedLogMeta.getLogMetas()) {\n         if (getAllContainers) {\n           for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n               .getLogMetas().entrySet()) {\n             ContainerLogMeta meta \u003d new ContainerLogMeta(\n                 log.getKey().toString(), curNodeId);\n             for (IndexedFileLogMeta aMeta : log.getValue()) {\n               meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                   aMeta.getFileSize()),\n                   Times.format(aMeta.getLastModificatedTime()));\n             }\n             containersLogMeta.add(meta);\n           }\n         } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n           ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n               curNodeId);\n           for (IndexedFileLogMeta log :\n               logMeta.getContainerLogMeta(containerIdStr)) {\n             meta.addLogMeta(log.getFileName(), Long.toString(\n                 log.getFileSize()),\n                 Times.format(log.getLastModificatedTime()));\n           }\n           containersLogMeta.add(meta);\n         }\n       }\n     }\n     Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n       @Override\n       public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n         return o1.getContainerId().compareTo(o2.getContainerId());\n       }\n     });\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        Long checkSumIndex \u003d checkSumFiles.get(\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSumIndex !\u003d null) {\n          endIndex \u003d checkSumIndex.longValue();\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7072. Add a new log aggregation file format controller. Contributed by Xuan Gong.\n",
      "commitDate": "08/09/17 3:16 PM",
      "commitName": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,79 @@\n+  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n+      ContainerLogsRequest logRequest) throws IOException {\n+    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n+    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n+    String containerIdStr \u003d logRequest.getContainerId();\n+    String nodeId \u003d logRequest.getNodeId();\n+    ApplicationId appId \u003d logRequest.getAppId();\n+    String appOwner \u003d logRequest.getAppOwner();\n+    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n+        containerIdStr.isEmpty());\n+    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n+        : LogAggregationUtils.getNodeString(nodeId);\n+    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n+        this.remoteRootLogDirSuffix);\n+    if (nodeFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n+        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n+    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n+        nodeFiles, nodeIdStr, appId);\n+    for(FileStatus thisNodeFile : fileToRead) {\n+      try {\n+        FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n+            thisNodeFile.getPath().getName());\n+        long endIndex \u003d -1;\n+        if (checkSum !\u003d null) {\n+          endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n+        }\n+        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n+            thisNodeFile.getPath(), endIndex);\n+        if (current !\u003d null) {\n+          listOfLogsMeta.add(current);\n+        }\n+      } catch (IOException ex) {\n+        // DO NOTHING\n+        LOG.warn(\"Can not get log meta from the log file:\"\n+            + thisNodeFile.getPath());\n+      }\n+    }\n+    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n+      String curNodeId \u003d indexedLogMeta.getNodeId();\n+      for (IndexedPerAggregationLogMeta logMeta :\n+          indexedLogMeta.getLogMetas()) {\n+        if (getAllContainers) {\n+          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n+              .getLogMetas().entrySet()) {\n+            ContainerLogMeta meta \u003d new ContainerLogMeta(\n+                log.getKey().toString(), curNodeId);\n+            for (IndexedFileLogMeta aMeta : log.getValue()) {\n+              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n+                  aMeta.getFileSize()),\n+                  Times.format(aMeta.getLastModificatedTime()));\n+            }\n+            containersLogMeta.add(meta);\n+          }\n+        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n+          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n+              curNodeId);\n+          for (IndexedFileLogMeta log :\n+              logMeta.getContainerLogMeta(containerIdStr)) {\n+            meta.addLogMeta(log.getFileName(), Long.toString(\n+                log.getFileSize()),\n+                Times.format(log.getLastModificatedTime()));\n+          }\n+          containersLogMeta.add(meta);\n+        }\n+      }\n+    }\n+    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n+      @Override\n+      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n+        return o1.getContainerId().compareTo(o2.getContainerId());\n+      }\n+    });\n+    return containersLogMeta;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cIndexedLogsMeta\u003e listOfLogsMeta \u003d new ArrayList\u003c\u003e();\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null ||\n        containerIdStr.isEmpty());\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, appOwner, this.remoteRootLogDir,\n        this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    for(FileStatus thisNodeFile : fileToRead) {\n      try {\n        FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n            thisNodeFile.getPath().getName());\n        long endIndex \u003d -1;\n        if (checkSum !\u003d null) {\n          endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n        }\n        IndexedLogsMeta current \u003d loadIndexedLogsMeta(\n            thisNodeFile.getPath(), endIndex);\n        if (current !\u003d null) {\n          listOfLogsMeta.add(current);\n        }\n      } catch (IOException ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not get log meta from the log file:\"\n            + thisNodeFile.getPath());\n      }\n    }\n    for (IndexedLogsMeta indexedLogMeta : listOfLogsMeta) {\n      String curNodeId \u003d indexedLogMeta.getNodeId();\n      for (IndexedPerAggregationLogMeta logMeta :\n          indexedLogMeta.getLogMetas()) {\n        if (getAllContainers) {\n          for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e log : logMeta\n              .getLogMetas().entrySet()) {\n            ContainerLogMeta meta \u003d new ContainerLogMeta(\n                log.getKey().toString(), curNodeId);\n            for (IndexedFileLogMeta aMeta : log.getValue()) {\n              meta.addLogMeta(aMeta.getFileName(), Long.toString(\n                  aMeta.getFileSize()),\n                  Times.format(aMeta.getLastModificatedTime()));\n            }\n            containersLogMeta.add(meta);\n          }\n        } else if (logMeta.getContainerLogMeta(containerIdStr) !\u003d null) {\n          ContainerLogMeta meta \u003d new ContainerLogMeta(containerIdStr,\n              curNodeId);\n          for (IndexedFileLogMeta log :\n              logMeta.getContainerLogMeta(containerIdStr)) {\n            meta.addLogMeta(log.getFileName(), Long.toString(\n                log.getFileSize()),\n                Times.format(log.getLastModificatedTime()));\n          }\n          containersLogMeta.add(meta);\n        }\n      }\n    }\n    Collections.sort(containersLogMeta, new Comparator\u003cContainerLogMeta\u003e() {\n      @Override\n      public int compare(ContainerLogMeta o1, ContainerLogMeta o2) {\n        return o1.getContainerId().compareTo(o2.getContainerId());\n      }\n    });\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java"
    }
  }
}