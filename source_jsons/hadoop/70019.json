{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureBlobFileSystemStore.java",
  "functionName": "listStatus",
  "functionId": "listStatus___path-Path(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
  "functionStartLine": 684,
  "functionEndLine": 686,
  "numCommitsSeen": 49,
  "timeTaken": 6785,
  "changeHistory": [
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
    "3988e75ca385aec31ca1fc49d6cffce1ea935825",
    "1f1655028eede24197705a594b6ef19e6737db35",
    "668817a6cefa6025ddfe082ed71d7d317d811381",
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
    "a8302e398c2ca4b0deff062c0e921053351b688e",
    "a383ac47cabe22e563725fae9de73e5e69e51f3e",
    "9c1e4e81399913f180131f4faa95604087c6d962",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae": "Ybodychange",
    "3988e75ca385aec31ca1fc49d6cffce1ea935825": "Ybodychange",
    "1f1655028eede24197705a594b6ef19e6737db35": "Ybodychange",
    "668817a6cefa6025ddfe082ed71d7d317d811381": "Ybodychange",
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d": "Ybodychange",
    "a8302e398c2ca4b0deff062c0e921053351b688e": "Ybodychange",
    "a383ac47cabe22e563725fae9de73e5e69e51f3e": "Ybodychange",
    "9c1e4e81399913f180131f4faa95604087c6d962": "Ybodychange",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": "Ybodychange",
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": "Ybodychange",
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Yparameterchange)",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3418bbbb597d354bf24cfd610c1ad3adb06d8eae": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16269. ABFS: add listFileStatus with StartFrom.\n\nAuthor:    Da Zhou\n",
      "commitDate": "08/05/19 9:20 AM",
      "commitName": "3418bbbb597d354bf24cfd610c1ad3adb06d8eae",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "08/03/19 5:53 AM",
      "commitNameOld": "e0260417ade5568ae37dcc3753aea0d1e0fd701b",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 61.1,
      "commitsBetweenForRepo": 396,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,3 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n-    LOG.debug(\"listStatus filesystem: {} path: {}\",\n-            client.getFileSystem(),\n-           path);\n-\n-    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n-    String continuation \u003d null;\n-    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n-\n-    do {\n-      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n-      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n-      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n-      if (retrievedSchema \u003d\u003d null) {\n-        throw new AbfsRestOperationException(\n-                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-                \"listStatusAsync path not found\",\n-                null, op.getResult());\n-      }\n-\n-      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n-\n-      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n-        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n-                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n-                : AbfsPermission.valueOf(entry.permissions());\n-        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n-\n-        long lastModifiedMillis \u003d 0;\n-        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n-        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n-        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n-          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n-        }\n-\n-        Path entryPath \u003d new Path(File.separator + entry.name());\n-        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n-\n-        fileStatuses.add(\n-                new VersionedFileStatus(\n-                        owner,\n-                        group,\n-                        fsPermission,\n-                        hasAcl,\n-                        contentLength,\n-                        isDirectory,\n-                        1,\n-                        blockSize,\n-                        lastModifiedMillis,\n-                        entryPath,\n-                        entry.eTag()));\n-      }\n-\n-    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n-\n-    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n+    return listStatus(path, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    return listStatus(path, null);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "3988e75ca385aec31ca1fc49d6cffce1ea935825": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16136. ABFS: Should only transform username to short name\n\nContributed by Da Zhou.\n",
      "commitDate": "26/02/19 7:37 AM",
      "commitName": "3988e75ca385aec31ca1fc49d6cffce1ea935825",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "07/02/19 1:58 PM",
      "commitNameOld": "1f1655028eede24197705a594b6ef19e6737db35",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 18.74,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), true, userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), false, primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "1f1655028eede24197705a594b6ef19e6737db35": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\n\nContributed by Da Zhou and Junhua Gu.\n",
      "commitDate": "07/02/19 1:58 PM",
      "commitName": "1f1655028eede24197705a594b6ef19e6737db35",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "07/02/19 1:57 PM",
      "commitNameOld": "668817a6cefa6025ddfe082ed71d7d317d811381",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n-        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[0]);\n+    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "668817a6cefa6025ddfe082ed71d7d317d811381": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\"\n\n(accidentally mixed in two patches)\n\nThis reverts commit fa8cd1bf28f5b81849ba351a2d7225fbc580350d.\n",
      "commitDate": "07/02/19 1:57 PM",
      "commitName": "668817a6cefa6025ddfe082ed71d7d317d811381",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/02/19 11:23 AM",
      "commitNameOld": "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n-        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n+        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n+        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n+    return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "fa8cd1bf28f5b81849ba351a2d7225fbc580350d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15954. ABFS: Enable owner and group conversion for MSI and login user using OAuth.\n\nContributed by Da Zhou and Junhua Gu.\n",
      "commitDate": "05/02/19 11:23 AM",
      "commitName": "fa8cd1bf28f5b81849ba351a2d7225fbc580350d",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "22/01/19 8:40 AM",
      "commitNameOld": "00ad9e23e88d1e1b1f887b6c9473a7a924a95a97",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n-        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n+        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n+        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n-    return fileStatuses.toArray(new FileStatus[0]);\n+    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d identityTransformer.transformIdentityForGetRequest(entry.owner(), userName);\n        final String group \u003d identityTransformer.transformIdentityForGetRequest(entry.group(), primaryUserGroup);\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[fileStatuses.size()]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a8302e398c2ca4b0deff062c0e921053351b688e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15872. ABFS: Update to target 2018-11-09 REST version for ADLS Gen 2.\n\nContributed by Junhua Gu and Da Zhou.\n",
      "commitDate": "23/11/18 6:17 AM",
      "commitName": "a8302e398c2ca4b0deff062c0e921053351b688e",
      "commitAuthor": "Da Zhou",
      "commitDateOld": "13/11/18 1:46 PM",
      "commitNameOld": "a13be203b7877ba56ef63aac4a2e65d4e1a4adbc",
      "commitAuthorOld": "Da Zhou",
      "daysBetweenCommits": 9.69,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n-        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n+        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n+        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d isSuperUserOrEmpty(entry.owner()) ? userName : entry.owner();\n        final String group \u003d isSuperUserOrEmpty(entry.group()) ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a383ac47cabe22e563725fae9de73e5e69e51f3e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15801. ABFS: Fixing skipUserGroupMetadata in AzureBlobFileSystemStore.\nContributed by Da Zhou\n",
      "commitDate": "02/10/18 3:42 AM",
      "commitName": "a383ac47cabe22e563725fae9de73e5e69e51f3e",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/09/18 4:20 AM",
      "commitNameOld": "df2166a6435b4b62011a363ea24dfcc9bc44181c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n-        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n-        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n+        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n+        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n         final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                 ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                 : AbfsPermission.valueOf(entry.permissions());\n         final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n \n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         owner,\n                         group,\n                         fsPermission,\n                         hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d entry.owner() \u003d\u003d null ? userName : entry.owner();\n        final String group \u003d entry.group() \u003d\u003d null ? primaryUserGroup : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "9c1e4e81399913f180131f4faa95604087c6d962": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15661. ABFS: Add support for ACL.\nContributed by Junhua Gu and Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "9c1e4e81399913f180131f4faa95604087c6d962",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "9149b9703e3ab09abdc087db129e82ad3f4cefa1",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,60 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n+        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n+        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n+        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n+                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n+                : AbfsPermission.valueOf(entry.permissions());\n+        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n+\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n-                        userGroupInformation.getUserName(),\n-                        userGroupInformation.getPrimaryGroupName(),\n+                        owner,\n+                        group,\n+                        fsPermission,\n+                        hasAcl,\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        final String owner \u003d entry.owner() \u003d\u003d null ? userGroupInformation.getUserName() : entry.owner();\n        final String group \u003d entry.group() \u003d\u003d null ? userGroupInformation.getPrimaryGroupName() : entry.group();\n        final FsPermission fsPermission \u003d entry.permissions() \u003d\u003d null\n                ? new AbfsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL)\n                : AbfsPermission.valueOf(entry.permissions());\n        final boolean hasAcl \u003d AbfsPermission.isExtendedAcl(entry.permissions());\n\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        owner,\n                        group,\n                        fsPermission,\n                        hasAcl,\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15659. Code changes for bug fix and new tests.\nContributed by Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,51 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n     LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n            path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n-          final DateTime dateTime \u003d DateTime.parse(\n-                  entry.lastModified(),\n-                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n-          lastModifiedMillis \u003d dateTime.getMillis();\n+          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         userGroupInformation.getUserName(),\n                         userGroupInformation.getPrimaryGroupName(),\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          lastModifiedMillis \u003d parseLastModifiedTime(entry.lastModified());\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15446. ABFS: tune imports \u0026 javadocs; stabilise tests.\nContributed by Steve Loughran and Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n   public FileStatus[] listStatus(final Path path) throws IOException {\n-    this.LOG.debug(\n-            \"listStatus filesystem: {} path: {}\",\n+    LOG.debug(\"listStatus filesystem: {} path: {}\",\n             client.getFileSystem(),\n-            path.toString());\n+           path);\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                 AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                 \"listStatusAsync path not found\",\n                 null, op.getResult());\n       }\n \n       long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n                   entry.lastModified(),\n                   DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n         Path entryPath \u003d new Path(File.separator + entry.name());\n         entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n \n         fileStatuses.add(\n                 new VersionedFileStatus(\n                         userGroupInformation.getUserName(),\n                         userGroupInformation.getPrimaryGroupName(),\n                         contentLength,\n                         isDirectory,\n                         1,\n                         blockSize,\n                         lastModifiedMillis,\n                         entryPath,\n                         entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    LOG.debug(\"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n           path);\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
      "extendedDetails": {}
    },
    "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462": {
      "type": "Ymultichange(Yfilerename,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldPath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpServiceImpl.java",
            "newPath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[AzureBlobFileSystemException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15560. ABFS: removed dependency injection and unnecessary dependencies.\nContributed by Da Zhou.\n",
          "commitDate": "17/09/18 12:54 PM",
          "commitName": "a271fd0eca75cef8b8ba940cdac8ad4fd21b4462",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "17/09/18 12:54 PM",
          "commitNameOld": "f044deedbbfee0812316d587139cb828f27172e9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n-    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n-\n+  public FileStatus[] listStatus(final Path path) throws IOException {\n     this.LOG.debug(\n-        \"listStatus filesystem: {} path: {}\",\n-        client.getFileSystem(),\n-        path.toString());\n+            \"listStatus filesystem: {} path: {}\",\n+            client.getFileSystem(),\n+            path.toString());\n \n     String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n     String continuation \u003d null;\n     ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n \n     do {\n       AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n       continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n       ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n       if (retrievedSchema \u003d\u003d null) {\n         throw new AbfsRestOperationException(\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n-            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n-            \"listStatusAsync path not found\",\n-            null, op.getResult());\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+                \"listStatusAsync path not found\",\n+                null, op.getResult());\n       }\n \n-      long blockSize \u003d configurationService.getAzureBlockSize();\n+      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n \n       for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n         long lastModifiedMillis \u003d 0;\n         long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n         boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n         if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n           final DateTime dateTime \u003d DateTime.parse(\n-              entry.lastModified(),\n-              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+                  entry.lastModified(),\n+                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n           lastModifiedMillis \u003d dateTime.getMillis();\n         }\n \n+        Path entryPath \u003d new Path(File.separator + entry.name());\n+        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n+\n         fileStatuses.add(\n-            new VersionedFileStatus(\n-                azureBlobFileSystem.getOwnerUser(),\n-                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n-                contentLength,\n-                isDirectory,\n-                1,\n-                blockSize,\n-                lastModifiedMillis,\n-                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n-                entry.eTag()));\n+                new VersionedFileStatus(\n+                        userGroupInformation.getUserName(),\n+                        userGroupInformation.getPrimaryGroupName(),\n+                        contentLength,\n+                        isDirectory,\n+                        1,\n+                        blockSize,\n+                        lastModifiedMillis,\n+                        entryPath,\n+                        entry.eTag()));\n       }\n \n     } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n \n     return fileStatuses.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(final Path path) throws IOException {\n    this.LOG.debug(\n            \"listStatus filesystem: {} path: {}\",\n            client.getFileSystem(),\n            path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n                AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n                AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n                \"listStatusAsync path not found\",\n                null, op.getResult());\n      }\n\n      long blockSize \u003d abfsConfiguration.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n                  entry.lastModified(),\n                  DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        Path entryPath \u003d new Path(File.separator + entry.name());\n        entryPath \u003d entryPath.makeQualified(this.uri, entryPath);\n\n        fileStatuses.add(\n                new VersionedFileStatus(\n                        userGroupInformation.getUserName(),\n                        userGroupInformation.getPrimaryGroupName(),\n                        contentLength,\n                        isDirectory,\n                        1,\n                        blockSize,\n                        lastModifiedMillis,\n                        entryPath,\n                        entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java",
          "extendedDetails": {
            "oldValue": "[azureBlobFileSystem-AzureBlobFileSystem(modifiers-final), path-Path(modifiers-final)]",
            "newValue": "[path-Path(modifiers-final)]"
          }
        }
      ]
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,54 @@\n+  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n+    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n+\n+    this.LOG.debug(\n+        \"listStatus filesystem: {} path: {}\",\n+        client.getFileSystem(),\n+        path.toString());\n+\n+    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n+    String continuation \u003d null;\n+    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n+\n+    do {\n+      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n+      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n+      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n+      if (retrievedSchema \u003d\u003d null) {\n+        throw new AbfsRestOperationException(\n+            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n+            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n+            \"listStatusAsync path not found\",\n+            null, op.getResult());\n+      }\n+\n+      long blockSize \u003d configurationService.getAzureBlockSize();\n+\n+      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n+        long lastModifiedMillis \u003d 0;\n+        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n+        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n+        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n+          final DateTime dateTime \u003d DateTime.parse(\n+              entry.lastModified(),\n+              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n+          lastModifiedMillis \u003d dateTime.getMillis();\n+        }\n+\n+        fileStatuses.add(\n+            new VersionedFileStatus(\n+                azureBlobFileSystem.getOwnerUser(),\n+                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n+                contentLength,\n+                isDirectory,\n+                1,\n+                blockSize,\n+                lastModifiedMillis,\n+                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n+                entry.eTag()));\n+      }\n+\n+    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n+\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(final AzureBlobFileSystem azureBlobFileSystem, final Path path) throws AzureBlobFileSystemException {\n    final AbfsClient client \u003d this.getOrCreateClient(azureBlobFileSystem);\n\n    this.LOG.debug(\n        \"listStatus filesystem: {} path: {}\",\n        client.getFileSystem(),\n        path.toString());\n\n    String relativePath \u003d path.isRoot() ? AbfsHttpConstants.EMPTY_STRING : getRelativePath(path);\n    String continuation \u003d null;\n    ArrayList\u003cFileStatus\u003e fileStatuses \u003d new ArrayList\u003c\u003e();\n\n    do {\n      AbfsRestOperation op \u003d client.listPath(relativePath, false, LIST_MAX_RESULTS, continuation);\n      continuation \u003d op.getResult().getResponseHeader(HttpHeaderConfigurations.X_MS_CONTINUATION);\n      ListResultSchema retrievedSchema \u003d op.getResult().getListResultSchema();\n      if (retrievedSchema \u003d\u003d null) {\n        throw new AbfsRestOperationException(\n            AzureServiceErrorCode.PATH_NOT_FOUND.getStatusCode(),\n            AzureServiceErrorCode.PATH_NOT_FOUND.getErrorCode(),\n            \"listStatusAsync path not found\",\n            null, op.getResult());\n      }\n\n      long blockSize \u003d configurationService.getAzureBlockSize();\n\n      for (ListResultEntrySchema entry : retrievedSchema.paths()) {\n        long lastModifiedMillis \u003d 0;\n        long contentLength \u003d entry.contentLength() \u003d\u003d null ? 0 : entry.contentLength();\n        boolean isDirectory \u003d entry.isDirectory() \u003d\u003d null ? false : entry.isDirectory();\n        if (entry.lastModified() !\u003d null \u0026\u0026 !entry.lastModified().isEmpty()) {\n          final DateTime dateTime \u003d DateTime.parse(\n              entry.lastModified(),\n              DateTimeFormat.forPattern(DATE_TIME_PATTERN).withZoneUTC());\n          lastModifiedMillis \u003d dateTime.getMillis();\n        }\n\n        fileStatuses.add(\n            new VersionedFileStatus(\n                azureBlobFileSystem.getOwnerUser(),\n                azureBlobFileSystem.getOwnerUserPrimaryGroup(),\n                contentLength,\n                isDirectory,\n                1,\n                blockSize,\n                lastModifiedMillis,\n                azureBlobFileSystem.makeQualified(new Path(File.separator + entry.name())),\n                entry.eTag()));\n      }\n\n    } while (continuation !\u003d null \u0026\u0026 !continuation.isEmpty());\n\n    return fileStatuses.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpServiceImpl.java"
    }
  }
}