{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirAppendOp.java",
  "functionName": "appendFile",
  "functionId": "appendFile___fsn-FSNamesystem(modifiers-final)__srcArg-String(modifiers-final)__pc-FSPermissionChecker(modifiers-final)__holder-String(modifiers-final)__clientMachine-String(modifiers-final)__newBlock-boolean(modifiers-final)__logRetryCache-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
  "functionStartLine": 81,
  "functionEndLine": 161,
  "numCommitsSeen": 1788,
  "timeTaken": 36135,
  "changeHistory": [
    "5962a518bd141e0e187342af89f6cab6011e75fb",
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "f6c0b7543f612de756ff0c03e9a2c6e33b496a36",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
    "bd909ed9f2d853f614f04a50e2230a7932732776",
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62",
    "31f117138a00794de4951ee8433e304d72b04094",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "bb84f1fccb18c6c7373851e05d2451d55e908242",
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd",
    "1e89eba47d0f291b33fc26f9406231fc70b63a87",
    "9a0ed1c4afd95827c6ff27490f33d0b86851e551",
    "c00703dd082474fea98a63b871c2183ca01147ed",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "10ec8a248ecbe37e52f81b13b939174eb43eda1f",
    "8c7a7e619699386f9e6991842558d78aa0c8053d",
    "b47df4e3b9089ad84185dd62693ae363ac994358"
  ],
  "changeHistoryShort": {
    "5962a518bd141e0e187342af89f6cab6011e75fb": "Ybodychange",
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb": "Ybodychange",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": "Ybodychange",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ybodychange",
    "f6c0b7543f612de756ff0c03e9a2c6e33b496a36": "Ybodychange",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": "Ybodychange",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": "Ybodychange",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": "Ybodychange",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": "Ybodychange",
    "bd909ed9f2d853f614f04a50e2230a7932732776": "Ybodychange",
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62": "Ybodychange",
    "31f117138a00794de4951ee8433e304d72b04094": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparametermetachange,Yrename,Yparameterchange)",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7": "Ybodychange",
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0": "Ymultichange(Yparameterchange,Ybodychange)",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ybodychange",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ybodychange",
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd": "Ybodychange",
    "1e89eba47d0f291b33fc26f9406231fc70b63a87": "Ybodychange",
    "9a0ed1c4afd95827c6ff27490f33d0b86851e551": "Ybodychange",
    "c00703dd082474fea98a63b871c2183ca01147ed": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "10ec8a248ecbe37e52f81b13b939174eb43eda1f": "Ybodychange",
    "8c7a7e619699386f9e6991842558d78aa0c8053d": "Ymultichange(Yparameterchange,Ybodychange)",
    "b47df4e3b9089ad84185dd62693ae363ac994358": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5962a518bd141e0e187342af89f6cab6011e75fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14581. Appending to EC files crashes NameNode. Contributed by Surendra Singh Lilhore.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "20/06/19 9:40 AM",
      "commitName": "5962a518bd141e0e187342af89f6cab6011e75fb",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "05/03/19 5:56 AM",
      "commitNameOld": "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 107.11,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,81 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final INodesInPath iip;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n+      if (file.isStriped() \u0026\u0026 !newBlock) {\n+        throw new UnsupportedOperationException(\n+            \"Append on EC file without new block is not supported. Use \"\n+                + CreateFlag.NEW_BLOCK + \" create flag while appending file.\");\n+      }\n+\n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d\n         FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      if (file.isStriped() \u0026\u0026 !newBlock) {\n        throw new UnsupportedOperationException(\n            \"Append on EC file without new block is not supported. Use \"\n                + CreateFlag.NEW_BLOCK + \" create flag while appending file.\");\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d\n        FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "f940ab242da80a22bae95509d5c282d7e2f7ecdb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7663. Erasure Coding: Append on striped file. Contributed by Ayush Saxena.\n",
      "commitDate": "05/03/19 5:56 AM",
      "commitName": "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "11/12/17 8:14 PM",
      "commitNameOld": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 448.4,
      "commitsBetweenForRepo": 3913,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,75 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final INodesInPath iip;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n-      // not support appending file with striped blocks\n-      if (file.isStriped()) {\n-        throw new UnsupportedOperationException(\n-            \"Cannot append to files with striped block \" + path);\n-      }\n-\n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d\n         FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d\n        FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
      "commitDate": "11/12/17 8:14 PM",
      "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 413.25,
      "commitsBetweenForRepo": 2723,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,81 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final INodesInPath iip;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + path);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n-    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n+    HdfsFileStatus stat \u003d\n+        FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + path);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d\n        FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/09/16 11:48 AM",
      "commitNameOld": "f6c0b7543f612de756ff0c03e9a2c6e33b496a36",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 48.14,
      "commitsBetweenForRepo": 319,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final INodesInPath iip;\n     fsd.writeLock();\n     try {\n-      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n+      iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + path);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePath(pc, srcArg, DirOp.WRITE);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + path);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "f6c0b7543f612de756ff0c03e9a2c6e33b496a36": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10841. Remove duplicate or unused variable in appendFile(). Contributed by Kihwal Lee.\n",
      "commitDate": "06/09/16 11:48 AM",
      "commitName": "f6c0b7543f612de756ff0c03e9a2c6e33b496a36",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "24/08/16 6:46 AM",
      "commitNameOld": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 13.21,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,80 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n-    final String src;\n     final INodesInPath iip;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n-      src \u003d iip.getPath();\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to files with striped block \" + src);\n+            \"Cannot append to files with striped block \" + path);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + path);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
      "commitDate": "24/08/16 6:46 AM",
      "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "22/08/16 2:57 PM",
      "commitNameOld": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n+    final INodesInPath iip;\n     fsd.writeLock();\n     try {\n-      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n+      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n       src \u003d iip.getPath();\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n-    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n-        FSDirectory.isReservedRawName(srcArg));\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n      src \u003d iip.getPath();\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
      "commitDate": "22/08/16 2:57 PM",
      "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/08/16 1:37 PM",
      "commitNameOld": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n-    final INodesInPath iip;\n     fsd.writeLock();\n     try {\n-      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n+      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n       src \u003d iip.getPath();\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n-    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg));\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n      src \u003d iip.getPath();\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg));\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
      "commitDate": "22/08/16 1:37 PM",
      "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/08/16 1:53 PM",
      "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n+    final INodesInPath iip;\n     fsd.writeLock();\n     try {\n-      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n+      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n       src \u003d iip.getPath();\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n-    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n-        FSDirectory.isReservedRawName(srcArg));\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    final INodesInPath iip;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n      src \u003d iip.getPath();\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, iip);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n     fsd.writeLock();\n     try {\n-      src \u003d fsd.resolvePath(pc, srcArg);\n-      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n+      src \u003d iip.getPath();\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n         FSDirectory.isReservedRawName(srcArg));\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      final INodesInPath iip \u003d fsd.resolvePathForWrite(pc, srcArg);\n      src \u003d iip.getPath();\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg));\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
      "commitDate": "15/08/16 2:45 PM",
      "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/01/16 6:32 PM",
      "commitNameOld": "bd909ed9f2d853f614f04a50e2230a7932732776",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 202.8,
      "commitsBetweenForRepo": 1445,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,82 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n-    final byte[][] pathComponents \u003d FSDirectory\n-        .getPathComponentsForReservedPath(srcArg);\n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n     fsd.writeLock();\n     try {\n-      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      src \u003d fsd.resolvePath(pc, srcArg);\n       final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null) {\n         if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n           throw new RetriableException(\n               new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                   + lastBlock + \" of src\u003d\" + path\n                   + \" is COMMITTED but not yet COMPLETE.\"));\n         } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n           throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n               + path + \" is not sufficiently replicated yet.\");\n         }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n         FSDirectory.isReservedRawName(srcArg));\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg));\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "bd909ed9f2d853f614f04a50e2230a7932732776": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8999. Allow a file to be closed with COMMITTED but not yet COMPLETE blocks.\n",
      "commitDate": "25/01/16 6:32 PM",
      "commitName": "bd909ed9f2d853f614f04a50e2230a7932732776",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/09/15 2:30 PM",
      "commitNameOld": "ab56fcdb1219d03713b408dd3a95d7405635254d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 146.21,
      "commitsBetweenForRepo": 1015,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,84 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final byte[][] pathComponents \u003d FSDirectory\n         .getPathComponentsForReservedPath(srcArg);\n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n     fsd.writeLock();\n     try {\n       src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n       final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n \n       // not support appending file with striped blocks\n       if (file.isStriped()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to files with striped block \" + src);\n       }\n \n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+      if (lastBlock !\u003d null) {\n+        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n+          throw new RetriableException(\n+              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n+                  + lastBlock + \" of src\u003d\" + path\n+                  + \" is COMMITTED but not yet COMPLETE.\"));\n+        } else if (lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n-            + path + \" is not sufficiently replicated yet.\");\n+          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+              + path + \" is not sufficiently replicated yet.\");\n+        }\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n         FSDirectory.isReservedRawName(srcArg));\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n\n      // not support appending file with striped blocks\n      if (file.isStriped()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to files with striped block \" + src);\n      }\n\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null) {\n        if (lastBlock.getBlockUCState() \u003d\u003d BlockUCState.COMMITTED) {\n          throw new RetriableException(\n              new NotReplicatedYetException(\"append: lastBlock\u003d\"\n                  + lastBlock + \" of src\u003d\" + path\n                  + \" is COMMITTED but not yet COMPLETE.\"));\n        } else if (lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n          throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n              + path + \" is not sufficiently replicated yet.\");\n        }\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg));\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8805. Archival Storage: getStoragePolicy should not need superuser privilege. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "11/08/15 10:28 AM",
      "commitName": "1fc3c779a422bafdb86ad1a5b2349802dda1cb62",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/07/15 5:25 PM",
      "commitNameOld": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 20.71,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n       final String srcArg, final FSPermissionChecker pc, final String holder,\n       final String clientMachine, final boolean newBlock,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     final byte[][] pathComponents \u003d FSDirectory\n         .getPathComponentsForReservedPath(srcArg);\n     final LocatedBlock lb;\n     final FSDirectory fsd \u003d fsn.getFSDirectory();\n     final String src;\n     fsd.writeLock();\n     try {\n       src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n       final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n       // Verify that the destination does not exist as a directory already\n       final INode inode \u003d iip.getLastINode();\n       final String path \u003d iip.getPath();\n       if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n         throw new FileAlreadyExistsException(\"Cannot append to directory \"\n             + path + \"; already exists as a directory.\");\n       }\n       if (fsd.isPermissionEnabled()) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n \n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\n             \"Failed to append to non-existent file \" + path + \" for client \"\n                 + clientMachine);\n       }\n       final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n       BlockManager blockManager \u003d fsd.getBlockManager();\n       final BlockStoragePolicy lpPolicy \u003d blockManager\n           .getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n           clientMachine, false);\n \n       final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n           \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n             + path + \" is not sufficiently replicated yet.\");\n       }\n       lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog\n           .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n     } finally {\n       fsd.writeUnlock();\n     }\n \n     HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n-        FSDirectory.isReservedRawName(srcArg), true);\n+        FSDirectory.isReservedRawName(srcArg));\n     if (lb !\u003d null) {\n       NameNode.stateChangeLog.debug(\n           \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n               + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n               .getBlock().getNumBytes());\n     }\n     return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg));\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
      "extendedDetails": {}
    },
    "31f117138a00794de4951ee8433e304d72b04094": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yparametermetachange,Yrename,Yparameterchange)",
      "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "21/07/15 5:25 PM",
      "commitName": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
            "oldMethodName": "appendFileInternal",
            "newMethodName": "appendFile"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "LocatedBlock",
            "newValue": "LastBlockWithStatus"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, iip-INodesInPath, holder-String, clientMachine-String, newBlock-boolean, logRetryCache-boolean]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), pc-FSPermissionChecker(modifiers-final), holder-String(modifiers-final), clientMachine-String(modifiers-final), newBlock-boolean(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Yrename",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "appendFileInternal",
            "newValue": "appendFile"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
          "commitDate": "21/07/15 5:25 PM",
          "commitName": "31f117138a00794de4951ee8433e304d72b04094",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/07/15 3:05 PM",
          "commitNameOld": "393fe71771e3ac6bc0efe59d9aaf19d3576411b3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.1,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,70 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n-      boolean logRetryCache) throws IOException {\n-    assert hasWriteLock();\n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n-          + \"; already exists as a directory.\");\n-    }\n-    if (isPermissionEnabled) {\n-      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n-    }\n+  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n+      final String srcArg, final FSPermissionChecker pc, final String holder,\n+      final String clientMachine, final boolean newBlock,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n \n+    final byte[][] pathComponents \u003d FSDirectory\n+        .getPathComponentsForReservedPath(srcArg);\n+    final LocatedBlock lb;\n+    final FSDirectory fsd \u003d fsn.getFSDirectory();\n+    final String src;\n+    fsd.writeLock();\n     try {\n-      if (inode \u003d\u003d null) {\n-        throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" for client \" + clientMachine);\n+      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n+      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+      // Verify that the destination does not exist as a directory already\n+      final INode inode \u003d iip.getLastINode();\n+      final String path \u003d iip.getPath();\n+      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n+            + path + \"; already exists as a directory.\");\n       }\n-      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-      final BlockStoragePolicy lpPolicy \u003d\n-          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-      if (lpPolicy !\u003d null \u0026\u0026\n-          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\n+            \"Failed to append to non-existent file \" + path + \" for client \"\n+                + clientMachine);\n+      }\n+      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n+      BlockManager blockManager \u003d fsd.getBlockManager();\n+      final BlockStoragePolicy lpPolicy \u003d blockManager\n+          .getStoragePolicy(\"LAZY_PERSIST\");\n+      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n-            \"Cannot append to lazy persist file \" + src);\n+            \"Cannot append to lazy persist file \" + path);\n       }\n       // Opening an existing file for append - may need to recover lease.\n-      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n-                           clientMachine, false);\n-      \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n+          clientMachine, false);\n+\n+      final BlockInfo lastBlock \u003d file.getLastBlock();\n       // Check that the block has at least minimum replication.\n-      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n-          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n-        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n-            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n+          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n+            + path + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      NameNode.stateChangeLog\n+          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n       throw ie;\n+    } finally {\n+      fsd.writeUnlock();\n     }\n+\n+    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n+        FSDirectory.isReservedRawName(srcArg), true);\n+    if (lb !\u003d null) {\n+      NameNode.stateChangeLog.debug(\n+          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n+              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n+              .getBlock().getNumBytes());\n+    }\n+    return new LastBlockWithStatus(lb, stat);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LastBlockWithStatus appendFile(final FSNamesystem fsn,\n      final String srcArg, final FSPermissionChecker pc, final String holder,\n      final String clientMachine, final boolean newBlock,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    final byte[][] pathComponents \u003d FSDirectory\n        .getPathComponentsForReservedPath(srcArg);\n    final LocatedBlock lb;\n    final FSDirectory fsd \u003d fsn.getFSDirectory();\n    final String src;\n    fsd.writeLock();\n    try {\n      src \u003d fsd.resolvePath(pc, srcArg, pathComponents);\n      final INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n      // Verify that the destination does not exist as a directory already\n      final INode inode \u003d iip.getLastINode();\n      final String path \u003d iip.getPath();\n      if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n        throw new FileAlreadyExistsException(\"Cannot append to directory \"\n            + path + \"; already exists as a directory.\");\n      }\n      if (fsd.isPermissionEnabled()) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\n            \"Failed to append to non-existent file \" + path + \" for client \"\n                + clientMachine);\n      }\n      final INodeFile file \u003d INodeFile.valueOf(inode, path, true);\n      BlockManager blockManager \u003d fsd.getBlockManager();\n      final BlockStoragePolicy lpPolicy \u003d blockManager\n          .getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026 lpPolicy.getId() \u003d\u003d file.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + path);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      fsn.recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, path, holder,\n          clientMachine, false);\n\n      final BlockInfo lastBlock \u003d file.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if (lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete()\n          \u0026\u0026 !blockManager.isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock + \" of src\u003d\"\n            + path + \" is not sufficiently replicated yet.\");\n      }\n      lb \u003d prepareFileForAppend(fsn, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog\n          .warn(\"DIR* NameSystem.append: \" + ie.getMessage());\n      throw ie;\n    } finally {\n      fsd.writeUnlock();\n    }\n\n    HdfsFileStatus stat \u003d FSDirStatAndListingOp.getFileInfo(fsd, src, false,\n        FSDirectory.isReservedRawName(srcArg), true);\n    if (lb !\u003d null) {\n      NameNode.stateChangeLog.debug(\n          \"DIR* NameSystem.appendFile: file {} for {} at {} block {} block\"\n              + \" size {}\", srcArg, holder, clientMachine, lb.getBlock(), lb\n              .getBlock().getNumBytes());\n    }\n    return new LastBlockWithStatus(lb, stat);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirAppendOp.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, iip-INodesInPath, holder-String, clientMachine-String, newBlock-boolean, logRetryCache-boolean]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), pc-FSPermissionChecker(modifiers-final), holder-String(modifiers-final), clientMachine-String(modifiers-final), newBlock-boolean(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        }
      ]
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n       INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n                            clientMachine, false);\n       \n-      final BlockInfoContiguous lastBlock \u003d myFile.getLastBlock();\n+      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE, iip, src, holder,\n                           clientMachine, false);\n      \n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/02/15 3:21 PM",
      "commitNameOld": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n       INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for append - may need to recover lease.\n       recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE,\n           iip, src, holder, clientMachine, false);\n       \n-      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      final BlockInfoContiguous lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE,\n          iip, src, holder, clientMachine, false);\n      \n      final BlockInfoContiguous lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7738. Revise the exception message for recover lease; add more truncate tests such as truncate with HA setup, negative tests, truncate with other operations and multiple truncates.\n",
      "commitDate": "07/02/15 3:21 PM",
      "commitName": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/02/15 12:45 PM",
      "commitNameOld": "843806d03ab1a24f191782f42eb817505228eb9f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n       INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n-      // Opening an existing file for write - may need to recover lease.\n-      recoverLeaseInternal(iip, src, holder, clientMachine, false);\n+      // Opening an existing file for append - may need to recover lease.\n+      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE,\n+          iip, src, holder, clientMachine, false);\n       \n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n           true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for append - may need to recover lease.\n      recoverLeaseInternal(RecoverLeaseOp.APPEND_FILE,\n          iip, src, holder, clientMachine, false);\n      \n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2848db814a98b83e7546f65a2751e56fb5b2dbe0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
      "commitDate": "27/01/15 12:58 PM",
      "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
          "commitDate": "27/01/15 12:58 PM",
          "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/01/15 3:44 PM",
          "commitNameOld": "e9fd46ddbf46954cfda4bb9c33f1789775be9d18",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 2.88,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,45 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine,\n+      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-\n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(iip, src, holder, clientMachine, false);\n       \n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForWrite(src, iip, holder, clientMachine, true,\n-              logRetryCache);\n+      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+          true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(iip, src, holder, clientMachine, false);\n      \n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, iip-INodesInPath, holder-String, clientMachine-String, logRetryCache-boolean]",
            "newValue": "[pc-FSPermissionChecker, iip-INodesInPath, holder-String, clientMachine-String, newBlock-boolean, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3689. Add support for variable length block. Contributed by Jing Zhao.\n",
          "commitDate": "27/01/15 12:58 PM",
          "commitName": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/01/15 3:44 PM",
          "commitNameOld": "e9fd46ddbf46954cfda4bb9c33f1789775be9d18",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 2.88,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,45 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n-      INodesInPath iip, String holder, String clientMachine,\n+      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n-\n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(iip, src, holder, clientMachine, false);\n       \n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForWrite(src, iip, holder, clientMachine, true,\n-              logRetryCache);\n+      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n+          true, logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine, boolean newBlock,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(iip, src, holder, clientMachine, false);\n      \n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForAppend(src, iip, holder, clientMachine, newBlock,\n          true, logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/12/14 11:51 AM",
      "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,46 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n       INodesInPath iip, String holder, String clientMachine,\n       boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n \n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n-      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n+      recoverLeaseInternal(iip, src, holder, clientMachine, false);\n       \n-      // recoverLeaseInternal may create a new InodeFile via \n-      // finalizeINodeFileUnderConstruction so we need to refresh \n-      // the referenced file.  \n-      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n-      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n-              iip.getLatestSnapshotId(), logRetryCache);\n+      return prepareFileForWrite(src, iip, holder, clientMachine, true,\n+              logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(iip, src, holder, clientMachine, false);\n      \n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, iip, holder, clientMachine, true,\n              logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,50 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n-      String holder, String clientMachine, boolean logRetryCache)\n-      throws AccessControlException, UnresolvedLinkException,\n-      FileNotFoundException, IOException {\n+  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n+      INodesInPath iip, String holder, String clientMachine,\n+      boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n-      checkPathAccess(pc, src, FsAction.WRITE);\n+      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n \n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n               iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, src-String, holder-String, clientMachine-String, logRetryCache-boolean]",
            "newValue": "[pc-FSPermissionChecker, iip-INodesInPath, holder-String, clientMachine-String, logRetryCache-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,50 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n-      String holder, String clientMachine, boolean logRetryCache)\n-      throws AccessControlException, UnresolvedLinkException,\n-      FileNotFoundException, IOException {\n+  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n+      INodesInPath iip, String holder, String clientMachine,\n+      boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n-      checkPathAccess(pc, src, FsAction.WRITE);\n+      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n \n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n               iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[AccessControlException, UnresolvedLinkException, FileNotFoundException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,50 @@\n-  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n-      String holder, String clientMachine, boolean logRetryCache)\n-      throws AccessControlException, UnresolvedLinkException,\n-      FileNotFoundException, IOException {\n+  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n+      INodesInPath iip, String holder, String clientMachine,\n+      boolean logRetryCache) throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n-      checkPathAccess(pc, src, FsAction.WRITE);\n+      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       final BlockStoragePolicy lpPolicy \u003d\n           blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n \n       if (lpPolicy !\u003d null \u0026\u0026\n           lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n               iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc,\n      INodesInPath iip, String holder, String clientMachine,\n      boolean logRetryCache) throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      dir.checkPathAccess(pc, iip, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "commitDateOld": "29/09/14 12:36 PM",
      "commitNameOld": "d45e7c7e856c7103752888c0395fa94985cd7670",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,51 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+      final BlockStoragePolicy lpPolicy \u003d\n+          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n \n-      if (myFile.getLazyPersistFlag()) {\n+      if (lpPolicy !\u003d null \u0026\u0026\n+          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n         throw new UnsupportedOperationException(\n             \"Cannot append to lazy persist file \" + src);\n       }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n               iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      final BlockStoragePolicy lpPolicy \u003d\n          blockManager.getStoragePolicy(\"LAZY_PERSIST\");\n\n      if (lpPolicy !\u003d null \u0026\u0026\n          lpPolicy.getId() \u003d\u003d myFile.getStoragePolicyID()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2e987148e02d0087fc70ce5b1ce571d3324bf1dd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6929. NN periodically unlinks lazy persist files with missing replicas from namespace. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "2e987148e02d0087fc70ce5b1ce571d3324bf1dd",
      "commitAuthor": "arp",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "042b33f20b01aadb5cd03da731ae7a3d94026aac",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,48 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+\n+      if (myFile.getLazyPersistFlag()) {\n+        throw new UnsupportedOperationException(\n+            \"Cannot append to lazy persist file \" + src);\n+      }\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n       return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n               iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n\n      if (myFile.getLazyPersistFlag()) {\n        throw new UnsupportedOperationException(\n            \"Cannot append to lazy persist file \" + src);\n      }\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1e89eba47d0f291b33fc26f9406231fc70b63a87": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6583. Remove clientNode in FileUnderConstructionFeature. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604541 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/06/14 12:39 AM",
      "commitName": "1e89eba47d0f291b33fc26f9406231fc70b63a87",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/06/14 11:54 AM",
      "commitNameOld": "9ca79e8d327e95845ef9794396afd43a52bc3d40",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.53,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,43 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       final BlockInfo lastBlock \u003d myFile.getLastBlock();\n       // Check that the block has at least minimum replication.\n       if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n           !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n         throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n             \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n       }\n-      final DatanodeDescriptor clientNode \u003d \n-          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n-      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n-          true, iip.getLatestSnapshotId(), logRetryCache);\n+      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n+              iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      return prepareFileForWrite(src, myFile, holder, clientMachine, true,\n              iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9a0ed1c4afd95827c6ff27490f33d0b86851e551": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6325. Append should fail if the last block has insufficient number of replicas (Keith Pak via cos)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595744 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/14 10:24 PM",
      "commitName": "9a0ed1c4afd95827c6ff27490f33d0b86851e551",
      "commitAuthor": "Konstantin Boudnik",
      "commitDateOld": "15/05/14 2:29 PM",
      "commitNameOld": "1959afe1133eee3d099a012635082d82a077c8b3",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.33,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,45 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n-      \n+      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n+      // Check that the block has at least minimum replication.\n+      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n+          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n+        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n+            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n+      }\n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n           true, iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      final BlockInfo lastBlock \u003d myFile.getLastBlock();\n      // Check that the block has at least minimum replication.\n      if(lastBlock !\u003d null \u0026\u0026 lastBlock.isComplete() \u0026\u0026\n          !getBlockManager().isSufficientlyReplicated(lastBlock)) {\n        throw new IOException(\"append: lastBlock\u003d\" + lastBlock +\n            \" of src\u003d\" + src + \" is not sufficiently replicated yet.\");\n      }\n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c00703dd082474fea98a63b871c2183ca01147ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6150. Add inode id information in the logs to make debugging easier. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581914 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/14 9:32 AM",
      "commitName": "c00703dd082474fea98a63b871c2183ca01147ed",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "25/03/14 10:53 AM",
      "commitNameOld": "867e0f8ea9b285a428db278edce38e241644b749",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n-          + src + \" on client \" + clientMachine);\n+          + src + \" for client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       \n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n           true, iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" for client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      \n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/01/14 6:45 PM",
      "commitNameOld": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" on client \" + clientMachine);\n       }\n       INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n       \n       // recoverLeaseInternal may create a new InodeFile via \n       // finalizeINodeFileUnderConstruction so we need to refresh \n       // the referenced file.  \n       myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n       \n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n-          true, iip.getLatestSnapshot(), logRetryCache);\n+          true, iip.getLatestSnapshotId(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" on client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      \n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshotId(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "10ec8a248ecbe37e52f81b13b939174eb43eda1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2994. If lease soft limit is recovered successfully the append can fail. Contributed by Tao Luo.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514500 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/08/13 2:21 PM",
      "commitName": "10ec8a248ecbe37e52f81b13b939174eb43eda1f",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "15/08/13 11:22 AM",
      "commitNameOld": "02b19e0738d9df1e4d38280c5575e1d3ba49f8cb",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,39 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n       String holder, String clientMachine, boolean logRetryCache)\n       throws AccessControlException, UnresolvedLinkException,\n       FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" on client \" + clientMachine);\n       }\n-      final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n-\n+      \n+      // recoverLeaseInternal may create a new InodeFile via \n+      // finalizeINodeFileUnderConstruction so we need to refresh \n+      // the referenced file.  \n+      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n+      \n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n           true, iip.getLatestSnapshot(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" on client \" + clientMachine);\n      }\n      INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n      \n      // recoverLeaseInternal may create a new InodeFile via \n      // finalizeINodeFileUnderConstruction so we need to refresh \n      // the referenced file.  \n      myFile \u003d INodeFile.valueOf(dir.getINode(src), src, true);\n      \n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshot(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8c7a7e619699386f9e6991842558d78aa0c8053d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/13 12:51 AM",
      "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
      "commitAuthor": "Suresh Srinivas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/13 12:51 AM",
          "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "26/07/13 4:59 PM",
          "commitNameOld": "dc17bda4b677e30c02c2a9a053895a43e41f7a12",
          "commitAuthorOld": "Konstantin Boudnik",
          "daysBetweenCommits": 3.33,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n-      String holder, String clientMachine) throws AccessControlException,\n-      UnresolvedLinkException, FileNotFoundException, IOException {\n+      String holder, String clientMachine, boolean logRetryCache)\n+      throws AccessControlException, UnresolvedLinkException,\n+      FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" on client \" + clientMachine);\n       }\n       final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n \n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n-          true, iip.getLatestSnapshot());\n+          true, iip.getLatestSnapshot(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" on client \" + clientMachine);\n      }\n      final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n\n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshot(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, src-String, holder-String, clientMachine-String]",
            "newValue": "[pc-FSPermissionChecker, src-String, holder-String, clientMachine-String, logRetryCache-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5025. Record ClientId and CallId in EditLog to enable rebuilding retry cache in case of HA failover. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/13 12:51 AM",
          "commitName": "8c7a7e619699386f9e6991842558d78aa0c8053d",
          "commitAuthor": "Suresh Srinivas",
          "commitDateOld": "26/07/13 4:59 PM",
          "commitNameOld": "dc17bda4b677e30c02c2a9a053895a43e41f7a12",
          "commitAuthorOld": "Konstantin Boudnik",
          "daysBetweenCommits": 3.33,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n   private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n-      String holder, String clientMachine) throws AccessControlException,\n-      UnresolvedLinkException, FileNotFoundException, IOException {\n+      String holder, String clientMachine, boolean logRetryCache)\n+      throws AccessControlException, UnresolvedLinkException,\n+      FileNotFoundException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n           + \"; already exists as a directory.\");\n     }\n     if (isPermissionEnabled) {\n       checkPathAccess(pc, src, FsAction.WRITE);\n     }\n \n     try {\n       if (inode \u003d\u003d null) {\n         throw new FileNotFoundException(\"failed to append to non-existent file \"\n           + src + \" on client \" + clientMachine);\n       }\n       final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n       // Opening an existing file for write - may need to recover lease.\n       recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n \n       final DatanodeDescriptor clientNode \u003d \n           blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n       return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n-          true, iip.getLatestSnapshot());\n+          true, iip.getLatestSnapshot(), logRetryCache);\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine, boolean logRetryCache)\n      throws AccessControlException, UnresolvedLinkException,\n      FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" on client \" + clientMachine);\n      }\n      final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n\n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshot(), logRetryCache);\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "b47df4e3b9089ad84185dd62693ae363ac994358": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4912. Cleanup FSNamesystem#startFileInternal. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502634 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/13 10:44 AM",
      "commitName": "b47df4e3b9089ad84185dd62693ae363ac994358",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,33 @@\n+  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n+      String holder, String clientMachine) throws AccessControlException,\n+      UnresolvedLinkException, FileNotFoundException, IOException {\n+    assert hasWriteLock();\n+    // Verify that the destination does not exist as a directory already.\n+    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n+    final INode inode \u003d iip.getLastINode();\n+    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n+      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n+          + \"; already exists as a directory.\");\n+    }\n+    if (isPermissionEnabled) {\n+      checkPathAccess(pc, src, FsAction.WRITE);\n+    }\n+\n+    try {\n+      if (inode \u003d\u003d null) {\n+        throw new FileNotFoundException(\"failed to append to non-existent file \"\n+          + src + \" on client \" + clientMachine);\n+      }\n+      final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+      // Opening an existing file for write - may need to recover lease.\n+      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n+\n+      final DatanodeDescriptor clientNode \u003d \n+          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n+      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n+          true, iip.getLatestSnapshot());\n+    } catch (IOException ie) {\n+      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n+      throw ie;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private LocatedBlock appendFileInternal(FSPermissionChecker pc, String src,\n      String holder, String clientMachine) throws AccessControlException,\n      UnresolvedLinkException, FileNotFoundException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(\"Cannot append to directory \" + src\n          + \"; already exists as a directory.\");\n    }\n    if (isPermissionEnabled) {\n      checkPathAccess(pc, src, FsAction.WRITE);\n    }\n\n    try {\n      if (inode \u003d\u003d null) {\n        throw new FileNotFoundException(\"failed to append to non-existent file \"\n          + src + \" on client \" + clientMachine);\n      }\n      final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n      // Opening an existing file for write - may need to recover lease.\n      recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n\n      final DatanodeDescriptor clientNode \u003d \n          blockManager.getDatanodeManager().getDatanodeByHost(clientMachine);\n      return prepareFileForWrite(src, myFile, holder, clientMachine, clientNode,\n          true, iip.getLatestSnapshot());\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.append: \" +ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}