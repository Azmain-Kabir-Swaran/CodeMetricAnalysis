{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ShellBasedIdMapping.java",
  "functionName": "updateMapInternal",
  "functionId": "updateMapInternal___map-BiMap__Integer,String____mapName-String__command-String__regex-String__staticMapping-Map__Integer,Integer__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
  "functionStartLine": 216,
  "functionEndLine": 273,
  "numCommitsSeen": 39,
  "timeTaken": 2720,
  "changeHistory": [
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
    "351c5561c2fd380ab7746ca4e91d7b838e61e03f",
    "72a556d3b0def0ab4e4509528cc513f6df06b084",
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974",
    "1c0e7a318e0e68e7c18c2555c1848d527a710722",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
    "6439cd0f691069cefb6da4ba261ffe60cc13bbd0",
    "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
    "4d63b7a016232d3d816e9a0229a029a07a06757a"
  ],
  "changeHistoryShort": {
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": "Ybodychange",
    "351c5561c2fd380ab7746ca4e91d7b838e61e03f": "Ymultichange(Yreturntypechange,Ybodychange)",
    "72a556d3b0def0ab4e4509528cc513f6df06b084": "Yfilerename",
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974": "Ymultichange(Yparameterchange,Ybodychange)",
    "1c0e7a318e0e68e7c18c2555c1848d527a710722": "Ybodychange",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": "Ybodychange",
    "6439cd0f691069cefb6da4ba261ffe60cc13bbd0": "Ybodychange",
    "aa4fba6d92faf5e51bb330c6d18825fbed63b553": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "4d63b7a016232d3d816e9a0229a029a07a06757a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11389. Clean up byte to string encoding issues in hadoop-common. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 4:42 PM",
      "commitName": "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "10/12/14 2:37 PM",
      "commitNameOld": "84d50003f6e46f9f9ac2b9d7bb937de757be161b",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,58 @@\n   public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n       String mapName, String command, String regex,\n       Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n     boolean updated \u003d false;\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n-      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n+      br \u003d new BufferedReader(\n+          new InputStreamReader(process.getInputStream(),\n+                                Charset.defaultCharset()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n         final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n         final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n         updated \u003d true;\n       }\n       LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n     return updated;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n      String mapName, String command, String regex,\n      Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n    boolean updated \u003d false;\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(\n          new InputStreamReader(process.getInputStream(),\n                                Charset.defaultCharset()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n        updated \u003d true;\n      }\n      LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n    return updated;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "351c5561c2fd380ab7746ca4e91d7b838e61e03f": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7146. NFS ID/Group lookup requires SSSD enumeration on the server. Contributed by Yongjun Zhang\n",
      "commitDate": "17/11/14 1:23 PM",
      "commitName": "351c5561c2fd380ab7746ca4e91d7b838e61e03f",
      "commitAuthor": "Brandon Li",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7146. NFS ID/Group lookup requires SSSD enumeration on the server. Contributed by Yongjun Zhang\n",
          "commitDate": "17/11/14 1:23 PM",
          "commitName": "351c5561c2fd380ab7746ca4e91d7b838e61e03f",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "29/10/14 11:05 AM",
          "commitNameOld": "72a556d3b0def0ab4e4509528cc513f6df06b084",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 19.14,
          "commitsBetweenForRepo": 193,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,56 @@\n-  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n-      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n-      throws IOException  {\n+  public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n+      String mapName, String command, String regex,\n+      Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n+    boolean updated \u003d false;\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n         final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n         final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n+        updated \u003d true;\n       }\n-      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n+      LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n+    return updated;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n      String mapName, String command, String regex,\n      Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n    boolean updated \u003d false;\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n        updated \u003d true;\n      }\n      LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n    return updated;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7146. NFS ID/Group lookup requires SSSD enumeration on the server. Contributed by Yongjun Zhang\n",
          "commitDate": "17/11/14 1:23 PM",
          "commitName": "351c5561c2fd380ab7746ca4e91d7b838e61e03f",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "29/10/14 11:05 AM",
          "commitNameOld": "72a556d3b0def0ab4e4509528cc513f6df06b084",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 19.14,
          "commitsBetweenForRepo": 193,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,56 @@\n-  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n-      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n-      throws IOException  {\n+  public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n+      String mapName, String command, String regex,\n+      Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n+    boolean updated \u003d false;\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n         final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n         final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n+        updated \u003d true;\n       }\n-      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n+      LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n+    return updated;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean updateMapInternal(BiMap\u003cInteger, String\u003e map,\n      String mapName, String command, String regex,\n      Map\u003cInteger, Integer\u003e staticMapping) throws IOException  {\n    boolean updated \u003d false;\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n        updated \u003d true;\n      }\n      LOG.debug(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n    return updated;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
          "extendedDetails": {}
        }
      ]
    },
    "72a556d3b0def0ab4e4509528cc513f6df06b084": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-11195. Move Id-Name mapping in NFS to the hadoop-common area for better maintenance. Contributed by Yongjun Zhang\n",
      "commitDate": "29/10/14 11:05 AM",
      "commitName": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/10/14 10:29 AM",
      "commitNameOld": "b056048114bf4701ef9dd22486db937cb589e81b",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n      throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {
        "oldPath": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java"
      }
    },
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6435. Add support for specifying a static uid/gid mapping for the NFS gateway. (atm via wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596966 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/05/14 1:44 PM",
      "commitName": "1ba203e3e0ead72afd9c3351827f44ff2d51b974",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6435. Add support for specifying a static uid/gid mapping for the NFS gateway. (atm via wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596966 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/05/14 1:44 PM",
          "commitName": "1ba203e3e0ead72afd9c3351827f44ff2d51b974",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "19/05/14 3:16 PM",
          "commitNameOld": "674c523db17b1f15792f4ba7c8c5bb4ad4f28ba2",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,53 @@\n   public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n-      String command, String regex) throws IOException  {\n+      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n+      throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n-        final Integer key \u003d parseId(nameId[1]);        \n+        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n         final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n       }\n-      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n+      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n      throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
          "extendedDetails": {
            "oldValue": "[map-BiMap\u003cInteger,String\u003e, mapName-String, command-String, regex-String]",
            "newValue": "[map-BiMap\u003cInteger,String\u003e, mapName-String, command-String, regex-String, staticMapping-Map\u003cInteger,Integer\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6435. Add support for specifying a static uid/gid mapping for the NFS gateway. (atm via wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596966 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/05/14 1:44 PM",
          "commitName": "1ba203e3e0ead72afd9c3351827f44ff2d51b974",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "19/05/14 3:16 PM",
          "commitNameOld": "674c523db17b1f15792f4ba7c8c5bb4ad4f28ba2",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 2.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,53 @@\n   public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n-      String command, String regex) throws IOException  {\n+      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n+      throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n-        final Integer key \u003d parseId(nameId[1]);        \n+        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n         final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n       }\n-      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n+      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex, Map\u003cInteger, Integer\u003e staticMapping)\n      throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d staticMapping.get(parseId(nameId[1]));\n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size: \" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
          "extendedDetails": {}
        }
      ]
    },
    "1c0e7a318e0e68e7c18c2555c1848d527a710722": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6361. TestIdUserGroup.testUserUpdateSetting failed due to out of range nfsnobody Id. Contributed by Yongjun Zhang\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595050 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/05/14 2:23 PM",
      "commitName": "1c0e7a318e0e68e7c18c2555c1848d527a710722",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "24/03/14 1:49 PM",
      "commitNameOld": "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 52.02,
      "commitsBetweenForRepo": 321,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n       String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n-        final Integer key \u003d Integer.valueOf(nameId[1]);\n-        final String value \u003d nameId[0];        \n+        final Integer key \u003d parseId(nameId[1]);        \n+        final String value \u003d nameId[0];\n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n       }\n       LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d parseId(nameId[1]);        \n        final String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
      "extendedDetails": {}
    },
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6050. NFS does not handle exceptions correctly in a few places. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 1:49 PM",
      "commitName": "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "05/03/14 11:01 AM",
      "commitNameOld": "206e2b0cd295fa5a8c4dcfd95385efc5f7e34499",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 19.08,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n       String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n         final Integer key \u003d Integer.valueOf(nameId[1]);\n         final String value \u003d nameId[0];        \n         if (map.containsKey(key)) {\n           final String prevValue \u003d map.get(key);\n           if (value.equals(prevValue)) {\n             // silently ignore equivalent entries\n             continue;\n           }\n           reportDuplicateEntry(\n               \"Got multiple names associated with the same id: \",\n               key, value, key, prevValue);           \n           continue;\n         }\n         if (map.containsValue(value)) {\n           final Integer prevKey \u003d map.inverse().get(value);\n           reportDuplicateEntry(\n               \"Got multiple ids associated with the same name: \",\n               key, value, prevKey, value);\n           continue;\n         }\n         map.put(key, value);\n       }\n       LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n-          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n-          e1.printStackTrace();\n+          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d Integer.valueOf(nameId[1]);\n        final String value \u003d nameId[0];        \n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\", e1);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
      "extendedDetails": {}
    },
    "6439cd0f691069cefb6da4ba261ffe60cc13bbd0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5767. NFS implementation assumes userName userId mapping to be unique, which is not true sometimes. Contributed by Yongjun Zhang\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1564141 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/02/14 4:27 PM",
      "commitName": "6439cd0f691069cefb6da4ba261ffe60cc13bbd0",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "04/12/13 11:13 PM",
      "commitNameOld": "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 60.72,
      "commitsBetweenForRepo": 319,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,53 @@\n   public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n       String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n           throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n         LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n         // HDFS can\u0027t differentiate duplicate names with simple authentication\n-        Integer key \u003d Integer.valueOf(nameId[1]);\n-        String value \u003d nameId[0];\n+        final Integer key \u003d Integer.valueOf(nameId[1]);\n+        final String value \u003d nameId[0];        \n         if (map.containsKey(key)) {\n-          LOG.error(String.format(\n-              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n-              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n-          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n+          final String prevValue \u003d map.get(key);\n+          if (value.equals(prevValue)) {\n+            // silently ignore equivalent entries\n+            continue;\n+          }\n+          reportDuplicateEntry(\n+              \"Got multiple names associated with the same id: \",\n+              key, value, key, prevValue);           \n+          continue;\n         }\n-        if (map.containsValue(nameId[0])) {\n-          LOG.error(String.format(\n-              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n-              key, value, map.inverse().get(value), value,\n-              DUPLICATE_NAME_ID_DEBUG_INFO));\n-          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n+        if (map.containsValue(value)) {\n+          final Integer prevKey \u003d map.inverse().get(value);\n+          reportDuplicateEntry(\n+              \"Got multiple ids associated with the same name: \",\n+              key, value, prevKey, value);\n+          continue;\n         }\n-        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n+        map.put(key, value);\n       }\n       LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n       LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\");\n           e1.printStackTrace();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        final Integer key \u003d Integer.valueOf(nameId[1]);\n        final String value \u003d nameId[0];        \n        if (map.containsKey(key)) {\n          final String prevValue \u003d map.get(key);\n          if (value.equals(prevValue)) {\n            // silently ignore equivalent entries\n            continue;\n          }\n          reportDuplicateEntry(\n              \"Got multiple names associated with the same id: \",\n              key, value, key, prevValue);           \n          continue;\n        }\n        if (map.containsValue(value)) {\n          final Integer prevKey \u003d map.inverse().get(value);\n          reportDuplicateEntry(\n              \"Got multiple ids associated with the same name: \",\n              key, value, prevKey, value);\n          continue;\n        }\n        map.put(key, value);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n          e1.printStackTrace();\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
      "extendedDetails": {}
    },
    "aa4fba6d92faf5e51bb330c6d18825fbed63b553": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5587. add debug information when NFS fails to start with duplicate user or group names. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548028 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 11:13 PM",
      "commitName": "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
      "commitAuthor": "Brandon Li",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5587. add debug information when NFS fails to start with duplicate user or group names. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548028 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 11:13 PM",
          "commitName": "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "12/09/13 9:21 PM",
          "commitNameOld": "ede10b8a1f9a4d099c16469f827345cb359cef3d",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 83.12,
          "commitsBetweenForRepo": 523,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,48 @@\n-  private void updateMapInternal(BiMap\u003cInteger, String\u003e map, String name,\n-      String command, String regex) throws IOException {\n+  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n+      String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n-          throw new IOException(\"Can\u0027t parse \" + name + \" list entry:\" + line);\n+          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n-        LOG.debug(\"add \" + name + \":\" + nameId[0] + \" id:\" + nameId[1]);\n+        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n+        // HDFS can\u0027t differentiate duplicate names with simple authentication\n+        Integer key \u003d Integer.valueOf(nameId[1]);\n+        String value \u003d nameId[0];\n+        if (map.containsKey(key)) {\n+          LOG.error(String.format(\n+              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n+              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n+        }\n+        if (map.containsValue(nameId[0])) {\n+          LOG.error(String.format(\n+              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n+              key, value, map.inverse().get(value), value,\n+              DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n+        }\n         map.put(Integer.valueOf(nameId[1]), nameId[0]);\n       }\n-      LOG.info(\"Updated \" + name + \" map size:\" + map.size());\n+      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n-      LOG.error(\"Can\u0027t update map \" + name);\n+      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\");\n           e1.printStackTrace();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        Integer key \u003d Integer.valueOf(nameId[1]);\n        String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          LOG.error(String.format(\n              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n        }\n        if (map.containsValue(nameId[0])) {\n          LOG.error(String.format(\n              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n              key, value, map.inverse().get(value), value,\n              DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n        }\n        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n          e1.printStackTrace();\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
          "extendedDetails": {
            "oldValue": "[map-BiMap\u003cInteger,String\u003e, name-String, command-String, regex-String]",
            "newValue": "[map-BiMap\u003cInteger,String\u003e, mapName-String, command-String, regex-String]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5587. add debug information when NFS fails to start with duplicate user or group names. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548028 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 11:13 PM",
          "commitName": "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "12/09/13 9:21 PM",
          "commitNameOld": "ede10b8a1f9a4d099c16469f827345cb359cef3d",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 83.12,
          "commitsBetweenForRepo": 523,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,48 @@\n-  private void updateMapInternal(BiMap\u003cInteger, String\u003e map, String name,\n-      String command, String regex) throws IOException {\n+  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n+      String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n-          throw new IOException(\"Can\u0027t parse \" + name + \" list entry:\" + line);\n+          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n-        LOG.debug(\"add \" + name + \":\" + nameId[0] + \" id:\" + nameId[1]);\n+        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n+        // HDFS can\u0027t differentiate duplicate names with simple authentication\n+        Integer key \u003d Integer.valueOf(nameId[1]);\n+        String value \u003d nameId[0];\n+        if (map.containsKey(key)) {\n+          LOG.error(String.format(\n+              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n+              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n+        }\n+        if (map.containsValue(nameId[0])) {\n+          LOG.error(String.format(\n+              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n+              key, value, map.inverse().get(value), value,\n+              DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n+        }\n         map.put(Integer.valueOf(nameId[1]), nameId[0]);\n       }\n-      LOG.info(\"Updated \" + name + \" map size:\" + map.size());\n+      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n-      LOG.error(\"Can\u0027t update map \" + name);\n+      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\");\n           e1.printStackTrace();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        Integer key \u003d Integer.valueOf(nameId[1]);\n        String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          LOG.error(String.format(\n              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n        }\n        if (map.containsValue(nameId[0])) {\n          LOG.error(String.format(\n              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n              key, value, map.inverse().get(value), value,\n              DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n        }\n        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n          e1.printStackTrace();\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5587. add debug information when NFS fails to start with duplicate user or group names. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548028 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 11:13 PM",
          "commitName": "aa4fba6d92faf5e51bb330c6d18825fbed63b553",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "12/09/13 9:21 PM",
          "commitNameOld": "ede10b8a1f9a4d099c16469f827345cb359cef3d",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 83.12,
          "commitsBetweenForRepo": 523,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,48 @@\n-  private void updateMapInternal(BiMap\u003cInteger, String\u003e map, String name,\n-      String command, String regex) throws IOException {\n+  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n+      String command, String regex) throws IOException  {\n     BufferedReader br \u003d null;\n     try {\n       Process process \u003d Runtime.getRuntime().exec(\n           new String[] { \"bash\", \"-c\", command });\n       br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n       String line \u003d null;\n       while ((line \u003d br.readLine()) !\u003d null) {\n         String[] nameId \u003d line.split(regex);\n         if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n-          throw new IOException(\"Can\u0027t parse \" + name + \" list entry:\" + line);\n+          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n         }\n-        LOG.debug(\"add \" + name + \":\" + nameId[0] + \" id:\" + nameId[1]);\n+        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n+        // HDFS can\u0027t differentiate duplicate names with simple authentication\n+        Integer key \u003d Integer.valueOf(nameId[1]);\n+        String value \u003d nameId[0];\n+        if (map.containsKey(key)) {\n+          LOG.error(String.format(\n+              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n+              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n+        }\n+        if (map.containsValue(nameId[0])) {\n+          LOG.error(String.format(\n+              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n+              key, value, map.inverse().get(value), value,\n+              DUPLICATE_NAME_ID_DEBUG_INFO));\n+          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n+        }\n         map.put(Integer.valueOf(nameId[1]), nameId[0]);\n       }\n-      LOG.info(\"Updated \" + name + \" map size:\" + map.size());\n+      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n       \n     } catch (IOException e) {\n-      LOG.error(\"Can\u0027t update map \" + name);\n+      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n       throw e;\n     } finally {\n       if (br !\u003d null) {\n         try {\n           br.close();\n         } catch (IOException e1) {\n           LOG.error(\"Can\u0027t close BufferedReader of command result\");\n           e1.printStackTrace();\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateMapInternal(BiMap\u003cInteger, String\u003e map, String mapName,\n      String command, String regex) throws IOException  {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + mapName + \" list entry:\" + line);\n        }\n        LOG.debug(\"add to \" + mapName + \"map:\" + nameId[0] + \" id:\" + nameId[1]);\n        // HDFS can\u0027t differentiate duplicate names with simple authentication\n        Integer key \u003d Integer.valueOf(nameId[1]);\n        String value \u003d nameId[0];\n        if (map.containsKey(key)) {\n          LOG.error(String.format(\n              \"Got duplicate id:(%d, %s), existing entry: (%d, %s).\\n%s\", key,\n              value, key, map.get(key), DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate id.\");\n        }\n        if (map.containsValue(nameId[0])) {\n          LOG.error(String.format(\n              \"Got duplicate name:(%d, %s), existing entry: (%d, %s) \\n%s\",\n              key, value, map.inverse().get(value), value,\n              DUPLICATE_NAME_ID_DEBUG_INFO));\n          throw new DuplicateNameOrIdException(\"Got duplicate name\");\n        }\n        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n      }\n      LOG.info(\"Updated \" + mapName + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update \" + mapName + \" map\");\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n          e1.printStackTrace();\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
          "extendedDetails": {}
        }
      ]
    },
    "4d63b7a016232d3d816e9a0229a029a07a06757a": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9515. Add general interface for NFS and Mount. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 1:32 PM",
      "commitName": "4d63b7a016232d3d816e9a0229a029a07a06757a",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,32 @@\n+  private void updateMapInternal(BiMap\u003cInteger, String\u003e map, String name,\n+      String command, String regex) throws IOException {\n+    BufferedReader br \u003d null;\n+    try {\n+      Process process \u003d Runtime.getRuntime().exec(\n+          new String[] { \"bash\", \"-c\", command });\n+      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n+      String line \u003d null;\n+      while ((line \u003d br.readLine()) !\u003d null) {\n+        String[] nameId \u003d line.split(regex);\n+        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n+          throw new IOException(\"Can\u0027t parse \" + name + \" list entry:\" + line);\n+        }\n+        LOG.debug(\"add \" + name + \":\" + nameId[0] + \" id:\" + nameId[1]);\n+        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n+      }\n+      LOG.info(\"Updated \" + name + \" map size:\" + map.size());\n+      \n+    } catch (IOException e) {\n+      LOG.error(\"Can\u0027t update map \" + name);\n+      throw e;\n+    } finally {\n+      if (br !\u003d null) {\n+        try {\n+          br.close();\n+        } catch (IOException e1) {\n+          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n+          e1.printStackTrace();\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateMapInternal(BiMap\u003cInteger, String\u003e map, String name,\n      String command, String regex) throws IOException {\n    BufferedReader br \u003d null;\n    try {\n      Process process \u003d Runtime.getRuntime().exec(\n          new String[] { \"bash\", \"-c\", command });\n      br \u003d new BufferedReader(new InputStreamReader(process.getInputStream()));\n      String line \u003d null;\n      while ((line \u003d br.readLine()) !\u003d null) {\n        String[] nameId \u003d line.split(regex);\n        if ((nameId \u003d\u003d null) || (nameId.length !\u003d 2)) {\n          throw new IOException(\"Can\u0027t parse \" + name + \" list entry:\" + line);\n        }\n        LOG.debug(\"add \" + name + \":\" + nameId[0] + \" id:\" + nameId[1]);\n        map.put(Integer.valueOf(nameId[1]), nameId[0]);\n      }\n      LOG.info(\"Updated \" + name + \" map size:\" + map.size());\n      \n    } catch (IOException e) {\n      LOG.error(\"Can\u0027t update map \" + name);\n      throw e;\n    } finally {\n      if (br !\u003d null) {\n        try {\n          br.close();\n        } catch (IOException e1) {\n          LOG.error(\"Can\u0027t close BufferedReader of command result\");\n          e1.printStackTrace();\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java"
    }
  }
}