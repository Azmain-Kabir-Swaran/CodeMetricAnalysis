{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "create",
  "functionId": "create___f-Path__permission-FsPermission__overwrite-boolean__createParent-boolean__bufferSize-int__replication-short__blockSize-long__progress-Progressable__parentFolderLease-SelfRenewingLease",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 1794,
  "functionEndLine": 1813,
  "numCommitsSeen": 66,
  "timeTaken": 5989,
  "changeHistory": [
    "9288206cb3c1a39044a8e106436987185ef43ddf",
    "13eda5000304099d1145631f9be13ce8a00b600d",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
    "686823529be09bea2a6cecb3503ef722017475bc",
    "52d7d5aa1a303cf70519a61487641211f4267c6f",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
    "3369a4f6916f12e9d6b97072badd1b176be443bd",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "efa97243ecb84b3b468e732897cd685e3869f480",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40"
  ],
  "changeHistoryShort": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": "Ybodychange",
    "13eda5000304099d1145631f9be13ce8a00b600d": "Ybodychange",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": "Ybodychange",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": "Ybodychange",
    "686823529be09bea2a6cecb3503ef722017475bc": "Ybodychange",
    "52d7d5aa1a303cf70519a61487641211f4267c6f": "Ybodychange",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": "Ybodychange",
    "3369a4f6916f12e9d6b97072badd1b176be443bd": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "efa97243ecb84b3b468e732897cd685e3869f480": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14845. Azure wasb: getFileStatus not making any auth check.\nContributed by Sivaguru Sankaridurg\n",
      "commitDate": "05/10/17 7:05 AM",
      "commitName": "9288206cb3c1a39044a8e106436987185ef43ddf",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "28/09/17 11:52 AM",
      "commitNameOld": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,20 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path ancestor \u003d getAncestor(absolutePath);\n \n     performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n \n-    String key \u003d pathToKey(absolutePath);\n-\n-    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n-    if (existingMetadata !\u003d null) {\n-      if (existingMetadata.isDir()) {\n-        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n-            + \"; already exists as a directory.\");\n-      }\n-      if (!overwrite) {\n-        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n-      }\n-      else {\n-        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n-      }\n-    }\n-\n-    Path parentFolder \u003d absolutePath.getParent();\n-    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n-      // Update the parent folder last modified time if the parent folder\n-      // already exists.\n-      String parentKey \u003d pathToKey(parentFolder);\n-      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n-      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n-        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n-        if (parentFolderLease !\u003d null) {\n-          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n-        } else {\n-          updateParentFolderLastModifiedTime(key);\n-        }\n-      } else {\n-        // Make sure that the parent folder exists.\n-        // Create it using inherited permissions from the first existing directory going up the path\n-        Path firstExisting \u003d parentFolder.getParent();\n-        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n-        while(metadata \u003d\u003d null) {\n-          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n-          firstExisting \u003d firstExisting.getParent();\n-          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n-        }\n-        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n-      }\n-    }\n-\n-    // Mask the permission first (with the default permission mask as well).\n-    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n-    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n-\n-    OutputStream bufOutStream;\n-    if (store.isPageBlobKey(key)) {\n-      // Store page blobs directly in-place without renames.\n-      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n-    } else {\n-      // This is a block blob, so open the output blob stream based on the\n-      // encoded key.\n-      //\n-      String keyEncoded \u003d encodeKey(key);\n-\n-\n-      // First create a blob at the real key, pointing back to the temporary file\n-      // This accomplishes a few things:\n-      // 1. Makes sure we can create a file there.\n-      // 2. Makes it visible to other concurrent threads/processes/nodes what\n-      // we\u0027re\n-      // doing.\n-      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n-      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n-\n-      // The key is encoded to point to a common container at the storage server.\n-      // This reduces the number of splits on the server side when load balancing.\n-      // Ingress to Azure storage can take advantage of earlier splits. We remove\n-      // the root path to the key and prefix a random GUID to the tail (or leaf\n-      // filename) of the key. Keys are thus broadly and randomly distributed over\n-      // a single container to ease load balancing on the storage server. When the\n-      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n-      // are not cleaned up and we leave it to Azure storage to garbage collect\n-      // these\n-      // blocks.\n-      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n-          keyEncoded, permissionStatus, key), key, keyEncoded);\n-    }\n-    // Construct the data output stream from the buffered output stream.\n-    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n-\n-\n-    // Increment the counter\n-    instrumentation.fileCreated();\n-\n-    // Return data output stream to caller.\n-    return fsOut;\n+    return createInternal(f, permission, overwrite, parentFolderLease);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path ancestor \u003d getAncestor(absolutePath);\n\n    performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n\n    return createInternal(f, permission, overwrite, parentFolderLease);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "13eda5000304099d1145631f9be13ce8a00b600d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14520. WASB: Block compaction for Azure Block Blobs.\nContributed by Georgi Chalakov\n",
      "commitDate": "07/09/17 10:35 AM",
      "commitName": "13eda5000304099d1145631f9be13ce8a00b600d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/17 6:16 AM",
      "commitNameOld": "792eff9ea70da2c6e0ff5a1b177a51e7b2fb96eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path ancestor \u003d getAncestor(absolutePath);\n \n     performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n       else {\n         performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n-      bufOutStream \u003d store.storefile(key, permissionStatus);\n+      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n-          keyEncoded, permissionStatus), key, keyEncoded);\n+          keyEncoded, permissionStatus, key), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n \n     // Increment the counter\n     instrumentation.fileCreated();\n \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path ancestor \u003d getAncestor(absolutePath);\n\n    performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n      else {\n        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus, key);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus, key), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14416. Path starting with \u0027wasb:///\u0027 not resolved correctly while authorizing with WASB-Ranger. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "16/05/17 11:22 AM",
      "commitName": "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/05/17 3:05 PM",
      "commitNameOld": "eed731496f63537350206274af09d2118b116a17",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path ancestor \u003d getAncestor(absolutePath);\n \n-    performAuthCheck(ancestor.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n+    performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n       else {\n-        performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n+        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n \n     // Increment the counter\n     instrumentation.fileCreated();\n \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path ancestor \u003d getAncestor(absolutePath);\n\n    performAuthCheck(ancestor, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n      else {\n        performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"create\", absolutePath);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "12/04/17 4:07 PM",
      "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "04/04/17 11:10 AM",
      "commitNameOld": "56ab02eed9b61e1c80605104dfc4c87fc6abac96",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,108 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n+    Path ancestor \u003d getAncestor(absolutePath);\n \n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n+    performAuthCheck(ancestor.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n \n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n+      else {\n+        performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n+      }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n \n     // Increment the counter\n     instrumentation.fileCreated();\n \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path ancestor \u003d getAncestor(absolutePath);\n\n    performAuthCheck(ancestor.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n      else {\n        performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"create\", absolutePath.toString());\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "686823529be09bea2a6cecb3503ef722017475bc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "06/03/17 5:16 PM",
      "commitName": "686823529be09bea2a6cecb3503ef722017475bc",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:10 PM",
      "commitNameOld": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,105 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n+\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n-    \n+\n     // Increment the counter\n     instrumentation.fileCreated();\n-    \n+\n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n\n    // Increment the counter\n    instrumentation.fileCreated();\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "52d7d5aa1a303cf70519a61487641211f4267c6f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\"\n\nThis reverts commit 6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f.\n",
      "commitDate": "06/03/17 5:10 PM",
      "commitName": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:00 PM",
      "commitNameOld": "c571cda5c7d929477961dfff4176d7de4944d874",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,101 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n-\n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n-\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "03/03/17 5:09 PM",
      "commitName": "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "29/12/16 4:24 PM",
      "commitNameOld": "c6a5b689db573046819f0e9193cb042e6c7298f4",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 64.03,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,105 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n+\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.WRITE.toString(), \"create\");\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "3369a4f6916f12e9d6b97072badd1b176be443bd": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-12535. Run FileSystem contract tests with hadoop-azure. Contributed by Madhumita Chakraborty.\n",
      "commitDate": "23/02/16 9:37 PM",
      "commitName": "3369a4f6916f12e9d6b97072badd1b176be443bd",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-12535. Run FileSystem contract tests with hadoop-azure. Contributed by Madhumita Chakraborty.\n",
          "commitDate": "23/02/16 9:37 PM",
          "commitName": "3369a4f6916f12e9d6b97072badd1b176be443bd",
          "commitAuthor": "cnauroth",
          "commitDateOld": "12/02/16 3:50 PM",
          "commitNameOld": "91a96eaa534dbb27e81b6c24bbb8138200a80a83",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 11.24,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,101 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n-          throws IOException {\n+          throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n-        throw new IOException(\"Cannot create file \" + f\n+        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n-        throw new IOException(\"File already exists:\" + f);\n+        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[FileAlreadyExistsException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12535. Run FileSystem contract tests with hadoop-azure. Contributed by Madhumita Chakraborty.\n",
          "commitDate": "23/02/16 9:37 PM",
          "commitName": "3369a4f6916f12e9d6b97072badd1b176be443bd",
          "commitAuthor": "cnauroth",
          "commitDateOld": "12/02/16 3:50 PM",
          "commitNameOld": "91a96eaa534dbb27e81b6c24bbb8138200a80a83",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 11.24,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,101 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n-          throws IOException {\n+          throws FileAlreadyExistsException, IOException {\n \n     LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n-        throw new IOException(\"Cannot create file \" + f\n+        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n-        throw new IOException(\"File already exists:\" + f);\n+        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws FileAlreadyExistsException, IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new FileAlreadyExistsException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new FileAlreadyExistsException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,101 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws IOException {\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Creating file: \" + f.toString());\n-    }\n+    LOG.debug(\"Creating file: {}\", f.toString());\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new IOException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new IOException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n         parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         if (parentFolderLease !\u003d null) {\n           store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n         } else {\n           updateParentFolderLastModifiedTime(key);\n         }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws IOException {\n\n    LOG.debug(\"Creating file: {}\", f.toString());\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new IOException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new IOException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "efa97243ecb84b3b468e732897cd685e3869f480": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12239. StorageException complaining \" no lease ID\" when updating FolderLastModifiedTime in WASB. Contributed by Duo Xu.\n",
      "commitDate": "22/07/15 11:16 AM",
      "commitName": "efa97243ecb84b3b468e732897cd685e3869f480",
      "commitAuthor": "cnauroth",
      "commitDateOld": "29/06/15 1:48 PM",
      "commitNameOld": "460e98f7b3ec84f3c5afcb2aad4f4e7031d16e3a",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 22.89,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,103 @@\n   private FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, boolean createParent, int bufferSize,\n       short replication, long blockSize, Progressable progress,\n       SelfRenewingLease parentFolderLease)\n           throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Creating file: \" + f.toString());\n     }\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new IOException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new IOException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n-          parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n-        store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n+        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+        if (parentFolderLease !\u003d null) {\n+          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n+        } else {\n+          updateParentFolderLastModifiedTime(key);\n+        }\n       } else {\n         // Make sure that the parent folder exists.\n         // Create it using inherited permissions from the first existing directory going up the path\n         Path firstExisting \u003d parentFolder.getParent();\n         FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         while(metadata \u003d\u003d null) {\n           // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n           firstExisting \u003d firstExisting.getParent();\n           metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n         }\n         mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n       }\n     }\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     OutputStream bufOutStream;\n     if (store.isPageBlobKey(key)) {\n       // Store page blobs directly in-place without renames.\n       bufOutStream \u003d store.storefile(key, permissionStatus);\n     } else {\n       // This is a block blob, so open the output blob stream based on the\n       // encoded key.\n       //\n       String keyEncoded \u003d encodeKey(key);\n \n \n       // First create a blob at the real key, pointing back to the temporary file\n       // This accomplishes a few things:\n       // 1. Makes sure we can create a file there.\n       // 2. Makes it visible to other concurrent threads/processes/nodes what\n       // we\u0027re\n       // doing.\n       // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n       store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n       // The key is encoded to point to a common container at the storage server.\n       // This reduces the number of splits on the server side when load balancing.\n       // Ingress to Azure storage can take advantage of earlier splits. We remove\n       // the root path to the key and prefix a random GUID to the tail (or leaf\n       // filename) of the key. Keys are thus broadly and randomly distributed over\n       // a single container to ease load balancing on the storage server. When the\n       // blob is committed it is renamed to its earlier key. Uncommitted blocks\n       // are not cleaned up and we leave it to Azure storage to garbage collect\n       // these\n       // blocks.\n       bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n           keyEncoded, permissionStatus), key, keyEncoded);\n     }\n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n     \n     // Increment the counter\n     instrumentation.fileCreated();\n     \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating file: \" + f.toString());\n    }\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new IOException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new IOException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n        parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        if (parentFolderLease !\u003d null) {\n          store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n        } else {\n          updateParentFolderLastModifiedTime(key);\n        }\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,99 @@\n+  private FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, boolean createParent, int bufferSize,\n+      short replication, long blockSize, Progressable progress,\n+      SelfRenewingLease parentFolderLease)\n+          throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Creating file: \" + f.toString());\n+    }\n+\n+    if (containsColon(f)) {\n+      throw new IOException(\"Cannot create file \" + f\n+          + \" through WASB that has colons in the name\");\n+    }\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+\n+    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n+    if (existingMetadata !\u003d null) {\n+      if (existingMetadata.isDir()) {\n+        throw new IOException(\"Cannot create file \" + f\n+            + \"; already exists as a directory.\");\n+      }\n+      if (!overwrite) {\n+        throw new IOException(\"File already exists:\" + f);\n+      }\n+    }\n+\n+    Path parentFolder \u003d absolutePath.getParent();\n+    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n+      // Update the parent folder last modified time if the parent folder\n+      // already exists.\n+      String parentKey \u003d pathToKey(parentFolder);\n+      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n+          parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+        store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n+      } else {\n+        // Make sure that the parent folder exists.\n+        // Create it using inherited permissions from the first existing directory going up the path\n+        Path firstExisting \u003d parentFolder.getParent();\n+        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n+        while(metadata \u003d\u003d null) {\n+          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n+          firstExisting \u003d firstExisting.getParent();\n+          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n+        }\n+        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n+      }\n+    }\n+\n+    // Mask the permission first (with the default permission mask as well).\n+    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n+    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n+\n+    OutputStream bufOutStream;\n+    if (store.isPageBlobKey(key)) {\n+      // Store page blobs directly in-place without renames.\n+      bufOutStream \u003d store.storefile(key, permissionStatus);\n+    } else {\n+      // This is a block blob, so open the output blob stream based on the\n+      // encoded key.\n+      //\n+      String keyEncoded \u003d encodeKey(key);\n+\n+\n+      // First create a blob at the real key, pointing back to the temporary file\n+      // This accomplishes a few things:\n+      // 1. Makes sure we can create a file there.\n+      // 2. Makes it visible to other concurrent threads/processes/nodes what\n+      // we\u0027re\n+      // doing.\n+      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n+      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n+\n+      // The key is encoded to point to a common container at the storage server.\n+      // This reduces the number of splits on the server side when load balancing.\n+      // Ingress to Azure storage can take advantage of earlier splits. We remove\n+      // the root path to the key and prefix a random GUID to the tail (or leaf\n+      // filename) of the key. Keys are thus broadly and randomly distributed over\n+      // a single container to ease load balancing on the storage server. When the\n+      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n+      // are not cleaned up and we leave it to Azure storage to garbage collect\n+      // these\n+      // blocks.\n+      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n+          keyEncoded, permissionStatus), key, keyEncoded);\n+    }\n+    // Construct the data output stream from the buffered output stream.\n+    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n+\n+    \n+    // Increment the counter\n+    instrumentation.fileCreated();\n+    \n+    // Return data output stream to caller.\n+    return fsOut;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, boolean createParent, int bufferSize,\n      short replication, long blockSize, Progressable progress,\n      SelfRenewingLease parentFolderLease)\n          throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating file: \" + f.toString());\n    }\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new IOException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new IOException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null \u0026\u0026 parentMetadata.isDir() \u0026\u0026\n          parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        store.updateFolderLastModifiedTime(parentKey, parentFolderLease);\n      } else {\n        // Make sure that the parent folder exists.\n        // Create it using inherited permissions from the first existing directory going up the path\n        Path firstExisting \u003d parentFolder.getParent();\n        FileMetadata metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        while(metadata \u003d\u003d null) {\n          // Guaranteed to terminate properly because we will eventually hit root, which will return non-null metadata\n          firstExisting \u003d firstExisting.getParent();\n          metadata \u003d store.retrieveMetadata(pathToKey(firstExisting));\n        }\n        mkdirs(parentFolder, metadata.getPermissionStatus().getPermission(), true);\n      }\n    }\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    OutputStream bufOutStream;\n    if (store.isPageBlobKey(key)) {\n      // Store page blobs directly in-place without renames.\n      bufOutStream \u003d store.storefile(key, permissionStatus);\n    } else {\n      // This is a block blob, so open the output blob stream based on the\n      // encoded key.\n      //\n      String keyEncoded \u003d encodeKey(key);\n\n\n      // First create a blob at the real key, pointing back to the temporary file\n      // This accomplishes a few things:\n      // 1. Makes sure we can create a file there.\n      // 2. Makes it visible to other concurrent threads/processes/nodes what\n      // we\u0027re\n      // doing.\n      // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n      store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n      // The key is encoded to point to a common container at the storage server.\n      // This reduces the number of splits on the server side when load balancing.\n      // Ingress to Azure storage can take advantage of earlier splits. We remove\n      // the root path to the key and prefix a random GUID to the tail (or leaf\n      // filename) of the key. Keys are thus broadly and randomly distributed over\n      // a single container to ease load balancing on the storage server. When the\n      // blob is committed it is renamed to its earlier key. Uncommitted blocks\n      // are not cleaned up and we leave it to Azure storage to garbage collect\n      // these\n      // blocks.\n      bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n          keyEncoded, permissionStatus), key, keyEncoded);\n    }\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}