{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServerProxy.java",
  "functionName": "createRetryPolicy",
  "functionId": "createRetryPolicy___conf-Configuration__maxWaitTimeStr-String__defMaxWaitTime-long__connectRetryIntervalStr-String__defRetryInterval-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
  "functionStartLine": 50,
  "functionEndLine": 92,
  "numCommitsSeen": 8,
  "timeTaken": 2413,
  "changeHistory": [
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
    "13de8359a1c6d9fc78cd5013c860c1086d86176f",
    "b00392dd9cbb6778f2f3e669e96cf7133590dfe7",
    "62e583c7dcbb30d95d8b32a4978fbdb3b98d67cc",
    "5ebf2817e58e1be8214dc1916a694a912075aa0a",
    "92d67ace3248930c0c0335070cc71a480c566a36",
    "5c9a51f140ba76ddb25580aeb288db25e3f9653f",
    "0708827a935d190d439854e08bb5a655d7daa606"
  ],
  "changeHistoryShort": {
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d": "Ybodychange",
    "13de8359a1c6d9fc78cd5013c860c1086d86176f": "Ybodychange",
    "b00392dd9cbb6778f2f3e669e96cf7133590dfe7": "Ybodychange",
    "62e583c7dcbb30d95d8b32a4978fbdb3b98d67cc": "Ybodychange",
    "5ebf2817e58e1be8214dc1916a694a912075aa0a": "Ybodychange",
    "92d67ace3248930c0c0335070cc71a480c566a36": "Ybodychange",
    "5c9a51f140ba76ddb25580aeb288db25e3f9653f": "Ybodychange",
    "0708827a935d190d439854e08bb5a655d7daa606": "Yintroduced"
  },
  "changeHistoryDetails": {
    "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3839. Quit throwing NMNotYetReadyException. Contributed by Manikandan R\n",
      "commitDate": "08/05/17 3:14 PM",
      "commitName": "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/01/16 7:56 AM",
      "commitNameOld": "13de8359a1c6d9fc78cd5013c860c1086d86176f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 482.26,
      "commitsBetweenForRepo": 3186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n \n     Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n         \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n             + \" positive value or -1.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d null;\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n       retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n           TimeUnit.MILLISECONDS);\n     } else {\n       retryPolicy \u003d\n           RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n               retryIntervalMS, TimeUnit.MILLISECONDS);\n     }\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n+    \n+    /*\n+     * Still keeping this to cover case like newer client talking\n+     * to an older version of server\n+     */\n     exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n\n    Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n        \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n            + \" positive value or -1.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d null;\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n          TimeUnit.MILLISECONDS);\n    } else {\n      retryPolicy \u003d\n          RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n              retryIntervalMS, TimeUnit.MILLISECONDS);\n    }\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n    \n    /*\n     * Still keeping this to cover case like newer client talking\n     * to an older version of server\n     */\n    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "13de8359a1c6d9fc78cd5013c860c1086d86176f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4414. Nodemanager connection errors are retried at multiple levels. Contributed by Chang Li\n",
      "commitDate": "12/01/16 7:56 AM",
      "commitName": "13de8359a1c6d9fc78cd5013c860c1086d86176f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "21/09/15 11:04 AM",
      "commitNameOld": "b00392dd9cbb6778f2f3e669e96cf7133590dfe7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 112.91,
      "commitsBetweenForRepo": 774,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n \n     Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n         \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n             + \" positive value or -1.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d null;\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n       retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n           TimeUnit.MILLISECONDS);\n     } else {\n       retryPolicy \u003d\n           RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n               retryIntervalMS, TimeUnit.MILLISECONDS);\n     }\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n+    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n     exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n\n    Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n        \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n            + \" positive value or -1.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d null;\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n          TimeUnit.MILLISECONDS);\n    } else {\n      retryPolicy \u003d\n          RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n              retryIntervalMS, TimeUnit.MILLISECONDS);\n    }\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "b00392dd9cbb6778f2f3e669e96cf7133590dfe7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4113. RM should respect retry-interval when uses RetryPolicies.RETRY_FOREVER. (Sunil G via wangda)\n",
      "commitDate": "21/09/15 11:04 AM",
      "commitName": "b00392dd9cbb6778f2f3e669e96cf7133590dfe7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/06/15 1:37 PM",
      "commitNameOld": "62e583c7dcbb30d95d8b32a4978fbdb3b98d67cc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 83.89,
      "commitsBetweenForRepo": 490,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n \n     Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n         \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n             + \" positive value or -1.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d null;\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n-      retryPolicy \u003d RetryPolicies.RETRY_FOREVER;\n+      retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n+          TimeUnit.MILLISECONDS);\n     } else {\n       retryPolicy \u003d\n           RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n               retryIntervalMS, TimeUnit.MILLISECONDS);\n     }\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n     exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n\n    Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n        \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n            + \" positive value or -1.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d null;\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      retryPolicy \u003d RetryPolicies.retryForeverWithFixedSleep(retryIntervalMS,\n          TimeUnit.MILLISECONDS);\n    } else {\n      retryPolicy \u003d\n          RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n              retryIntervalMS, TimeUnit.MILLISECONDS);\n    }\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "62e583c7dcbb30d95d8b32a4978fbdb3b98d67cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3695. ServerProxy (NMProxy, etc.) shouldn\u0027t retry forever for non network exception. Contributed by Raju Bairishetti\n",
      "commitDate": "29/06/15 1:37 PM",
      "commitName": "62e583c7dcbb30d95d8b32a4978fbdb3b98d67cc",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/06/15 5:47 PM",
      "commitNameOld": "5ebf2817e58e1be8214dc1916a694a912075aa0a",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.83,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,36 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n-    if (maxWaitTime \u003d\u003d -1) {\n-      // wait forever.\n-      return RetryPolicies.RETRY_FOREVER;\n-    }\n \n-    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n-        + maxWaitTimeStr + \" should be a positive value.\");\n+    Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n+        \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n+            + \" positive value or -1.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n-    RetryPolicy retryPolicy \u003d\n-        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n-          retryIntervalMS, TimeUnit.MILLISECONDS);\n+    RetryPolicy retryPolicy \u003d null;\n+    if (maxWaitTime \u003d\u003d -1) {\n+      // wait forever.\n+      retryPolicy \u003d RetryPolicies.RETRY_FOREVER;\n+    } else {\n+      retryPolicy \u003d\n+          RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n+              retryIntervalMS, TimeUnit.MILLISECONDS);\n+    }\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n     exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n\n    Preconditions.checkArgument((maxWaitTime \u003d\u003d -1 || maxWaitTime \u003e 0),\n        \"Invalid Configuration. \" + maxWaitTimeStr + \" should be either\"\n            + \" positive value or -1.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d null;\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      retryPolicy \u003d RetryPolicies.RETRY_FOREVER;\n    } else {\n      retryPolicy \u003d\n          RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n              retryIntervalMS, TimeUnit.MILLISECONDS);\n    }\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "5ebf2817e58e1be8214dc1916a694a912075aa0a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3842. NMProxy should retry on NMNotYetReadyException. (Robert Kanter via kasha)\n",
      "commitDate": "22/06/15 5:47 PM",
      "commitName": "5ebf2817e58e1be8214dc1916a694a912075aa0a",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/02/15 4:06 PM",
      "commitNameOld": "92d67ace3248930c0c0335070cc71a480c566a36",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 121.03,
      "commitsBetweenForRepo": 1062,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n       return RetryPolicies.RETRY_FOREVER;\n     }\n \n     Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n         + maxWaitTimeStr + \" should be a positive value.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d\n         RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n           retryIntervalMS, TimeUnit.MILLISECONDS);\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n+    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      return RetryPolicies.RETRY_FOREVER;\n    }\n\n    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n        + maxWaitTimeStr + \" should be a positive value.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d\n        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n          retryIntervalMS, TimeUnit.MILLISECONDS);\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n    exceptionToPolicyMap.put(NMNotYetReadyException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "92d67ace3248930c0c0335070cc71a480c566a36": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3238. Connection timeouts to nodemanagers are retried at multiple\nlevels. Contributed by Jason Lowe\n",
      "commitDate": "21/02/15 4:06 PM",
      "commitName": "92d67ace3248930c0c0335070cc71a480c566a36",
      "commitAuthor": "Xuan",
      "commitDateOld": "10/11/14 6:25 PM",
      "commitNameOld": "5c9a51f140ba76ddb25580aeb288db25e3f9653f",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 102.9,
      "commitsBetweenForRepo": 762,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,32 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n       return RetryPolicies.RETRY_FOREVER;\n     }\n \n     Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n         + maxWaitTimeStr + \" should be a positive value.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d\n         RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n           retryIntervalMS, TimeUnit.MILLISECONDS);\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n     exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n-    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      return RetryPolicies.RETRY_FOREVER;\n    }\n\n    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n        + maxWaitTimeStr + \" should be a positive value.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d\n        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n          retryIntervalMS, TimeUnit.MILLISECONDS);\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "5c9a51f140ba76ddb25580aeb288db25e3f9653f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2841. RMProxy should retry EOFException.  Contributed by Jian He\n",
      "commitDate": "10/11/14 6:25 PM",
      "commitName": "5c9a51f140ba76ddb25580aeb288db25e3f9653f",
      "commitAuthor": "Xuan",
      "commitDateOld": "01/10/14 4:50 PM",
      "commitNameOld": "0708827a935d190d439854e08bb5a655d7daa606",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 40.11,
      "commitsBetweenForRepo": 377,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n   protected static RetryPolicy createRetryPolicy(Configuration conf,\n       String maxWaitTimeStr, long defMaxWaitTime,\n       String connectRetryIntervalStr, long defRetryInterval) {\n     long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n     long retryIntervalMS \u003d\n         conf.getLong(connectRetryIntervalStr, defRetryInterval);\n     if (maxWaitTime \u003d\u003d -1) {\n       // wait forever.\n       return RetryPolicies.RETRY_FOREVER;\n     }\n \n     Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n         + maxWaitTimeStr + \" should be a positive value.\");\n     Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n         + connectRetryIntervalStr + \"should be a positive value.\");\n \n     RetryPolicy retryPolicy \u003d\n         RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n           retryIntervalMS, TimeUnit.MILLISECONDS);\n \n     Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n         new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n+    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n     exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n     exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n     exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n     exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n \n     return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n       exceptionToPolicyMap);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      return RetryPolicies.RETRY_FOREVER;\n    }\n\n    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n        + maxWaitTimeStr + \" should be a positive value.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d\n        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n          retryIntervalMS, TimeUnit.MILLISECONDS);\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(EOFException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java",
      "extendedDetails": {}
    },
    "0708827a935d190d439854e08bb5a655d7daa606": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2613. Support retry in NMClient for rolling-upgrades. (Contributed by Jian He)\n",
      "commitDate": "01/10/14 4:50 PM",
      "commitName": "0708827a935d190d439854e08bb5a655d7daa606",
      "commitAuthor": "junping_du",
      "diff": "@@ -0,0 +1,32 @@\n+  protected static RetryPolicy createRetryPolicy(Configuration conf,\n+      String maxWaitTimeStr, long defMaxWaitTime,\n+      String connectRetryIntervalStr, long defRetryInterval) {\n+    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n+    long retryIntervalMS \u003d\n+        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n+    if (maxWaitTime \u003d\u003d -1) {\n+      // wait forever.\n+      return RetryPolicies.RETRY_FOREVER;\n+    }\n+\n+    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n+        + maxWaitTimeStr + \" should be a positive value.\");\n+    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n+        + connectRetryIntervalStr + \"should be a positive value.\");\n+\n+    RetryPolicy retryPolicy \u003d\n+        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n+          retryIntervalMS, TimeUnit.MILLISECONDS);\n+\n+    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n+        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n+    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n+    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n+    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n+    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n+    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n+    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n+\n+    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n+      exceptionToPolicyMap);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected static RetryPolicy createRetryPolicy(Configuration conf,\n      String maxWaitTimeStr, long defMaxWaitTime,\n      String connectRetryIntervalStr, long defRetryInterval) {\n    long maxWaitTime \u003d conf.getLong(maxWaitTimeStr, defMaxWaitTime);\n    long retryIntervalMS \u003d\n        conf.getLong(connectRetryIntervalStr, defRetryInterval);\n    if (maxWaitTime \u003d\u003d -1) {\n      // wait forever.\n      return RetryPolicies.RETRY_FOREVER;\n    }\n\n    Preconditions.checkArgument(maxWaitTime \u003e 0, \"Invalid Configuration. \"\n        + maxWaitTimeStr + \" should be a positive value.\");\n    Preconditions.checkArgument(retryIntervalMS \u003e 0, \"Invalid Configuration. \"\n        + connectRetryIntervalStr + \"should be a positive value.\");\n\n    RetryPolicy retryPolicy \u003d\n        RetryPolicies.retryUpToMaximumTimeWithFixedSleep(maxWaitTime,\n          retryIntervalMS, TimeUnit.MILLISECONDS);\n\n    Map\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e exceptionToPolicyMap \u003d\n        new HashMap\u003cClass\u003c? extends Exception\u003e, RetryPolicy\u003e();\n    exceptionToPolicyMap.put(ConnectException.class, retryPolicy);\n    exceptionToPolicyMap.put(NoRouteToHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(UnknownHostException.class, retryPolicy);\n    exceptionToPolicyMap.put(ConnectTimeoutException.class, retryPolicy);\n    exceptionToPolicyMap.put(RetriableException.class, retryPolicy);\n    exceptionToPolicyMap.put(SocketException.class, retryPolicy);\n\n    return RetryPolicies.retryByException(RetryPolicies.TRY_ONCE_THEN_FAIL,\n      exceptionToPolicyMap);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/client/ServerProxy.java"
    }
  }
}