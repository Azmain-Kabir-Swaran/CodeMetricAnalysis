{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "addApplication",
  "functionId": "addApplication___applicationId-ApplicationId__queueName-String__user-String__isAppRecovering-boolean__placementContext-ApplicationPlacementContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 467,
  "functionEndLine": 581,
  "numCommitsSeen": 745,
  "timeTaken": 14286,
  "changeHistory": [
    "581072a8f04f7568d3560f105fd1988d3acc9e54",
    "5257f50abb71905ef3068fd45541d00ce9e8f355",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "524a7523c427b55273133078898ae3535897bada",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
    "86bc6425d425913899f1d951498bd040e453b3d0",
    "f48fec83d0f2d1a781a141ad7216463c5526321f",
    "bc93ac229e17b1be440052217e51820b95c179ec",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "0da54e8848764c71a31473516d23ada582013f8c",
    "4992398aeeb213ce59e068b0226e22e49ce559eb",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "bda23181bf1931c37d2590e03da9acdc6688ad34",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "b06cc16f7df63766531721a55280061949cab9b4",
    "f677175f35f68bde9df72e648dffacbd31cfd620",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b",
    "3858b9018e3c2f4b883b02021679852591b706f7",
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22",
    "171493215889a3b6bf2f6ba33212c4f06861a189",
    "345bcee0664392323b4297c0797897a96fef8958",
    "19a291a0d65b64e50571c3519414b9d54acbe28a",
    "5014a4b133000648e25ca7a801e2f23baa2273f5",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
    "1943fdbec613715f3cdc3ca60cbd273115f28299",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "581072a8f04f7568d3560f105fd1988d3acc9e54": "Ybodychange",
    "5257f50abb71905ef3068fd45541d00ce9e8f355": "Ymultichange(Yparameterchange,Ybodychange)",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "524a7523c427b55273133078898ae3535897bada": "Ybodychange",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": "Ybodychange",
    "86bc6425d425913899f1d951498bd040e453b3d0": "Ybodychange",
    "f48fec83d0f2d1a781a141ad7216463c5526321f": "Ybodychange",
    "bc93ac229e17b1be440052217e51820b95c179ec": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "0da54e8848764c71a31473516d23ada582013f8c": "Ybodychange",
    "4992398aeeb213ce59e068b0226e22e49ce559eb": "Ybodychange",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": "Ybodychange",
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b": "Ybodychange",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "bda23181bf1931c37d2590e03da9acdc6688ad34": "Ymultichange(Yparameterchange,Ybodychange)",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "b06cc16f7df63766531721a55280061949cab9b4": "Ybodychange",
    "f677175f35f68bde9df72e648dffacbd31cfd620": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": "Yrename",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": "Yrename",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": "Yrename",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": "Ybodychange",
    "3858b9018e3c2f4b883b02021679852591b706f7": "Ybodychange",
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38": "Ybodychange",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": "Ybodychange",
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22": "Ybodychange",
    "171493215889a3b6bf2f6ba33212c4f06861a189": "Ybodychange",
    "345bcee0664392323b4297c0797897a96fef8958": "Ybodychange",
    "19a291a0d65b64e50571c3519414b9d54acbe28a": "Ybodychange",
    "5014a4b133000648e25ca7a801e2f23baa2273f5": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Ybodychange",
    "1943fdbec613715f3cdc3ca60cbd273115f28299": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "581072a8f04f7568d3560f105fd1988d3acc9e54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7913. Improve error handling when application recovery fails with exception. Contributed by Wilfred Spiegelenburg\n",
      "commitDate": "20/01/20 4:10 AM",
      "commitName": "581072a8f04f7568d3560f105fd1988d3acc9e54",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/01/20 3:42 AM",
      "commitNameOld": "2aa065d98f36527d7769c9c58a923a706036391d",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 5.02,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,115 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering,\n       ApplicationPlacementContext placementContext) {\n     // If the  placement was rejected the placementContext will be null.\n     // We ignore placement rules on recovery.\n     if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n       String message \u003d \"Reject application \" + applicationId +\n           \" submitted by user \" + user +\n           \" application rejected by placement rules.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     writeLock.lock();\n     try {\n       // Assign the app to the queue creating and prevent queue delete.\n+      // This will re-create the queue on restore, however this could fail if\n+      // the config was changed.\n       FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n           applicationId);\n       if (queue \u003d\u003d null) {\n-        rejectApplicationWithMessage(applicationId,\n-            queueName + \" is not a leaf queue\");\n-        return;\n+        if (!isAppRecovering) {\n+          rejectApplicationWithMessage(applicationId,\n+              queueName + \" is not a leaf queue\");\n+          return;\n+        }\n+        // app is recovering we do not want to fail the app now as it was there\n+        // before we started the recovery. Add it to the recovery queue:\n+        // dynamic queue directly under root, no ACL needed (auto clean up)\n+        queueName \u003d \"root.recovery\";\n+        queue \u003d queueMgr.getLeafQueue(queueName, true, applicationId);\n       }\n \n-      // Enforce ACLs: 2nd check, there could be a time laps between the app\n-      // creation in the RMAppManager and getting here. That means we could\n-      // have a configuration change (prevent race condition)\n-      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n-          user);\n-\n-      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n-          !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-        String msg \u003d \"User \" + user + \" does not have permission to submit \" +\n-            applicationId + \" to queue \" + queueName;\n-        rejectApplicationWithMessage(applicationId, msg);\n-        queue.removeAssignedApp(applicationId);\n-        return;\n+      // Skip ACL check for recovering applications: they have been accepted\n+      // in the queue already recovery should not break that.\n+      if (!isAppRecovering) {\n+        // Enforce ACLs: 2nd check, there could be a time laps between the app\n+        // creation in the RMAppManager and getting here. That means we could\n+        // have a configuration change (prevent race condition)\n+        UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n+            user);\n+        if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n+            !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+          String msg \u003d \"User \" + user + \" does not have permission to submit \"\n+              + applicationId + \" to queue \" + queueName;\n+          rejectApplicationWithMessage(applicationId, msg);\n+          queue.removeAssignedApp(applicationId);\n+          return;\n+        }\n       }\n \n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       if (rmApp !\u003d null) {\n         rmApp.setQueue(queueName);\n       } else {\n         LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n             \" to set queue name on\");\n       }\n \n-      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n+      // when recovering the NMs might not have registered and we could have\n+      // no resources in the queue, the app is already running and has thus\n+      // passed all these checks, skip them now.\n+      if (!isAppRecovering \u0026\u0026 rmApp !\u003d null \u0026\u0026\n+          rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n                   applicationId, queueName,\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           queue.removeAssignedApp(applicationId);\n           return;\n         }\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003c\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queueName\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n             applicationId);\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering,\n      ApplicationPlacementContext placementContext) {\n    // If the  placement was rejected the placementContext will be null.\n    // We ignore placement rules on recovery.\n    if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n      String message \u003d \"Reject application \" + applicationId +\n          \" submitted by user \" + user +\n          \" application rejected by placement rules.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      // Assign the app to the queue creating and prevent queue delete.\n      // This will re-create the queue on restore, however this could fail if\n      // the config was changed.\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n          applicationId);\n      if (queue \u003d\u003d null) {\n        if (!isAppRecovering) {\n          rejectApplicationWithMessage(applicationId,\n              queueName + \" is not a leaf queue\");\n          return;\n        }\n        // app is recovering we do not want to fail the app now as it was there\n        // before we started the recovery. Add it to the recovery queue:\n        // dynamic queue directly under root, no ACL needed (auto clean up)\n        queueName \u003d \"root.recovery\";\n        queue \u003d queueMgr.getLeafQueue(queueName, true, applicationId);\n      }\n\n      // Skip ACL check for recovering applications: they have been accepted\n      // in the queue already recovery should not break that.\n      if (!isAppRecovering) {\n        // Enforce ACLs: 2nd check, there could be a time laps between the app\n        // creation in the RMAppManager and getting here. That means we could\n        // have a configuration change (prevent race condition)\n        UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n            user);\n        if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n            !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n          String msg \u003d \"User \" + user + \" does not have permission to submit \"\n              + applicationId + \" to queue \" + queueName;\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      if (rmApp !\u003d null) {\n        rmApp.setQueue(queueName);\n      } else {\n        LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n            \" to set queue name on\");\n      }\n\n      // when recovering the NMs might not have registered and we could have\n      // no resources in the queue, the app is already running and has thus\n      // passed all these checks, skip them now.\n      if (!isAppRecovering \u0026\u0026 rmApp !\u003d null \u0026\u0026\n          rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queueName,\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003c\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queueName\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n            applicationId);\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "5257f50abb71905ef3068fd45541d00ce9e8f355": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "25/03/19 10:47 PM",
      "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
      "commitAuthor": "yufei",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "15/03/19 4:20 PM",
          "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 10.27,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,99 @@\n   protected void addApplication(ApplicationId applicationId,\n-      String queueName, String user, boolean isAppRecovering) {\n-    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d\n-          \"Reject application \" + applicationId + \" submitted by user \" + user\n-              + \" with an empty queue name.\";\n-      rejectApplicationWithMessage(applicationId, message);\n-      return;\n-    }\n-\n-    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n-      String message \u003d\n-          \"Reject application \" + applicationId + \" submitted by user \" + user\n-              + \" with an illegal queue name \" + queueName + \". \"\n-              + \"The queue name cannot start/end with period.\";\n+      String queueName, String user, boolean isAppRecovering,\n+      ApplicationPlacementContext placementContext) {\n+    // If the  placement was rejected the placementContext will be null.\n+    // We ignore placement rules on recovery.\n+    if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n+      String message \u003d \"Reject application \" + applicationId +\n+          \" submitted by user \" + user +\n+          \" application rejected by placement rules.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     writeLock.lock();\n     try {\n-      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n-      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n+      // Assign the app to the queue creating and prevent queue delete.\n+      FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n+          applicationId);\n       if (queue \u003d\u003d null) {\n+        rejectApplicationWithMessage(applicationId,\n+            queueName + \" is not a leaf queue\");\n         return;\n       }\n \n+      // Enforce ACLs: 2nd check, there could be a time laps between the app\n+      // creation in the RMAppManager and getting here. That means we could\n+      // have a configuration change (prevent race condition)\n+      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n+          user);\n+\n+      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n+          !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+        String msg \u003d \"User \" + user + \" does not have permission to submit \" +\n+            applicationId + \" to queue \" + queueName;\n+        rejectApplicationWithMessage(applicationId, msg);\n+        queue.removeAssignedApp(applicationId);\n+        return;\n+      }\n+\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      if (rmApp !\u003d null) {\n+        rmApp.setQueue(queueName);\n+      } else {\n+        LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n+            \" to set queue name on\");\n+      }\n+\n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n-                  applicationId, queue.getName(),\n+                  applicationId, queueName,\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           queue.removeAssignedApp(applicationId);\n           return;\n         }\n       }\n \n-      // Enforce ACLs\n-      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n-          user);\n-\n-      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n-          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-        String msg \u003d \"User \" + userUgi.getUserName()\n-            + \" cannot submit applications to queue \" + queue.getName()\n-            + \"(requested queuename is \" + queueName + \")\";\n-        rejectApplicationWithMessage(applicationId, msg);\n-        queue.removeAssignedApp(applicationId);\n-        return;\n-      }\n-\n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n+          new SchedulerApplication\u003c\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-          + \", in queue: \" + queue.getName()\n+          + \", in queue: \" + queueName\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n             applicationId);\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering,\n      ApplicationPlacementContext placementContext) {\n    // If the  placement was rejected the placementContext will be null.\n    // We ignore placement rules on recovery.\n    if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n      String message \u003d \"Reject application \" + applicationId +\n          \" submitted by user \" + user +\n          \" application rejected by placement rules.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      // Assign the app to the queue creating and prevent queue delete.\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n          applicationId);\n      if (queue \u003d\u003d null) {\n        rejectApplicationWithMessage(applicationId,\n            queueName + \" is not a leaf queue\");\n        return;\n      }\n\n      // Enforce ACLs: 2nd check, there could be a time laps between the app\n      // creation in the RMAppManager and getting here. That means we could\n      // have a configuration change (prevent race condition)\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n          !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + user + \" does not have permission to submit \" +\n            applicationId + \" to queue \" + queueName;\n        rejectApplicationWithMessage(applicationId, msg);\n        queue.removeAssignedApp(applicationId);\n        return;\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      if (rmApp !\u003d null) {\n        rmApp.setQueue(queueName);\n      } else {\n        LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n            \" to set queue name on\");\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queueName,\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003c\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queueName\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n            applicationId);\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationId-ApplicationId, queueName-String, user-String, isAppRecovering-boolean]",
            "newValue": "[applicationId-ApplicationId, queueName-String, user-String, isAppRecovering-boolean, placementContext-ApplicationPlacementContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8967. Change FairScheduler to use PlacementRule interface. Contributed by Wilfred Spiegelenburg.\n",
          "commitDate": "25/03/19 10:47 PM",
          "commitName": "5257f50abb71905ef3068fd45541d00ce9e8f355",
          "commitAuthor": "yufei",
          "commitDateOld": "15/03/19 4:20 PM",
          "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 10.27,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,99 @@\n   protected void addApplication(ApplicationId applicationId,\n-      String queueName, String user, boolean isAppRecovering) {\n-    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d\n-          \"Reject application \" + applicationId + \" submitted by user \" + user\n-              + \" with an empty queue name.\";\n-      rejectApplicationWithMessage(applicationId, message);\n-      return;\n-    }\n-\n-    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n-      String message \u003d\n-          \"Reject application \" + applicationId + \" submitted by user \" + user\n-              + \" with an illegal queue name \" + queueName + \". \"\n-              + \"The queue name cannot start/end with period.\";\n+      String queueName, String user, boolean isAppRecovering,\n+      ApplicationPlacementContext placementContext) {\n+    // If the  placement was rejected the placementContext will be null.\n+    // We ignore placement rules on recovery.\n+    if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n+      String message \u003d \"Reject application \" + applicationId +\n+          \" submitted by user \" + user +\n+          \" application rejected by placement rules.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     writeLock.lock();\n     try {\n-      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n-      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n+      // Assign the app to the queue creating and prevent queue delete.\n+      FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n+          applicationId);\n       if (queue \u003d\u003d null) {\n+        rejectApplicationWithMessage(applicationId,\n+            queueName + \" is not a leaf queue\");\n         return;\n       }\n \n+      // Enforce ACLs: 2nd check, there could be a time laps between the app\n+      // creation in the RMAppManager and getting here. That means we could\n+      // have a configuration change (prevent race condition)\n+      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n+          user);\n+\n+      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n+          !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+        String msg \u003d \"User \" + user + \" does not have permission to submit \" +\n+            applicationId + \" to queue \" + queueName;\n+        rejectApplicationWithMessage(applicationId, msg);\n+        queue.removeAssignedApp(applicationId);\n+        return;\n+      }\n+\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      if (rmApp !\u003d null) {\n+        rmApp.setQueue(queueName);\n+      } else {\n+        LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n+            \" to set queue name on\");\n+      }\n+\n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n-                  applicationId, queue.getName(),\n+                  applicationId, queueName,\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           queue.removeAssignedApp(applicationId);\n           return;\n         }\n       }\n \n-      // Enforce ACLs\n-      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n-          user);\n-\n-      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n-          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-        String msg \u003d \"User \" + userUgi.getUserName()\n-            + \" cannot submit applications to queue \" + queue.getName()\n-            + \"(requested queuename is \" + queueName + \")\";\n-        rejectApplicationWithMessage(applicationId, msg);\n-        queue.removeAssignedApp(applicationId);\n-        return;\n-      }\n-\n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n+          new SchedulerApplication\u003c\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-          + \", in queue: \" + queue.getName()\n+          + \", in queue: \" + queueName\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n             applicationId);\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering,\n      ApplicationPlacementContext placementContext) {\n    // If the  placement was rejected the placementContext will be null.\n    // We ignore placement rules on recovery.\n    if (!isAppRecovering \u0026\u0026 placementContext \u003d\u003d null) {\n      String message \u003d \"Reject application \" + applicationId +\n          \" submitted by user \" + user +\n          \" application rejected by placement rules.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      // Assign the app to the queue creating and prevent queue delete.\n      FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName, true,\n          applicationId);\n      if (queue \u003d\u003d null) {\n        rejectApplicationWithMessage(applicationId,\n            queueName + \" is not a leaf queue\");\n        return;\n      }\n\n      // Enforce ACLs: 2nd check, there could be a time laps between the app\n      // creation in the RMAppManager and getting here. That means we could\n      // have a configuration change (prevent race condition)\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026\n          !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + user + \" does not have permission to submit \" +\n            applicationId + \" to queue \" + queueName;\n        rejectApplicationWithMessage(applicationId, msg);\n        queue.removeAssignedApp(applicationId);\n        return;\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      if (rmApp !\u003d null) {\n        rmApp.setQueue(queueName);\n      } else {\n        LOG.error(\"Couldn\u0027t find RM app for \" + applicationId +\n            \" to set queue name on\");\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queueName,\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003c\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queueName\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n            applicationId);\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,93 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     writeLock.lock();\n     try {\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n                   applicationId, queue.getName(),\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           queue.removeAssignedApp(applicationId);\n           return;\n         }\n       }\n \n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n         rejectApplicationWithMessage(applicationId, msg);\n         queue.removeAssignedApp(applicationId);\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queue.getName()\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(applicationId\n-              + \" is recovering. Skip notifying APP_ACCEPTED\");\n-        }\n+        LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n+            applicationId);\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queue.getName(),\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        rejectApplicationWithMessage(applicationId, msg);\n        queue.removeAssignedApp(applicationId);\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        LOG.debug(\"{} is recovering. Skip notifying APP_ACCEPTED\",\n            applicationId);\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "524a7523c427b55273133078898ae3535897bada": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8990. Fix fair scheduler race condition in app submit and queue cleanup. (Contributed by Wilfred Spiegelenburg)\n",
      "commitDate": "08/11/18 4:02 PM",
      "commitName": "524a7523c427b55273133078898ae3535897bada",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "29/09/18 2:47 AM",
      "commitNameOld": "fd6be5898ad1a650e3bceacb8169a53520da57e5",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 40.59,
      "commitsBetweenForRepo": 381,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,95 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     writeLock.lock();\n     try {\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n-      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n+      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n                   applicationId, queue.getName(),\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n+          queue.removeAssignedApp(applicationId);\n           return;\n         }\n       }\n \n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n         rejectApplicationWithMessage(applicationId, msg);\n+        queue.removeAssignedApp(applicationId);\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n-      queue.addAssignedApp(applicationId);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queue.getName()\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationId\n               + \" is recovering. Skip notifying APP_ACCEPTED\");\n         }\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user, applicationId);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queue.getName(),\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          queue.removeAssignedApp(applicationId);\n          return;\n        }\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        rejectApplicationWithMessage(applicationId, msg);\n        queue.removeAssignedApp(applicationId);\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7133. Clean up lock-try order in fair scheduler. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "24/07/18 12:46 PM",
      "commitName": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/06/18 11:12 AM",
      "commitNameOld": "c190ac2be88e574b3322cdc73a7c0af0cef708b2",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 43.07,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n                   applicationId, queue.getName(),\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           return;\n         }\n       }\n \n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n         rejectApplicationWithMessage(applicationId, msg);\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n       queue.addAssignedApp(applicationId);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queue.getName()\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationId\n               + \" is recovering. Skip notifying APP_ACCEPTED\");\n         }\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    writeLock.lock();\n    try {\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queue.getName(),\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          return;\n        }\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        rejectApplicationWithMessage(applicationId, msg);\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n      queue.addAssignedApp(applicationId);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "86bc6425d425913899f1d951498bd040e453b3d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8191. Fair scheduler: queue deletion without RM restart. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "24/05/18 5:12 PM",
      "commitName": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "21/05/18 8:10 AM",
      "commitNameOld": "f48fec83d0f2d1a781a141ad7216463c5526321f",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 3.38,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,94 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n       rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     try {\n       writeLock.lock();\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n       if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n         // Resources.fitsIn would always return false when queueMaxShare is 0\n         // for any resource, but only using Resources.fitsIn is not enough\n         // is it would return false for such cases when the requested\n         // resource is smaller than the max resource but that max resource is\n         // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n         // With this check, we only reject those applications where resource\n         // requested is greater than 0 and we have 0\n         // of that resource on the queue.\n         List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                 validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n \n         if (!invalidAMResourceRequests.isEmpty()) {\n           String msg \u003d String.format(\n                   \"Cannot submit application %s to queue %s because \"\n                           + \"it has zero amount of resource for a requested \"\n                           + \"resource! Invalid requested AM resources: %s, \"\n                           + \"maximum queue resources: %s\",\n                   applicationId, queue.getName(),\n                   invalidAMResourceRequests, queue.getMaxShare());\n           rejectApplicationWithMessage(applicationId, msg);\n           return;\n         }\n       }\n \n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n         rejectApplicationWithMessage(applicationId, msg);\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n+      queue.addAssignedApp(applicationId);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queue.getName()\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationId\n               + \" is recovering. Skip notifying APP_ACCEPTED\");\n         }\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    try {\n      writeLock.lock();\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queue.getName(),\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          return;\n        }\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        rejectApplicationWithMessage(applicationId, msg);\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n      queue.addAssignedApp(applicationId);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f48fec83d0f2d1a781a141ad7216463c5526321f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8248. Job hangs when a job requests a resource that its queue does not have. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "21/05/18 8:10 AM",
      "commitName": "f48fec83d0f2d1a781a141ad7216463c5526321f",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 110.24,
      "commitsBetweenForRepo": 1383,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,93 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n-      LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n-              message));\n+      rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n-      LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n-              message));\n+      rejectApplicationWithMessage(applicationId, message);\n       return;\n     }\n \n     try {\n       writeLock.lock();\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n+      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n+        // Resources.fitsIn would always return false when queueMaxShare is 0\n+        // for any resource, but only using Resources.fitsIn is not enough\n+        // is it would return false for such cases when the requested\n+        // resource is smaller than the max resource but that max resource is\n+        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n+        // With this check, we only reject those applications where resource\n+        // requested is greater than 0 and we have 0\n+        // of that resource on the queue.\n+        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n+                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n+\n+        if (!invalidAMResourceRequests.isEmpty()) {\n+          String msg \u003d String.format(\n+                  \"Cannot submit application %s to queue %s because \"\n+                          + \"it has zero amount of resource for a requested \"\n+                          + \"resource! Invalid requested AM resources: %s, \"\n+                          + \"maximum queue resources: %s\",\n+                  applicationId, queue.getName(),\n+                  invalidAMResourceRequests, queue.getMaxShare());\n+          rejectApplicationWithMessage(applicationId, msg);\n+          return;\n+        }\n+      }\n+\n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n-        LOG.info(msg);\n-        rmContext.getDispatcher().getEventHandler().handle(\n-            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n+        rejectApplicationWithMessage(applicationId, msg);\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n       LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n           + \", in queue: \" + queue.getName()\n           + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationId\n               + \" is recovering. Skip notifying APP_ACCEPTED\");\n         }\n       } else {\n         // During tests we do not always have an application object, handle\n         // it here but we probably should fix the tests\n         if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n           // Before we send out the event that the app is accepted is\n           // to set the queue in the submissionContext (needed on restore etc)\n           rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n         }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      rejectApplicationWithMessage(applicationId, message);\n      return;\n    }\n\n    try {\n      writeLock.lock();\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      if (rmApp !\u003d null \u0026\u0026 rmApp.getAMResourceRequests() !\u003d null) {\n        // Resources.fitsIn would always return false when queueMaxShare is 0\n        // for any resource, but only using Resources.fitsIn is not enough\n        // is it would return false for such cases when the requested\n        // resource is smaller than the max resource but that max resource is\n        // not zero, e.g. requested vCores \u003d 2, max vCores \u003d 1.\n        // With this check, we only reject those applications where resource\n        // requested is greater than 0 and we have 0\n        // of that resource on the queue.\n        List\u003cMaxResourceValidationResult\u003e invalidAMResourceRequests \u003d\n                validateResourceRequests(rmApp.getAMResourceRequests(), queue);\n\n        if (!invalidAMResourceRequests.isEmpty()) {\n          String msg \u003d String.format(\n                  \"Cannot submit application %s to queue %s because \"\n                          + \"it has zero amount of resource for a requested \"\n                          + \"resource! Invalid requested AM resources: %s, \"\n                          + \"maximum queue resources: %s\",\n                  applicationId, queue.getName(),\n                  invalidAMResourceRequests, queue.getMaxShare());\n          rejectApplicationWithMessage(applicationId, msg);\n          return;\n        }\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        rejectApplicationWithMessage(applicationId, msg);\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bc93ac229e17b1be440052217e51820b95c179ec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7139. FairScheduler: finished applications are always restored to default queue. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "18/01/18 5:43 PM",
      "commitName": "bc93ac229e17b1be440052217e51820b95c179ec",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "16/01/18 2:46 PM",
      "commitNameOld": "370f1c6283813dc1c7d001f44930e3c79c140c54",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,76 @@\n   protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n               message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d\n           \"Reject application \" + applicationId + \" submitted by user \" + user\n               + \" with an illegal queue name \" + queueName + \". \"\n               + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n               message));\n       return;\n     }\n \n     try {\n       writeLock.lock();\n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n       FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n       if (queue \u003d\u003d null) {\n         return;\n       }\n \n       // Enforce ACLs\n       UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n           user);\n \n       if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n           .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n         String msg \u003d \"User \" + userUgi.getUserName()\n             + \" cannot submit applications to queue \" + queue.getName()\n             + \"(requested queuename is \" + queueName + \")\";\n         LOG.info(msg);\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n         return;\n       }\n \n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n           new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n       applications.put(applicationId, application);\n       queue.getMetrics().submitApp(user);\n \n-        LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-            + \", in queue: \" + queue.getName()\n-            + \", currently num of applications: \" + applications.size());\n+      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+          + \", in queue: \" + queue.getName()\n+          + \", currently num of applications: \" + applications.size());\n       if (isAppRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationId\n               + \" is recovering. Skip notifying APP_ACCEPTED\");\n         }\n-      } else{\n+      } else {\n+        // During tests we do not always have an application object, handle\n+        // it here but we probably should fix the tests\n+        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n+          // Before we send out the event that the app is accepted is\n+          // to set the queue in the submissionContext (needed on restore etc)\n+          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n+        }\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    try {\n      writeLock.lock();\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        LOG.info(msg);\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n      LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n          + \", in queue: \" + queue.getName()\n          + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else {\n        // During tests we do not always have an application object, handle\n        // it here but we probably should fix the tests\n        if (rmApp !\u003d null \u0026\u0026 rmApp.getApplicationSubmissionContext() !\u003d null) {\n          // Before we send out the event that the app is accepted is\n          // to set the queue in the submissionContext (needed on restore etc)\n          rmApp.getApplicationSubmissionContext().setQueue(queue.getName());\n        }\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,69 @@\n-  protected synchronized void addApplication(ApplicationId applicationId,\n+  protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationId +\n-              \" submitted by user \" + user + \" with an empty queue name.\";\n+      String message \u003d\n+          \"Reject application \" + applicationId + \" submitted by user \" + user\n+              + \" with an empty queue name.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, message));\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n+              message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n-      String message \u003d \"Reject application \" + applicationId\n-          + \" submitted by user \" + user + \" with an illegal queue name \"\n-          + queueName + \". \"\n-          + \"The queue name cannot start/end with period.\";\n+      String message \u003d\n+          \"Reject application \" + applicationId + \" submitted by user \" + user\n+              + \" with an illegal queue name \" + queueName + \". \"\n+              + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, message));\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n+              message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n-    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n-    if (queue \u003d\u003d null) {\n-      return;\n-    }\n-\n-    // Enforce ACLs\n-    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n-        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-      String msg \u003d \"User \" + userUgi.getUserName() +\n-              \" cannot submit applications to queue \" + queue.getName() +\n-              \"(requested queuename is \" + queueName + \")\";\n-      LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, msg));\n-      return;\n-    }\n-  \n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n-    applications.put(applicationId, application);\n-    queue.getMetrics().submitApp(user);\n-\n-    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-        + \", in queue: \" + queue.getName()\n-        + \", currently num of applications: \" + applications.size());\n-    if (isAppRecovering) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(applicationId\n-            + \" is recovering. Skip notifying APP_ACCEPTED\");\n+    try {\n+      writeLock.lock();\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n+      if (queue \u003d\u003d null) {\n+        return;\n       }\n-    } else {\n-      rmContext.getDispatcher().getEventHandler()\n-        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+\n+      // Enforce ACLs\n+      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n+          user);\n+\n+      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n+          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+        String msg \u003d \"User \" + userUgi.getUserName()\n+            + \" cannot submit applications to queue \" + queue.getName()\n+            + \"(requested queuename is \" + queueName + \")\";\n+        LOG.info(msg);\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n+        return;\n+      }\n+\n+      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n+          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n+      applications.put(applicationId, application);\n+      queue.getMetrics().submitApp(user);\n+\n+        LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+            + \", in queue: \" + queue.getName()\n+            + \", currently num of applications: \" + applications.size());\n+      if (isAppRecovering) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(applicationId\n+              + \" is recovering. Skip notifying APP_ACCEPTED\");\n+        }\n+      } else{\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    try {\n      writeLock.lock();\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        LOG.info(msg);\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n        LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n            + \", in queue: \" + queue.getName()\n            + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,69 @@\n-  protected synchronized void addApplication(ApplicationId applicationId,\n+  protected void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationId +\n-              \" submitted by user \" + user + \" with an empty queue name.\";\n+      String message \u003d\n+          \"Reject application \" + applicationId + \" submitted by user \" + user\n+              + \" with an empty queue name.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, message));\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n+              message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n-      String message \u003d \"Reject application \" + applicationId\n-          + \" submitted by user \" + user + \" with an illegal queue name \"\n-          + queueName + \". \"\n-          + \"The queue name cannot start/end with period.\";\n+      String message \u003d\n+          \"Reject application \" + applicationId + \" submitted by user \" + user\n+              + \" with an illegal queue name \" + queueName + \". \"\n+              + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, message));\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n+              message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n-    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n-    if (queue \u003d\u003d null) {\n-      return;\n-    }\n-\n-    // Enforce ACLs\n-    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n-        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-      String msg \u003d \"User \" + userUgi.getUserName() +\n-              \" cannot submit applications to queue \" + queue.getName() +\n-              \"(requested queuename is \" + queueName + \")\";\n-      LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              RMAppEventType.APP_REJECTED, msg));\n-      return;\n-    }\n-  \n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n-    applications.put(applicationId, application);\n-    queue.getMetrics().submitApp(user);\n-\n-    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-        + \", in queue: \" + queue.getName()\n-        + \", currently num of applications: \" + applications.size());\n-    if (isAppRecovering) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(applicationId\n-            + \" is recovering. Skip notifying APP_ACCEPTED\");\n+    try {\n+      writeLock.lock();\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n+      if (queue \u003d\u003d null) {\n+        return;\n       }\n-    } else {\n-      rmContext.getDispatcher().getEventHandler()\n-        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+\n+      // Enforce ACLs\n+      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n+          user);\n+\n+      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n+          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n+        String msg \u003d \"User \" + userUgi.getUserName()\n+            + \" cannot submit applications to queue \" + queue.getName()\n+            + \"(requested queuename is \" + queueName + \")\";\n+        LOG.info(msg);\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n+        return;\n+      }\n+\n+      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n+          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n+      applications.put(applicationId, application);\n+      queue.getMetrics().submitApp(user);\n+\n+        LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+            + \", in queue: \" + queue.getName()\n+            + \", currently num of applications: \" + applications.size());\n+      if (isAppRecovering) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(applicationId\n+              + \" is recovering. Skip notifying APP_ACCEPTED\");\n+        }\n+      } else{\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d\n          \"Reject application \" + applicationId + \" submitted by user \" + user\n              + \" with an illegal queue name \" + queueName + \". \"\n              + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED,\n              message));\n      return;\n    }\n\n    try {\n      writeLock.lock();\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n      FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n      if (queue \u003d\u003d null) {\n        return;\n      }\n\n      // Enforce ACLs\n      UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(\n          user);\n\n      if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi) \u0026\u0026 !queue\n          .hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n        String msg \u003d \"User \" + userUgi.getUserName()\n            + \" cannot submit applications to queue \" + queue.getName()\n            + \"(requested queuename is \" + queueName + \")\";\n        LOG.info(msg);\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_REJECTED, msg));\n        return;\n      }\n\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n          new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n      applications.put(applicationId, application);\n      queue.getMetrics().submitApp(user);\n\n        LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n            + \", in queue: \" + queue.getName()\n            + \", currently num of applications: \" + applications.size());\n      if (isAppRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationId\n              + \" is recovering. Skip notifying APP_ACCEPTED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "0da54e8848764c71a31473516d23ada582013f8c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5672. FairScheduler: Wrong queue name in log when adding application. (Wilfred Spiegelenburg via kasha)\n",
      "commitDate": "03/10/16 6:03 AM",
      "commitName": "0da54e8848764c71a31473516d23ada582013f8c",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "16/09/16 10:05 PM",
      "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 16.33,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d \"Reject application \" + applicationId\n           + \" submitted by user \" + user + \" with an illegal queue name \"\n           + queueName + \". \"\n           + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName() +\n               \"(requested queuename is \" + queueName + \")\";\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-        + \", in queue: \" + queueName + \", currently num of applications: \"\n-        + applications.size());\n+        + \", in queue: \" + queue.getName()\n+        + \", currently num of applications: \" + applications.size());\n     if (isAppRecovering) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n+        LOG.debug(applicationId\n+            + \" is recovering. Skip notifying APP_ACCEPTED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d \"Reject application \" + applicationId\n          + \" submitted by user \" + user + \" with an illegal queue name \"\n          + queueName + \". \"\n          + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName() +\n              \"(requested queuename is \" + queueName + \")\";\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queue.getName()\n        + \", currently num of applications: \" + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId\n            + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4992398aeeb213ce59e068b0226e22e49ce559eb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4603. FairScheduler should mention user requested queuename in error message when failed in queue ACL check. (Tao Jie via kasha)\n",
      "commitDate": "21/01/16 8:40 AM",
      "commitName": "4992398aeeb213ce59e068b0226e22e49ce559eb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "18/01/16 5:30 PM",
      "commitNameOld": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d \"Reject application \" + applicationId\n           + \" submitted by user \" + user + \" with an illegal queue name \"\n           + queueName + \". \"\n           + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n-              \" cannot submit applications to queue \" + queue.getName();\n+              \" cannot submit applications to queue \" + queue.getName() +\n+              \"(requested queuename is \" + queueName + \")\";\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     if (isAppRecovering) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d \"Reject application \" + applicationId\n          + \" submitted by user \" + user + \" with an illegal queue name \"\n          + queueName + \". \"\n          + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName() +\n              \"(requested queuename is \" + queueName + \")\";\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4000. RM crashes with NPE if leaf queue becomes parent queue during restart. Contributed by Varun Saxena\n",
      "commitDate": "15/10/15 5:12 PM",
      "commitName": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 22.15,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,61 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(applicationId, message));\n+          .handle(new RMAppEvent(applicationId,\n+              RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n       String message \u003d \"Reject application \" + applicationId\n           + \" submitted by user \" + user + \" with an illegal queue name \"\n           + queueName + \". \"\n           + \"The queue name cannot start/end with period.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(applicationId, message));\n+          .handle(new RMAppEvent(applicationId,\n+              RMAppEventType.APP_REJECTED, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(applicationId, msg));\n+          .handle(new RMAppEvent(applicationId,\n+              RMAppEventType.APP_REJECTED, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     if (isAppRecovering) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d \"Reject application \" + applicationId\n          + \" submitted by user \" + user + \" with an illegal queue name \"\n          + queueName + \". \"\n          + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2669. FairScheduler: queue names shouldn\u0027t allow periods (Wei Yan via Sandy Ryza)\n",
      "commitDate": "21/11/14 4:06 PM",
      "commitName": "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
      "commitAuthor": "Sandy Ryza",
      "commitDateOld": "21/11/14 10:32 AM",
      "commitNameOld": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,58 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n+    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n+      String message \u003d \"Reject application \" + applicationId\n+          + \" submitted by user \" + user + \" with an illegal queue name \"\n+          + queueName + \". \"\n+          + \"The queue name cannot start/end with period.\";\n+      LOG.info(message);\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, message));\n+      return;\n+    }\n+\n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     if (isAppRecovering) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    if (queueName.startsWith(\".\") || queueName.endsWith(\".\")) {\n      String message \u003d \"Reject application \" + applicationId\n          + \" submitted by user \" + user + \" with an illegal queue name \"\n          + queueName + \". \"\n          + \"The queue name cannot start/end with period.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n-    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n-        new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n+    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n+        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     if (isAppRecovering) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        new SchedulerApplication\u003cFSAppAttempt\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bda23181bf1931c37d2590e03da9acdc6688ad34": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/14 5:14 PM",
      "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/14 5:14 PM",
          "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/07/14 2:48 PM",
          "commitNameOld": "43589a8df70d4dbaf86609961e27cc4e23dda993",
          "commitAuthorOld": "Mayank Bansal",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,47 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n-      String queueName, String user) {\n+      String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n-    rmContext.getDispatcher().getEventHandler()\n+    if (isAppRecovering) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n+      }\n+    } else {\n+      rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationId-ApplicationId, queueName-String, user-String]",
            "newValue": "[applicationId-ApplicationId, queueName-String, user-String, isAppRecovering-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/14 5:14 PM",
          "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/07/14 2:48 PM",
          "commitNameOld": "43589a8df70d4dbaf86609961e27cc4e23dda993",
          "commitAuthorOld": "Mayank Bansal",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,47 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n-      String queueName, String user) {\n+      String queueName, String user, boolean isAppRecovering) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n-    rmContext.getDispatcher().getEventHandler()\n+    if (isAppRecovering) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n+      }\n+    } else {\n+      rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user, boolean isAppRecovering) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    if (isAppRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationId + \" is recovering. Skip notifying APP_ACCEPTED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n-    SchedulerApplication application \u003d\n-        new SchedulerApplication(queue, user);\n+    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n+        new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        new SchedulerApplication\u003cFSSchedulerApp\u003e(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "b06cc16f7df63766531721a55280061949cab9b4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1774. FS: Submitting to non-leaf queue throws NPE. (Anubhav Dhoot and Karthik Kambatla via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575415 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 1:34 PM",
      "commitName": "b06cc16f7df63766531721a55280061949cab9b4",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "05/03/14 10:22 AM",
      "commitNameOld": "2e7c51227006e85d83f5ffc7f252f2d98362c15d",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,41 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppRejectedEvent(applicationId,\n-              \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication application \u003d\n         new SchedulerApplication(queue, user);\n     applications.put(applicationId, application);\n     queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f677175f35f68bde9df72e648dffacbd31cfd620": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1166. Fixed app-specific and attempt-specific QueueMetrics to be triggered by accordingly app event and attempt event. Contributed by Zhijie Shen\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557296 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 5:15 PM",
      "commitName": "f677175f35f68bde9df72e648dffacbd31cfd620",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/01/14 7:04 AM",
      "commitNameOld": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication application \u003d\n         new SchedulerApplication(queue, user);\n     applications.put(applicationId, application);\n+    queue.getMetrics().submitApp(user);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n         + \", in queue: \" + queueName + \", currently num of applications: \"\n         + applications.size());\n     rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n    queue.getMetrics().submitApp(user);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n   protected synchronized void addApplication(ApplicationId applicationId,\n       String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n               \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n   \n     SchedulerApplication application \u003d\n         new SchedulerApplication(queue, user);\n     applications.put(applicationId, application);\n \n     LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n-        + \", in queue: \" + queueName);\n+        + \", in queue: \" + queueName + \", currently num of applications: \"\n+        + applications.size());\n     rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName + \", currently num of applications: \"\n        + applications.size());\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/01/14 12:19 PM",
          "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/12/13 5:44 PM",
          "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,42 @@\n-  protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n+  protected synchronized void addApplication(ApplicationId applicationId,\n+      String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationAttemptId +\n+      String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(\n-        applicationAttemptId.getApplicationId());\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRejectedEvent(applicationAttemptId,\n+          new RMAppRejectedEvent(applicationId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n-    FSSchedulerApp schedulerApp \u003d\n-        new FSSchedulerApp(applicationAttemptId, user,\n-            queue, new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext);\n-\n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n-    \t        \" cannot submit applications to queue \" + queue.getName();\n+              \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n+  \n+    SchedulerApplication application \u003d\n+        new SchedulerApplication(queue, user);\n+    applications.put(applicationId, application);\n \n-    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(schedulerApp, runnable);\n-    if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n-    } else {\n-      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n-    }\n-    \n-    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-\n-    applications.put(applicationAttemptId, schedulerApp);\n-\n-    LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \"+ user +\n-        \", currently active: \" + applications.size());\n-\n-    rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.APP_ACCEPTED));\n+    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+        + \", in queue: \" + queueName);\n+    rmContext.getDispatcher().getEventHandler()\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName);\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "addApplicationAttempt",
            "newValue": "addApplication"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/01/14 12:19 PM",
          "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/12/13 5:44 PM",
          "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,42 @@\n-  protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n+  protected synchronized void addApplication(ApplicationId applicationId,\n+      String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationAttemptId +\n+      String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(\n-        applicationAttemptId.getApplicationId());\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRejectedEvent(applicationAttemptId,\n+          new RMAppRejectedEvent(applicationId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n-    FSSchedulerApp schedulerApp \u003d\n-        new FSSchedulerApp(applicationAttemptId, user,\n-            queue, new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext);\n-\n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n-    \t        \" cannot submit applications to queue \" + queue.getName();\n+              \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n+  \n+    SchedulerApplication application \u003d\n+        new SchedulerApplication(queue, user);\n+    applications.put(applicationId, application);\n \n-    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(schedulerApp, runnable);\n-    if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n-    } else {\n-      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n-    }\n-    \n-    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-\n-    applications.put(applicationAttemptId, schedulerApp);\n-\n-    LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \"+ user +\n-        \", currently active: \" + applications.size());\n-\n-    rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.APP_ACCEPTED));\n+    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+        + \", in queue: \" + queueName);\n+    rmContext.getDispatcher().getEventHandler()\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName);\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, queueName-String, user-String]",
            "newValue": "[applicationId-ApplicationId, queueName-String, user-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/01/14 12:19 PM",
          "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/12/13 5:44 PM",
          "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,42 @@\n-  protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n+  protected synchronized void addApplication(ApplicationId applicationId,\n+      String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationAttemptId +\n+      String message \u003d \"Reject application \" + applicationId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(\n-        applicationAttemptId.getApplicationId());\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRejectedEvent(applicationAttemptId,\n+          new RMAppRejectedEvent(applicationId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n-    FSSchedulerApp schedulerApp \u003d\n-        new FSSchedulerApp(applicationAttemptId, user,\n-            queue, new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext);\n-\n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n-    \t        \" cannot submit applications to queue \" + queue.getName();\n+              \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n+      rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, msg));\n       return;\n     }\n+  \n+    SchedulerApplication application \u003d\n+        new SchedulerApplication(queue, user);\n+    applications.put(applicationId, application);\n \n-    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(schedulerApp, runnable);\n-    if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n-    } else {\n-      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n-    }\n-    \n-    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-\n-    applications.put(applicationAttemptId, schedulerApp);\n-\n-    LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \"+ user +\n-        \", currently active: \" + applications.size());\n-\n-    rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.APP_ACCEPTED));\n+    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n+        + \", in queue: \" + queueName);\n+    rmContext.getDispatcher().getEventHandler()\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplication(ApplicationId applicationId,\n      String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n              \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, msg));\n      return;\n    }\n  \n    SchedulerApplication application \u003d\n        new SchedulerApplication(queue, user);\n    applications.put(applicationId, application);\n\n    LOG.info(\"Accepted application \" + applicationId + \" from user: \" + user\n        + \", in queue: \" + queueName);\n    rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.APP_ACCEPTED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 5:44 PM",
      "commitName": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:45 PM",
      "commitNameOld": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplication(\n+  protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplication",
        "newValue": "addApplicationAttempt"
      }
    },
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": {
      "type": "Yrename",
      "commitMessage": "Reverting YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:45 PM",
      "commitName": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:07 PM",
      "commitNameOld": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplicationAttempt(\n+  protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplicationAttempt",
        "newValue": "addApplication"
      }
    },
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550579 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:07 PM",
      "commitName": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/12/13 7:09 PM",
      "commitNameOld": "e1d3670f4c233696dc673c37b578ce46b44a6876",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplication(\n+  protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplication",
        "newValue": "addApplicationAttempt"
      }
    },
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1241. In Fair Scheduler, maxRunningApps does not work for non-leaf queues. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/13 11:02 AM",
      "commitName": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/11/13 2:12 PM",
      "commitNameOld": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,59 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n-    queue.addApp(schedulerApp);\n+    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n+    queue.addApp(schedulerApp, runnable);\n+    if (runnable) {\n+      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n+    } else {\n+      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n+    }\n+    \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3858b9018e3c2f4b883b02021679852591b706f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1392. Allow sophisticated app-to-queue placement policies in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:12 PM",
      "commitName": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "05/11/13 1:23 PM",
      "commitNameOld": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 9.03,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,52 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n+    if (queue \u003d\u003d null) {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptRejectedEvent(applicationAttemptId,\n+              \"Application rejected by queue placement policy\"));\n+      return;\n+    }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1236. FairScheduler setting queue name in RMApp is not working. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 4:29 PM",
      "commitName": "ac2cdb5f6586cc3358ea4fc818f477959d2daa38",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "02/10/13 6:17 PM",
      "commitNameOld": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n+    RMApp rmApp \u003d rmContext.getRMApps().get(\n+        applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": {
      "type": "Ybodychange",
      "commitMessage": "YARN-899. Added back queue level administrator-acls so that there is no regression w.r.t 1.x. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/09/13 1:21 AM",
      "commitName": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/09/13 6:24 PM",
      "commitNameOld": "59b5490989fad4c8e80dd85c3419810cdc8332f7",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 19.29,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,45 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n+\n+    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n+        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n-    \n+\n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-461. Fair scheduler should not accept apps with empty string queue name. (ywskycn via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 5:00 PM",
      "commitName": "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "11/07/13 2:39 PM",
      "commitNameOld": "171493215889a3b6bf2f6ba33212c4f06861a189",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 11.1,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,43 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n+    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n+      String message \u003d \"Reject application \" + applicationAttemptId +\n+              \" submitted by user \" + user + \" with an empty queue name.\";\n+      LOG.info(message);\n+      rmContext.getDispatcher().getEventHandler().handle(\n+              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n+      return;\n+    }\n+\n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "171493215889a3b6bf2f6ba33212c4f06861a189": {
      "type": "Ybodychange",
      "commitMessage": "YARN-333. Schedulers cannot control the queue-name of an application. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502374 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/07/13 2:39 PM",
      "commitName": "171493215889a3b6bf2f6ba33212c4f06861a189",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "28/06/13 11:59 AM",
      "commitNameOld": "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 13.11,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,34 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n-\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n-    if (queue \u003d\u003d null) {\n-      // queue is not an existing or createable leaf queue\n-      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n-    }\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n+    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "345bcee0664392323b4297c0797897a96fef8958": {
      "type": "Ybodychange",
      "commitMessage": "YARN-319. Submitting a job to a fair scheduler queue for which the user does not have permission causes the client to wait forever. Contributed by shenhong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1437336 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/01/13 2:53 AM",
      "commitName": "345bcee0664392323b4297c0797897a96fef8958",
      "commitAuthor": "Thomas White",
      "commitDateOld": "15/01/13 9:09 AM",
      "commitNameOld": "72e631098d2db8a9a18c32c9b25b57b7af4d9275",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 7.74,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n-      LOG.info(\"User \" + userUgi.getUserName() +\n-          \" cannot submit applications to queue \" + queue.getName());\n+      String msg \u003d \"User \" + userUgi.getUserName() +\n+    \t        \" cannot submit applications to queue \" + queue.getName();\n+      LOG.info(msg);\n+      rmContext.getDispatcher().getEventHandler().handle(\n+    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "19a291a0d65b64e50571c3519414b9d54acbe28a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-288. Fair scheduler queue doesn\u0027t accept any jobs when ACLs are configured. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1428362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/01/13 6:32 AM",
      "commitName": "19a291a0d65b64e50571c3519414b9d54acbe28a",
      "commitAuthor": "Thomas White",
      "commitDateOld": "21/12/12 8:12 AM",
      "commitNameOld": "5014a4b133000648e25ca7a801e2f23baa2273f5",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,35 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n-    \n+\n     // Enforce ACLs\n-    UserGroupInformation userUgi;\n-    try {\n-      userUgi \u003d UserGroupInformation.getCurrentUser();\n-    } catch (IOException ioe) {\n-      LOG.info(\"Failed to get current user information\");\n-      return;\n-    }\n-\n-    // Always a singleton list\n-    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n-    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n+    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n+    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n-          \" cannot submit\" + \" applications to queue \" + queue.getName());\n+          \" cannot submit applications to queue \" + queue.getName());\n       return;\n     }\n-\n+    \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit applications to queue \" + queue.getName());\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "5014a4b133000648e25ca7a801e2f23baa2273f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-282. Fair scheduler web UI double counts Apps Submitted. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424995 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/12/12 8:12 AM",
      "commitName": "5014a4b133000648e25ca7a801e2f23baa2273f5",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "21/12/12 7:10 AM",
      "commitNameOld": "ee007d3f38e6f437a79ca47f2ebd44966860746e",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,44 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     \n     // Enforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     // Always a singleton list\n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    \n    // Enforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    // Always a singleton list\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Ybodychange",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.42,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,45 @@\n-  addApplication(ApplicationAttemptId applicationAttemptId,\n-      String queueName, String user) {\n+  protected synchronized void addApplication(\n+      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n-    FSQueue queue \u003d queueMgr.getQueue(queueName);\n+    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n+    if (queue \u003d\u003d null) {\n+      // queue is not an existing or createable leaf queue\n+      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n+    }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n-            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n+            queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n-\n-    // Inforce ACLs\n+    \n+    // Enforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n-    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n-        userUgi); // Always a signleton list\n+    // Always a singleton list\n+    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n-    queue.getQueueSchedulable().getMetrics().submitApp(user,\n-    \t\tapplicationAttemptId.getAttemptId());\n+    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \" + user +\n+        \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    \n    // Enforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    // Always a singleton list\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1943fdbec613715f3cdc3ca60cbd273115f28299": {
      "type": "Ybodychange",
      "commitMessage": "YARN-229. Remove old unused RM recovery code. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/12 5:56 PM",
      "commitName": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/11/12 4:27 AM",
      "commitNameOld": "d9050e12081c0e56e1185e330badcca00e5d4b21",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   addApplication(ApplicationAttemptId applicationAttemptId,\n       String queueName, String user) {\n \n     FSQueue queue \u003d queueMgr.getQueue(queueName);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext, null);\n+            rmContext);\n \n     // Inforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n         userUgi); // Always a signleton list\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getQueueSchedulable().getMetrics().submitApp(user,\n     \t\tapplicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \" + user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "26/10/12 1:55 PM",
      "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   addApplication(ApplicationAttemptId applicationAttemptId,\n       String queueName, String user) {\n \n-    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n+    FSQueue queue \u003d queueMgr.getQueue(queueName);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n-            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n+            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext, null);\n \n     // Inforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n         userUgi); // Always a signleton list\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getQueueSchedulable().getMetrics().submitApp(user,\n     \t\tapplicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \" + user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,42 @@\n+  addApplication(ApplicationAttemptId applicationAttemptId,\n+      String queueName, String user) {\n+\n+    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n+\n+    FSSchedulerApp schedulerApp \u003d\n+        new FSSchedulerApp(applicationAttemptId, user,\n+            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n+            rmContext, null);\n+\n+    // Inforce ACLs\n+    UserGroupInformation userUgi;\n+    try {\n+      userUgi \u003d UserGroupInformation.getCurrentUser();\n+    } catch (IOException ioe) {\n+      LOG.info(\"Failed to get current user information\");\n+      return;\n+    }\n+\n+    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n+        userUgi); // Always a signleton list\n+    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n+      LOG.info(\"User \" + userUgi.getUserName() +\n+          \" cannot submit\" + \" applications to queue \" + queue.getName());\n+      return;\n+    }\n+\n+    queue.addApp(schedulerApp);\n+    queue.getQueueSchedulable().getMetrics().submitApp(user,\n+    \t\tapplicationAttemptId.getAttemptId());\n+    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n+\n+    applications.put(applicationAttemptId, schedulerApp);\n+\n+    LOG.info(\"Application Submission: \" + applicationAttemptId +\n+        \", user: \" + user +\n+        \", currently active: \" + applications.size());\n+\n+    rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppAttemptEvent(applicationAttemptId,\n+            RMAppAttemptEventType.APP_ACCEPTED));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}