{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "EntityCacheItem.java",
  "functionName": "refreshCache",
  "functionId": "refreshCache___aclManager-TimelineACLsManager__metrics-EntityGroupFSTimelineStoreMetrics",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
  "functionStartLine": 86,
  "functionEndLine": 126,
  "numCommitsSeen": 20,
  "timeTaken": 4866,
  "changeHistory": [
    "53d372a2550c970f3dd3c49738af3c1789ae589b",
    "7f3c306e2ed9e865171324898decb9b587d90e73",
    "673e5e02feba9171498a518c06ae70639c5f8854",
    "705286ccaeea36941d97ec1c1700746b74264924",
    "06413da72efed9a50e49efaf7110c220c88a7f4a",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
    "02f597c5db36ded385413958bdee793ad7eda40e"
  ],
  "changeHistoryShort": {
    "53d372a2550c970f3dd3c49738af3c1789ae589b": "Ybodychange",
    "7f3c306e2ed9e865171324898decb9b587d90e73": "Ybodychange",
    "673e5e02feba9171498a518c06ae70639c5f8854": "Ymultichange(Yparameterchange,Ybodychange)",
    "705286ccaeea36941d97ec1c1700746b74264924": "Ymultichange(Yparameterchange,Ybodychange)",
    "06413da72efed9a50e49efaf7110c220c88a7f4a": "Ymultichange(Yparameterchange,Ybodychange)",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": "Ybodychange",
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": "Ybodychange",
    "02f597c5db36ded385413958bdee793ad7eda40e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "53d372a2550c970f3dd3c49738af3c1789ae589b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6228: EntityGroupFSTimelineStore should allow configurable cache\nstores. Contributed by Li Lu\n",
      "commitDate": "24/02/17 10:59 AM",
      "commitName": "53d372a2550c970f3dd3c49738af3c1789ae589b",
      "commitAuthor": "Xuan",
      "commitDateOld": "28/07/16 6:35 AM",
      "commitNameOld": "7f3c306e2ed9e865171324898decb9b587d90e73",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 211.23,
      "commitsBetweenForRepo": 1343,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,41 @@\n   public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n       EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n-          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n-              \"LeveldbCache.\" + groupId);\n+          store \u003d ReflectionUtils.newInstance(config.getClass(\n+              YarnConfiguration\n+                  .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_CACHE_STORE,\n+              MemoryTimelineStore.class, TimelineStore.class),\n+              config);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           // Load data from appLogs to tdm\n           appLogs.loadDetailLog(tdm, groupId);\n         }\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d ReflectionUtils.newInstance(config.getClass(\n              YarnConfiguration\n                  .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_CACHE_STORE,\n              MemoryTimelineStore.class, TimelineStore.class),\n              config);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          // Load data from appLogs to tdm\n          appLogs.loadDetailLog(tdm, groupId);\n        }\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
      "extendedDetails": {}
    },
    "7f3c306e2ed9e865171324898decb9b587d90e73": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5432. Lock already held by another process while LevelDB cache store creation for dag. Contributed by Li Lu.\n",
      "commitDate": "28/07/16 6:35 AM",
      "commitName": "7f3c306e2ed9e865171324898decb9b587d90e73",
      "commitAuthor": "Junping Du",
      "commitDateOld": "07/07/16 10:37 PM",
      "commitNameOld": "673e5e02feba9171498a518c06ae70639c5f8854",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.33,
      "commitsBetweenForRepo": 249,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n       EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n-          activeStores.getAndIncrement();\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           // Load data from appLogs to tdm\n           appLogs.loadDetailLog(tdm, groupId);\n         }\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          // Load data from appLogs to tdm\n          appLogs.loadDetailLog(tdm, groupId);\n        }\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
      "extendedDetails": {}
    },
    "673e5e02feba9171498a518c06ae70639c5f8854": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5314. Fixed a ConcurrentModificationException in ATS v1.5 EntityGroupFSTimelineStore. Contributed by Li Lu.\n",
      "commitDate": "07/07/16 10:37 PM",
      "commitName": "673e5e02feba9171498a518c06ae70639c5f8854",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5314. Fixed a ConcurrentModificationException in ATS v1.5 EntityGroupFSTimelineStore. Contributed by Li Lu.\n",
          "commitDate": "07/07/16 10:37 PM",
          "commitName": "673e5e02feba9171498a518c06ae70639c5f8854",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "27/05/16 6:58 AM",
          "commitNameOld": "705286ccaeea36941d97ec1c1700746b74264924",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 41.65,
          "commitsBetweenForRepo": 272,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,39 @@\n   public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n-      JsonFactory jsonFactory, ObjectMapper objMapper,\n       EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n           activeStores.getAndIncrement();\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n-        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n-          for (LogInfo log : appLogs.getDetailLogs()) {\n-            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n-            // Only refresh the log that matches the cache id\n-            if (log.matchesGroupId(groupId)) {\n-              Path appDirPath \u003d appLogs.getAppDirPath();\n-              if (fs.exists(log.getPath(appDirPath))) {\n-                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n-                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n-                    jsonFactory, objMapper, fs);\n-              } else {\n-                // The log may have been removed, remove the log\n-                removeList.add(log);\n-                LOG.info(\"File {} no longer exists, removing it from log list\",\n-                    log.getPath(appDirPath));\n-              }\n-            }\n-          }\n+          // Load data from appLogs to tdm\n+          appLogs.loadDetailLog(tdm, groupId);\n         }\n-        appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          activeStores.getAndIncrement();\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          // Load data from appLogs to tdm\n          appLogs.loadDetailLog(tdm, groupId);\n        }\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {
            "oldValue": "[aclManager-TimelineACLsManager, jsonFactory-JsonFactory, objMapper-ObjectMapper, metrics-EntityGroupFSTimelineStoreMetrics]",
            "newValue": "[aclManager-TimelineACLsManager, metrics-EntityGroupFSTimelineStoreMetrics]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5314. Fixed a ConcurrentModificationException in ATS v1.5 EntityGroupFSTimelineStore. Contributed by Li Lu.\n",
          "commitDate": "07/07/16 10:37 PM",
          "commitName": "673e5e02feba9171498a518c06ae70639c5f8854",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "27/05/16 6:58 AM",
          "commitNameOld": "705286ccaeea36941d97ec1c1700746b74264924",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 41.65,
          "commitsBetweenForRepo": 272,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,39 @@\n   public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n-      JsonFactory jsonFactory, ObjectMapper objMapper,\n       EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n           activeStores.getAndIncrement();\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n-        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n-          for (LogInfo log : appLogs.getDetailLogs()) {\n-            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n-            // Only refresh the log that matches the cache id\n-            if (log.matchesGroupId(groupId)) {\n-              Path appDirPath \u003d appLogs.getAppDirPath();\n-              if (fs.exists(log.getPath(appDirPath))) {\n-                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n-                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n-                    jsonFactory, objMapper, fs);\n-              } else {\n-                // The log may have been removed, remove the log\n-                removeList.add(log);\n-                LOG.info(\"File {} no longer exists, removing it from log list\",\n-                    log.getPath(appDirPath));\n-              }\n-            }\n-          }\n+          // Load data from appLogs to tdm\n+          appLogs.loadDetailLog(tdm, groupId);\n         }\n-        appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          activeStores.getAndIncrement();\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          // Load data from appLogs to tdm\n          appLogs.loadDetailLog(tdm, groupId);\n        }\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {}
        }
      ]
    },
    "705286ccaeea36941d97ec1c1700746b74264924": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4987. Read cache concurrency issue between read and evict in EntityGroupFS timeline store. Contributed by Li Lu.\n",
      "commitDate": "27/05/16 6:58 AM",
      "commitName": "705286ccaeea36941d97ec1c1700746b74264924",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4987. Read cache concurrency issue between read and evict in EntityGroupFS timeline store. Contributed by Li Lu.\n",
          "commitDate": "27/05/16 6:58 AM",
          "commitName": "705286ccaeea36941d97ec1c1700746b74264924",
          "commitAuthor": "Junping Du",
          "commitDateOld": "03/05/16 4:16 AM",
          "commitNameOld": "06413da72efed9a50e49efaf7110c220c88a7f4a",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 24.11,
          "commitsBetweenForRepo": 182,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,57 @@\n-  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n-      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n-      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n-      throws IOException {\n+  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n+      JsonFactory jsonFactory, ObjectMapper objMapper,\n+      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n+          activeStores.getAndIncrement();\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n         List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           for (LogInfo log : appLogs.getDetailLogs()) {\n             LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n             // Only refresh the log that matches the cache id\n             if (log.matchesGroupId(groupId)) {\n               Path appDirPath \u003d appLogs.getAppDirPath();\n               if (fs.exists(log.getPath(appDirPath))) {\n                 LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                 log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                     jsonFactory, objMapper, fs);\n               } else {\n                 // The log may have been removed, remove the log\n                 removeList.add(log);\n                 LOG.info(\"File {} no longer exists, removing it from log list\",\n                     log.getPath(appDirPath));\n               }\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      JsonFactory jsonFactory, ObjectMapper objMapper,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          activeStores.getAndIncrement();\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          for (LogInfo log : appLogs.getDetailLogs()) {\n            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n            // Only refresh the log that matches the cache id\n            if (log.matchesGroupId(groupId)) {\n              Path appDirPath \u003d appLogs.getAppDirPath();\n              if (fs.exists(log.getPath(appDirPath))) {\n                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                    jsonFactory, objMapper, fs);\n              } else {\n                // The log may have been removed, remove the log\n                removeList.add(log);\n                LOG.info(\"File {} no longer exists, removing it from log list\",\n                    log.getPath(appDirPath));\n              }\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {
            "oldValue": "[groupId-TimelineEntityGroupId, aclManager-TimelineACLsManager, jsonFactory-JsonFactory, objMapper-ObjectMapper, metrics-EntityGroupFSTimelineStoreMetrics]",
            "newValue": "[aclManager-TimelineACLsManager, jsonFactory-JsonFactory, objMapper-ObjectMapper, metrics-EntityGroupFSTimelineStoreMetrics]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4987. Read cache concurrency issue between read and evict in EntityGroupFS timeline store. Contributed by Li Lu.\n",
          "commitDate": "27/05/16 6:58 AM",
          "commitName": "705286ccaeea36941d97ec1c1700746b74264924",
          "commitAuthor": "Junping Du",
          "commitDateOld": "03/05/16 4:16 AM",
          "commitNameOld": "06413da72efed9a50e49efaf7110c220c88a7f4a",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 24.11,
          "commitsBetweenForRepo": 182,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,57 @@\n-  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n-      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n-      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n-      throws IOException {\n+  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n+      JsonFactory jsonFactory, ObjectMapper objMapper,\n+      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n     if (needRefresh()) {\n       long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n+          activeStores.getAndIncrement();\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         } else {\n           // Store is not null, the refresh is triggered by stale storage.\n           metrics.incrCacheStaleRefreshes();\n         }\n         List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n         try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           for (LogInfo log : appLogs.getDetailLogs()) {\n             LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n             // Only refresh the log that matches the cache id\n             if (log.matchesGroupId(groupId)) {\n               Path appDirPath \u003d appLogs.getAppDirPath();\n               if (fs.exists(log.getPath(appDirPath))) {\n                 LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                 log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                     jsonFactory, objMapper, fs);\n               } else {\n                 // The log may have been removed, remove the log\n                 removeList.add(log);\n                 LOG.info(\"File {} no longer exists, removing it from log list\",\n                     log.getPath(appDirPath));\n               }\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n       metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n       metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineACLsManager aclManager,\n      JsonFactory jsonFactory, ObjectMapper objMapper,\n      EntityGroupFSTimelineStoreMetrics metrics) throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          activeStores.getAndIncrement();\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          for (LogInfo log : appLogs.getDetailLogs()) {\n            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n            // Only refresh the log that matches the cache id\n            if (log.matchesGroupId(groupId)) {\n              Path appDirPath \u003d appLogs.getAppDirPath();\n              if (fs.exists(log.getPath(appDirPath))) {\n                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                    jsonFactory, objMapper, fs);\n              } else {\n                // The log may have been removed, remove the log\n                removeList.add(log);\n                LOG.info(\"File {} no longer exists, removing it from log list\",\n                    log.getPath(appDirPath));\n              }\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {}
        }
      ]
    },
    "06413da72efed9a50e49efaf7110c220c88a7f4a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4851. Metric improvements for ATS v1.5 storage components. Li Lu via junping_du.\n",
      "commitDate": "03/05/16 4:16 AM",
      "commitName": "06413da72efed9a50e49efaf7110c220c88a7f4a",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4851. Metric improvements for ATS v1.5 storage components. Li Lu via junping_du.\n",
          "commitDate": "03/05/16 4:16 AM",
          "commitName": "06413da72efed9a50e49efaf7110c220c88a7f4a",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/03/16 10:51 AM",
          "commitNameOld": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 53.68,
          "commitsBetweenForRepo": 312,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,57 @@\n   public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n       TimelineACLsManager aclManager, JsonFactory jsonFactory,\n-      ObjectMapper objMapper) throws IOException {\n+      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n+      throws IOException {\n     if (needRefresh()) {\n+      long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n+        } else {\n+          // Store is not null, the refresh is triggered by stale storage.\n+          metrics.incrCacheStaleRefreshes();\n         }\n         List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n-        try(TimelineDataManager tdm \u003d\n+        try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           for (LogInfo log : appLogs.getDetailLogs()) {\n             LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n             // Only refresh the log that matches the cache id\n             if (log.matchesGroupId(groupId)) {\n               Path appDirPath \u003d appLogs.getAppDirPath();\n               if (fs.exists(log.getPath(appDirPath))) {\n                 LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                 log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                     jsonFactory, objMapper, fs);\n               } else {\n                 // The log may have been removed, remove the log\n                 removeList.add(log);\n                 LOG.info(\"File {} no longer exists, removing it from log list\",\n                     log.getPath(appDirPath));\n               }\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n+      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n+      metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n      throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          for (LogInfo log : appLogs.getDetailLogs()) {\n            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n            // Only refresh the log that matches the cache id\n            if (log.matchesGroupId(groupId)) {\n              Path appDirPath \u003d appLogs.getAppDirPath();\n              if (fs.exists(log.getPath(appDirPath))) {\n                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                    jsonFactory, objMapper, fs);\n              } else {\n                // The log may have been removed, remove the log\n                removeList.add(log);\n                LOG.info(\"File {} no longer exists, removing it from log list\",\n                    log.getPath(appDirPath));\n              }\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {
            "oldValue": "[groupId-TimelineEntityGroupId, aclManager-TimelineACLsManager, jsonFactory-JsonFactory, objMapper-ObjectMapper]",
            "newValue": "[groupId-TimelineEntityGroupId, aclManager-TimelineACLsManager, jsonFactory-JsonFactory, objMapper-ObjectMapper, metrics-EntityGroupFSTimelineStoreMetrics]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4851. Metric improvements for ATS v1.5 storage components. Li Lu via junping_du.\n",
          "commitDate": "03/05/16 4:16 AM",
          "commitName": "06413da72efed9a50e49efaf7110c220c88a7f4a",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/03/16 10:51 AM",
          "commitNameOld": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 53.68,
          "commitsBetweenForRepo": 312,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,57 @@\n   public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n       TimelineACLsManager aclManager, JsonFactory jsonFactory,\n-      ObjectMapper objMapper) throws IOException {\n+      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n+      throws IOException {\n     if (needRefresh()) {\n+      long startTime \u003d Time.monotonicNow();\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n+        } else {\n+          // Store is not null, the refresh is triggered by stale storage.\n+          metrics.incrCacheStaleRefreshes();\n         }\n         List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n-        try(TimelineDataManager tdm \u003d\n+        try (TimelineDataManager tdm \u003d\n                 new TimelineDataManager(store, aclManager)) {\n           tdm.init(config);\n           tdm.start();\n           for (LogInfo log : appLogs.getDetailLogs()) {\n             LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n             // Only refresh the log that matches the cache id\n             if (log.matchesGroupId(groupId)) {\n               Path appDirPath \u003d appLogs.getAppDirPath();\n               if (fs.exists(log.getPath(appDirPath))) {\n                 LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                 log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                     jsonFactory, objMapper, fs);\n               } else {\n                 // The log may have been removed, remove the log\n                 removeList.add(log);\n                 LOG.info(\"File {} no longer exists, removing it from log list\",\n                     log.getPath(appDirPath));\n               }\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n       }\n       updateRefreshTimeToNow();\n+      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n+      metrics.incrNoRefreshCacheRead();\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n      ObjectMapper objMapper, EntityGroupFSTimelineStoreMetrics metrics)\n      throws IOException {\n    if (needRefresh()) {\n      long startTime \u003d Time.monotonicNow();\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        } else {\n          // Store is not null, the refresh is triggered by stale storage.\n          metrics.incrCacheStaleRefreshes();\n        }\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n        try (TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          for (LogInfo log : appLogs.getDetailLogs()) {\n            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n            // Only refresh the log that matches the cache id\n            if (log.matchesGroupId(groupId)) {\n              Path appDirPath \u003d appLogs.getAppDirPath();\n              if (fs.exists(log.getPath(appDirPath))) {\n                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                    jsonFactory, objMapper, fs);\n              } else {\n                // The log may have been removed, remove the log\n                removeList.add(log);\n                LOG.info(\"File {} no longer exists, removing it from log list\",\n                    log.getPath(appDirPath));\n              }\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n      }\n      updateRefreshTimeToNow();\n      metrics.addCacheRefreshTime(Time.monotonicNow() - startTime);\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n      metrics.incrNoRefreshCacheRead();\n    }\n    return store;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
          "extendedDetails": {}
        }
      ]
    },
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4696. Improving EntityGroupFSTimelineStore on exception handling, test setup, and concurrency. (Steve Loughran via gtcarrera9)\n",
      "commitDate": "10/03/16 10:51 AM",
      "commitName": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
      "commitAuthor": "Li Lu",
      "commitDateOld": "28/01/16 2:24 PM",
      "commitNameOld": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 41.85,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n       TimelineACLsManager aclManager, JsonFactory jsonFactory,\n       ObjectMapper objMapper) throws IOException {\n     if (needRefresh()) {\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n           store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n               \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         }\n-        TimelineDataManager tdm \u003d new TimelineDataManager(store,\n-            aclManager);\n-        tdm.init(config);\n-        tdm.start();\n-        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003cLogInfo\u003e();\n-        for (LogInfo log : appLogs.getDetailLogs()) {\n-          LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n-          // Only refresh the log that matches the cache id\n-          if (log.matchesGroupId(groupId)) {\n-            Path appDirPath \u003d appLogs.getAppDirPath();\n-            if (fs.exists(log.getPath(appDirPath))) {\n-              LOG.debug(\"Refresh logs for cache id {}\", groupId);\n-              log.parseForStore(tdm, appDirPath, appLogs.isDone(), jsonFactory,\n-                  objMapper, fs);\n-            } else {\n-              // The log may have been removed, remove the log\n-              removeList.add(log);\n-              LOG.info(\"File {} no longer exists, remove it from log list\",\n-                  log.getPath(appDirPath));\n+        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n+        try(TimelineDataManager tdm \u003d\n+                new TimelineDataManager(store, aclManager)) {\n+          tdm.init(config);\n+          tdm.start();\n+          for (LogInfo log : appLogs.getDetailLogs()) {\n+            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n+            // Only refresh the log that matches the cache id\n+            if (log.matchesGroupId(groupId)) {\n+              Path appDirPath \u003d appLogs.getAppDirPath();\n+              if (fs.exists(log.getPath(appDirPath))) {\n+                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n+                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n+                    jsonFactory, objMapper, fs);\n+              } else {\n+                // The log may have been removed, remove the log\n+                removeList.add(log);\n+                LOG.info(\"File {} no longer exists, removing it from log list\",\n+                    log.getPath(appDirPath));\n+              }\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n-        tdm.close();\n       }\n       updateRefreshTimeToNow();\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n      ObjectMapper objMapper) throws IOException {\n    if (needRefresh()) {\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        }\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003c\u003e();\n        try(TimelineDataManager tdm \u003d\n                new TimelineDataManager(store, aclManager)) {\n          tdm.init(config);\n          tdm.start();\n          for (LogInfo log : appLogs.getDetailLogs()) {\n            LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n            // Only refresh the log that matches the cache id\n            if (log.matchesGroupId(groupId)) {\n              Path appDirPath \u003d appLogs.getAppDirPath();\n              if (fs.exists(log.getPath(appDirPath))) {\n                LOG.debug(\"Refresh logs for cache id {}\", groupId);\n                log.parseForStore(tdm, appDirPath, appLogs.isDone(),\n                    jsonFactory, objMapper, fs);\n              } else {\n                // The log may have been removed, remove the log\n                removeList.add(log);\n                LOG.info(\"File {} no longer exists, removing it from log list\",\n                    log.getPath(appDirPath));\n              }\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n      }\n      updateRefreshTimeToNow();\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n    }\n    return store;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
      "extendedDetails": {}
    },
    "9fab22b36673e7f1a0bb629d2c07966ac2482e99": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4219. New levelDB cache storage for timeline v1.5. Contributed by\nLi Lu\n",
      "commitDate": "28/01/16 2:24 PM",
      "commitName": "9fab22b36673e7f1a0bb629d2c07966ac2482e99",
      "commitAuthor": "Xuan",
      "commitDateOld": "17/01/16 5:37 PM",
      "commitNameOld": "02f597c5db36ded385413958bdee793ad7eda40e",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n       TimelineACLsManager aclManager, JsonFactory jsonFactory,\n       ObjectMapper objMapper) throws IOException {\n     if (needRefresh()) {\n       // If an application is not finished, we only update summary logs (and put\n       // new entities into summary storage).\n       // Otherwise, since the application is done, we can update detail logs.\n       if (!appLogs.isDone()) {\n         appLogs.parseSummaryLogs();\n       } else if (appLogs.getDetailLogs().isEmpty()) {\n         appLogs.scanForLogs();\n       }\n       if (!appLogs.getDetailLogs().isEmpty()) {\n         if (store \u003d\u003d null) {\n-          store \u003d new MemoryTimelineStore();\n+          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n+              \"LeveldbCache.\" + groupId);\n           store.init(config);\n           store.start();\n         }\n         TimelineDataManager tdm \u003d new TimelineDataManager(store,\n             aclManager);\n         tdm.init(config);\n         tdm.start();\n         List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003cLogInfo\u003e();\n         for (LogInfo log : appLogs.getDetailLogs()) {\n           LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n           // Only refresh the log that matches the cache id\n           if (log.matchesGroupId(groupId)) {\n             Path appDirPath \u003d appLogs.getAppDirPath();\n             if (fs.exists(log.getPath(appDirPath))) {\n               LOG.debug(\"Refresh logs for cache id {}\", groupId);\n               log.parseForStore(tdm, appDirPath, appLogs.isDone(), jsonFactory,\n                   objMapper, fs);\n             } else {\n               // The log may have been removed, remove the log\n               removeList.add(log);\n               LOG.info(\"File {} no longer exists, remove it from log list\",\n                   log.getPath(appDirPath));\n             }\n           }\n         }\n         appLogs.getDetailLogs().removeAll(removeList);\n         tdm.close();\n       }\n       updateRefreshTimeToNow();\n     } else {\n       LOG.debug(\"Cache new enough, skip refreshing\");\n     }\n     return store;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n      ObjectMapper objMapper) throws IOException {\n    if (needRefresh()) {\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new LevelDBCacheTimelineStore(groupId.toString(),\n              \"LeveldbCache.\" + groupId);\n          store.init(config);\n          store.start();\n        }\n        TimelineDataManager tdm \u003d new TimelineDataManager(store,\n            aclManager);\n        tdm.init(config);\n        tdm.start();\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003cLogInfo\u003e();\n        for (LogInfo log : appLogs.getDetailLogs()) {\n          LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n          // Only refresh the log that matches the cache id\n          if (log.matchesGroupId(groupId)) {\n            Path appDirPath \u003d appLogs.getAppDirPath();\n            if (fs.exists(log.getPath(appDirPath))) {\n              LOG.debug(\"Refresh logs for cache id {}\", groupId);\n              log.parseForStore(tdm, appDirPath, appLogs.isDone(), jsonFactory,\n                  objMapper, fs);\n            } else {\n              // The log may have been removed, remove the log\n              removeList.add(log);\n              LOG.info(\"File {} no longer exists, remove it from log list\",\n                  log.getPath(appDirPath));\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n        tdm.close();\n      }\n      updateRefreshTimeToNow();\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n    }\n    return store;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java",
      "extendedDetails": {}
    },
    "02f597c5db36ded385413958bdee793ad7eda40e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4265. Provide new timeline plugin storage to support fine-grained entity caching. Contributed by Li Lu and Jason Lowe\n",
      "commitDate": "17/01/16 5:37 PM",
      "commitName": "02f597c5db36ded385413958bdee793ad7eda40e",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,49 @@\n+  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n+      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n+      ObjectMapper objMapper) throws IOException {\n+    if (needRefresh()) {\n+      // If an application is not finished, we only update summary logs (and put\n+      // new entities into summary storage).\n+      // Otherwise, since the application is done, we can update detail logs.\n+      if (!appLogs.isDone()) {\n+        appLogs.parseSummaryLogs();\n+      } else if (appLogs.getDetailLogs().isEmpty()) {\n+        appLogs.scanForLogs();\n+      }\n+      if (!appLogs.getDetailLogs().isEmpty()) {\n+        if (store \u003d\u003d null) {\n+          store \u003d new MemoryTimelineStore();\n+          store.init(config);\n+          store.start();\n+        }\n+        TimelineDataManager tdm \u003d new TimelineDataManager(store,\n+            aclManager);\n+        tdm.init(config);\n+        tdm.start();\n+        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003cLogInfo\u003e();\n+        for (LogInfo log : appLogs.getDetailLogs()) {\n+          LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n+          // Only refresh the log that matches the cache id\n+          if (log.matchesGroupId(groupId)) {\n+            Path appDirPath \u003d appLogs.getAppDirPath();\n+            if (fs.exists(log.getPath(appDirPath))) {\n+              LOG.debug(\"Refresh logs for cache id {}\", groupId);\n+              log.parseForStore(tdm, appDirPath, appLogs.isDone(), jsonFactory,\n+                  objMapper, fs);\n+            } else {\n+              // The log may have been removed, remove the log\n+              removeList.add(log);\n+              LOG.info(\"File {} no longer exists, remove it from log list\",\n+                  log.getPath(appDirPath));\n+            }\n+          }\n+        }\n+        appLogs.getDetailLogs().removeAll(removeList);\n+        tdm.close();\n+      }\n+      updateRefreshTimeToNow();\n+    } else {\n+      LOG.debug(\"Cache new enough, skip refreshing\");\n+    }\n+    return store;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized TimelineStore refreshCache(TimelineEntityGroupId groupId,\n      TimelineACLsManager aclManager, JsonFactory jsonFactory,\n      ObjectMapper objMapper) throws IOException {\n    if (needRefresh()) {\n      // If an application is not finished, we only update summary logs (and put\n      // new entities into summary storage).\n      // Otherwise, since the application is done, we can update detail logs.\n      if (!appLogs.isDone()) {\n        appLogs.parseSummaryLogs();\n      } else if (appLogs.getDetailLogs().isEmpty()) {\n        appLogs.scanForLogs();\n      }\n      if (!appLogs.getDetailLogs().isEmpty()) {\n        if (store \u003d\u003d null) {\n          store \u003d new MemoryTimelineStore();\n          store.init(config);\n          store.start();\n        }\n        TimelineDataManager tdm \u003d new TimelineDataManager(store,\n            aclManager);\n        tdm.init(config);\n        tdm.start();\n        List\u003cLogInfo\u003e removeList \u003d new ArrayList\u003cLogInfo\u003e();\n        for (LogInfo log : appLogs.getDetailLogs()) {\n          LOG.debug(\"Try refresh logs for {}\", log.getFilename());\n          // Only refresh the log that matches the cache id\n          if (log.matchesGroupId(groupId)) {\n            Path appDirPath \u003d appLogs.getAppDirPath();\n            if (fs.exists(log.getPath(appDirPath))) {\n              LOG.debug(\"Refresh logs for cache id {}\", groupId);\n              log.parseForStore(tdm, appDirPath, appLogs.isDone(), jsonFactory,\n                  objMapper, fs);\n            } else {\n              // The log may have been removed, remove the log\n              removeList.add(log);\n              LOG.info(\"File {} no longer exists, remove it from log list\",\n                  log.getPath(appDirPath));\n            }\n          }\n        }\n        appLogs.getDetailLogs().removeAll(removeList);\n        tdm.close();\n      }\n      updateRefreshTimeToNow();\n    } else {\n      LOG.debug(\"Cache new enough, skip refreshing\");\n    }\n    return store;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityCacheItem.java"
    }
  }
}