{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "getEntity",
  "functionId": "getEntity___entityId-String__entityType-String__startTime-Long__fields-EnumSet__Field____iterator-DBIterator__prefix-byte[]__prefixlen-int",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 440,
  "functionEndLine": 538,
  "numCommitsSeen": 12,
  "timeTaken": 1730,
  "changeHistory": [
    "5f1ee72b0ebf0330417b7c0115083bc851923be4",
    "4369690ce63566131aee28696bf2683a3cb20205",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "5f1ee72b0ebf0330417b7c0115083bc851923be4": "Ybodychange",
    "4369690ce63566131aee28696bf2683a3cb20205": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5f1ee72b0ebf0330417b7c0115083bc851923be4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6654. RollingLevelDBTimelineStore backwards incompatible after fst upgrade. Contributed by Jonathan Eagles\n",
      "commitDate": "13/07/17 3:27 PM",
      "commitName": "5f1ee72b0ebf0330417b7c0115083bc851923be4",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "31/05/17 9:32 AM",
      "commitNameOld": "4369690ce63566131aee28696bf2683a3cb20205",
      "commitAuthorOld": "Nathan Roberts",
      "daysBetweenCommits": 43.25,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,99 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n     if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n     }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key, prefixlen\n               + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n           Object o \u003d null;\n           String keyStr \u003d parseRemainingKey(key,\n               prefixlen + OTHER_INFO_COLUMN.length);\n           try {\n             o \u003d fstConf.asObject(iterator.peekNext().getValue());\n             entity.addOtherInfo(keyStr, o);\n-          } catch (Exception e) {\n-            LOG.warn(\"Error while decoding \"\n-                + entityId + \":otherInfo:\" + keyStr, e);\n+          } catch (Exception ignore) {\n+            try {\n+              // Fall back to 2.24 parser\n+              o \u003d fstConf224.asObject(iterator.peekNext().getValue());\n+              entity.addOtherInfo(keyStr, o);\n+            } catch (Exception e) {\n+              LOG.warn(\"Error while decoding \"\n+                  + entityId + \":otherInfo:\" + keyStr, e);\n+            }\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key, prefixlen\n               + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n               + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n         byte[] v \u003d iterator.peekNext().getValue();\n         String domainId \u003d new String(v, UTF_8);\n         entity.setDomainId(domainId);\n       } else {\n         LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n             + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key, prefixlen\n              + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          Object o \u003d null;\n          String keyStr \u003d parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length);\n          try {\n            o \u003d fstConf.asObject(iterator.peekNext().getValue());\n            entity.addOtherInfo(keyStr, o);\n          } catch (Exception ignore) {\n            try {\n              // Fall back to 2.24 parser\n              o \u003d fstConf224.asObject(iterator.peekNext().getValue());\n              entity.addOtherInfo(keyStr, o);\n            } catch (Exception e) {\n              LOG.warn(\"Error while decoding \"\n                  + entityId + \":otherInfo:\" + keyStr, e);\n            }\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key, prefixlen\n              + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n              + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v, UTF_8);\n        entity.setDomainId(domainId);\n      } else {\n        LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n            + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "4369690ce63566131aee28696bf2683a3cb20205": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6649. RollingLevelDBTimelineServer throws RuntimeException if object decoding ever fails runtime exception. Contributed by Jon Eagles.\n",
      "commitDate": "31/05/17 9:32 AM",
      "commitName": "4369690ce63566131aee28696bf2683a3cb20205",
      "commitAuthor": "Nathan Roberts",
      "commitDateOld": "28/03/17 1:23 PM",
      "commitNameOld": "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 63.84,
      "commitsBetweenForRepo": 353,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,93 @@\n   private static TimelineEntity getEntity(String entityId, String entityType,\n       Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n       byte[] prefix, int prefixlen) throws IOException {\n     if (fields \u003d\u003d null) {\n       fields \u003d EnumSet.allOf(Field.class);\n     }\n \n     TimelineEntity entity \u003d new TimelineEntity();\n     boolean events \u003d false;\n     boolean lastEvent \u003d false;\n     if (fields.contains(Field.EVENTS)) {\n       events \u003d true;\n     } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n       lastEvent \u003d true;\n     } else {\n       entity.setEvents(null);\n     }\n     boolean relatedEntities \u003d false;\n     if (fields.contains(Field.RELATED_ENTITIES)) {\n       relatedEntities \u003d true;\n     } else {\n       entity.setRelatedEntities(null);\n     }\n     boolean primaryFilters \u003d false;\n     if (fields.contains(Field.PRIMARY_FILTERS)) {\n       primaryFilters \u003d true;\n     } else {\n       entity.setPrimaryFilters(null);\n     }\n     boolean otherInfo \u003d false;\n     if (fields.contains(Field.OTHER_INFO)) {\n       otherInfo \u003d true;\n     } else {\n       entity.setOtherInfo(null);\n     }\n \n     // iterate through the entity\u0027s entry, parsing information if it is part\n     // of a requested field\n     for (; iterator.hasNext(); iterator.next()) {\n       byte[] key \u003d iterator.peekNext().getKey();\n       if (!prefixMatches(prefix, prefixlen, key)) {\n         break;\n       }\n       if (key.length \u003d\u003d prefixlen) {\n         continue;\n       }\n       if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n         if (primaryFilters) {\n           addPrimaryFilter(entity, key, prefixlen\n               + PRIMARY_FILTERS_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n         if (otherInfo) {\n-          entity.addOtherInfo(\n-              parseRemainingKey(key, prefixlen + OTHER_INFO_COLUMN.length),\n-              fstConf.asObject(iterator.peekNext().getValue()));\n+          Object o \u003d null;\n+          String keyStr \u003d parseRemainingKey(key,\n+              prefixlen + OTHER_INFO_COLUMN.length);\n+          try {\n+            o \u003d fstConf.asObject(iterator.peekNext().getValue());\n+            entity.addOtherInfo(keyStr, o);\n+          } catch (Exception e) {\n+            LOG.warn(\"Error while decoding \"\n+                + entityId + \":otherInfo:\" + keyStr, e);\n+          }\n         }\n       } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n         if (relatedEntities) {\n           addRelatedEntity(entity, key, prefixlen\n               + RELATED_ENTITIES_COLUMN.length);\n         }\n       } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n         if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n           TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n               + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n           if (event !\u003d null) {\n             entity.addEvent(event);\n           }\n         }\n       } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n         byte[] v \u003d iterator.peekNext().getValue();\n         String domainId \u003d new String(v, UTF_8);\n         entity.setDomainId(domainId);\n       } else {\n         LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n             + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n       }\n     }\n \n     entity.setEntityId(entityId);\n     entity.setEntityType(entityType);\n     entity.setStartTime(startTime);\n \n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key, prefixlen\n              + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          Object o \u003d null;\n          String keyStr \u003d parseRemainingKey(key,\n              prefixlen + OTHER_INFO_COLUMN.length);\n          try {\n            o \u003d fstConf.asObject(iterator.peekNext().getValue());\n            entity.addOtherInfo(keyStr, o);\n          } catch (Exception e) {\n            LOG.warn(\"Error while decoding \"\n                + entityId + \":otherInfo:\" + keyStr, e);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key, prefixlen\n              + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n              + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v, UTF_8);\n        entity.setDomainId(domainId);\n      } else {\n        LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n            + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,86 @@\n+  private static TimelineEntity getEntity(String entityId, String entityType,\n+      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n+      byte[] prefix, int prefixlen) throws IOException {\n+    if (fields \u003d\u003d null) {\n+      fields \u003d EnumSet.allOf(Field.class);\n+    }\n+\n+    TimelineEntity entity \u003d new TimelineEntity();\n+    boolean events \u003d false;\n+    boolean lastEvent \u003d false;\n+    if (fields.contains(Field.EVENTS)) {\n+      events \u003d true;\n+    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n+      lastEvent \u003d true;\n+    } else {\n+      entity.setEvents(null);\n+    }\n+    boolean relatedEntities \u003d false;\n+    if (fields.contains(Field.RELATED_ENTITIES)) {\n+      relatedEntities \u003d true;\n+    } else {\n+      entity.setRelatedEntities(null);\n+    }\n+    boolean primaryFilters \u003d false;\n+    if (fields.contains(Field.PRIMARY_FILTERS)) {\n+      primaryFilters \u003d true;\n+    } else {\n+      entity.setPrimaryFilters(null);\n+    }\n+    boolean otherInfo \u003d false;\n+    if (fields.contains(Field.OTHER_INFO)) {\n+      otherInfo \u003d true;\n+    } else {\n+      entity.setOtherInfo(null);\n+    }\n+\n+    // iterate through the entity\u0027s entry, parsing information if it is part\n+    // of a requested field\n+    for (; iterator.hasNext(); iterator.next()) {\n+      byte[] key \u003d iterator.peekNext().getKey();\n+      if (!prefixMatches(prefix, prefixlen, key)) {\n+        break;\n+      }\n+      if (key.length \u003d\u003d prefixlen) {\n+        continue;\n+      }\n+      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n+        if (primaryFilters) {\n+          addPrimaryFilter(entity, key, prefixlen\n+              + PRIMARY_FILTERS_COLUMN.length);\n+        }\n+      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n+        if (otherInfo) {\n+          entity.addOtherInfo(\n+              parseRemainingKey(key, prefixlen + OTHER_INFO_COLUMN.length),\n+              fstConf.asObject(iterator.peekNext().getValue()));\n+        }\n+      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n+        if (relatedEntities) {\n+          addRelatedEntity(entity, key, prefixlen\n+              + RELATED_ENTITIES_COLUMN.length);\n+        }\n+      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n+        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n+          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n+              + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n+          if (event !\u003d null) {\n+            entity.addEvent(event);\n+          }\n+        }\n+      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n+        byte[] v \u003d iterator.peekNext().getValue();\n+        String domainId \u003d new String(v, UTF_8);\n+        entity.setDomainId(domainId);\n+      } else {\n+        LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n+            + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n+      }\n+    }\n+\n+    entity.setEntityId(entityId);\n+    entity.setEntityType(entityType);\n+    entity.setStartTime(startTime);\n+\n+    return entity;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity getEntity(String entityId, String entityType,\n      Long startTime, EnumSet\u003cField\u003e fields, DBIterator iterator,\n      byte[] prefix, int prefixlen) throws IOException {\n    if (fields \u003d\u003d null) {\n      fields \u003d EnumSet.allOf(Field.class);\n    }\n\n    TimelineEntity entity \u003d new TimelineEntity();\n    boolean events \u003d false;\n    boolean lastEvent \u003d false;\n    if (fields.contains(Field.EVENTS)) {\n      events \u003d true;\n    } else if (fields.contains(Field.LAST_EVENT_ONLY)) {\n      lastEvent \u003d true;\n    } else {\n      entity.setEvents(null);\n    }\n    boolean relatedEntities \u003d false;\n    if (fields.contains(Field.RELATED_ENTITIES)) {\n      relatedEntities \u003d true;\n    } else {\n      entity.setRelatedEntities(null);\n    }\n    boolean primaryFilters \u003d false;\n    if (fields.contains(Field.PRIMARY_FILTERS)) {\n      primaryFilters \u003d true;\n    } else {\n      entity.setPrimaryFilters(null);\n    }\n    boolean otherInfo \u003d false;\n    if (fields.contains(Field.OTHER_INFO)) {\n      otherInfo \u003d true;\n    } else {\n      entity.setOtherInfo(null);\n    }\n\n    // iterate through the entity\u0027s entry, parsing information if it is part\n    // of a requested field\n    for (; iterator.hasNext(); iterator.next()) {\n      byte[] key \u003d iterator.peekNext().getKey();\n      if (!prefixMatches(prefix, prefixlen, key)) {\n        break;\n      }\n      if (key.length \u003d\u003d prefixlen) {\n        continue;\n      }\n      if (key[prefixlen] \u003d\u003d PRIMARY_FILTERS_COLUMN[0]) {\n        if (primaryFilters) {\n          addPrimaryFilter(entity, key, prefixlen\n              + PRIMARY_FILTERS_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d OTHER_INFO_COLUMN[0]) {\n        if (otherInfo) {\n          entity.addOtherInfo(\n              parseRemainingKey(key, prefixlen + OTHER_INFO_COLUMN.length),\n              fstConf.asObject(iterator.peekNext().getValue()));\n        }\n      } else if (key[prefixlen] \u003d\u003d RELATED_ENTITIES_COLUMN[0]) {\n        if (relatedEntities) {\n          addRelatedEntity(entity, key, prefixlen\n              + RELATED_ENTITIES_COLUMN.length);\n        }\n      } else if (key[prefixlen] \u003d\u003d EVENTS_COLUMN[0]) {\n        if (events || (lastEvent \u0026\u0026 entity.getEvents().size() \u003d\u003d 0)) {\n          TimelineEvent event \u003d getEntityEvent(null, key, prefixlen\n              + EVENTS_COLUMN.length, iterator.peekNext().getValue());\n          if (event !\u003d null) {\n            entity.addEvent(event);\n          }\n        }\n      } else if (key[prefixlen] \u003d\u003d DOMAIN_ID_COLUMN[0]) {\n        byte[] v \u003d iterator.peekNext().getValue();\n        String domainId \u003d new String(v, UTF_8);\n        entity.setDomainId(domainId);\n      } else {\n        LOG.warn(String.format(\"Found unexpected column for entity %s of \"\n            + \"type %s (0x%02x)\", entityId, entityType, key[prefixlen]));\n      }\n    }\n\n    entity.setEntityId(entityId);\n    entity.setEntityType(entityType);\n    entity.setStartTime(startTime);\n\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}