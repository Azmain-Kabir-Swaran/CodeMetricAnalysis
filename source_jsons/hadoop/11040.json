{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReceiver.java",
  "functionName": "receivePacket",
  "functionId": "receivePacket",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
  "functionStartLine": 534,
  "functionEndLine": 858,
  "numCommitsSeen": 111,
  "timeTaken": 15369,
  "changeHistory": [
    "0ceb1b70f3200873fe1f40c264b91051b4a3d721",
    "462e25a3b264e1148d0cbca00db7f10d43a0555f",
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3",
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc",
    "ffa160ddb824cbcb8ab6b10ee1414507686e3c63",
    "603f3ef1386048111940b66f3a0750ab84d0588f",
    "4e9029653dfa7a803d73c173cb7044f7e0dc1eb1",
    "5daa8d8631835de97d4e4979e507a080017ca159",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf",
    "dcedb72af468128458e597f08d22f5c34b744ae5",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
    "a7d1fb0cd2fdbf830602eb4dbbd9bbe62f4d5584",
    "b4a05c1fd5ae98e28cf2b15f5b068e6c2d12f2a8",
    "c7c36cbd6218f46c33d7fb2f60cd52cb29e6d720",
    "99e5204ff5326430558b6f6fd9da7c44654c15d7",
    "59388a801514d6af64ef27fbf246d8054f1dcc74",
    "c74517c46bf00af408ed866b6577623cdec02de1",
    "02e7dec79d2d4f2b801435343219d8fb53ec931f",
    "463aec11718e47d4aabb86a7a539cb973460aae6",
    "195961a7c1da86421761162836766b1de07930fd",
    "6554994fab2d8a2a139fb71ed54be144f4057e08",
    "471b1368e2a81b4d9850f0f4d98d31df1451354c",
    "33518e561368c372bf9254b6b55a9b0c499fbd4d",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
    "e9459baec5a46651c156fbae5f8f3c9cc8325ef0",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
    "98a692fd6361365db4afb9523a5d83ee32774112",
    "1e7010cf38115604d6fa3aa5728362c86644e66a",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
    "83cf475050dba27e72b4e399491638c670621175",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "0ceb1b70f3200873fe1f40c264b91051b4a3d721": "Ybodychange",
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": "Ybodychange",
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3": "Ybodychange",
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc": "Ybodychange",
    "ffa160ddb824cbcb8ab6b10ee1414507686e3c63": "Ybodychange",
    "603f3ef1386048111940b66f3a0750ab84d0588f": "Ybodychange",
    "4e9029653dfa7a803d73c173cb7044f7e0dc1eb1": "Ybodychange",
    "5daa8d8631835de97d4e4979e507a080017ca159": "Ybodychange",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": "Ybodychange",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": "Ybodychange",
    "dcedb72af468128458e597f08d22f5c34b744ae5": "Ybodychange",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": "Ybodychange",
    "a7d1fb0cd2fdbf830602eb4dbbd9bbe62f4d5584": "Ybodychange",
    "b4a05c1fd5ae98e28cf2b15f5b068e6c2d12f2a8": "Ybodychange",
    "c7c36cbd6218f46c33d7fb2f60cd52cb29e6d720": "Ybodychange",
    "99e5204ff5326430558b6f6fd9da7c44654c15d7": "Ybodychange",
    "59388a801514d6af64ef27fbf246d8054f1dcc74": "Ybodychange",
    "c74517c46bf00af408ed866b6577623cdec02de1": "Ybodychange",
    "02e7dec79d2d4f2b801435343219d8fb53ec931f": "Ybodychange",
    "463aec11718e47d4aabb86a7a539cb973460aae6": "Ybodychange",
    "195961a7c1da86421761162836766b1de07930fd": "Ybodychange",
    "6554994fab2d8a2a139fb71ed54be144f4057e08": "Ybodychange",
    "471b1368e2a81b4d9850f0f4d98d31df1451354c": "Ybodychange",
    "33518e561368c372bf9254b6b55a9b0c499fbd4d": "Ybodychange",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": "Ybodychange",
    "e9459baec5a46651c156fbae5f8f3c9cc8325ef0": "Ybodychange",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": "Ybodychange",
    "98a692fd6361365db4afb9523a5d83ee32774112": "Ybodychange",
    "1e7010cf38115604d6fa3aa5728362c86644e66a": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": "Ybodychange",
    "83cf475050dba27e72b4e399491638c670621175": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0ceb1b70f3200873fe1f40c264b91051b4a3d721": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14260. Replace synchronized method in BlockReceiver with atomic value. Contributed by BELUGA BEHR.\n",
      "commitDate": "11/02/19 10:09 AM",
      "commitName": "0ceb1b70f3200873fe1f40c264b91051b4a3d721",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "11/10/18 1:49 PM",
      "commitNameOld": "3532aa38867dc928b415c6c5eb47cca4fac349fe",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 122.89,
      "commitsBetweenForRepo": 884,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,325 +1,325 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n       // sync directory for finalize irrespective of syncOnClose config since\n       // sync is requested.\n       this.dirSyncOnFinalize \u003d true;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n-        setLastSentTime(now);\n+        this.lastSentTime.set(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n               + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n               + \", blockId\u003d\" + replicaInfo.getBlockId());\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                 + \"volume\u003d\" + getVolumeBaseUri()\n                 + \", blockId\u003d\" + replicaInfo.getBlockId());\n           }\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n      // sync directory for finalize irrespective of syncOnClose config since\n      // sync is requested.\n      this.dirSyncOnFinalize \u003d true;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        this.lastSentTime.set(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n              + \", blockId\u003d\" + replicaInfo.getBlockId());\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                + \"volume\u003d\" + getVolumeBaseUri()\n                + \", blockId\u003d\" + replicaInfo.getBlockId());\n          }\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12814. Add blockId when warning slow mirror/disk in BlockReceiver. Contributed by Jiandan Yang.\n",
      "commitDate": "16/11/17 12:19 AM",
      "commitName": "462e25a3b264e1148d0cbca00db7f10d43a0555f",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/08/17 3:49 PM",
      "commitNameOld": "a1e3f84afe6c02cc642699634052d2fb60b30179",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 79.4,
      "commitsBetweenForRepo": 781,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,323 +1,325 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n       // sync directory for finalize irrespective of syncOnClose config since\n       // sync is requested.\n       this.dirSyncOnFinalize \u003d true;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n-              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs));\n+              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n+              + \", blockId\u003d\" + replicaInfo.getBlockId());\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n-                + \"volume\u003d\" + getVolumeBaseUri());\n+                + \"volume\u003d\" + getVolumeBaseUri()\n+                + \", blockId\u003d\" + replicaInfo.getBlockId());\n           }\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n      // sync directory for finalize irrespective of syncOnClose config since\n      // sync is requested.\n      this.dirSyncOnFinalize \u003d true;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs)\n              + \", blockId\u003d\" + replicaInfo.getBlockId());\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                + \"volume\u003d\" + getVolumeBaseUri()\n                + \", blockId\u003d\" + replicaInfo.getBlockId());\n          }\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "1543d0f5be6a02ad00e7a33e35d78af8516043e3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5042. Completed files lost after power failure. Contributed by Vinayakumar B.\n",
      "commitDate": "31/05/17 8:55 AM",
      "commitName": "1543d0f5be6a02ad00e7a33e35d78af8516043e3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "31/05/17 8:09 AM",
      "commitNameOld": "13de636b4079b077890ad10389ff350dcf8086a2",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,320 +1,323 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n+      // sync directory for finalize irrespective of syncOnClose config since\n+      // sync is requested.\n+      this.dirSyncOnFinalize \u003d true;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n               + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs));\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                 + \"volume\u003d\" + getVolumeBaseUri());\n           }\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n      // sync directory for finalize irrespective of syncOnClose config since\n      // sync is requested.\n      this.dirSyncOnFinalize \u003d true;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs));\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                + \"volume\u003d\" + getVolumeBaseUri());\n          }\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11603. Improve slow mirror/disk warnings in BlockReceiver.\n",
      "commitDate": "31/03/17 12:10 PM",
      "commitName": "5485d93bda3329a7c80767c3723cc6e1a9233dbc",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/03/17 7:02 PM",
      "commitNameOld": "ffa160ddb824cbcb8ab6b10ee1414507686e3c63",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 13.71,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,318 +1,320 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n-        if (duration \u003e datanodeSlowLogThresholdMs) {\n+        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n-              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n+              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs));\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n-          if (duration \u003e datanodeSlowLogThresholdMs) {\n+          if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n-                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n+                + \"volume\u003d\" + getVolumeBaseUri());\n           }\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n              + \"downstream DNs\u003d\" + Arrays.toString(downstreamDNs));\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms), \"\n                + \"volume\u003d\" + getVolumeBaseUri());\n          }\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "ffa160ddb824cbcb8ab6b10ee1414507686e3c63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11547. Add logs for slow BlockReceiver while writing data to disk. Contributed by Xiaobing Zhou.\n",
      "commitDate": "17/03/17 7:02 PM",
      "commitName": "ffa160ddb824cbcb8ab6b10ee1414507686e3c63",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "31/01/17 10:42 PM",
      "commitNameOld": "bec9b7aa1dd3ed95b8783597135f8d90b3cc8dcd",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 44.81,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,314 +1,318 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n+          if (duration \u003e datanodeSlowLogThresholdMs) {\n+            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n+                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+          }\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "603f3ef1386048111940b66f3a0750ab84d0588f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11274. Datanode should only check the failed volume upon IO errors. Contributed by Xiaoyu Yao.\n",
      "commitDate": "28/12/16 10:08 PM",
      "commitName": "603f3ef1386048111940b66f3a0750ab84d0588f",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "22/12/16 11:46 PM",
      "commitNameOld": "4e9029653dfa7a803d73c173cb7044f7e0dc1eb1",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,314 +1,314 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n         trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n-        datanode.checkDiskErrorAsync();\n+        // Volume error check moved to FileIoProvider\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        // Volume error check moved to FileIoProvider\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "4e9029653dfa7a803d73c173cb7044f7e0dc1eb1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10917. Collect peer performance statistics on DataNode. Contributed by Xiaobing Zhou.\n",
      "commitDate": "22/12/16 11:46 PM",
      "commitName": "4e9029653dfa7a803d73c173cb7044f7e0dc1eb1",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "20/12/16 1:17 PM",
      "commitNameOld": "5daa8d8631835de97d4e4979e507a080017ca159",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 2.44,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,313 +1,314 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n             mirrorAddr,\n             duration);\n+        trackSendPacketToLastNodeInPipeline(duration);\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        trackSendPacketToLastNodeInPipeline(duration);\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "5daa8d8631835de97d4e4979e507a080017ca159": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10913. Introduce fault injectors to simulate slow mirrors. Contributed by Xiaobing Zhou.\n",
      "commitDate": "20/12/16 1:17 PM",
      "commitName": "5daa8d8631835de97d4e4979e507a080017ca159",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "14/12/16 11:18 AM",
      "commitNameOld": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 6.08,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,310 +1,313 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n-        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n+        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n+        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n+            mirrorAddr,\n+            duration);\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream(mirrorAddr);\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        DataNodeFaultInjector.get().logDelaySendingPacketDownstream(\n            mirrorAddr,\n            duration);\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10958. Add instrumentation hooks around Datanode disk IO.\n",
      "commitDate": "14/12/16 11:18 AM",
      "commitName": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/12/16 11:05 AM",
      "commitNameOld": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,308 +1,310 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n-          long duration \u003d streams.writeToDisk(dataBuf.array(),\n+          long begin \u003d Time.monotonicNow();\n+          streams.writeDataToDisk(dataBuf.array(),\n               startByteToDisk, numBytesToDisk);\n+          long duration \u003d Time.monotonicNow() - begin;\n \n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          streams.writeDataToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "06/12/16 11:05 AM",
      "commitName": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "05/12/16 12:44 PM",
      "commitNameOld": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,312 +1,308 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n-          long begin \u003d Time.monotonicNow();\n-          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n-          long duration \u003d Time.monotonicNow() - begin;\n+          long duration \u003d streams.writeToDisk(dataBuf.array(),\n+              startByteToDisk, numBytesToDisk);\n+\n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n-          if (duration \u003e datanodeSlowLogThresholdMs) {\n-            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n-                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n-          }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long duration \u003d streams.writeToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "dcedb72af468128458e597f08d22f5c34b744ae5": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\"\n\nThis reverts commit aeecfa24f4fb6af289920cbf8830c394e66bd78e.\n",
      "commitDate": "05/12/16 12:44 PM",
      "commitName": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "29/11/16 8:52 PM",
      "commitNameOld": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,308 +1,312 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n-          long duration \u003d streams.writeToDisk(dataBuf.array(),\n-              startByteToDisk, numBytesToDisk);\n-\n+          long begin \u003d Time.monotonicNow();\n+          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n+          long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n+          if (duration \u003e datanodeSlowLogThresholdMs) {\n+            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n+                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+          }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "29/11/16 8:52 PM",
      "commitName": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "13/09/16 12:54 PM",
      "commitNameOld": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 77.37,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,312 +1,308 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         // For testing. Normally no-op.\n         DataNodeFaultInjector.get().stopSendingPacketDownstream();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n-          long begin \u003d Time.monotonicNow();\n-          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n-          long duration \u003d Time.monotonicNow() - begin;\n+          long duration \u003d streams.writeToDisk(dataBuf.array(),\n+              startByteToDisk, numBytesToDisk);\n+\n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n-          if (duration \u003e datanodeSlowLogThresholdMs) {\n-            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n-                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n-          }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long duration \u003d streams.writeToDisk(dataBuf.array(),\n              startByteToDisk, numBytesToDisk);\n\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "a7d1fb0cd2fdbf830602eb4dbbd9bbe62f4d5584": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10178. Permanent write failures can happen if pipeline recoveries occur for the first packet. Contributed by Kihwal Lee.\n",
      "commitDate": "04/04/16 2:40 PM",
      "commitName": "a7d1fb0cd2fdbf830602eb4dbbd9bbe62f4d5584",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/03/16 2:56 PM",
      "commitNameOld": "a7d8f2b3960d27c74abb17ce2aa4bcd999706ad2",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 12.99,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,310 +1,312 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n+        // For testing. Normally no-op.\n+        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e maxWriteToDiskMs) {\n             maxWriteToDiskMs \u003d duration;\n           }\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        // For testing. Normally no-op.\n        DataNodeFaultInjector.get().stopSendingPacketDownstream();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "b4a05c1fd5ae98e28cf2b15f5b068e6c2d12f2a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9674. The HTrace span for OpWriteBlock should record the maxWriteToDisk time. Contributed by Colin McCabe.\n\nChange-Id: I9bf3f3bcd57f5880189ad7c160f3dd66f97d904b\n",
      "commitDate": "21/01/16 1:25 PM",
      "commitName": "b4a05c1fd5ae98e28cf2b15f5b068e6c2d12f2a8",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "22/11/15 3:54 PM",
      "commitNameOld": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 59.9,
      "commitsBetweenForRepo": 377,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,307 +1,310 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n+          if (duration \u003e maxWriteToDiskMs) {\n+            maxWriteToDiskMs \u003d duration;\n+          }\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e maxWriteToDiskMs) {\n            maxWriteToDiskMs \u003d duration;\n          }\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "c7c36cbd6218f46c33d7fb2f60cd52cb29e6d720": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9220. Reading small file (\u003c 512 bytes) that is open for append fails due to incorrect checksum. Contributed by Jing Zhao.\n",
      "commitDate": "15/10/15 9:24 AM",
      "commitName": "c7c36cbd6218f46c33d7fb2f60cd52cb29e6d720",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "07/10/15 8:17 AM",
      "commitNameOld": "99e5204ff5326430558b6f6fd9da7c44654c15d7",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.05,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,308 +1,307 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     // Drop heartbeat for testing.\n     if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n         DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n       return 0;\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long now \u003d Time.monotonicNow();\n         setLastSentTime(now);\n         long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n-            // If offset \u003e end, there is no more checksum to write.\n+            // If offset \u003e\u003d end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n-            if (offset \u003e end) {\n-              assert crcBytes !\u003d null;\n+            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e\u003d end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e\u003d end \u0026\u0026 doCrcRecalc) {\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "99e5204ff5326430558b6f6fd9da7c44654c15d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9178. Slow datanode I/O can cause a wrong node to be marked bad. Contributed by Kihwal Lee.\n",
      "commitDate": "07/10/15 8:17 AM",
      "commitName": "99e5204ff5326430558b6f6fd9da7c44654c15d7",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "26/09/15 11:08 AM",
      "commitNameOld": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 10.88,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,300 +1,308 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n+    // Drop heartbeat for testing.\n+    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n+        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n+      return 0;\n+    }\n+\n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n-        long duration \u003d Time.monotonicNow() - begin;\n+        long now \u003d Time.monotonicNow();\n+        setLastSentTime(now);\n+        long duration \u003d now - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n           long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n           // If the end of the on-disk data is not chunk-aligned, the last\n           // checksum needs to be overwritten.\n           boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n           // If the starting offset of the packat data is at the last chunk\n           // boundary of the data on disk, the partial checksum recalculation\n           // can be skipped and the checksum supplied by the client can be used\n           // instead. This reduces disk reads and cpu load.\n           boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n               (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n           // from the right state. If the client provided the checksum for\n           // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n           if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n             // First, prepare to overwrite the partial crc at the end.\n             if (overwriteLastCrc) { // not chunk-aligned on disk\n               // prepare to overwrite last checksum\n               adjustCrcFilePosition();\n             }\n \n             // The CRC was recalculated for the last partial chunk. Update the\n             // CRC by reading the rest of the chunk, then write it out.\n             if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e end) {\n               assert crcBytes !\u003d null;\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    // Drop heartbeat for testing.\n    if (seqno \u003c 0 \u0026\u0026 len \u003d\u003d 0 \u0026\u0026\n        DataNodeFaultInjector.get().dropHeartbeatPacket()) {\n      return 0;\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long now \u003d Time.monotonicNow();\n        setLastSentTime(now);\n        long duration \u003d now - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e end) {\n              assert crcBytes !\u003d null;\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "59388a801514d6af64ef27fbf246d8054f1dcc74": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8722. Optimize datanode writes for small writes and flushes. Contributed by Kihwal Lee\n",
      "commitDate": "14/07/15 12:04 PM",
      "commitName": "59388a801514d6af64ef27fbf246d8054f1dcc74",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "16/06/15 1:40 PM",
      "commitNameOld": "c74517c46bf00af408ed866b6577623cdec02de1",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 27.93,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,290 +1,300 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           // Normally the beginning of an incoming packet is aligned with the\n           // existing data on disk. If the beginning packet data offset is not\n           // checksum chunk aligned, the end of packet will not go beyond the\n           // next chunk boundary.\n           // When a failure-recovery is involved, the client state and the\n           // the datanode state may not exactly agree. I.e. the client may\n           // resend part of data that is already on disk. Correct number of\n           // bytes should be skipped when writing the data and checksum\n           // buffers out to disk.\n           long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n+          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n           boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n           boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n \n-          // Since data is always appended, not overwritten, partial CRC\n-          // recalculation is necessary if the on-disk data is not chunk-\n-          // aligned, regardless of whether the beginning of the data in\n-          // the packet is chunk-aligned.\n-          boolean doPartialCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n+          // If the end of the on-disk data is not chunk-aligned, the last\n+          // checksum needs to be overwritten.\n+          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n+          // If the starting offset of the packat data is at the last chunk\n+          // boundary of the data on disk, the partial checksum recalculation\n+          // can be skipped and the checksum supplied by the client can be used\n+          // instead. This reduces disk reads and cpu load.\n+          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n+              (lastChunkBoundary !\u003d firstByteInBlock);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. If the starting offset is not chunk\n           // aligned, the packet should terminate at or before the next\n           // chunk boundary.\n           if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n             throw new IOException(\"Unexpected packet data length for \"\n                 +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                 + \" sent in an individual packet (data length \u003d \" + len\n                 +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n \n           // If the last portion of the block file is not a full chunk,\n           // then read in pre-existing partial data chunk and recalculate\n           // the checksum so that the checksum calculation can continue\n-          // from the right state.\n+          // from the right state. If the client provided the checksum for\n+          // the whole chunk, this is not necessary.\n           Checksum partialCrc \u003d null;\n-          if (doPartialCrc) {\n+          if (doCrcRecalc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": previous write did not end at the chunk boundary.\"\n                   + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           // The data buffer position where write will begin. If the packet\n           // data and on-disk data have no overlap, this will not be at the\n           // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else {\n             int skip \u003d 0;\n             byte[] crcBytes \u003d null;\n \n-            // First, overwrite the partial crc at the end, if necessary.\n-            if (doPartialCrc) { // not chunk-aligned on disk\n+            // First, prepare to overwrite the partial crc at the end.\n+            if (overwriteLastCrc) { // not chunk-aligned on disk\n+              // prepare to overwrite last checksum\n+              adjustCrcFilePosition();\n+            }\n+\n+            // The CRC was recalculated for the last partial chunk. Update the\n+            // CRC by reading the rest of the chunk, then write it out.\n+            if (doCrcRecalc) {\n               // Calculate new crc for this chunk.\n               int bytesToReadForRecalc \u003d\n                   (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n               if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                 bytesToReadForRecalc \u003d numBytesToDisk;\n               }\n \n               partialCrc.update(dataBuf.array(), startByteToDisk,\n                   bytesToReadForRecalc);\n               byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                   checksumSize);\n               crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n-              // prepare to overwrite last checksum\n-              adjustCrcFilePosition();\n               checksumOut.write(buf);\n               if(LOG.isDebugEnabled()) {\n                 LOG.debug(\"Writing out partial crc for data len \" + len +\n                     \", skip\u003d\" + skip);\n               }\n               skip++; //  For the partial chunk that was just read.\n             }\n \n             // Determine how many checksums need to be skipped up to the last\n             // boundary. The checksum after the boundary was already counted\n             // above. Only count the number of checksums skipped up to the\n             // boundary here.\n-            long lastChunkBoundary \u003d onDiskLen - (onDiskLen%bytesPerChecksum);\n             long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n \n             if (skippedDataBytes \u003e 0) {\n               skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                   ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n             }\n             skip *\u003d checksumSize; // Convert to number of bytes\n \n             // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position() + skip;\n             final int end \u003d offset + checksumLen - skip;\n             // If offset \u003e end, there is no more checksum to write.\n             // I.e. a partial chunk checksum rewrite happened and there is no\n             // more to write after that.\n             if (offset \u003e end) {\n               assert crcBytes !\u003d null;\n               lastCrc \u003d crcBytes;\n             } else {\n               final int remainingBytes \u003d checksumLen - skip;\n               lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                   checksumSize, end);\n               checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n             }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          long lastChunkBoundary \u003d onDiskLen - partialChunkSizeOnDisk;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // If the end of the on-disk data is not chunk-aligned, the last\n          // checksum needs to be overwritten.\n          boolean overwriteLastCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n          // If the starting offset of the packat data is at the last chunk\n          // boundary of the data on disk, the partial checksum recalculation\n          // can be skipped and the checksum supplied by the client can be used\n          // instead. This reduces disk reads and cpu load.\n          boolean doCrcRecalc \u003d overwriteLastCrc \u0026\u0026\n              (lastChunkBoundary !\u003d firstByteInBlock);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state. If the client provided the checksum for\n          // the whole chunk, this is not necessary.\n          Checksum partialCrc \u003d null;\n          if (doCrcRecalc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, prepare to overwrite the partial crc at the end.\n            if (overwriteLastCrc) { // not chunk-aligned on disk\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n            }\n\n            // The CRC was recalculated for the last partial chunk. Update the\n            // CRC by reading the rest of the chunk, then write it out.\n            if (doCrcRecalc) {\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e end) {\n              assert crcBytes !\u003d null;\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "c74517c46bf00af408ed866b6577623cdec02de1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4660. Block corruption can happen during pipeline recovery. Contributed by Kihwal Lee.\n",
      "commitDate": "16/06/15 1:40 PM",
      "commitName": "c74517c46bf00af408ed866b6577623cdec02de1",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "11/06/15 10:12 AM",
      "commitNameOld": "b258b344bb76af6492828201959e36b45f0f75b8",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 5.14,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,228 +1,290 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n-          //finally write to the disk :\n-          \n-          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n-            // prepare to overwrite last checksum\n-            adjustCrcFilePosition();\n+          // Normally the beginning of an incoming packet is aligned with the\n+          // existing data on disk. If the beginning packet data offset is not\n+          // checksum chunk aligned, the end of packet will not go beyond the\n+          // next chunk boundary.\n+          // When a failure-recovery is involved, the client state and the\n+          // the datanode state may not exactly agree. I.e. the client may\n+          // resend part of data that is already on disk. Correct number of\n+          // bytes should be skipped when writing the data and checksum\n+          // buffers out to disk.\n+          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n+          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n+          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n+\n+          // Since data is always appended, not overwritten, partial CRC\n+          // recalculation is necessary if the on-disk data is not chunk-\n+          // aligned, regardless of whether the beginning of the data in\n+          // the packet is chunk-aligned.\n+          boolean doPartialCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n+\n+          // If this is a partial chunk, then verify that this is the only\n+          // chunk in the packet. If the starting offset is not chunk\n+          // aligned, the packet should terminate at or before the next\n+          // chunk boundary.\n+          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n+            throw new IOException(\"Unexpected packet data length for \"\n+                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n+                + \" sent in an individual packet (data length \u003d \" + len\n+                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n           }\n-          \n-          // If this is a partial chunk, then read in pre-existing checksum\n+\n+          // If the last portion of the block file is not a full chunk,\n+          // then read in pre-existing partial data chunk and recalculate\n+          // the checksum so that the checksum calculation can continue\n+          // from the right state.\n           Checksum partialCrc \u003d null;\n-          if (!shouldNotWriteChecksum \u0026\u0026 firstByteInBlock % bytesPerChecksum !\u003d 0) {\n+          if (doPartialCrc) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n-                  + \": bytesPerChecksum\u003d\" + bytesPerChecksum                  \n-                  + \" does not divide firstByteInBlock\u003d\" + firstByteInBlock);\n+                  + \": previous write did not end at the chunk boundary.\"\n+                  + \" onDiskLen\u003d\" + onDiskLen);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n+          // The data buffer position where write will begin. If the packet\n+          // data and on-disk data have no overlap, this will not be at the\n+          // beginning of the buffer.\n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n+          // Actual number of data bytes to write.\n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n-          } else if (partialCrc !\u003d null) {\n-            // If this is a partial chunk, then verify that this is the only\n-            // chunk in the packet. Calculate new crc for this chunk.\n-            if (len \u003e bytesPerChecksum) {\n-              throw new IOException(\"Unexpected packet data length for \"\n-                  +  block + \" from \" + inAddr + \": a partial chunk must be \"\n-                  + \" sent in an individual packet (data length \u003d \" + len\n-                  +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n-            }\n-            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n-            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n-            lastCrc \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n-            checksumOut.write(buf);\n-            if(LOG.isDebugEnabled()) {\n-              LOG.debug(\"Writing out partial crc for data len \" + len);\n-            }\n-            partialCrc \u003d null;\n           } else {\n-            // write checksum\n+            int skip \u003d 0;\n+            byte[] crcBytes \u003d null;\n+\n+            // First, overwrite the partial crc at the end, if necessary.\n+            if (doPartialCrc) { // not chunk-aligned on disk\n+              // Calculate new crc for this chunk.\n+              int bytesToReadForRecalc \u003d\n+                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n+              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n+                bytesToReadForRecalc \u003d numBytesToDisk;\n+              }\n+\n+              partialCrc.update(dataBuf.array(), startByteToDisk,\n+                  bytesToReadForRecalc);\n+              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n+                  checksumSize);\n+              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n+              // prepare to overwrite last checksum\n+              adjustCrcFilePosition();\n+              checksumOut.write(buf);\n+              if(LOG.isDebugEnabled()) {\n+                LOG.debug(\"Writing out partial crc for data len \" + len +\n+                    \", skip\u003d\" + skip);\n+              }\n+              skip++; //  For the partial chunk that was just read.\n+            }\n+\n+            // Determine how many checksums need to be skipped up to the last\n+            // boundary. The checksum after the boundary was already counted\n+            // above. Only count the number of checksums skipped up to the\n+            // boundary here.\n+            long lastChunkBoundary \u003d onDiskLen - (onDiskLen%bytesPerChecksum);\n+            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n+\n+            if (skippedDataBytes \u003e 0) {\n+              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n+                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n+            }\n+            skip *\u003d checksumSize; // Convert to number of bytes\n+\n+            // write the rest of checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n-                checksumBuf.position();\n-            final int end \u003d offset + checksumLen;\n-            lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(), checksumSize,\n-                end);\n-            checksumOut.write(checksumBuf.array(), offset, checksumLen);\n+                checksumBuf.position() + skip;\n+            final int end \u003d offset + checksumLen - skip;\n+            // If offset \u003e end, there is no more checksum to write.\n+            // I.e. a partial chunk checksum rewrite happened and there is no\n+            // more to write after that.\n+            if (offset \u003e end) {\n+              assert crcBytes !\u003d null;\n+              lastCrc \u003d crcBytes;\n+            } else {\n+              final int remainingBytes \u003d checksumLen - skip;\n+              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n+                  checksumSize, end);\n+              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n+            }\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n           datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          // Normally the beginning of an incoming packet is aligned with the\n          // existing data on disk. If the beginning packet data offset is not\n          // checksum chunk aligned, the end of packet will not go beyond the\n          // next chunk boundary.\n          // When a failure-recovery is involved, the client state and the\n          // the datanode state may not exactly agree. I.e. the client may\n          // resend part of data that is already on disk. Correct number of\n          // bytes should be skipped when writing the data and checksum\n          // buffers out to disk.\n          long partialChunkSizeOnDisk \u003d onDiskLen % bytesPerChecksum;\n          boolean alignedOnDisk \u003d partialChunkSizeOnDisk \u003d\u003d 0;\n          boolean alignedInPacket \u003d firstByteInBlock % bytesPerChecksum \u003d\u003d 0;\n\n          // Since data is always appended, not overwritten, partial CRC\n          // recalculation is necessary if the on-disk data is not chunk-\n          // aligned, regardless of whether the beginning of the data in\n          // the packet is chunk-aligned.\n          boolean doPartialCrc \u003d !alignedOnDisk \u0026\u0026 !shouldNotWriteChecksum;\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. If the starting offset is not chunk\n          // aligned, the packet should terminate at or before the next\n          // chunk boundary.\n          if (!alignedInPacket \u0026\u0026 len \u003e bytesPerChecksum) {\n            throw new IOException(\"Unexpected packet data length for \"\n                +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                + \" sent in an individual packet (data length \u003d \" + len\n                +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n          }\n\n          // If the last portion of the block file is not a full chunk,\n          // then read in pre-existing partial data chunk and recalculate\n          // the checksum so that the checksum calculation can continue\n          // from the right state.\n          Checksum partialCrc \u003d null;\n          if (doPartialCrc) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": previous write did not end at the chunk boundary.\"\n                  + \" onDiskLen\u003d\" + onDiskLen);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          // The data buffer position where write will begin. If the packet\n          // data and on-disk data have no overlap, this will not be at the\n          // beginning of the buffer.\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          // Actual number of data bytes to write.\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else {\n            int skip \u003d 0;\n            byte[] crcBytes \u003d null;\n\n            // First, overwrite the partial crc at the end, if necessary.\n            if (doPartialCrc) { // not chunk-aligned on disk\n              // Calculate new crc for this chunk.\n              int bytesToReadForRecalc \u003d\n                  (int)(bytesPerChecksum - partialChunkSizeOnDisk);\n              if (numBytesToDisk \u003c bytesToReadForRecalc) {\n                bytesToReadForRecalc \u003d numBytesToDisk;\n              }\n\n              partialCrc.update(dataBuf.array(), startByteToDisk,\n                  bytesToReadForRecalc);\n              byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc,\n                  checksumSize);\n              crcBytes \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n              // prepare to overwrite last checksum\n              adjustCrcFilePosition();\n              checksumOut.write(buf);\n              if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Writing out partial crc for data len \" + len +\n                    \", skip\u003d\" + skip);\n              }\n              skip++; //  For the partial chunk that was just read.\n            }\n\n            // Determine how many checksums need to be skipped up to the last\n            // boundary. The checksum after the boundary was already counted\n            // above. Only count the number of checksums skipped up to the\n            // boundary here.\n            long lastChunkBoundary \u003d onDiskLen - (onDiskLen%bytesPerChecksum);\n            long skippedDataBytes \u003d lastChunkBoundary - firstByteInBlock;\n\n            if (skippedDataBytes \u003e 0) {\n              skip +\u003d (int)(skippedDataBytes / bytesPerChecksum) +\n                  ((skippedDataBytes % bytesPerChecksum \u003d\u003d 0) ? 0 : 1);\n            }\n            skip *\u003d checksumSize; // Convert to number of bytes\n\n            // write the rest of checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position() + skip;\n            final int end \u003d offset + checksumLen - skip;\n            // If offset \u003e end, there is no more checksum to write.\n            // I.e. a partial chunk checksum rewrite happened and there is no\n            // more to write after that.\n            if (offset \u003e end) {\n              assert crcBytes !\u003d null;\n              lastCrc \u003d crcBytes;\n            } else {\n              final int remainingBytes \u003d checksumLen - skip;\n              lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(),\n                  checksumSize, end);\n              checksumOut.write(checksumBuf.array(), offset, remainingBytes);\n            }\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "02e7dec79d2d4f2b801435343219d8fb53ec931f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7773. Additional metrics in HDFS to be accessed via jmx. Contributed by Anu Engineer.\n",
      "commitDate": "20/02/15 12:37 PM",
      "commitName": "02e7dec79d2d4f2b801435343219d8fb53ec931f",
      "commitAuthor": "cnauroth",
      "commitDateOld": "11/02/15 3:12 PM",
      "commitNameOld": "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 8.89,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,227 +1,228 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n       final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n         throw new IOException(\"Invalid checksum length: received length is \"\n             + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n       if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n \n       if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n         // checksum is missing, need to calculate it\n         checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n         diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n           \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           Checksum partialCrc \u003d null;\n           if (!shouldNotWriteChecksum \u0026\u0026 firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"receivePacket for \" + block \n                   + \": bytesPerChecksum\u003d\" + bytesPerChecksum                  \n                   + \" does not divide firstByteInBlock\u003d\" + firstByteInBlock);\n             }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           final byte[] lastCrc;\n           if (shouldNotWriteChecksum) {\n             lastCrc \u003d null;\n           } else if (partialCrc !\u003d null) {\n             // If this is a partial chunk, then verify that this is the only\n             // chunk in the packet. Calculate new crc for this chunk.\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Unexpected packet data length for \"\n                   +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                   + \" sent in an individual packet (data length \u003d \" + len\n                   +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastCrc \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             // write checksum\n             final int offset \u003d checksumBuf.arrayOffset() +\n                 checksumBuf.position();\n             final int end \u003d offset + checksumLen;\n             lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(), checksumSize,\n                 end);\n             checksumOut.write(checksumBuf.array(), offset, checksumLen);\n           }\n \n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n+          datanode.metrics.incrTotalWriteTime(duration);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          Checksum partialCrc \u003d null;\n          if (!shouldNotWriteChecksum \u0026\u0026 firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": bytesPerChecksum\u003d\" + bytesPerChecksum                  \n                  + \" does not divide firstByteInBlock\u003d\" + firstByteInBlock);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else if (partialCrc !\u003d null) {\n            // If this is a partial chunk, then verify that this is the only\n            // chunk in the packet. Calculate new crc for this chunk.\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Unexpected packet data length for \"\n                  +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                  + \" sent in an individual packet (data length \u003d \" + len\n                  +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastCrc \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            // write checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position();\n            final int end \u003d offset + checksumLen;\n            lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(), checksumSize,\n                end);\n            checksumOut.write(checksumBuf.array(), offset, checksumLen);\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n          datanode.metrics.incrTotalWriteTime(duration);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "463aec11718e47d4aabb86a7a539cb973460aae6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.\n",
      "commitDate": "27/10/14 9:38 AM",
      "commitName": "463aec11718e47d4aabb86a7a539cb973460aae6",
      "commitAuthor": "cnauroth",
      "commitDateOld": "22/10/14 1:38 PM",
      "commitNameOld": "7b0f9bb2583cd9b7274f1e31c173c1c6a7ce467b",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,221 +1,227 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n-    int len \u003d header.getDataLen();\n+    final int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n-    long firstByteInBlock \u003d offsetInBlock;\n+    final long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n-      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n-                                                            checksumSize;\n+      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n+      final int checksumReceivedLen \u003d checksumBuf.capacity();\n \n-      if ( checksumBuf.capacity() !\u003d checksumLen) {\n-        throw new IOException(\"Length of checksums in packet \" +\n-            checksumBuf.capacity() + \" does not match calculated checksum \" +\n-            \"length \" + checksumLen);\n+      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n+        throw new IOException(\"Invalid checksum length: received length is \"\n+            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n       }\n \n-      if (shouldVerifyChecksum()) {\n+      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n+\n+      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n+        // checksum is missing, need to calculate it\n+        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n+        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n+      }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n-      byte[] lastChunkChecksum;\n-      \n+      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n+          \u0026\u0026 streams.isTransientStorage();\n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n-          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n-            LOG.info(\"Packet starts at \" + firstByteInBlock +\n-                     \" for \" + block +\n-                     \" which is not a multiple of bytesPerChecksum \" +\n-                     bytesPerChecksum);\n+          Checksum partialCrc \u003d null;\n+          if (!shouldNotWriteChecksum \u0026\u0026 firstByteInBlock % bytesPerChecksum !\u003d 0) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"receivePacket for \" + block \n+                  + \": bytesPerChecksum\u003d\" + bytesPerChecksum                  \n+                  + \" does not divide firstByteInBlock\u003d\" + firstByteInBlock);\n+            }\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n-            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n+            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n-          // If this is a partial chunk, then verify that this is the only\n-          // chunk in the packet. Calculate new crc for this chunk.\n-          if (partialCrc !\u003d null) {\n+          final byte[] lastCrc;\n+          if (shouldNotWriteChecksum) {\n+            lastCrc \u003d null;\n+          } else if (partialCrc !\u003d null) {\n+            // If this is a partial chunk, then verify that this is the only\n+            // chunk in the packet. Calculate new crc for this chunk.\n             if (len \u003e bytesPerChecksum) {\n-              throw new IOException(\"Got wrong length during writeBlock(\" + \n-                                    block + \") from \" + inAddr + \" \" +\n-                                    \"A packet can have only one partial chunk.\"+\n-                                    \" len \u003d \" + len + \n-                                    \" bytesPerChecksum \" + bytesPerChecksum);\n+              throw new IOException(\"Unexpected packet data length for \"\n+                  +  block + \" from \" + inAddr + \": a partial chunk must be \"\n+                  + \" sent in an individual packet (data length \u003d \" + len\n+                  +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n-            lastChunkChecksum \u003d Arrays.copyOfRange(\n-              buf, buf.length - checksumSize, buf.length\n-            );\n+            lastCrc \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n-            lastChunkChecksum \u003d Arrays.copyOfRange(\n-                checksumBuf.array(),\n-                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n-                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n-            checksumOut.write(checksumBuf.array(),\n-                checksumBuf.arrayOffset() + checksumBuf.position(),\n-                checksumLen);\n+            // write checksum\n+            final int offset \u003d checksumBuf.arrayOffset() +\n+                checksumBuf.position();\n+            final int end \u003d offset + checksumLen;\n+            lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(), checksumSize,\n+                end);\n+            checksumOut.write(checksumBuf.array(), offset, checksumLen);\n           }\n+\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n-          replicaInfo.setLastChecksumAndDataLen(\n-            offsetInBlock, lastChunkChecksum\n-          );\n+          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     /*\n      * Send in-progress responses for the replaceBlock() calls back to caller to\n      * avoid timeouts due to balancer throttling. HDFS-6247\n      */\n     if (isReplaceBlock\n         \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n       BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n           .setStatus(Status.IN_PROGRESS);\n       response.build().writeDelimitedTo(replyOut);\n       replyOut.flush();\n \n       lastResponseTime \u003d Time.monotonicNow();\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    final int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    final long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      final int checksumLen \u003d diskChecksum.getChecksumSize(len);\n      final int checksumReceivedLen \u003d checksumBuf.capacity();\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 checksumReceivedLen !\u003d checksumLen) {\n        throw new IOException(\"Invalid checksum length: received length is \"\n            + checksumReceivedLen + \" but expected length is \" + checksumLen);\n      }\n\n      if (checksumReceivedLen \u003e 0 \u0026\u0026 shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n\n      if (checksumReceivedLen \u003d\u003d 0 \u0026\u0026 !streams.isTransientStorage()) {\n        // checksum is missing, need to calculate it\n        checksumBuf \u003d ByteBuffer.allocate(checksumLen);\n        diskChecksum.calculateChunkedSums(dataBuf, checksumBuf);\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      final boolean shouldNotWriteChecksum \u003d checksumReceivedLen \u003d\u003d 0\n          \u0026\u0026 streams.isTransientStorage();\n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          Checksum partialCrc \u003d null;\n          if (!shouldNotWriteChecksum \u0026\u0026 firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"receivePacket for \" + block \n                  + \": bytesPerChecksum\u003d\" + bytesPerChecksum                  \n                  + \" does not divide firstByteInBlock\u003d\" + firstByteInBlock);\n            }\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            partialCrc \u003d computePartialChunkCrc(onDiskLen, offsetInChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          final byte[] lastCrc;\n          if (shouldNotWriteChecksum) {\n            lastCrc \u003d null;\n          } else if (partialCrc !\u003d null) {\n            // If this is a partial chunk, then verify that this is the only\n            // chunk in the packet. Calculate new crc for this chunk.\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Unexpected packet data length for \"\n                  +  block + \" from \" + inAddr + \": a partial chunk must be \"\n                  + \" sent in an individual packet (data length \u003d \" + len\n                  +  \" \u003e bytesPerChecksum \u003d \" + bytesPerChecksum + \")\");\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastCrc \u003d copyLastChunkChecksum(buf, checksumSize, buf.length);\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            // write checksum\n            final int offset \u003d checksumBuf.arrayOffset() +\n                checksumBuf.position();\n            final int end \u003d offset + checksumLen;\n            lastCrc \u003d copyLastChunkChecksum(checksumBuf.array(), checksumSize,\n                end);\n            checksumOut.write(checksumBuf.array(), offset, checksumLen);\n          }\n\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(offsetInBlock, lastCrc);\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "195961a7c1da86421761162836766b1de07930fd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6247. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (vinayakumarb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617799 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:43 AM",
      "commitName": "195961a7c1da86421761162836766b1de07930fd",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "13/08/14 11:36 AM",
      "commitNameOld": "6554994fab2d8a2a139fb71ed54be144f4057e08",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,221 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n+    /*\n+     * Send in-progress responses for the replaceBlock() calls back to caller to\n+     * avoid timeouts due to balancer throttling. HDFS-6247\n+     */\n+    if (isReplaceBlock\n+        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n+      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n+          .setStatus(Status.IN_PROGRESS);\n+      response.build().writeDelimitedTo(replyOut);\n+      replyOut.flush();\n+\n+      lastResponseTime \u003d Time.monotonicNow();\n+    }\n+\n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "6554994fab2d8a2a139fb71ed54be144f4057e08": {
      "type": "Ybodychange",
      "commitMessage": "Reverted\nMerged revision(s) 1617784 from hadoop/common/trunk:\nHDFS-6847. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (Contributed by Vinayakumar B.)\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617794 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:36 AM",
      "commitName": "6554994fab2d8a2a139fb71ed54be144f4057e08",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "13/08/14 11:06 AM",
      "commitNameOld": "471b1368e2a81b4d9850f0f4d98d31df1451354c",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,221 +1,207 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n-    /*\n-     * Send in-progress responses for the replaceBlock() calls back to caller to\n-     * avoid timeouts due to balancer throttling. HDFS-6247\n-     */\n-    if (isReplaceBlock\n-        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n-      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n-          .setStatus(Status.IN_PROGRESS);\n-      response.build().writeDelimitedTo(replyOut);\n-      replyOut.flush();\n-\n-      lastResponseTime \u003d Time.monotonicNow();\n-    }\n-\n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "471b1368e2a81b4d9850f0f4d98d31df1451354c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6847. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (Contributed by Vinayakumar B.)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617784 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:06 AM",
      "commitName": "471b1368e2a81b4d9850f0f4d98d31df1451354c",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "04/08/14 1:43 AM",
      "commitNameOld": "33518e561368c372bf9254b6b55a9b0c499fbd4d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 9.39,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,221 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n+    /*\n+     * Send in-progress responses for the replaceBlock() calls back to caller to\n+     * avoid timeouts due to balancer throttling. HDFS-6247\n+     */\n+    if (isReplaceBlock\n+        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n+      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n+          .setStatus(Status.IN_PROGRESS);\n+      response.build().writeDelimitedTo(replyOut);\n+      replyOut.flush();\n+\n+      lastResponseTime \u003d Time.monotonicNow();\n+    }\n+\n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    /*\n     * Send in-progress responses for the replaceBlock() calls back to caller to\n     * avoid timeouts due to balancer throttling. HDFS-6247\n     */\n    if (isReplaceBlock\n        \u0026\u0026 (Time.monotonicNow() - lastResponseTime \u003e responseInterval)) {\n      BlockOpResponseProto.Builder response \u003d BlockOpResponseProto.newBuilder()\n          .setStatus(Status.IN_PROGRESS);\n      response.build().writeDelimitedTo(replyOut);\n      replyOut.flush();\n\n      lastResponseTime \u003d Time.monotonicNow();\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "33518e561368c372bf9254b6b55a9b0c499fbd4d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5185. DN fails to startup if one of the data dir is full. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615504 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/14 1:43 AM",
      "commitName": "33518e561368c372bf9254b6b55a9b0c499fbd4d",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "22/07/14 12:41 AM",
      "commitNameOld": "25b0e8471ed744578b2d8e3f0debe5477b268e54",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 13.04,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,207 +1,207 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n           long duration \u003d Time.monotonicNow() - begin;\n           if (duration \u003e datanodeSlowLogThresholdMs) {\n             LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                 + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n           }\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n-        datanode.checkDiskError();\n+        datanode.checkDiskErrorAsync();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskErrorAsync();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": {
      "type": "Ybodychange",
      "commitMessage": "HBASE-6110 adding more slow action log in critical write path (Liang Xie via stack)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/14 12:38 PM",
      "commitName": "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
      "commitAuthor": "Michael Stack",
      "commitDateOld": "12/05/14 12:08 PM",
      "commitNameOld": "e9459baec5a46651c156fbae5f8f3c9cc8325ef0",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,207 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n+        long begin \u003d Time.monotonicNow();\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n+        long duration \u003d Time.monotonicNow() - begin;\n+        if (duration \u003e datanodeSlowLogThresholdMs) {\n+          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n+              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+        }\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n+          long begin \u003d Time.monotonicNow();\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n+          long duration \u003d Time.monotonicNow() - begin;\n+          if (duration \u003e datanodeSlowLogThresholdMs) {\n+            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n+                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+          }\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskError();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        long begin \u003d Time.monotonicNow();\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow BlockReceiver write packet to mirror took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          long begin \u003d Time.monotonicNow();\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n          long duration \u003d Time.monotonicNow() - begin;\n          if (duration \u003e datanodeSlowLogThresholdMs) {\n            LOG.warn(\"Slow BlockReceiver write data to disk cost:\" + duration\n                + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n          }\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "e9459baec5a46651c156fbae5f8f3c9cc8325ef0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5522. Datanode disk error check may be incorrectly skipped. Contributed by Rushabh Shah.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/05/14 12:08 PM",
      "commitName": "e9459baec5a46651c156fbae5f8f3c9cc8325ef0",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "23/04/14 10:05 PM",
      "commitNameOld": "f36f0dde8866e2233dad26b38a8d432d2302a51a",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 18.58,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n-        datanode.checkDiskError(iex);\n+        datanode.checkDiskError();\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError();\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4817.  Make HDFS advisory caching configurable on a per-file basis.  (Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 11:15 AM",
      "commitName": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "21/05/13 6:42 AM",
      "commitNameOld": "98a692fd6361365db4afb9523a5d83ee32774112",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 62.19,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n     if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n       }\n \n       if (shouldVerifyChecksum()) {\n         try {\n           verifyChunks(dataBuf, checksumBuf);\n         } catch (IOException ioe) {\n           // checksum error detected locally. there is no reason to continue.\n           if (responder !\u003d null) {\n             try {\n               ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                   lastPacketInBlock, offsetInBlock,\n                   Status.ERROR_CHECKSUM);\n               // Wait until the responder sends back the response\n               // and interrupt this thread.\n               Thread.sleep(3000);\n             } catch (InterruptedException e) { }\n           }\n           throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n         }\n  \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n-          dropOsCacheBehindWriter(offsetInBlock);\n+          manageWriterOsCache(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskError(iex);\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n     if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n           lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          manageWriterOsCache(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError(iex);\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "98a692fd6361365db4afb9523a5d83ee32774112": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3875. Issue handling checksum errors in write pipeline. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1484808 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/13 6:42 AM",
      "commitName": "98a692fd6361365db4afb9523a5d83ee32774112",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/03/13 11:15 AM",
      "commitNameOld": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 75.77,
      "commitsBetweenForRepo": 469,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,186 +1,195 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // avoid double sync\u0027ing on close\n     if (syncBlock \u0026\u0026 lastPacketInBlock) {\n       this.syncOnClose \u003d false;\n     }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks, unless sync was requested\n-    if (responder !\u003d null \u0026\u0026 !syncBlock) {\n+    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n-          lastPacketInBlock, offsetInBlock);\n+          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // sync block if requested\n       if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n-     }\n+      }\n \n-      /* skip verifying checksum iff this is not the last one in the \n-       * pipeline and clientName is non-null. i.e. Checksum is verified\n-       * on all the datanodes when the data is being written by a \n-       * datanode rather than a client. Whe client is writing the data, \n-       * protocol includes acks and only the last datanode needs to verify \n-       * checksum.\n-       */\n-      if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n-        verifyChunks(dataBuf, checksumBuf);\n+      if (shouldVerifyChecksum()) {\n+        try {\n+          verifyChunks(dataBuf, checksumBuf);\n+        } catch (IOException ioe) {\n+          // checksum error detected locally. there is no reason to continue.\n+          if (responder !\u003d null) {\n+            try {\n+              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n+                  lastPacketInBlock, offsetInBlock,\n+                  Status.ERROR_CHECKSUM);\n+              // Wait until the responder sends back the response\n+              // and interrupt this thread.\n+              Thread.sleep(3000);\n+            } catch (InterruptedException e) { }\n+          }\n+          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n+        }\n+ \n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync if requested\n           flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           dropOsCacheBehindWriter(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskError(iex);\n         throw iex;\n       }\n     }\n \n     // if sync was requested, put in queue for pending acks here\n     // (after the fsync finished)\n-    if (responder !\u003d null \u0026\u0026 syncBlock) {\n+    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n       ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n-          lastPacketInBlock, offsetInBlock);\n+          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock \u0026\u0026 !shouldVerifyChecksum()) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n      }\n\n      if (shouldVerifyChecksum()) {\n        try {\n          verifyChunks(dataBuf, checksumBuf);\n        } catch (IOException ioe) {\n          // checksum error detected locally. there is no reason to continue.\n          if (responder !\u003d null) {\n            try {\n              ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n                  lastPacketInBlock, offsetInBlock,\n                  Status.ERROR_CHECKSUM);\n              // Wait until the responder sends back the response\n              // and interrupt this thread.\n              Thread.sleep(3000);\n            } catch (InterruptedException e) { }\n          }\n          throw new IOException(\"Terminating due to a checksum error.\" + ioe);\n        }\n \n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          dropOsCacheBehindWriter(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError(iex);\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 (syncBlock || shouldVerifyChecksum())) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock, Status.SUCCESS);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "1e7010cf38115604d6fa3aa5728362c86644e66a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3979. For hsync, datanode should wait for the local sync to complete before sending ack. Contributed by Lars Hofhansl\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406382 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/11/12 2:34 PM",
      "commitName": "1e7010cf38115604d6fa3aa5728362c86644e66a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 8.97,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,177 +1,186 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n-    // make sure the block gets sync\u0027ed upon close\n-    this.syncOnClose |\u003d syncBlock \u0026\u0026 lastPacketInBlock;\n+    // avoid double sync\u0027ing on close\n+    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n+      this.syncOnClose \u003d false;\n+    }\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n-    // put in queue for pending acks\n-    if (responder !\u003d null) {\n-      ((PacketResponder)responder.getRunnable()).enqueue(seqno,\n-                                      lastPacketInBlock, offsetInBlock); \n-    }  \n+    // put in queue for pending acks, unless sync was requested\n+    if (responder !\u003d null \u0026\u0026 !syncBlock) {\n+      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n+          lastPacketInBlock, offsetInBlock);\n+    }\n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n-      // flush unless close() would flush anyway\n-      if (syncBlock \u0026\u0026 !lastPacketInBlock) {\n+      // sync block if requested\n+      if (syncBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n      }\n \n       /* skip verifying checksum iff this is not the last one in the \n        * pipeline and clientName is non-null. i.e. Checksum is verified\n        * on all the datanodes when the data is being written by a \n        * datanode rather than a client. Whe client is writing the data, \n        * protocol includes acks and only the last datanode needs to verify \n        * checksum.\n        */\n       if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n         verifyChunks(dataBuf, checksumBuf);\n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n                      \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n-          /// flush entire packet, sync unless close() will sync\n-          flushOrSync(syncBlock \u0026\u0026 !lastPacketInBlock);\n+          /// flush entire packet, sync if requested\n+          flushOrSync(syncBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           dropOsCacheBehindWriter(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskError(iex);\n         throw iex;\n       }\n     }\n \n+    // if sync was requested, put in queue for pending acks here\n+    // (after the fsync finished)\n+    if (responder !\u003d null \u0026\u0026 syncBlock) {\n+      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n+          lastPacketInBlock, offsetInBlock);\n+    }\n+\n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // avoid double sync\u0027ing on close\n    if (syncBlock \u0026\u0026 lastPacketInBlock) {\n      this.syncOnClose \u003d false;\n    }\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks, unless sync was requested\n    if (responder !\u003d null \u0026\u0026 !syncBlock) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock);\n    }\n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // sync block if requested\n      if (syncBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n     }\n\n      /* skip verifying checksum iff this is not the last one in the \n       * pipeline and clientName is non-null. i.e. Checksum is verified\n       * on all the datanodes when the data is being written by a \n       * datanode rather than a client. Whe client is writing the data, \n       * protocol includes acks and only the last datanode needs to verify \n       * checksum.\n       */\n      if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n        verifyChunks(dataBuf, checksumBuf);\n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync if requested\n          flushOrSync(syncBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          dropOsCacheBehindWriter(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError(iex);\n        throw iex;\n      }\n    }\n\n    // if sync was requested, put in queue for pending acks here\n    // (after the fsync finished)\n    if (responder !\u003d null \u0026\u0026 syncBlock) {\n      ((PacketResponder) responder.getRunnable()).enqueue(seqno,\n          lastPacketInBlock, offsetInBlock);\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 2:31 PM",
      "commitNameOld": "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 80.07,
      "commitsBetweenForRepo": 496,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,177 +1,177 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     packetReceiver.receiveNextPacket(in);\n \n     PacketHeader header \u003d packetReceiver.getHeader();\n     if (LOG.isDebugEnabled()){\n       LOG.debug(\"Receiving one packet for block \" + block +\n                 \": \" + header);\n     }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     long offsetInBlock \u003d header.getOffsetInBlock();\n     long seqno \u003d header.getSeqno();\n     boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n     int len \u003d header.getDataLen();\n     boolean syncBlock \u003d header.getSyncBlock();\n \n     // make sure the block gets sync\u0027ed upon close\n     this.syncOnClose |\u003d syncBlock \u0026\u0026 lastPacketInBlock;\n \n     // update received bytes\n     long firstByteInBlock \u003d offsetInBlock;\n     offsetInBlock +\u003d len;\n     if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n       replicaInfo.setNumBytes(offsetInBlock);\n     }\n     \n     // put in queue for pending acks\n     if (responder !\u003d null) {\n       ((PacketResponder)responder.getRunnable()).enqueue(seqno,\n                                       lastPacketInBlock, offsetInBlock); \n     }  \n \n     //First write the packet to the mirror:\n     if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n       try {\n         packetReceiver.mirrorPacketTo(mirrorOut);\n         mirrorOut.flush();\n       } catch (IOException e) {\n         handleMirrorOutError(e);\n       }\n     }\n     \n     ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n     ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n     \n     if (lastPacketInBlock || len \u003d\u003d 0) {\n       if(LOG.isDebugEnabled()) {\n         LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n       }\n       // flush unless close() would flush anyway\n       if (syncBlock \u0026\u0026 !lastPacketInBlock) {\n         flushOrSync(true);\n       }\n     } else {\n       int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                             checksumSize;\n \n       if ( checksumBuf.capacity() !\u003d checksumLen) {\n         throw new IOException(\"Length of checksums in packet \" +\n             checksumBuf.capacity() + \" does not match calculated checksum \" +\n             \"length \" + checksumLen);\n      }\n \n       /* skip verifying checksum iff this is not the last one in the \n        * pipeline and clientName is non-null. i.e. Checksum is verified\n        * on all the datanodes when the data is being written by a \n        * datanode rather than a client. Whe client is writing the data, \n        * protocol includes acks and only the last datanode needs to verify \n        * checksum.\n        */\n       if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n         verifyChunks(dataBuf, checksumBuf);\n         if (needsChecksumTranslation) {\n           // overwrite the checksums in the packet buffer with the\n           // appropriate polynomial for the disk storage.\n           translateChunks(dataBuf, checksumBuf);\n         }\n       }\n       \n       // by this point, the data in the buffer uses the disk checksum\n \n       byte[] lastChunkChecksum;\n       \n       try {\n         long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n         if (onDiskLen\u003coffsetInBlock) {\n           //finally write to the disk :\n           \n           if (onDiskLen % bytesPerChecksum !\u003d 0) { \n             // prepare to overwrite last checksum\n             adjustCrcFilePosition();\n           }\n           \n           // If this is a partial chunk, then read in pre-existing checksum\n           if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n             LOG.info(\"Packet starts at \" + firstByteInBlock +\n-                     \" for block \" + block +\n+                     \" for \" + block +\n                      \" which is not a multiple of bytesPerChecksum \" +\n                      bytesPerChecksum);\n             long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                 onDiskLen / bytesPerChecksum * checksumSize;\n             computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n           }\n \n           int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n               + dataBuf.arrayOffset() + dataBuf.position();\n \n           int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n           \n           // Write data to disk.\n           out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n \n           // If this is a partial chunk, then verify that this is the only\n           // chunk in the packet. Calculate new crc for this chunk.\n           if (partialCrc !\u003d null) {\n             if (len \u003e bytesPerChecksum) {\n               throw new IOException(\"Got wrong length during writeBlock(\" + \n                                     block + \") from \" + inAddr + \" \" +\n                                     \"A packet can have only one partial chunk.\"+\n                                     \" len \u003d \" + len + \n                                     \" bytesPerChecksum \" + bytesPerChecksum);\n             }\n             partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n             byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n               buf, buf.length - checksumSize, buf.length\n             );\n             checksumOut.write(buf);\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Writing out partial crc for data len \" + len);\n             }\n             partialCrc \u003d null;\n           } else {\n             lastChunkChecksum \u003d Arrays.copyOfRange(\n                 checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                 checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n             checksumOut.write(checksumBuf.array(),\n                 checksumBuf.arrayOffset() + checksumBuf.position(),\n                 checksumLen);\n           }\n           /// flush entire packet, sync unless close() will sync\n           flushOrSync(syncBlock \u0026\u0026 !lastPacketInBlock);\n           \n           replicaInfo.setLastChecksumAndDataLen(\n             offsetInBlock, lastChunkChecksum\n           );\n \n           datanode.metrics.incrBytesWritten(len);\n \n           dropOsCacheBehindWriter(offsetInBlock);\n         }\n       } catch (IOException iex) {\n         datanode.checkDiskError(iex);\n         throw iex;\n       }\n     }\n \n     if (throttler !\u003d null) { // throttle I/O\n       throttler.throttle(len);\n     }\n     \n     return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // make sure the block gets sync\u0027ed upon close\n    this.syncOnClose |\u003d syncBlock \u0026\u0026 lastPacketInBlock;\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks\n    if (responder !\u003d null) {\n      ((PacketResponder)responder.getRunnable()).enqueue(seqno,\n                                      lastPacketInBlock, offsetInBlock); \n    }  \n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // flush unless close() would flush anyway\n      if (syncBlock \u0026\u0026 !lastPacketInBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n     }\n\n      /* skip verifying checksum iff this is not the last one in the \n       * pipeline and clientName is non-null. i.e. Checksum is verified\n       * on all the datanodes when the data is being written by a \n       * datanode rather than a client. Whe client is writing the data, \n       * protocol includes acks and only the last datanode needs to verify \n       * checksum.\n       */\n      if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n        verifyChunks(dataBuf, checksumBuf);\n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync unless close() will sync\n          flushOrSync(syncBlock \u0026\u0026 !lastPacketInBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          dropOsCacheBehindWriter(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError(iex);\n        throw iex;\n      }\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3721. hsync support broke wire compatibility. Contributed by Todd Lipcon and Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371495 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 2:31 PM",
      "commitName": "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 24.77,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,177 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n-    readNextPacket();\n+    packetReceiver.receiveNextPacket(in);\n \n-    buf.mark();\n-    PacketHeader header \u003d new PacketHeader();\n-    header.readFields(buf);\n-    int endOfHeader \u003d buf.position();\n-    buf.reset();\n+    PacketHeader header \u003d packetReceiver.getHeader();\n+    if (LOG.isDebugEnabled()){\n+      LOG.debug(\"Receiving one packet for block \" + block +\n+                \": \" + header);\n+    }\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n-    return receivePacket(\n-      header.getOffsetInBlock(),\n-      header.getSeqno(),\n-      header.isLastPacketInBlock(),\n-      header.getDataLen(),\n-      header.getSyncBlock(),\n-      endOfHeader);\n+    long offsetInBlock \u003d header.getOffsetInBlock();\n+    long seqno \u003d header.getSeqno();\n+    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n+    int len \u003d header.getDataLen();\n+    boolean syncBlock \u003d header.getSyncBlock();\n+\n+    // make sure the block gets sync\u0027ed upon close\n+    this.syncOnClose |\u003d syncBlock \u0026\u0026 lastPacketInBlock;\n+\n+    // update received bytes\n+    long firstByteInBlock \u003d offsetInBlock;\n+    offsetInBlock +\u003d len;\n+    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n+      replicaInfo.setNumBytes(offsetInBlock);\n+    }\n+    \n+    // put in queue for pending acks\n+    if (responder !\u003d null) {\n+      ((PacketResponder)responder.getRunnable()).enqueue(seqno,\n+                                      lastPacketInBlock, offsetInBlock); \n+    }  \n+\n+    //First write the packet to the mirror:\n+    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n+      try {\n+        packetReceiver.mirrorPacketTo(mirrorOut);\n+        mirrorOut.flush();\n+      } catch (IOException e) {\n+        handleMirrorOutError(e);\n+      }\n+    }\n+    \n+    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n+    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n+    \n+    if (lastPacketInBlock || len \u003d\u003d 0) {\n+      if(LOG.isDebugEnabled()) {\n+        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n+      }\n+      // flush unless close() would flush anyway\n+      if (syncBlock \u0026\u0026 !lastPacketInBlock) {\n+        flushOrSync(true);\n+      }\n+    } else {\n+      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n+                                                            checksumSize;\n+\n+      if ( checksumBuf.capacity() !\u003d checksumLen) {\n+        throw new IOException(\"Length of checksums in packet \" +\n+            checksumBuf.capacity() + \" does not match calculated checksum \" +\n+            \"length \" + checksumLen);\n+     }\n+\n+      /* skip verifying checksum iff this is not the last one in the \n+       * pipeline and clientName is non-null. i.e. Checksum is verified\n+       * on all the datanodes when the data is being written by a \n+       * datanode rather than a client. Whe client is writing the data, \n+       * protocol includes acks and only the last datanode needs to verify \n+       * checksum.\n+       */\n+      if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n+        verifyChunks(dataBuf, checksumBuf);\n+        if (needsChecksumTranslation) {\n+          // overwrite the checksums in the packet buffer with the\n+          // appropriate polynomial for the disk storage.\n+          translateChunks(dataBuf, checksumBuf);\n+        }\n+      }\n+      \n+      // by this point, the data in the buffer uses the disk checksum\n+\n+      byte[] lastChunkChecksum;\n+      \n+      try {\n+        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n+        if (onDiskLen\u003coffsetInBlock) {\n+          //finally write to the disk :\n+          \n+          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n+            // prepare to overwrite last checksum\n+            adjustCrcFilePosition();\n+          }\n+          \n+          // If this is a partial chunk, then read in pre-existing checksum\n+          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n+            LOG.info(\"Packet starts at \" + firstByteInBlock +\n+                     \" for block \" + block +\n+                     \" which is not a multiple of bytesPerChecksum \" +\n+                     bytesPerChecksum);\n+            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n+                onDiskLen / bytesPerChecksum * checksumSize;\n+            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n+          }\n+\n+          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n+              + dataBuf.arrayOffset() + dataBuf.position();\n+\n+          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n+          \n+          // Write data to disk.\n+          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n+\n+          // If this is a partial chunk, then verify that this is the only\n+          // chunk in the packet. Calculate new crc for this chunk.\n+          if (partialCrc !\u003d null) {\n+            if (len \u003e bytesPerChecksum) {\n+              throw new IOException(\"Got wrong length during writeBlock(\" + \n+                                    block + \") from \" + inAddr + \" \" +\n+                                    \"A packet can have only one partial chunk.\"+\n+                                    \" len \u003d \" + len + \n+                                    \" bytesPerChecksum \" + bytesPerChecksum);\n+            }\n+            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n+            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n+            lastChunkChecksum \u003d Arrays.copyOfRange(\n+              buf, buf.length - checksumSize, buf.length\n+            );\n+            checksumOut.write(buf);\n+            if(LOG.isDebugEnabled()) {\n+              LOG.debug(\"Writing out partial crc for data len \" + len);\n+            }\n+            partialCrc \u003d null;\n+          } else {\n+            lastChunkChecksum \u003d Arrays.copyOfRange(\n+                checksumBuf.array(),\n+                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n+                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n+            checksumOut.write(checksumBuf.array(),\n+                checksumBuf.arrayOffset() + checksumBuf.position(),\n+                checksumLen);\n+          }\n+          /// flush entire packet, sync unless close() will sync\n+          flushOrSync(syncBlock \u0026\u0026 !lastPacketInBlock);\n+          \n+          replicaInfo.setLastChecksumAndDataLen(\n+            offsetInBlock, lastChunkChecksum\n+          );\n+\n+          datanode.metrics.incrBytesWritten(len);\n+\n+          dropOsCacheBehindWriter(offsetInBlock);\n+        }\n+      } catch (IOException iex) {\n+        datanode.checkDiskError(iex);\n+        throw iex;\n+      }\n+    }\n+\n+    if (throttler !\u003d null) { // throttle I/O\n+      throttler.throttle(len);\n+    }\n+    \n+    return lastPacketInBlock?-1:len;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    packetReceiver.receiveNextPacket(in);\n\n    PacketHeader header \u003d packetReceiver.getHeader();\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Receiving one packet for block \" + block +\n                \": \" + header);\n    }\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    long offsetInBlock \u003d header.getOffsetInBlock();\n    long seqno \u003d header.getSeqno();\n    boolean lastPacketInBlock \u003d header.isLastPacketInBlock();\n    int len \u003d header.getDataLen();\n    boolean syncBlock \u003d header.getSyncBlock();\n\n    // make sure the block gets sync\u0027ed upon close\n    this.syncOnClose |\u003d syncBlock \u0026\u0026 lastPacketInBlock;\n\n    // update received bytes\n    long firstByteInBlock \u003d offsetInBlock;\n    offsetInBlock +\u003d len;\n    if (replicaInfo.getNumBytes() \u003c offsetInBlock) {\n      replicaInfo.setNumBytes(offsetInBlock);\n    }\n    \n    // put in queue for pending acks\n    if (responder !\u003d null) {\n      ((PacketResponder)responder.getRunnable()).enqueue(seqno,\n                                      lastPacketInBlock, offsetInBlock); \n    }  \n\n    //First write the packet to the mirror:\n    if (mirrorOut !\u003d null \u0026\u0026 !mirrorError) {\n      try {\n        packetReceiver.mirrorPacketTo(mirrorOut);\n        mirrorOut.flush();\n      } catch (IOException e) {\n        handleMirrorOutError(e);\n      }\n    }\n    \n    ByteBuffer dataBuf \u003d packetReceiver.getDataSlice();\n    ByteBuffer checksumBuf \u003d packetReceiver.getChecksumSlice();\n    \n    if (lastPacketInBlock || len \u003d\u003d 0) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Receiving an empty packet or the end of the block \" + block);\n      }\n      // flush unless close() would flush anyway\n      if (syncBlock \u0026\u0026 !lastPacketInBlock) {\n        flushOrSync(true);\n      }\n    } else {\n      int checksumLen \u003d ((len + bytesPerChecksum - 1)/bytesPerChecksum)*\n                                                            checksumSize;\n\n      if ( checksumBuf.capacity() !\u003d checksumLen) {\n        throw new IOException(\"Length of checksums in packet \" +\n            checksumBuf.capacity() + \" does not match calculated checksum \" +\n            \"length \" + checksumLen);\n     }\n\n      /* skip verifying checksum iff this is not the last one in the \n       * pipeline and clientName is non-null. i.e. Checksum is verified\n       * on all the datanodes when the data is being written by a \n       * datanode rather than a client. Whe client is writing the data, \n       * protocol includes acks and only the last datanode needs to verify \n       * checksum.\n       */\n      if (mirrorOut \u003d\u003d null || isDatanode || needsChecksumTranslation) {\n        verifyChunks(dataBuf, checksumBuf);\n        if (needsChecksumTranslation) {\n          // overwrite the checksums in the packet buffer with the\n          // appropriate polynomial for the disk storage.\n          translateChunks(dataBuf, checksumBuf);\n        }\n      }\n      \n      // by this point, the data in the buffer uses the disk checksum\n\n      byte[] lastChunkChecksum;\n      \n      try {\n        long onDiskLen \u003d replicaInfo.getBytesOnDisk();\n        if (onDiskLen\u003coffsetInBlock) {\n          //finally write to the disk :\n          \n          if (onDiskLen % bytesPerChecksum !\u003d 0) { \n            // prepare to overwrite last checksum\n            adjustCrcFilePosition();\n          }\n          \n          // If this is a partial chunk, then read in pre-existing checksum\n          if (firstByteInBlock % bytesPerChecksum !\u003d 0) {\n            LOG.info(\"Packet starts at \" + firstByteInBlock +\n                     \" for block \" + block +\n                     \" which is not a multiple of bytesPerChecksum \" +\n                     bytesPerChecksum);\n            long offsetInChecksum \u003d BlockMetadataHeader.getHeaderSize() +\n                onDiskLen / bytesPerChecksum * checksumSize;\n            computePartialChunkCrc(onDiskLen, offsetInChecksum, bytesPerChecksum);\n          }\n\n          int startByteToDisk \u003d (int)(onDiskLen-firstByteInBlock) \n              + dataBuf.arrayOffset() + dataBuf.position();\n\n          int numBytesToDisk \u003d (int)(offsetInBlock-onDiskLen);\n          \n          // Write data to disk.\n          out.write(dataBuf.array(), startByteToDisk, numBytesToDisk);\n\n          // If this is a partial chunk, then verify that this is the only\n          // chunk in the packet. Calculate new crc for this chunk.\n          if (partialCrc !\u003d null) {\n            if (len \u003e bytesPerChecksum) {\n              throw new IOException(\"Got wrong length during writeBlock(\" + \n                                    block + \") from \" + inAddr + \" \" +\n                                    \"A packet can have only one partial chunk.\"+\n                                    \" len \u003d \" + len + \n                                    \" bytesPerChecksum \" + bytesPerChecksum);\n            }\n            partialCrc.update(dataBuf.array(), startByteToDisk, numBytesToDisk);\n            byte[] buf \u003d FSOutputSummer.convertToByteStream(partialCrc, checksumSize);\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n              buf, buf.length - checksumSize, buf.length\n            );\n            checksumOut.write(buf);\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Writing out partial crc for data len \" + len);\n            }\n            partialCrc \u003d null;\n          } else {\n            lastChunkChecksum \u003d Arrays.copyOfRange(\n                checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen - checksumSize,\n                checksumBuf.arrayOffset() + checksumBuf.position() + checksumLen);\n            checksumOut.write(checksumBuf.array(),\n                checksumBuf.arrayOffset() + checksumBuf.position(),\n                checksumLen);\n          }\n          /// flush entire packet, sync unless close() will sync\n          flushOrSync(syncBlock \u0026\u0026 !lastPacketInBlock);\n          \n          replicaInfo.setLastChecksumAndDataLen(\n            offsetInBlock, lastChunkChecksum\n          );\n\n          datanode.metrics.incrBytesWritten(len);\n\n          dropOsCacheBehindWriter(offsetInBlock);\n        }\n      } catch (IOException iex) {\n        datanode.checkDiskError(iex);\n        throw iex;\n      }\n    }\n\n    if (throttler !\u003d null) { // throttle I/O\n      throttler.throttle(len);\n    }\n    \n    return lastPacketInBlock?-1:len;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "83cf475050dba27e72b4e399491638c670621175": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-744. Support hsync in HDFS. Contributed by Lars Hofhans\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344419 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/12 12:10 PM",
      "commitName": "83cf475050dba27e72b4e399491638c670621175",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "28/03/12 1:37 PM",
      "commitNameOld": "99a68a14237b4cd1936ba5e9468d25d35dad594c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 62.94,
      "commitsBetweenForRepo": 450,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   private int receivePacket() throws IOException {\n     // read the next packet\n     readNextPacket();\n \n     buf.mark();\n     PacketHeader header \u003d new PacketHeader();\n     header.readFields(buf);\n     int endOfHeader \u003d buf.position();\n     buf.reset();\n \n     // Sanity check the header\n     if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n       throw new IOException(\"Received an out-of-sequence packet for \" + block + \n           \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n           \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n     }\n     if (header.getDataLen() \u003c 0) {\n       throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                             \") from \" + inAddr + \" at offset \" + \n                             header.getOffsetInBlock() + \": \" +\n                             header.getDataLen()); \n     }\n \n     return receivePacket(\n       header.getOffsetInBlock(),\n       header.getSeqno(),\n       header.isLastPacketInBlock(),\n-      header.getDataLen(), endOfHeader);\n+      header.getDataLen(),\n+      header.getSyncBlock(),\n+      endOfHeader);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    readNextPacket();\n\n    buf.mark();\n    PacketHeader header \u003d new PacketHeader();\n    header.readFields(buf);\n    int endOfHeader \u003d buf.position();\n    buf.reset();\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    return receivePacket(\n      header.getOffsetInBlock(),\n      header.getSeqno(),\n      header.isLastPacketInBlock(),\n      header.getDataLen(),\n      header.getSyncBlock(),\n      endOfHeader);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    readNextPacket();\n\n    buf.mark();\n    PacketHeader header \u003d new PacketHeader();\n    header.readFields(buf);\n    int endOfHeader \u003d buf.position();\n    buf.reset();\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    return receivePacket(\n      header.getOffsetInBlock(),\n      header.getSeqno(),\n      header.isLastPacketInBlock(),\n      header.getDataLen(), endOfHeader);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    readNextPacket();\n\n    buf.mark();\n    PacketHeader header \u003d new PacketHeader();\n    header.readFields(buf);\n    int endOfHeader \u003d buf.position();\n    buf.reset();\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    return receivePacket(\n      header.getOffsetInBlock(),\n      header.getSeqno(),\n      header.isLastPacketInBlock(),\n      header.getDataLen(), endOfHeader);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,29 @@\n+  private int receivePacket() throws IOException {\n+    // read the next packet\n+    readNextPacket();\n+\n+    buf.mark();\n+    PacketHeader header \u003d new PacketHeader();\n+    header.readFields(buf);\n+    int endOfHeader \u003d buf.position();\n+    buf.reset();\n+\n+    // Sanity check the header\n+    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n+      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n+          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n+          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n+    }\n+    if (header.getDataLen() \u003c 0) {\n+      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n+                            \") from \" + inAddr + \" at offset \" + \n+                            header.getOffsetInBlock() + \": \" +\n+                            header.getDataLen()); \n+    }\n+\n+    return receivePacket(\n+      header.getOffsetInBlock(),\n+      header.getSeqno(),\n+      header.isLastPacketInBlock(),\n+      header.getDataLen(), endOfHeader);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int receivePacket() throws IOException {\n    // read the next packet\n    readNextPacket();\n\n    buf.mark();\n    PacketHeader header \u003d new PacketHeader();\n    header.readFields(buf);\n    int endOfHeader \u003d buf.position();\n    buf.reset();\n\n    // Sanity check the header\n    if (header.getOffsetInBlock() \u003e replicaInfo.getNumBytes()) {\n      throw new IOException(\"Received an out-of-sequence packet for \" + block + \n          \"from \" + inAddr + \" at offset \" + header.getOffsetInBlock() +\n          \". Expecting packet starting at \" + replicaInfo.getNumBytes());\n    }\n    if (header.getDataLen() \u003c 0) {\n      throw new IOException(\"Got wrong length during writeBlock(\" + block + \n                            \") from \" + inAddr + \" at offset \" + \n                            header.getOffsetInBlock() + \": \" +\n                            header.getDataLen()); \n    }\n\n    return receivePacket(\n      header.getOffsetInBlock(),\n      header.getSeqno(),\n      header.isLastPacketInBlock(),\n      header.getDataLen(), endOfHeader);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java"
    }
  }
}