{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MRAppMaster.java",
  "functionName": "serviceStart",
  "functionId": "serviceStart",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
  "functionStartLine": 1028,
  "functionEndLine": 1040,
  "numCommitsSeen": 181,
  "timeTaken": 11296,
  "changeHistory": [
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
    "cce71dceef9e82d31fe8ec59648b2a4a50c8869a",
    "fbb7d6bcbb887ce52ab1e9d5a1fed67a7f8a4be8",
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
    "e8a31f2e1c34514fba2f480e8db652f6e2ed65d8",
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602",
    "8d569c2220236551d5c95e2ebdaaea52eebe37e6",
    "6015e9594180f157472a88030c85c5599fdc289c",
    "0ab1f90d40352d4daad8efd21eda0a87dec55cf9",
    "1c1ebc1553650ac8e4486faf21f0d95150f607ad",
    "0928502029ef141759008997335ea2cd836a7154",
    "6a1c41111edcdc58c846fc50e53554fbba230171",
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
    "42d1eaf237ef0a3a30c061888d35329b2a2e1453",
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58",
    "47a381e306877750b5a3ce5d76e0a5ff652ec188",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
    "312a7e71001d55f88781e56b331ab1b40a72a980",
    "61900651b1b85cf235e01142acf2a51727fc5537",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": "Ybodychange",
    "cce71dceef9e82d31fe8ec59648b2a4a50c8869a": "Ybodychange",
    "fbb7d6bcbb887ce52ab1e9d5a1fed67a7f8a4be8": "Ybodychange",
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2": "Ybodychange",
    "e8a31f2e1c34514fba2f480e8db652f6e2ed65d8": "Ybodychange",
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602": "Ybodychange",
    "8d569c2220236551d5c95e2ebdaaea52eebe37e6": "Ybodychange",
    "6015e9594180f157472a88030c85c5599fdc289c": "Ybodychange",
    "0ab1f90d40352d4daad8efd21eda0a87dec55cf9": "Ybodychange",
    "1c1ebc1553650ac8e4486faf21f0d95150f607ad": "Ybodychange",
    "0928502029ef141759008997335ea2cd836a7154": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "6a1c41111edcdc58c846fc50e53554fbba230171": "Ybodychange",
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403": "Ybodychange",
    "42d1eaf237ef0a3a30c061888d35329b2a2e1453": "Ybodychange",
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58": "Ybodychange",
    "47a381e306877750b5a3ce5d76e0a5ff652ec188": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": "Ybodychange",
    "312a7e71001d55f88781e56b331ab1b40a72a980": "Ybodychange",
    "61900651b1b85cf235e01142acf2a51727fc5537": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15254. Correct the wrong word spelling \u0027intialize\u0027. Contributed by fang zhenyi.\n",
      "commitDate": "24/02/18 2:41 PM",
      "commitName": "2fa7963c3d8cdfc65f90efabc6fe51a160be5c78",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "25/01/18 4:11 PM",
      "commitNameOld": "cc10852252c2d69294eabc68bd032cc630a53b18",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 29.94,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n     cleanUpPreviousJobOutput();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort(), appSubmitTime)));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString(), appSubmitTime)));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n-      // create a job event for job intialization\n+      // create a job event for job initialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // finally set the job classloader\n     MRApps.setClassLoader(jobClassLoader, getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n    cleanUpPreviousJobOutput();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort(), appSubmitTime)));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString(), appSubmitTime)));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job initialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "cce71dceef9e82d31fe8ec59648b2a4a50c8869a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6984. MR AM to clean up temporary files from previous attempt in case of no recovery. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "19/01/18 12:56 PM",
      "commitName": "cce71dceef9e82d31fe8ec59648b2a4a50c8869a",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "02/10/17 8:14 PM",
      "commitNameOld": "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 108.74,
      "commitsBetweenForRepo": 750,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n+    cleanUpPreviousJobOutput();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort(), appSubmitTime)));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString(), appSubmitTime)));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // finally set the job classloader\n     MRApps.setClassLoader(jobClassLoader, getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n    cleanUpPreviousJobOutput();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort(), appSubmitTime)));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString(), appSubmitTime)));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "fbb7d6bcbb887ce52ab1e9d5a1fed67a7f8a4be8": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"MAPREDUCE-5875. Make Counter limits consistent across JobClient, MRAppMaster, and YarnChild. (Gera Shegalov via kasha)\"\n\nThis reverts commit e8a31f2e1c34514fba2f480e8db652f6e2ed65d8.\n",
      "commitDate": "31/07/17 2:09 PM",
      "commitName": "fbb7d6bcbb887ce52ab1e9d5a1fed67a7f8a4be8",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/06/17 3:21 PM",
      "commitNameOld": "6ed54f3439ea9c7af6bf129ebe1938380febb5e2",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 47.95,
      "commitsBetweenForRepo": 227,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,88 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort(), appSubmitTime)));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString(), appSubmitTime)));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // finally set the job classloader\n     MRApps.setClassLoader(jobClassLoader, getConfig());\n-    // set job classloader if configured\n-    Limits.init(getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort(), appSubmitTime)));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString(), appSubmitTime)));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "bf70c5ae2824a9139c1aa9d7c14020018881cec2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6259. IllegalArgumentException due to missing job submit time. Contributed by zhihai xu\n",
      "commitDate": "04/05/15 1:39 PM",
      "commitName": "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "21/04/15 1:57 PM",
      "commitNameOld": "725eb52ddc647074f0bf1cc73c3029f1352f51d5",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 12.99,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n-                  .getNodeManagerHttpPort())));\n+                  .getNodeManagerHttpPort(), appSubmitTime)));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n-                    : this.forcedState.toString())));\n+                    : this.forcedState.toString(), appSubmitTime)));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // finally set the job classloader\n     MRApps.setClassLoader(jobClassLoader, getConfig());\n     // set job classloader if configured\n     Limits.init(getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort(), appSubmitTime)));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString(), appSubmitTime)));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n    // set job classloader if configured\n    Limits.init(getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "e8a31f2e1c34514fba2f480e8db652f6e2ed65d8": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5875. Make Counter limits consistent across JobClient, MRAppMaster, and YarnChild. (Gera Shegalov via kasha)\n",
      "commitDate": "11/10/14 10:49 PM",
      "commitName": "e8a31f2e1c34514fba2f480e8db652f6e2ed65d8",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/09/14 8:20 AM",
      "commitNameOld": "7039b98e1c459e9e0d8caa28cdaa2868e2bde2eb",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 19.6,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,90 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString())));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // finally set the job classloader\n     MRApps.setClassLoader(jobClassLoader, getConfig());\n+    // set job classloader if configured\n+    Limits.init(getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString())));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n    // set job classloader if configured\n    Limits.init(getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5957. AM throws ClassNotFoundException with job classloader enabled if custom output format/committer is used. Contributed by Sangjin Lee\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612358 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 10:54 AM",
      "commitName": "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "11/07/14 1:45 AM",
      "commitNameOld": "64306aa1b5f280e5ffaf2186bef706acd93b1412",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.38,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString())));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n       // If job is still not initialized, an error happened during\n       // initialization. Must complete starting all of the services so failure\n       // events can be processed.\n       initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n-    // set job classloader if configured\n-    MRApps.setJobClassLoader(getConfig());\n+    // finally set the job classloader\n+    MRApps.setClassLoader(jobClassLoader, getConfig());\n \n     if (initFailed) {\n       JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n       jobEventDispatcher.handle(initFailedEvent);\n     } else {\n       // All components have started, start the job.\n       startJobs();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString())));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // finally set the job classloader\n    MRApps.setClassLoader(jobClassLoader, getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "8d569c2220236551d5c95e2ebdaaea52eebe37e6": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4937. MR AM handles an oversized split metainfo file poorly. Contributed by Eric Payne\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1588559 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/14 1:33 PM",
      "commitName": "8d569c2220236551d5c95e2ebdaaea52eebe37e6",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "24/03/14 7:00 PM",
      "commitNameOld": "6015e9594180f157472a88030c85c5599fdc289c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 24.77,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,88 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // Send out an MR AM inited event for this AM.\n     dispatcher.getEventHandler().handle(\n         new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n             .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n             amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                 .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                     : this.forcedState.toString())));\n     amInfos.add(amInfo);\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n+    boolean initFailed \u003d false;\n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n+      // If job is still not initialized, an error happened during\n+      // initialization. Must complete starting all of the services so failure\n+      // events can be processed.\n+      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // set job classloader if configured\n     MRApps.setJobClassLoader(getConfig());\n-    // All components have started, start the job.\n-    startJobs();\n+\n+    if (initFailed) {\n+      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n+      jobEventDispatcher.handle(initFailedEvent);\n+    } else {\n+      // All components have started, start the job.\n+      startJobs();\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString())));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    boolean initFailed \u003d false;\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n      // If job is still not initialized, an error happened during\n      // initialization. Must complete starting all of the services so failure\n      // events can be processed.\n      initFailed \u003d (((JobImpl)job).getInternalState() !\u003d JobStateInternal.INITED);\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // set job classloader if configured\n    MRApps.setJobClassLoader(getConfig());\n\n    if (initFailed) {\n      JobEvent initFailedEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT_FAILED);\n      jobEventDispatcher.handle(initFailedEvent);\n    } else {\n      // All components have started, start the job.\n      startJobs();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "6015e9594180f157472a88030c85c5599fdc289c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5795. Fixed MRAppMaster to record the correct job-state after it recovers from a commit during a previous attempt. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 7:00 PM",
      "commitName": "6015e9594180f157472a88030c85c5599fdc289c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/03/14 7:43 AM",
      "commitNameOld": "0ab1f90d40352d4daad8efd21eda0a87dec55cf9",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 10.47,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,77 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n-    amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n-    // Send out an MR AM inited event for this AM and all previous AMs.\n+    // Send out an MR AM inited event for all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n+    // Send out an MR AM inited event for this AM.\n+    dispatcher.getEventHandler().handle(\n+        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n+            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n+            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n+                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n+                    : this.forcedState.toString())));\n+    amInfos.add(amInfo);\n+\n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n     // set job classloader if configured\n     MRApps.setJobClassLoader(getConfig());\n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // Send out an MR AM inited event for this AM.\n    dispatcher.getEventHandler().handle(\n        new JobHistoryEvent(job.getID(), new AMStartedEvent(amInfo\n            .getAppAttemptId(), amInfo.getStartTime(), amInfo.getContainerId(),\n            amInfo.getNodeManagerHost(), amInfo.getNodeManagerPort(), amInfo\n                .getNodeManagerHttpPort(), this.forcedState \u003d\u003d null ? null\n                    : this.forcedState.toString())));\n    amInfos.add(amInfo);\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // set job classloader if configured\n    MRApps.setJobClassLoader(getConfig());\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "0ab1f90d40352d4daad8efd21eda0a87dec55cf9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5751. MR app master fails to start in some cases if mapreduce.job.classloader is true. Contributed by Sangjin Lee\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577554 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/03/14 7:43 AM",
      "commitName": "0ab1f90d40352d4daad8efd21eda0a87dec55cf9",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "27/02/14 11:23 AM",
      "commitNameOld": "94b29b3348f5919a7599cc4b8e0466a4c72e95ae",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.81,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,69 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n       // Start ClientService here, since it\u0027s not initialized if\n       // errorHappenedShutDown is true\n       clientService.start();\n     }\n     //start all the components\n     super.serviceStart();\n \n+    // set job classloader if configured\n+    MRApps.setJobClassLoader(getConfig());\n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // set job classloader if configured\n    MRApps.setJobClassLoader(getConfig());\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "1c1ebc1553650ac8e4486faf21f0d95150f607ad": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5497. Changed MRAppMaster to sleep only after doing everything else but just before ClientService to avoid race conditions during RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1521699 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/13 5:38 PM",
      "commitName": "1c1ebc1553650ac8e4486faf21f0d95150f607ad",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/08/13 7:09 PM",
      "commitNameOld": "236b8530bd05015d3b8a8131b111454c54c9e55d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 10.94,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n+      // Start ClientService here, since it\u0027s not initialized if\n+      // errorHappenedShutDown is true\n+      clientService.start();\n     }\n-\n     //start all the components\n     super.serviceStart();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n      // Start ClientService here, since it\u0027s not initialized if\n      // errorHappenedShutDown is true\n      clientService.start();\n    }\n    //start all the components\n    super.serviceStart();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "0928502029ef141759008997335ea2cd836a7154": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 8:54 AM",
      "commitName": "0928502029ef141759008997335ea2cd836a7154",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,65 @@\n-  public void start() {\n+  protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n     }\n \n     //start all the components\n-    super.start();\n+    super.serviceStart();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.serviceStart();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "start",
            "newValue": "serviceStart"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,65 @@\n-  public void start() {\n+  protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n     }\n \n     //start all the components\n-    super.start();\n+    super.serviceStart();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.serviceStart();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,65 @@\n-  public void start() {\n+  protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n     }\n \n     //start all the components\n-    super.start();\n+    super.serviceStart();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.serviceStart();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,65 @@\n-  public void start() {\n+  protected void serviceStart() throws Exception {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n     processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n     }\n \n     //start all the components\n-    super.start();\n+    super.serviceStart();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceStart() throws Exception {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.serviceStart();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "6a1c41111edcdc58c846fc50e53554fbba230171": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5079. Changes job recovery to restore state directly from job history, instaed of simulating state machine events. Contributed by Jason Lowe and Robert Parker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466767 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 9:52 PM",
      "commitName": "6a1c41111edcdc58c846fc50e53554fbba230171",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/04/13 6:56 PM",
      "commitNameOld": "fc75d3f3dc2733d6c783eb4d4f1c5c6ae680f08e",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,65 @@\n   public void start() {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n-\n-    // Pull completedTasks etc from recovery\n-    if (inRecovery) {\n-      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n-      amInfos \u003d recoveryServ.getAMInfos();\n-    } else {\n-      // Get the amInfos anyways irrespective of whether recovery is enabled or\n-      // not IF this is not the first AM generation\n-      if (appAttemptID.getAttemptId() !\u003d 1) {\n-        amInfos.addAll(readJustAMInfos());\n-      }\n-    }\n+    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n+    processRecovery();\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     if (!errorHappenedShutDown) {\n       // create a job event for job intialization\n       JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n       // Send init to the job (this does NOT trigger job execution)\n       // This is a synchronous call, not an event through dispatcher. We want\n       // job-init to be done completely here.\n       jobEventDispatcher.handle(initJobEvent);\n \n \n       // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n       // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n       // ubermode if appropriate (by registering different container-allocator\n       // and container-launcher services/event-handlers).\n \n       if (job.isUber()) {\n         speculatorEventDispatcher.disableSpeculation();\n         LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n             + \" in local container (\\\"uber-AM\\\") on node \"\n             + nmHost + \":\" + nmPort + \".\");\n       } else {\n         // send init to speculator only for non-uber jobs. \n         // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n         dispatcher.getEventHandler().handle(\n             new SpeculatorEvent(job.getID(), clock.getTime()));\n         LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n             + \"job \" + job.getID() + \".\");\n       }\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    completedTasksFromPreviousRun \u003d new HashMap\u003cTaskId, TaskInfo\u003e();\n    processRecovery();\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "64e4fb983e022d8d3375a3e1b8facbf95f7ba403": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4819. AM can rerun job after reporting final job status to the client (bobby and Bikas Saha via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1429114 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/13 12:35 PM",
      "commitName": "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "04/01/13 11:15 AM",
      "commitNameOld": "78ab699fe93cafbaff8f496be53d26aff40a68b1",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,75 @@\n   public void start() {\n \n     amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n \n     // Pull completedTasks etc from recovery\n     if (inRecovery) {\n       completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n       amInfos \u003d recoveryServ.getAMInfos();\n     } else {\n       // Get the amInfos anyways irrespective of whether recovery is enabled or\n       // not IF this is not the first AM generation\n       if (appAttemptID.getAttemptId() !\u003d 1) {\n         amInfos.addAll(readJustAMInfos());\n       }\n     }\n \n     // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n-    job \u003d createJob(getConfig());\n+    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n-    // create a job event for job intialization\n-    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n-    // Send init to the job (this does NOT trigger job execution)\n-    // This is a synchronous call, not an event through dispatcher. We want\n-    // job-init to be done completely here.\n-    jobEventDispatcher.handle(initJobEvent);\n+    if (!errorHappenedShutDown) {\n+      // create a job event for job intialization\n+      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n+      // Send init to the job (this does NOT trigger job execution)\n+      // This is a synchronous call, not an event through dispatcher. We want\n+      // job-init to be done completely here.\n+      jobEventDispatcher.handle(initJobEvent);\n \n \n-    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n-    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n-    // ubermode if appropriate (by registering different container-allocator\n-    // and container-launcher services/event-handlers).\n+      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n+      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n+      // ubermode if appropriate (by registering different container-allocator\n+      // and container-launcher services/event-handlers).\n \n-    if (job.isUber()) {\n-      speculatorEventDispatcher.disableSpeculation();\n-      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n-               + \" in local container (\\\"uber-AM\\\") on node \"\n-               + nmHost + \":\" + nmPort + \".\");\n-    } else {\n-      // send init to speculator only for non-uber jobs. \n-      // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n-      dispatcher.getEventHandler().handle(\n-          new SpeculatorEvent(job.getID(), clock.getTime()));\n-      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n-               + \"job \" + job.getID() + \".\");\n+      if (job.isUber()) {\n+        speculatorEventDispatcher.disableSpeculation();\n+        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n+            + \" in local container (\\\"uber-AM\\\") on node \"\n+            + nmHost + \":\" + nmPort + \".\");\n+      } else {\n+        // send init to speculator only for non-uber jobs. \n+        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n+        dispatcher.getEventHandler().handle(\n+            new SpeculatorEvent(job.getID(), clock.getTime()));\n+        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n+            + \"job \" + job.getID() + \".\");\n+      }\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    } else {\n      // Get the amInfos anyways irrespective of whether recovery is enabled or\n      // not IF this is not the first AM generation\n      if (appAttemptID.getAttemptId() !\u003d 1) {\n        amInfos.addAll(readJustAMInfos());\n      }\n    }\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig(), forcedState, shutDownMessage);\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    if (!errorHappenedShutDown) {\n      // create a job event for job intialization\n      JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n      // Send init to the job (this does NOT trigger job execution)\n      // This is a synchronous call, not an event through dispatcher. We want\n      // job-init to be done completely here.\n      jobEventDispatcher.handle(initJobEvent);\n\n\n      // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n      // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n      // ubermode if appropriate (by registering different container-allocator\n      // and container-launcher services/event-handlers).\n\n      if (job.isUber()) {\n        speculatorEventDispatcher.disableSpeculation();\n        LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n            + \" in local container (\\\"uber-AM\\\") on node \"\n            + nmHost + \":\" + nmPort + \".\");\n      } else {\n        // send init to speculator only for non-uber jobs. \n        // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n        dispatcher.getEventHandler().handle(\n            new SpeculatorEvent(job.getID(), clock.getTime()));\n        LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n            + \"job \" + job.getID() + \".\");\n      }\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "42d1eaf237ef0a3a30c061888d35329b2a2e1453": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4729. job history UI not showing all job attempts. Contributed by Vinod Kumar Vavilapalli\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1404817 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/11/12 3:59 PM",
      "commitName": "42d1eaf237ef0a3a30c061888d35329b2a2e1453",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "24/10/12 8:20 AM",
      "commitNameOld": "614a743fea5ab5181b2b7989bba84146e81039de",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 8.32,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,73 @@\n   public void start() {\n \n+    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n+\n     // Pull completedTasks etc from recovery\n     if (inRecovery) {\n       completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n       amInfos \u003d recoveryServ.getAMInfos();\n+    } else {\n+      // Get the amInfos anyways irrespective of whether recovery is enabled or\n+      // not IF this is not the first AM generation\n+      if (appAttemptID.getAttemptId() !\u003d 1) {\n+        amInfos.addAll(readJustAMInfos());\n+      }\n     }\n \n-    // / Create the AMInfo for the current AppMaster\n-    if (amInfos \u003d\u003d null) {\n-      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n-    }\n+    // Current an AMInfo for the current AM generation.\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n     // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n       speculatorEventDispatcher.disableSpeculation();\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n                + \" in local container (\\\"uber-AM\\\") on node \"\n                + nmHost + \":\" + nmPort + \".\");\n     } else {\n       // send init to speculator only for non-uber jobs. \n       // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n       dispatcher.getEventHandler().handle(\n           new SpeculatorEvent(job.getID(), clock.getTime()));\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    } else {\n      // Get the amInfos anyways irrespective of whether recovery is enabled or\n      // not IF this is not the first AM generation\n      if (appAttemptID.getAttemptId() !\u003d 1) {\n        amInfos.addAll(readJustAMInfos());\n      }\n    }\n\n    // Current an AMInfo for the current AM generation.\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      speculatorEventDispatcher.disableSpeculation();\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\") on node \"\n               + nmHost + \":\" + nmPort + \".\");\n    } else {\n      // send init to speculator only for non-uber jobs. \n      // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n      dispatcher.getEventHandler().handle(\n          new SpeculatorEvent(job.getID(), clock.getTime()));\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3426. Fixed MR AM in uber mode to write map intermediate outputs in the correct directory to work properly in secure mode. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213987 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 3:35 PM",
      "commitName": "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/12/11 12:35 AM",
      "commitNameOld": "08da8ea5db5359fc04010be486b842a5d2e6b9c2",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 12.62,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   public void start() {\n \n     // Pull completedTasks etc from recovery\n     if (inRecovery) {\n       completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n       amInfos \u003d recoveryServ.getAMInfos();\n     }\n \n     // / Create the AMInfo for the current AppMaster\n     if (amInfos \u003d\u003d null) {\n       amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     }\n     AMInfo amInfo \u003d\n         MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n             nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n     // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n-    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n-    // started yet.\n-    dispatcher.getEventHandler().handle(\n-        new SpeculatorEvent(job.getID(), clock.getTime()));\n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n+      speculatorEventDispatcher.disableSpeculation();\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n-               + \" in local container (\\\"uber-AM\\\").\");\n+               + \" in local container (\\\"uber-AM\\\") on node \"\n+               + nmHost + \":\" + nmPort + \".\");\n     } else {\n+      // send init to speculator only for non-uber jobs. \n+      // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n+      dispatcher.getEventHandler().handle(\n+          new SpeculatorEvent(job.getID(), clock.getTime()));\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    }\n\n    // / Create the AMInfo for the current AppMaster\n    if (amInfos \u003d\u003d null) {\n      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    }\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      speculatorEventDispatcher.disableSpeculation();\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\") on node \"\n               + nmHost + \":\" + nmPort + \".\");\n    } else {\n      // send init to speculator only for non-uber jobs. \n      // This won\u0027t yet start as dispatcher isn\u0027t started yet.\n      dispatcher.getEventHandler().handle(\n          new SpeculatorEvent(job.getID(), clock.getTime()));\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "47a381e306877750b5a3ce5d76e0a5ff652ec188": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3146. Added a MR specific command line to dump logs for a given TaskAttemptID. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195349 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/11 11:42 PM",
      "commitName": "47a381e306877750b5a3ce5d76e0a5ff652ec188",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void start() {\n \n     // Pull completedTasks etc from recovery\n     if (inRecovery) {\n       completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n       amInfos \u003d recoveryServ.getAMInfos();\n     }\n \n     // / Create the AMInfo for the current AppMaster\n     if (amInfos \u003d\u003d null) {\n       amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     }\n     AMInfo amInfo \u003d\n-        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmPort,\n-            nmHttpPort);\n+        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n+            nmPort, nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n               info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                   .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n     // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n     // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n     // started yet.\n     dispatcher.getEventHandler().handle(\n         new SpeculatorEvent(job.getID(), clock.getTime()));\n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n                + \" in local container (\\\"uber-AM\\\").\");\n     } else {\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    }\n\n    // / Create the AMInfo for the current AppMaster\n    if (amInfos \u003d\u003d null) {\n      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    }\n    AMInfo amInfo \u003d\n        MRBuilderUtils.newAMInfo(appAttemptID, startTime, containerID, nmHost,\n            nmPort, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n    // started yet.\n    dispatcher.getEventHandler().handle(\n        new SpeculatorEvent(job.getID(), clock.getTime()));\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\").\");\n    } else {\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/11 2:02 PM",
      "commitNameOld": "6288dfa873364d1bb735bdb811002f0080e9a1be",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.4,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public void start() {\n \n     // Pull completedTasks etc from recovery\n     if (inRecovery) {\n       completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n       amInfos \u003d recoveryServ.getAMInfos();\n     }\n \n     // / Create the AMInfo for the current AppMaster\n     if (amInfos \u003d\u003d null) {\n       amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n     }\n     AMInfo amInfo \u003d\n-        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmHttpPort);\n+        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmPort,\n+            nmHttpPort);\n     amInfos.add(amInfo);\n \n     // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n \n     // End of creating the job.\n \n     // Send out an MR AM inited event for this AM and all previous AMs.\n     for (AMInfo info : amInfos) {\n       dispatcher.getEventHandler().handle(\n           new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n               .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n-              info.getNodeManagerHost(), info.getNodeManagerHttpPort())));\n+              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n+                  .getNodeManagerHttpPort())));\n     }\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n     // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n     // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n     // started yet.\n     dispatcher.getEventHandler().handle(\n         new SpeculatorEvent(job.getID(), clock.getTime()));\n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n                + \" in local container (\\\"uber-AM\\\").\");\n     } else {\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    }\n\n    // / Create the AMInfo for the current AppMaster\n    if (amInfos \u003d\u003d null) {\n      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    }\n    AMInfo amInfo \u003d\n        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmPort,\n            nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerPort(), info\n                  .getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n    // started yet.\n    dispatcher.getEventHandler().handle(\n        new SpeculatorEvent(job.getID(), clock.getTime()));\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\").\");\n    } else {\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 10:21 PM",
      "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/10/11 3:46 PM",
      "commitNameOld": "b4d20c707af6fe8b9b3e5ffa95a88012a1cdfc17",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,64 @@\n   public void start() {\n \n-    ///////////////////// Create the job itself.\n+    // Pull completedTasks etc from recovery\n+    if (inRecovery) {\n+      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n+      amInfos \u003d recoveryServ.getAMInfos();\n+    }\n+\n+    // / Create the AMInfo for the current AppMaster\n+    if (amInfos \u003d\u003d null) {\n+      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n+    }\n+    AMInfo amInfo \u003d\n+        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmHttpPort);\n+    amInfos.add(amInfo);\n+\n+    // /////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n-    \n+\n     // End of creating the job.\n \n+    // Send out an MR AM inited event for this AM and all previous AMs.\n+    for (AMInfo info : amInfos) {\n+      dispatcher.getEventHandler().handle(\n+          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n+              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n+              info.getNodeManagerHost(), info.getNodeManagerHttpPort())));\n+    }\n+\n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n     // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n     // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n     // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n     // started yet.\n     dispatcher.getEventHandler().handle(\n         new SpeculatorEvent(job.getID(), clock.getTime()));\n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n                + \" in local container (\\\"uber-AM\\\").\");\n     } else {\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    // Pull completedTasks etc from recovery\n    if (inRecovery) {\n      completedTasksFromPreviousRun \u003d recoveryServ.getCompletedTasks();\n      amInfos \u003d recoveryServ.getAMInfos();\n    }\n\n    // / Create the AMInfo for the current AppMaster\n    if (amInfos \u003d\u003d null) {\n      amInfos \u003d new LinkedList\u003cAMInfo\u003e();\n    }\n    AMInfo amInfo \u003d\n        new AMInfo(appAttemptID, startTime, containerID, nmHost, nmHttpPort);\n    amInfos.add(amInfo);\n\n    // /////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n\n    // End of creating the job.\n\n    // Send out an MR AM inited event for this AM and all previous AMs.\n    for (AMInfo info : amInfos) {\n      dispatcher.getEventHandler().handle(\n          new JobHistoryEvent(job.getID(), new AMStartedEvent(info\n              .getAppAttemptId(), info.getStartTime(), info.getContainerId(),\n              info.getNodeManagerHost(), info.getNodeManagerHttpPort())));\n    }\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n    // started yet.\n    dispatcher.getEventHandler().handle(\n        new SpeculatorEvent(job.getID(), clock.getTime()));\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\").\");\n    } else {\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "312a7e71001d55f88781e56b331ab1b40a72a980": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3078. Ensure MapReduce AM reports progress correctly for displaying on the RM Web-UI. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1176762 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 12:31 AM",
      "commitName": "312a7e71001d55f88781e56b331ab1b40a72a980",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "26/09/11 1:44 AM",
      "commitNameOld": "c9a7d3dbf902244902b636bf566154c09ecd1116",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.95,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public void start() {\n \n     ///////////////////// Create the job itself.\n     job \u003d createJob(getConfig());\n     // End of creating the job.\n \n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n-    /** create a job event for job intialization */\n+    // create a job event for job intialization\n     JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n-    /** send init to the job (this does NOT trigger job execution) */\n+    // Send init to the job (this does NOT trigger job execution)\n     // This is a synchronous call, not an event through dispatcher. We want\n     // job-init to be done completely here.\n     jobEventDispatcher.handle(initJobEvent);\n \n     // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n     // started yet.\n     dispatcher.getEventHandler().handle(\n         new SpeculatorEvent(job.getID(), clock.getTime()));\n \n     // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n     // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n     // ubermode if appropriate (by registering different container-allocator\n     // and container-launcher services/event-handlers).\n \n     if (job.isUber()) {\n       LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n                + \" in local container (\\\"uber-AM\\\").\");\n     } else {\n       LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n                + \"job \" + job.getID() + \".\");\n     }\n \n     //start all the components\n     super.start();\n \n     // All components have started, start the job.\n     startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    ///////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n    // End of creating the job.\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    // create a job event for job intialization\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    // Send init to the job (this does NOT trigger job execution)\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n    // started yet.\n    dispatcher.getEventHandler().handle(\n        new SpeculatorEvent(job.getID(), clock.getTime()));\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\").\");\n    } else {\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "61900651b1b85cf235e01142acf2a51727fc5537": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3006. Fixed MapReduce AM to exit only after properly writing out history file. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1172206 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/09/11 12:16 AM",
      "commitName": "61900651b1b85cf235e01142acf2a51727fc5537",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/09/11 10:57 AM",
      "commitNameOld": "4ba2acf3363bdfd7fcdd9de496cd57f8af6f03ad",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.55,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,9 +1,41 @@\n   public void start() {\n+\n+    ///////////////////// Create the job itself.\n+    job \u003d createJob(getConfig());\n+    // End of creating the job.\n+\n     // metrics system init is really init \u0026 start.\n     // It\u0027s more test friendly to put it here.\n     DefaultMetricsSystem.initialize(\"MRAppMaster\");\n \n-    startJobs();\n+    /** create a job event for job intialization */\n+    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n+    /** send init to the job (this does NOT trigger job execution) */\n+    // This is a synchronous call, not an event through dispatcher. We want\n+    // job-init to be done completely here.\n+    jobEventDispatcher.handle(initJobEvent);\n+\n+    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n+    // started yet.\n+    dispatcher.getEventHandler().handle(\n+        new SpeculatorEvent(job.getID(), clock.getTime()));\n+\n+    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n+    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n+    // ubermode if appropriate (by registering different container-allocator\n+    // and container-launcher services/event-handlers).\n+\n+    if (job.isUber()) {\n+      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n+               + \" in local container (\\\"uber-AM\\\").\");\n+    } else {\n+      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n+               + \"job \" + job.getID() + \".\");\n+    }\n+\n     //start all the components\n     super.start();\n+\n+    // All components have started, start the job.\n+    startJobs();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n\n    ///////////////////// Create the job itself.\n    job \u003d createJob(getConfig());\n    // End of creating the job.\n\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    /** create a job event for job intialization */\n    JobEvent initJobEvent \u003d new JobEvent(job.getID(), JobEventType.JOB_INIT);\n    /** send init to the job (this does NOT trigger job execution) */\n    // This is a synchronous call, not an event through dispatcher. We want\n    // job-init to be done completely here.\n    jobEventDispatcher.handle(initJobEvent);\n\n    // send init to speculator. This won\u0027t yest start as dispatcher isn\u0027t\n    // started yet.\n    dispatcher.getEventHandler().handle(\n        new SpeculatorEvent(job.getID(), clock.getTime()));\n\n    // JobImpl\u0027s InitTransition is done (call above is synchronous), so the\n    // \"uber-decision\" (MR-1220) has been made.  Query job and switch to\n    // ubermode if appropriate (by registering different container-allocator\n    // and container-launcher services/event-handlers).\n\n    if (job.isUber()) {\n      LOG.info(\"MRAppMaster uberizing job \" + job.getID()\n               + \" in local container (\\\"uber-AM\\\").\");\n    } else {\n      LOG.info(\"MRAppMaster launching normal, non-uberized, multi-container \"\n               + \"job \" + job.getID() + \".\");\n    }\n\n    //start all the components\n    super.start();\n\n    // All components have started, start the job.\n    startJobs();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() {\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    startJobs();\n    //start all the components\n    super.start();\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,9 @@\n+  public void start() {\n+    // metrics system init is really init \u0026 start.\n+    // It\u0027s more test friendly to put it here.\n+    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n+\n+    startJobs();\n+    //start all the components\n+    super.start();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() {\n    // metrics system init is really init \u0026 start.\n    // It\u0027s more test friendly to put it here.\n    DefaultMetricsSystem.initialize(\"MRAppMaster\");\n\n    startJobs();\n    //start all the components\n    super.start();\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java"
    }
  }
}