{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacitySchedulerConfiguration.java",
  "functionName": "getMultiNodePlacementPolicies",
  "functionId": "getMultiNodePlacementPolicies",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java",
  "functionStartLine": 2270,
  "functionEndLine": 2309,
  "numCommitsSeen": 90,
  "timeTaken": 2255,
  "changeHistory": [
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181"
  ],
  "changeHistoryShort": {
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "diff": "@@ -0,0 +1,40 @@\n+  public Set\u003cMultiNodePolicySpec\u003e getMultiNodePlacementPolicies() {\n+    String[] policies \u003d getTrimmedStrings(MULTI_NODE_SORTING_POLICIES);\n+\n+    // In other cases, split the accessibleLabelStr by \",\"\n+    Set\u003cMultiNodePolicySpec\u003e set \u003d new HashSet\u003cMultiNodePolicySpec\u003e();\n+    for (String str : policies) {\n+      if (!str.trim().isEmpty()) {\n+        String policyClassName \u003d get(\n+            MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim() + DOT + \"class\");\n+        if (str.trim().equals(DEFAULT_NODE_SORTING_POLICY)) {\n+          policyClassName \u003d get(\n+              MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim() + DOT + \"class\",\n+              DEFAULT_NODE_SORTING_POLICY_CLASSNAME);\n+        }\n+\n+        // This check is needed as default class name is loaded only for\n+        // DEFAULT_NODE_SORTING_POLICY.\n+        if (policyClassName \u003d\u003d null) {\n+          throw new YarnRuntimeException(\n+              str.trim() + \" Class is not configured or not an instance of \"\n+                  + MultiNodeLookupPolicy.class.getCanonicalName());\n+        }\n+        policyClassName \u003d normalizePolicyName(policyClassName.trim());\n+        long policySortingInterval \u003d getLong(\n+            MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim()\n+                + DOT + \"sorting-interval.ms\",\n+            DEFAULT_MULTI_NODE_SORTING_INTERVAL);\n+        if (policySortingInterval \u003c 0) {\n+          throw new YarnRuntimeException(\n+              str.trim()\n+                  + \" multi-node policy is configured with invalid\"\n+                  + \" sorting-interval:\" + policySortingInterval);\n+        }\n+        set.add(\n+            new MultiNodePolicySpec(policyClassName, policySortingInterval));\n+      }\n+    }\n+\n+    return Collections.unmodifiableSet(set);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Set\u003cMultiNodePolicySpec\u003e getMultiNodePlacementPolicies() {\n    String[] policies \u003d getTrimmedStrings(MULTI_NODE_SORTING_POLICIES);\n\n    // In other cases, split the accessibleLabelStr by \",\"\n    Set\u003cMultiNodePolicySpec\u003e set \u003d new HashSet\u003cMultiNodePolicySpec\u003e();\n    for (String str : policies) {\n      if (!str.trim().isEmpty()) {\n        String policyClassName \u003d get(\n            MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim() + DOT + \"class\");\n        if (str.trim().equals(DEFAULT_NODE_SORTING_POLICY)) {\n          policyClassName \u003d get(\n              MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim() + DOT + \"class\",\n              DEFAULT_NODE_SORTING_POLICY_CLASSNAME);\n        }\n\n        // This check is needed as default class name is loaded only for\n        // DEFAULT_NODE_SORTING_POLICY.\n        if (policyClassName \u003d\u003d null) {\n          throw new YarnRuntimeException(\n              str.trim() + \" Class is not configured or not an instance of \"\n                  + MultiNodeLookupPolicy.class.getCanonicalName());\n        }\n        policyClassName \u003d normalizePolicyName(policyClassName.trim());\n        long policySortingInterval \u003d getLong(\n            MULTI_NODE_SORTING_POLICY_NAME + DOT + str.trim()\n                + DOT + \"sorting-interval.ms\",\n            DEFAULT_MULTI_NODE_SORTING_INTERVAL);\n        if (policySortingInterval \u003c 0) {\n          throw new YarnRuntimeException(\n              str.trim()\n                  + \" multi-node policy is configured with invalid\"\n                  + \" sorting-interval:\" + policySortingInterval);\n        }\n        set.add(\n            new MultiNodePolicySpec(policyClassName, policySortingInterval));\n      }\n    }\n\n    return Collections.unmodifiableSet(set);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacitySchedulerConfiguration.java"
    }
  }
}