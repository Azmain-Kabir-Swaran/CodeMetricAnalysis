{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryStore.java",
  "functionName": "getHistory",
  "functionId": "getHistory___recurrenceId-RecurrenceId(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-resourceestimator/src/main/java/org/apache/hadoop/resourceestimator/skylinestore/impl/InMemoryStore.java",
  "functionStartLine": 191,
  "functionEndLine": 244,
  "numCommitsSeen": 1,
  "timeTaken": 405,
  "changeHistory": [
    "625039ef20e6011ab360131d70582a6e4bf2ec1d"
  ],
  "changeHistoryShort": {
    "625039ef20e6011ab360131d70582a6e4bf2ec1d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "625039ef20e6011ab360131d70582a6e4bf2ec1d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14840. Tool to estimate resource requirements of an application pipeline based on prior executions. (Rui Li via Subru).\n",
      "commitDate": "25/10/17 3:51 PM",
      "commitName": "625039ef20e6011ab360131d70582a6e4bf2ec1d",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,54 @@\n+  @Override public final Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e getHistory(\n+      final RecurrenceId recurrenceId) throws SkylineStoreException {\n+    inputValidator.validate(recurrenceId);\n+    readLock.lock();\n+    try {\n+      String pipelineId \u003d recurrenceId.getPipelineId();\n+      // User tries to getHistory all resource skylines in the skylineStore\n+      if (pipelineId.equals(\"*\")) {\n+        LOGGER\n+            .info(\"Successfully query resource skylines for {}.\", recurrenceId);\n+        return Collections.unmodifiableMap(skylineStore);\n+      }\n+      String runId \u003d recurrenceId.getRunId();\n+      Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e result \u003d\n+          new HashMap\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e();\n+      // User tries to getHistory pipelineId\u0027s all resource skylines in the\n+      // skylineStore\n+      if (runId.equals(\"*\")) {\n+        // TODO: this for loop is expensive, so we may change the type of\n+        // skylineStore to\n+        // speed up this loop.\n+        for (Map.Entry\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e entry : skylineStore\n+            .entrySet()) {\n+          RecurrenceId index \u003d entry.getKey();\n+          if (index.getPipelineId().equals(pipelineId)) {\n+            result.put(index, entry.getValue());\n+          }\n+        }\n+        if (result.size() \u003e 0) {\n+          LOGGER.info(\"Successfully query resource skylines for {}.\",\n+              recurrenceId);\n+          return Collections.unmodifiableMap(result);\n+        } else {\n+          LOGGER.warn(\n+              \"Trying to getHistory non-existing resource skylines for {}.\",\n+              recurrenceId);\n+          return null;\n+        }\n+      }\n+      // User tries to getHistory {pipelineId, runId}\u0027s resource skylines\n+      if (skylineStore.containsKey(recurrenceId)) {\n+        result.put(recurrenceId, skylineStore.get(recurrenceId));\n+      } else {\n+        LOGGER\n+            .warn(\"Trying to getHistory non-existing resource skylines for {}.\",\n+                recurrenceId);\n+        return null;\n+      }\n+      LOGGER.info(\"Successfully query resource skylines for {}.\", recurrenceId);\n+      return Collections.unmodifiableMap(result);\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  @Override public final Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e getHistory(\n      final RecurrenceId recurrenceId) throws SkylineStoreException {\n    inputValidator.validate(recurrenceId);\n    readLock.lock();\n    try {\n      String pipelineId \u003d recurrenceId.getPipelineId();\n      // User tries to getHistory all resource skylines in the skylineStore\n      if (pipelineId.equals(\"*\")) {\n        LOGGER\n            .info(\"Successfully query resource skylines for {}.\", recurrenceId);\n        return Collections.unmodifiableMap(skylineStore);\n      }\n      String runId \u003d recurrenceId.getRunId();\n      Map\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e result \u003d\n          new HashMap\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e();\n      // User tries to getHistory pipelineId\u0027s all resource skylines in the\n      // skylineStore\n      if (runId.equals(\"*\")) {\n        // TODO: this for loop is expensive, so we may change the type of\n        // skylineStore to\n        // speed up this loop.\n        for (Map.Entry\u003cRecurrenceId, List\u003cResourceSkyline\u003e\u003e entry : skylineStore\n            .entrySet()) {\n          RecurrenceId index \u003d entry.getKey();\n          if (index.getPipelineId().equals(pipelineId)) {\n            result.put(index, entry.getValue());\n          }\n        }\n        if (result.size() \u003e 0) {\n          LOGGER.info(\"Successfully query resource skylines for {}.\",\n              recurrenceId);\n          return Collections.unmodifiableMap(result);\n        } else {\n          LOGGER.warn(\n              \"Trying to getHistory non-existing resource skylines for {}.\",\n              recurrenceId);\n          return null;\n        }\n      }\n      // User tries to getHistory {pipelineId, runId}\u0027s resource skylines\n      if (skylineStore.containsKey(recurrenceId)) {\n        result.put(recurrenceId, skylineStore.get(recurrenceId));\n      } else {\n        LOGGER\n            .warn(\"Trying to getHistory non-existing resource skylines for {}.\",\n                recurrenceId);\n        return null;\n      }\n      LOGGER.info(\"Successfully query resource skylines for {}.\", recurrenceId);\n      return Collections.unmodifiableMap(result);\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-tools/hadoop-resourceestimator/src/main/java/org/apache/hadoop/resourceestimator/skylinestore/impl/InMemoryStore.java"
    }
  }
}