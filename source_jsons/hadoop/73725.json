{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProtobufRpcEngine.java",
  "functionName": "call",
  "functionId": "call___server-RPC.Server__connectionProtocolName-String__writableRequest-Writable__receiveTime-long",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
  "functionStartLine": 480,
  "functionEndLine": 549,
  "numCommitsSeen": 80,
  "timeTaken": 4743,
  "changeHistory": [
    "f96a2df38d889f29314c57f4d94227b2e419a11f",
    "2d105a206884b62ccdba61f2de3e2fe65fc43074",
    "8bef4eca28a3466707cc4ea0de0330449319a5eb",
    "3d94da1e00fc6238fad458e415219f87920f1fc3",
    "caf800d5290d8618003b764afb0b3ef8d9a5a0a8",
    "580a8334963709e728ed677c815fb7fef9bca70e",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
    "48774d0a45d95557affbd6bbaf8035cc9575ef36",
    "790ee456439729073d75ccf91e1f63b3d360b1c7",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd",
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172",
    "461e614a3aa11372d18537028aa217a9d79527af",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "266a0f1de9811d031c6f56ff32185d65c5a9aaa0",
    "081eda94fec4bbf321047c93a9bb40be678b1666",
    "22d5944c42b4bef5144a9f6426751b15717c5a3e",
    "65200998c01b17e017d1814e8b1f4d82ac334a23",
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655"
  ],
  "changeHistoryShort": {
    "f96a2df38d889f29314c57f4d94227b2e419a11f": "Ybodychange",
    "2d105a206884b62ccdba61f2de3e2fe65fc43074": "Ybodychange",
    "8bef4eca28a3466707cc4ea0de0330449319a5eb": "Ybodychange",
    "3d94da1e00fc6238fad458e415219f87920f1fc3": "Ybodychange",
    "caf800d5290d8618003b764afb0b3ef8d9a5a0a8": "Ybodychange",
    "580a8334963709e728ed677c815fb7fef9bca70e": "Ybodychange",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": "Ybodychange",
    "48774d0a45d95557affbd6bbaf8035cc9575ef36": "Ybodychange",
    "790ee456439729073d75ccf91e1f63b3d360b1c7": "Ybodychange",
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": "Ybodychange",
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172": "Ybodychange",
    "461e614a3aa11372d18537028aa217a9d79527af": "Ybodychange",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "266a0f1de9811d031c6f56ff32185d65c5a9aaa0": "Ymultichange(Yparameterchange,Ybodychange)",
    "081eda94fec4bbf321047c93a9bb40be678b1666": "Ymultichange(Yexceptionschange,Ybodychange)",
    "22d5944c42b4bef5144a9f6426751b15717c5a3e": "Ybodychange",
    "65200998c01b17e017d1814e8b1f4d82ac334a23": "Ymultichange(Yparameterchange,Ybodychange)",
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f96a2df38d889f29314c57f4d94227b2e419a11f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16266. Add more fine-grained processing time metrics to the RPC layer. Contributed by Christopher Gregorian.\n",
      "commitDate": "23/05/19 10:28 AM",
      "commitName": "f96a2df38d889f29314c57f4d94227b2e419a11f",
      "commitAuthor": "Christopher Gregorian",
      "commitDateOld": "11/03/19 6:59 PM",
      "commitNameOld": "2a54feabb2d1245d80f061c5c796f0663dd2a689",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 72.65,
      "commitsBetweenForRepo": 449,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,70 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n         String methodName \u003d rpcRequest.getMethodName();\n \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d request.getValue(prototype);\n \n         Message result;\n-        long startTime \u003d Time.now();\n-        int qTime \u003d (int) (startTime - receiveTime);\n-        Exception exception \u003d null;\n-        boolean isDeferred \u003d false;\n+        Call currentCall \u003d Server.getCurCall().get();\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           currentCallInfo.set(new CallInfo(server, methodName));\n+          currentCall.setDetailedMetricsName(methodName);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           // Check if this needs to be a deferred response,\n           // by checking the ThreadLocal callback being set\n           if (currentCallback.get() !\u003d null) {\n-            Server.getCurCall().get().deferResponse();\n-            isDeferred \u003d true;\n+            currentCall.deferResponse();\n             currentCallback.set(null);\n             return null;\n           }\n         } catch (ServiceException e) {\n-          exception \u003d (Exception) e.getCause();\n+          Exception exception \u003d (Exception) e.getCause();\n+          currentCall.setDetailedMetricsName(\n+              exception.getClass().getSimpleName());\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n-          exception \u003d e;\n+          currentCall.setDetailedMetricsName(e.getClass().getSimpleName());\n           throw e;\n         } finally {\n           currentCallInfo.set(null);\n-          int processingTime \u003d (int) (Time.now() - startTime);\n-          if (LOG.isDebugEnabled()) {\n-            String msg \u003d\n-                \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n-                    \", queueTime\u003d \" + qTime +\n-                    \" procesingTime\u003d \" + processingTime;\n-            if (exception !\u003d null) {\n-              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n-            }\n-            LOG.debug(msg);\n-          }\n-          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n-              methodName :\n-              exception.getClass().getSimpleName();\n-          server.updateMetrics(detailedMetricsName, qTime, processingTime,\n-              isDeferred);\n         }\n         return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        Call currentCall \u003d Server.getCurCall().get();\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          currentCallInfo.set(new CallInfo(server, methodName));\n          currentCall.setDetailedMetricsName(methodName);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          // Check if this needs to be a deferred response,\n          // by checking the ThreadLocal callback being set\n          if (currentCallback.get() !\u003d null) {\n            currentCall.deferResponse();\n            currentCallback.set(null);\n            return null;\n          }\n        } catch (ServiceException e) {\n          Exception exception \u003d (Exception) e.getCause();\n          currentCall.setDetailedMetricsName(\n              exception.getClass().getSimpleName());\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          currentCall.setDetailedMetricsName(e.getClass().getSimpleName());\n          throw e;\n        } finally {\n          currentCallInfo.set(null);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "2d105a206884b62ccdba61f2de3e2fe65fc43074": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14732. ProtobufRpcEngine should use Time.monotonicNow to measure durations. Contributed by Hanisha Koneru.\"\n\nThis reverts commit 8bef4eca28a3466707cc4ea0de0330449319a5eb.\n",
      "commitDate": "18/08/17 10:15 AM",
      "commitName": "2d105a206884b62ccdba61f2de3e2fe65fc43074",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/08/17 3:53 PM",
      "commitNameOld": "8bef4eca28a3466707cc4ea0de0330449319a5eb",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n         String methodName \u003d rpcRequest.getMethodName();\n \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d request.getValue(prototype);\n \n         Message result;\n-        long startTime \u003d Time.monotonicNow();\n+        long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         boolean isDeferred \u003d false;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           currentCallInfo.set(new CallInfo(server, methodName));\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           // Check if this needs to be a deferred response,\n           // by checking the ThreadLocal callback being set\n           if (currentCallback.get() !\u003d null) {\n             Server.getCurCall().get().deferResponse();\n             isDeferred \u003d true;\n             currentCallback.set(null);\n             return null;\n           }\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           currentCallInfo.set(null);\n-          int processingTime \u003d (int) (Time.monotonicNow() - startTime);\n+          int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d\n                 \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n                     \", queueTime\u003d \" + qTime +\n                     \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n           server.updateMetrics(detailedMetricsName, qTime, processingTime,\n               isDeferred);\n         }\n         return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        boolean isDeferred \u003d false;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          currentCallInfo.set(new CallInfo(server, methodName));\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          // Check if this needs to be a deferred response,\n          // by checking the ThreadLocal callback being set\n          if (currentCallback.get() !\u003d null) {\n            Server.getCurCall().get().deferResponse();\n            isDeferred \u003d true;\n            currentCallback.set(null);\n            return null;\n          }\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          currentCallInfo.set(null);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d\n                \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n                    \", queueTime\u003d \" + qTime +\n                    \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime,\n              isDeferred);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "8bef4eca28a3466707cc4ea0de0330449319a5eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14732. ProtobufRpcEngine should use Time.monotonicNow to measure durations. Contributed by Hanisha Koneru.\n",
      "commitDate": "14/08/17 3:53 PM",
      "commitName": "8bef4eca28a3466707cc4ea0de0330449319a5eb",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n         String methodName \u003d rpcRequest.getMethodName();\n \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d request.getValue(prototype);\n \n         Message result;\n-        long startTime \u003d Time.now();\n+        long startTime \u003d Time.monotonicNow();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         boolean isDeferred \u003d false;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           currentCallInfo.set(new CallInfo(server, methodName));\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           // Check if this needs to be a deferred response,\n           // by checking the ThreadLocal callback being set\n           if (currentCallback.get() !\u003d null) {\n             Server.getCurCall().get().deferResponse();\n             isDeferred \u003d true;\n             currentCallback.set(null);\n             return null;\n           }\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           currentCallInfo.set(null);\n-          int processingTime \u003d (int) (Time.now() - startTime);\n+          int processingTime \u003d (int) (Time.monotonicNow() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d\n                 \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n                     \", queueTime\u003d \" + qTime +\n                     \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n           server.updateMetrics(detailedMetricsName, qTime, processingTime,\n               isDeferred);\n         }\n         return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        long startTime \u003d Time.monotonicNow();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        boolean isDeferred \u003d false;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          currentCallInfo.set(new CallInfo(server, methodName));\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          // Check if this needs to be a deferred response,\n          // by checking the ThreadLocal callback being set\n          if (currentCallback.get() !\u003d null) {\n            Server.getCurCall().get().deferResponse();\n            isDeferred \u003d true;\n            currentCallback.set(null);\n            return null;\n          }\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          currentCallInfo.set(null);\n          int processingTime \u003d (int) (Time.monotonicNow() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d\n                \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n                    \", queueTime\u003d \" + qTime +\n                    \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime,\n              isDeferred);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "3d94da1e00fc6238fad458e415219f87920f1fc3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11552. Allow handoff on the server side for RPC requests. Contributed by Siddharth Seth\n",
      "commitDate": "23/11/16 4:01 PM",
      "commitName": "3d94da1e00fc6238fad458e415219f87920f1fc3",
      "commitAuthor": "Jian He",
      "commitDateOld": "14/09/16 7:46 PM",
      "commitNameOld": "ea0c2b8b051a2d14927e8f314245442f30748dc8",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 69.89,
      "commitsBetweenForRepo": 553,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,87 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n         String methodName \u003d rpcRequest.getMethodName();\n \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d request.getValue(prototype);\n \n         Message result;\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n+        boolean isDeferred \u003d false;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n+          currentCallInfo.set(new CallInfo(server, methodName));\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n+          // Check if this needs to be a deferred response,\n+          // by checking the ThreadLocal callback being set\n+          if (currentCallback.get() !\u003d null) {\n+            Server.getCurCall().get().deferResponse();\n+            isDeferred \u003d true;\n+            currentCallback.set(null);\n+            return null;\n+          }\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n+          currentCallInfo.set(null);\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n-            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n-                \" procesingTime\u003d \" + processingTime;\n+            String msg \u003d\n+                \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n+                    \", queueTime\u003d \" + qTime +\n+                    \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n-          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n+          server.updateMetrics(detailedMetricsName, qTime, processingTime,\n+              isDeferred);\n         }\n         return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        boolean isDeferred \u003d false;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          currentCallInfo.set(new CallInfo(server, methodName));\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          // Check if this needs to be a deferred response,\n          // by checking the ThreadLocal callback being set\n          if (currentCallback.get() !\u003d null) {\n            Server.getCurCall().get().deferResponse();\n            isDeferred \u003d true;\n            currentCallback.set(null);\n            return null;\n          }\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          currentCallInfo.set(null);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d\n                \"Served: \" + methodName + (isDeferred ? \", deferred\" : \"\") +\n                    \", queueTime\u003d \" + qTime +\n                    \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime,\n              isDeferred);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "caf800d5290d8618003b764afb0b3ef8d9a5a0a8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13473. Tracing in IPC Server is broken. Contributed by Daryn Sharp.\n",
      "commitDate": "09/08/16 12:33 PM",
      "commitName": "caf800d5290d8618003b764afb0b3ef8d9a5a0a8",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/08/16 11:22 AM",
      "commitNameOld": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.05,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,73 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n-        RpcWritable.Buffer request \u003d (RpcWritable.Buffer) writableRequest;\n-        RequestHeaderProto rpcRequest \u003d\n-            request.getValue(RequestHeaderProto.getDefaultInstance());\n+        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n+        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n         String methodName \u003d rpcRequest.getMethodName();\n \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d request.getValue(prototype);\n \n         Message result;\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                 \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n           server.updateMetrics(detailedMetricsName, qTime, processingTime);\n         }\n         return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcProtobufRequest request \u003d (RpcProtobufRequest) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.getRequestHeader();\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "580a8334963709e728ed677c815fb7fef9bca70e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "03/08/16 11:22 AM",
      "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/06/16 1:31 AM",
      "commitNameOld": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 58.41,
      "commitsBetweenForRepo": 506,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,74 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n-        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n-        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n+        RpcWritable.Buffer request \u003d (RpcWritable.Buffer) writableRequest;\n+        RequestHeaderProto rpcRequest \u003d\n+            request.getValue(RequestHeaderProto.getDefaultInstance());\n         String methodName \u003d rpcRequest.getMethodName();\n-        \n-        \n+\n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n-        Message param \u003d prototype.newBuilderForType()\n-            .mergeFrom(request.theRequestRead).build();\n-        \n+        Message param \u003d request.getValue(prototype);\n+\n         Message result;\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                 \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n           server.updateMetrics(detailedMetricsName, qTime, processingTime);\n         }\n-        return new RpcResponseWrapper(result);\n+        return RpcWritable.wrap(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcWritable.Buffer request \u003d (RpcWritable.Buffer) writableRequest;\n        RequestHeaderProto rpcRequest \u003d\n            request.getValue(RequestHeaderProto.getDefaultInstance());\n        String methodName \u003d rpcRequest.getMethodName();\n\n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d request.getValue(prototype);\n\n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n        }\n        return RpcWritable.wrap(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12916. Allow RPC scheduler/callqueue backoff using response times. Contributed by Xiaoyu Yao.\n",
      "commitDate": "31/03/16 8:42 AM",
      "commitName": "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "28/09/15 7:42 AM",
      "commitNameOld": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 185.04,
      "commitsBetweenForRepo": 1240,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,75 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.requestHeader;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(request.theRequestRead).build();\n         \n         Message result;\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                 \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n-          server.rpcMetrics.addRpcQueueTime(qTime);\n-          server.rpcMetrics.addRpcProcessingTime(processingTime);\n-          server.rpcDetailedMetrics.addProcessingTime(detailedMetricsName,\n-              processingTime);\n-          if (server.isLogSlowRPC()) {\n-            server.logSlowRpcCalls(methodName, processingTime);\n-          }\n+          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n         }\n         return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(request.theRequestRead).build();\n        \n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "48774d0a45d95557affbd6bbaf8035cc9575ef36": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12325. RPC Metrics : Add the ability track and log slow RPCs. Contributed by Anu Engineer\n",
      "commitDate": "24/08/15 2:31 PM",
      "commitName": "48774d0a45d95557affbd6bbaf8035cc9575ef36",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "20/07/15 5:13 AM",
      "commitNameOld": "a9431425d1aff657fc1ea501c706235f2ebc518f",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 35.39,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,81 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.requestHeader;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(request.theRequestRead).build();\n         \n         Message result;\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime - receiveTime);\n         Exception exception \u003d null;\n         try {\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n         } catch (ServiceException e) {\n           exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           exception \u003d e;\n           throw e;\n         } finally {\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                 \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               methodName :\n               exception.getClass().getSimpleName();\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(detailedMetricsName,\n               processingTime);\n+          if (server.isLogSlowRPC()) {\n+            server.logSlowRpcCalls(methodName, processingTime);\n+          }\n         }\n         return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(request.theRequestRead).build();\n        \n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(detailedMetricsName,\n              processingTime);\n          if (server.isLogSlowRPC()) {\n            server.logSlowRpcCalls(methodName, processingTime);\n          }\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "790ee456439729073d75ccf91e1f63b3d360b1c7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10673. Update rpc metrics when the call throws an exception. Contributed by Ming Ma.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610879 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/14 4:05 PM",
      "commitName": "790ee456439729073d75ccf91e1f63b3d360b1c7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "22/07/13 12:22 AM",
      "commitNameOld": "3eb61be352589491117ac2781bb18f55988a8084",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 358.66,
      "commitsBetweenForRepo": 2384,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,78 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.requestHeader;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(request.theRequestRead).build();\n         \n         Message result;\n+        long startTime \u003d Time.now();\n+        int qTime \u003d (int) (startTime - receiveTime);\n+        Exception exception \u003d null;\n         try {\n-          long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n-          int processingTime \u003d (int) (Time.now() - startTime);\n-          int qTime \u003d (int) (startTime - receiveTime);\n-          if (LOG.isDebugEnabled()) {\n-            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n-                      \" procesingTime\u003d \" + processingTime);\n-          }\n-          server.rpcMetrics.addRpcQueueTime(qTime);\n-          server.rpcMetrics.addRpcProcessingTime(processingTime);\n-          server.rpcDetailedMetrics.addProcessingTime(methodName,\n-              processingTime);\n         } catch (ServiceException e) {\n+          exception \u003d (Exception) e.getCause();\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n+          exception \u003d e;\n           throw e;\n+        } finally {\n+          int processingTime \u003d (int) (Time.now() - startTime);\n+          if (LOG.isDebugEnabled()) {\n+            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n+                \" procesingTime\u003d \" + processingTime;\n+            if (exception !\u003d null) {\n+              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n+            }\n+            LOG.debug(msg);\n+          }\n+          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n+              methodName :\n+              exception.getClass().getSimpleName();\n+          server.rpcMetrics.addRpcQueueTime(qTime);\n+          server.rpcMetrics.addRpcProcessingTime(processingTime);\n+          server.rpcDetailedMetrics.addProcessingTime(detailedMetricsName,\n+              processingTime);\n         }\n         return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(request.theRequestRead).build();\n        \n        Message result;\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime - receiveTime);\n        Exception exception \u003d null;\n        try {\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          exception \u003d (Exception) e.getCause();\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          exception \u003d e;\n          throw e;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              methodName :\n              exception.getClass().getSimpleName();\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(detailedMetricsName,\n              processingTime);\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "725623534ce7ab20c28af6e0cdf57bd7278551dd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9425 Add error codes to rpc-response (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/13 10:51 AM",
      "commitName": "725623534ce7ab20c28af6e0cdf57bd7278551dd",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "21/03/13 9:41 AM",
      "commitNameOld": "357472001725e786f28b27560bac8aca54c3c983",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 44.05,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n         RequestHeaderProto rpcRequest \u003d request.requestHeader;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n-          throw new RpcServerException(msg);\n+          throw new RpcNoSuchMethodException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(request.theRequestRead).build();\n         \n         Message result;\n         try {\n           long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (Time.now() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcNoSuchMethodException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(request.theRequestRead).build();\n        \n        Message result;\n        try {\n          long startTime \u003d Time.now();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9163 The rpc msg in ProtobufRpcEngine.proto should be moved out to avoid an extra copy (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1452581 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 2:55 PM",
      "commitName": "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "14/02/13 6:26 PM",
      "commitNameOld": "461e614a3aa11372d18537028aa217a9d79527af",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 17.85,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n-        RequestProto rpcRequest \u003d request.message;\n+        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n-            .mergeFrom(rpcRequest.getRequest()).build();\n+            .mergeFrom(request.theRequestRead).build();\n+        \n         Message result;\n         try {\n           long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (Time.now() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestHeaderProto rpcRequest \u003d request.requestHeader;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(request.theRequestRead).build();\n        \n        Message result;\n        try {\n          long startTime \u003d Time.now();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "461e614a3aa11372d18537028aa217a9d79527af": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9218 Document the Rpc-wrappers used internally (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1446428 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/13 6:26 PM",
      "commitName": "461e614a3aa11372d18537028aa217a9d79527af",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "17/12/12 2:16 PM",
      "commitNameOld": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 59.17,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n-        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n+        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n         RequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (Time.now() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n-        return new RpcResponseWritable(result);\n+        return new RpcResponseWrapper(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWrapper request \u003d (RpcRequestWrapper) writableRequest;\n        RequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d Time.now();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWrapper(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9140 Cleanup rpc PB protos (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/12 2:16 PM",
      "commitName": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 114.88,
      "commitsBetweenForRepo": 607,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n-        HadoopRpcRequestProto rpcRequest \u003d request.message;\n+        RequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (Time.now() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        RequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d Time.now();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "02/07/12 3:15 PM",
      "commitNameOld": "22822df7c3d08f157cf268b907083d0782d3fa67",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 9.87,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n       public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         \n         \n         /** \n          * RPCs for a particular interface (ie protocol) are done using a\n          * IPC connection that is setup using rpcProxy.\n          * The rpcProxy\u0027s has a declared protocol name that is \n          * sent form client to server at connection time. \n          * \n          * Each Rpc call also sends a protocol name \n          * (called declaringClassprotocolName). This name is usually the same\n          * as the connection protocol name except in some cases. \n          * For example metaProtocols such ProtocolInfoProto which get info\n          * about the protocol reuse the connection but need to indicate that\n          * the actual protocol is different (i.e. the protocol is\n          * ProtocolInfoProto) since they reuse the connection; in this case\n          * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n          */\n \n         String declaringClassProtoName \u003d \n             rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n               \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                               declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                 + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n-          long startTime \u003d System.currentTimeMillis();\n+          long startTime \u003d Time.now();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n-          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n+          int processingTime \u003d (int) (Time.now() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d Time.now();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (Time.now() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "266a0f1de9811d031c6f56ff32185d65c5a9aaa0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-8367 Improve documentation of declaringClassProtocolName in rpc headers (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1342051 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/12 2:16 PM",
      "commitName": "266a0f1de9811d031c6f56ff32185d65c5a9aaa0",
      "commitAuthor": "Sanjay Radia",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-8367 Improve documentation of declaringClassProtocolName in rpc headers (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1342051 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/05/12 2:16 PM",
          "commitName": "266a0f1de9811d031c6f56ff32185d65c5a9aaa0",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "23/04/12 9:34 AM",
          "commitNameOld": "589c68ae09effd6c4f26505d61636f779c22e99f",
          "commitAuthorOld": "Sanjay Radia",
          "daysBetweenCommits": 30.2,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,66 @@\n-      public Writable call(RPC.Server server, String protocol,\n+      public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n-        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n+        \n+        \n+        /** \n+         * RPCs for a particular interface (ie protocol) are done using a\n+         * IPC connection that is setup using rpcProxy.\n+         * The rpcProxy\u0027s has a declared protocol name that is \n+         * sent form client to server at connection time. \n+         * \n+         * Each Rpc call also sends a protocol name \n+         * (called declaringClassprotocolName). This name is usually the same\n+         * as the connection protocol name except in some cases. \n+         * For example metaProtocols such ProtocolInfoProto which get info\n+         * about the protocol reuse the connection but need to indicate that\n+         * the actual protocol is different (i.e. the protocol is\n+         * ProtocolInfoProto) since they reuse the connection; in this case\n+         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n+         */\n+\n+        String declaringClassProtoName \u003d \n+            rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n-          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n+          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n+              \", method\u003d\" + methodName);\n         \n-        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n-            clientVersion);\n+        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n+                              declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n-          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n-              + \" protocol.\";\n+          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n+                                + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d System.currentTimeMillis();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d System.currentTimeMillis();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[server-RPC.Server, protocol-String, writableRequest-Writable, receiveTime-long]",
            "newValue": "[server-RPC.Server, connectionProtocolName-String, writableRequest-Writable, receiveTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-8367 Improve documentation of declaringClassProtocolName in rpc headers (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1342051 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/05/12 2:16 PM",
          "commitName": "266a0f1de9811d031c6f56ff32185d65c5a9aaa0",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "23/04/12 9:34 AM",
          "commitNameOld": "589c68ae09effd6c4f26505d61636f779c22e99f",
          "commitAuthorOld": "Sanjay Radia",
          "daysBetweenCommits": 30.2,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,66 @@\n-      public Writable call(RPC.Server server, String protocol,\n+      public Writable call(RPC.Server server, String connectionProtocolName,\n           Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n-        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n+        \n+        \n+        /** \n+         * RPCs for a particular interface (ie protocol) are done using a\n+         * IPC connection that is setup using rpcProxy.\n+         * The rpcProxy\u0027s has a declared protocol name that is \n+         * sent form client to server at connection time. \n+         * \n+         * Each Rpc call also sends a protocol name \n+         * (called declaringClassprotocolName). This name is usually the same\n+         * as the connection protocol name except in some cases. \n+         * For example metaProtocols such ProtocolInfoProto which get info\n+         * about the protocol reuse the connection but need to indicate that\n+         * the actual protocol is different (i.e. the protocol is\n+         * ProtocolInfoProto) since they reuse the connection; in this case\n+         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n+         */\n+\n+        String declaringClassProtoName \u003d \n+            rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n-          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n+          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n+              \", method\u003d\" + methodName);\n         \n-        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n-            clientVersion);\n+        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n+                              declaringClassProtoName, clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n-          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n-              + \" protocol.\";\n+          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n+                                + connectionProtocolName + \" protocol.\";\n           LOG.warn(msg);\n           throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d System.currentTimeMillis();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n           throw (Exception) e.getCause();\n         } catch (Exception e) {\n           throw e;\n         }\n         return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String connectionProtocolName,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        \n        \n        /** \n         * RPCs for a particular interface (ie protocol) are done using a\n         * IPC connection that is setup using rpcProxy.\n         * The rpcProxy\u0027s has a declared protocol name that is \n         * sent form client to server at connection time. \n         * \n         * Each Rpc call also sends a protocol name \n         * (called declaringClassprotocolName). This name is usually the same\n         * as the connection protocol name except in some cases. \n         * For example metaProtocols such ProtocolInfoProto which get info\n         * about the protocol reuse the connection but need to indicate that\n         * the actual protocol is different (i.e. the protocol is\n         * ProtocolInfoProto) since they reuse the connection; in this case\n         * the declaringClassProtocolName field is set to the ProtocolInfoProto.\n         */\n\n        String declaringClassProtoName \u003d \n            rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: connectionProtocolName\u003d\" + connectionProtocolName + \n              \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, \n                              declaringClassProtoName, clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" \n                                + connectionProtocolName + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d System.currentTimeMillis();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        }
      ]
    },
    "081eda94fec4bbf321047c93a9bb40be678b1666": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-8184.  ProtoBuf RPC engine uses the IPC layer reply packet.  Contributed by Sanjay Radia\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/03/12 11:21 AM",
      "commitName": "081eda94fec4bbf321047c93a9bb40be678b1666",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-8184.  ProtoBuf RPC engine uses the IPC layer reply packet.  Contributed by Sanjay Radia\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304542 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/03/12 11:21 AM",
          "commitName": "081eda94fec4bbf321047c93a9bb40be678b1666",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "23/02/12 8:05 PM",
          "commitNameOld": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
          "commitAuthorOld": "Suresh Srinivas",
          "daysBetweenCommits": 28.59,
          "commitsBetweenForRepo": 193,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,46 @@\n       public Writable call(RPC.Server server, String protocol,\n-          Writable writableRequest, long receiveTime) throws IOException {\n+          Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n             clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n               + \" protocol.\";\n           LOG.warn(msg);\n-          return handleException(new RpcServerException(msg));\n+          throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d System.currentTimeMillis();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n-          Throwable cause \u003d e.getCause();\n-          return handleException(cause !\u003d null ? cause : e);\n+          throw (Exception) e.getCause();\n         } catch (Exception e) {\n-          return handleException(e);\n+          throw e;\n         }\n-  \n-        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n-        return new RpcResponseWritable(response);\n+        return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String protocol,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n            clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n              + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d System.currentTimeMillis();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-8184.  ProtoBuf RPC engine uses the IPC layer reply packet.  Contributed by Sanjay Radia\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304542 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/03/12 11:21 AM",
          "commitName": "081eda94fec4bbf321047c93a9bb40be678b1666",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "23/02/12 8:05 PM",
          "commitNameOld": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
          "commitAuthorOld": "Suresh Srinivas",
          "daysBetweenCommits": 28.59,
          "commitsBetweenForRepo": 193,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,46 @@\n       public Writable call(RPC.Server server, String protocol,\n-          Writable writableRequest, long receiveTime) throws IOException {\n+          Writable writableRequest, long receiveTime) throws Exception {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n         \n         ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n             clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n               + \" protocol.\";\n           LOG.warn(msg);\n-          return handleException(new RpcServerException(msg));\n+          throw new RpcServerException(msg);\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n           long startTime \u003d System.currentTimeMillis();\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n           int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n           int qTime \u003d (int) (startTime - receiveTime);\n           if (LOG.isDebugEnabled()) {\n             LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                       \" procesingTime\u003d \" + processingTime);\n           }\n           server.rpcMetrics.addRpcQueueTime(qTime);\n           server.rpcMetrics.addRpcProcessingTime(processingTime);\n           server.rpcDetailedMetrics.addProcessingTime(methodName,\n               processingTime);\n         } catch (ServiceException e) {\n-          Throwable cause \u003d e.getCause();\n-          return handleException(cause !\u003d null ? cause : e);\n+          throw (Exception) e.getCause();\n         } catch (Exception e) {\n-          return handleException(e);\n+          throw e;\n         }\n-  \n-        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n-        return new RpcResponseWritable(response);\n+        return new RpcResponseWritable(result);\n       }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String protocol,\n          Writable writableRequest, long receiveTime) throws Exception {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n            clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n              + \" protocol.\";\n          LOG.warn(msg);\n          throw new RpcServerException(msg);\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d System.currentTimeMillis();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          throw (Exception) e.getCause();\n        } catch (Exception e) {\n          throw e;\n        }\n        return new RpcResponseWritable(result);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        }
      ]
    },
    "22d5944c42b4bef5144a9f6426751b15717c5a3e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8085. Add RPC metrics to ProtobufRpcEngine. Contributed by Hari Mankude.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293071 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/02/12 8:05 PM",
      "commitName": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "20/02/12 9:19 PM",
      "commitNameOld": "ae7e43139dda16c501f6d7606f04d631e0a23c3e",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,49 @@\n       public Writable call(RPC.Server server, String protocol,\n           Writable writableRequest, long receiveTime) throws IOException {\n         RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n         HadoopRpcRequestProto rpcRequest \u003d request.message;\n         String methodName \u003d rpcRequest.getMethodName();\n         String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n         long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n         if (server.verbose)\n           LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n         \n-        ProtoNameVer pv \u003d new ProtoNameVer(protoName, clientVersion);\n-        ProtoClassProtoImpl protocolImpl \u003d \n-            server.getProtocolImplMap(RpcKind.RPC_PROTOCOL_BUFFER).get(pv);\n-        if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n-          VerProtocolImpl highest \u003d \n-              server.getHighestSupportedProtocol(RpcKind.RPC_PROTOCOL_BUFFER, \n-                  protoName);\n-          if (highest \u003d\u003d null) {\n-            throw new IOException(\"Unknown protocol: \" + protoName);\n-          }\n-          // protocol supported but not the version that client wants\n-          throw new RPC.VersionMismatch(protoName, clientVersion,\n-              highest.version);\n-        }\n-        \n+        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n+            clientVersion);\n         BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n         MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n             .findMethodByName(methodName);\n         if (methodDescriptor \u003d\u003d null) {\n           String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n               + \" protocol.\";\n           LOG.warn(msg);\n           return handleException(new RpcServerException(msg));\n         }\n         Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n         Message param \u003d prototype.newBuilderForType()\n             .mergeFrom(rpcRequest.getRequest()).build();\n         Message result;\n         try {\n+          long startTime \u003d System.currentTimeMillis();\n+          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n+          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n+          int qTime \u003d (int) (startTime - receiveTime);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n+                      \" procesingTime\u003d \" + processingTime);\n+          }\n+          server.rpcMetrics.addRpcQueueTime(qTime);\n+          server.rpcMetrics.addRpcProcessingTime(processingTime);\n+          server.rpcDetailedMetrics.addProcessingTime(methodName,\n+              processingTime);\n         } catch (ServiceException e) {\n           Throwable cause \u003d e.getCause();\n           return handleException(cause !\u003d null ? cause : e);\n         } catch (Exception e) {\n           return handleException(e);\n         }\n   \n         HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n         return new RpcResponseWritable(response);\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(RPC.Server server, String protocol,\n          Writable writableRequest, long receiveTime) throws IOException {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n        \n        ProtoClassProtoImpl protocolImpl \u003d getProtocolImpl(server, protoName,\n            clientVersion);\n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n              + \" protocol.\";\n          LOG.warn(msg);\n          return handleException(new RpcServerException(msg));\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          long startTime \u003d System.currentTimeMillis();\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n          int processingTime \u003d (int) (System.currentTimeMillis() - startTime);\n          int qTime \u003d (int) (startTime - receiveTime);\n          if (LOG.isDebugEnabled()) {\n            LOG.info(\"Served: \" + methodName + \" queueTime\u003d \" + qTime +\n                      \" procesingTime\u003d \" + processingTime);\n          }\n          server.rpcMetrics.addRpcQueueTime(qTime);\n          server.rpcMetrics.addRpcProcessingTime(processingTime);\n          server.rpcDetailedMetrics.addProcessingTime(methodName,\n              processingTime);\n        } catch (ServiceException e) {\n          Throwable cause \u003d e.getCause();\n          return handleException(cause !\u003d null ? cause : e);\n        } catch (Exception e) {\n          return handleException(e);\n        }\n  \n        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n        return new RpcResponseWritable(response);\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "65200998c01b17e017d1814e8b1f4d82ac334a23": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/11 12:44 PM",
      "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthor": "Sanjay Radia",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/11 12:44 PM",
          "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "04/11/11 10:06 PM",
          "commitNameOld": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
          "commitAuthorOld": "Sanjay Radia",
          "daysBetweenCommits": 29.65,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-    public Writable call(String protocol, Writable writableRequest,\n-        long receiveTime) throws IOException {\n-      RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n-      HadoopRpcRequestProto rpcRequest \u003d request.message;\n-      String methodName \u003d rpcRequest.getMethodName();\n-      if (verbose)\n-        LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n-      MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n-          .findMethodByName(methodName);\n-      if (methodDescriptor \u003d\u003d null) {\n-        String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n-            + \" protocol.\";\n-        LOG.warn(msg);\n-        return handleException(new RpcServerException(msg));\n-      }\n-      Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n-      Message param \u003d prototype.newBuilderForType()\n-          .mergeFrom(rpcRequest.getRequest()).build();\n-      Message result;\n-      try {\n-        result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n-      } catch (ServiceException e) {\n-        Throwable cause \u003d e.getCause();\n-        return handleException(cause !\u003d null ? cause : e);\n-      } catch (Exception e) {\n-        return handleException(e);\n-      }\n-\n-      HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n-      return new RpcResponseWritable(response);\n-    }\n\\ No newline at end of file\n+      public Writable call(RPC.Server server, String protocol,\n+          Writable writableRequest, long receiveTime) throws IOException {\n+        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n+        HadoopRpcRequestProto rpcRequest \u003d request.message;\n+        String methodName \u003d rpcRequest.getMethodName();\n+        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n+        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n+        if (server.verbose)\n+          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n+        \n+        ProtoNameVer pv \u003d new ProtoNameVer(protoName, clientVersion);\n+        ProtoClassProtoImpl protocolImpl \u003d \n+            server.getProtocolImplMap(RpcKind.RPC_PROTOCOL_BUFFER).get(pv);\n+        if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n+          VerProtocolImpl highest \u003d \n+              server.getHighestSupportedProtocol(RpcKind.RPC_PROTOCOL_BUFFER, \n+                  protoName);\n+          if (highest \u003d\u003d null) {\n+            throw new IOException(\"Unknown protocol: \" + protoName);\n+          }\n+          // protocol supported but not the version that client wants\n+          throw new RPC.VersionMismatch(protoName, clientVersion,\n+              highest.version);\n+        }\n+        \n+        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n+        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n+            .findMethodByName(methodName);\n+        if (methodDescriptor \u003d\u003d null) {\n+          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n+              + \" protocol.\";\n+          LOG.warn(msg);\n+          return handleException(new RpcServerException(msg));\n+        }\n+        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n+        Message param \u003d prototype.newBuilderForType()\n+            .mergeFrom(rpcRequest.getRequest()).build();\n+        Message result;\n+        try {\n+          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n+        } catch (ServiceException e) {\n+          Throwable cause \u003d e.getCause();\n+          return handleException(cause !\u003d null ? cause : e);\n+        } catch (Exception e) {\n+          return handleException(e);\n+        }\n+  \n+        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n+        return new RpcResponseWritable(response);\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String protocol,\n          Writable writableRequest, long receiveTime) throws IOException {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n        \n        ProtoNameVer pv \u003d new ProtoNameVer(protoName, clientVersion);\n        ProtoClassProtoImpl protocolImpl \u003d \n            server.getProtocolImplMap(RpcKind.RPC_PROTOCOL_BUFFER).get(pv);\n        if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n          VerProtocolImpl highest \u003d \n              server.getHighestSupportedProtocol(RpcKind.RPC_PROTOCOL_BUFFER, \n                  protoName);\n          if (highest \u003d\u003d null) {\n            throw new IOException(\"Unknown protocol: \" + protoName);\n          }\n          // protocol supported but not the version that client wants\n          throw new RPC.VersionMismatch(protoName, clientVersion,\n              highest.version);\n        }\n        \n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n              + \" protocol.\";\n          LOG.warn(msg);\n          return handleException(new RpcServerException(msg));\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          Throwable cause \u003d e.getCause();\n          return handleException(cause !\u003d null ? cause : e);\n        } catch (Exception e) {\n          return handleException(e);\n        }\n  \n        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n        return new RpcResponseWritable(response);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[protocol-String, writableRequest-Writable, receiveTime-long]",
            "newValue": "[server-RPC.Server, protocol-String, writableRequest-Writable, receiveTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-7862  Move the support for multiple protocols to lower layer so that Writable, PB and Avro can all use it (includes HDFS and MR changes to match) (Sanjay) \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1210208 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/11 12:44 PM",
          "commitName": "65200998c01b17e017d1814e8b1f4d82ac334a23",
          "commitAuthor": "Sanjay Radia",
          "commitDateOld": "04/11/11 10:06 PM",
          "commitNameOld": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
          "commitAuthorOld": "Sanjay Radia",
          "daysBetweenCommits": 29.65,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,50 @@\n-    public Writable call(String protocol, Writable writableRequest,\n-        long receiveTime) throws IOException {\n-      RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n-      HadoopRpcRequestProto rpcRequest \u003d request.message;\n-      String methodName \u003d rpcRequest.getMethodName();\n-      if (verbose)\n-        LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n-      MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n-          .findMethodByName(methodName);\n-      if (methodDescriptor \u003d\u003d null) {\n-        String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n-            + \" protocol.\";\n-        LOG.warn(msg);\n-        return handleException(new RpcServerException(msg));\n-      }\n-      Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n-      Message param \u003d prototype.newBuilderForType()\n-          .mergeFrom(rpcRequest.getRequest()).build();\n-      Message result;\n-      try {\n-        result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n-      } catch (ServiceException e) {\n-        Throwable cause \u003d e.getCause();\n-        return handleException(cause !\u003d null ? cause : e);\n-      } catch (Exception e) {\n-        return handleException(e);\n-      }\n-\n-      HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n-      return new RpcResponseWritable(response);\n-    }\n\\ No newline at end of file\n+      public Writable call(RPC.Server server, String protocol,\n+          Writable writableRequest, long receiveTime) throws IOException {\n+        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n+        HadoopRpcRequestProto rpcRequest \u003d request.message;\n+        String methodName \u003d rpcRequest.getMethodName();\n+        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n+        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n+        if (server.verbose)\n+          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n+        \n+        ProtoNameVer pv \u003d new ProtoNameVer(protoName, clientVersion);\n+        ProtoClassProtoImpl protocolImpl \u003d \n+            server.getProtocolImplMap(RpcKind.RPC_PROTOCOL_BUFFER).get(pv);\n+        if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n+          VerProtocolImpl highest \u003d \n+              server.getHighestSupportedProtocol(RpcKind.RPC_PROTOCOL_BUFFER, \n+                  protoName);\n+          if (highest \u003d\u003d null) {\n+            throw new IOException(\"Unknown protocol: \" + protoName);\n+          }\n+          // protocol supported but not the version that client wants\n+          throw new RPC.VersionMismatch(protoName, clientVersion,\n+              highest.version);\n+        }\n+        \n+        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n+        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n+            .findMethodByName(methodName);\n+        if (methodDescriptor \u003d\u003d null) {\n+          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n+              + \" protocol.\";\n+          LOG.warn(msg);\n+          return handleException(new RpcServerException(msg));\n+        }\n+        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n+        Message param \u003d prototype.newBuilderForType()\n+            .mergeFrom(rpcRequest.getRequest()).build();\n+        Message result;\n+        try {\n+          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n+        } catch (ServiceException e) {\n+          Throwable cause \u003d e.getCause();\n+          return handleException(cause !\u003d null ? cause : e);\n+        } catch (Exception e) {\n+          return handleException(e);\n+        }\n+  \n+        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n+        return new RpcResponseWritable(response);\n+      }\n\\ No newline at end of file\n",
          "actualSource": "      public Writable call(RPC.Server server, String protocol,\n          Writable writableRequest, long receiveTime) throws IOException {\n        RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n        HadoopRpcRequestProto rpcRequest \u003d request.message;\n        String methodName \u003d rpcRequest.getMethodName();\n        String protoName \u003d rpcRequest.getDeclaringClassProtocolName();\n        long clientVersion \u003d rpcRequest.getClientProtocolVersion();\n        if (server.verbose)\n          LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n        \n        ProtoNameVer pv \u003d new ProtoNameVer(protoName, clientVersion);\n        ProtoClassProtoImpl protocolImpl \u003d \n            server.getProtocolImplMap(RpcKind.RPC_PROTOCOL_BUFFER).get(pv);\n        if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n          VerProtocolImpl highest \u003d \n              server.getHighestSupportedProtocol(RpcKind.RPC_PROTOCOL_BUFFER, \n                  protoName);\n          if (highest \u003d\u003d null) {\n            throw new IOException(\"Unknown protocol: \" + protoName);\n          }\n          // protocol supported but not the version that client wants\n          throw new RPC.VersionMismatch(protoName, clientVersion,\n              highest.version);\n        }\n        \n        BlockingService service \u003d (BlockingService) protocolImpl.protocolImpl;\n        MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n            .findMethodByName(methodName);\n        if (methodDescriptor \u003d\u003d null) {\n          String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n              + \" protocol.\";\n          LOG.warn(msg);\n          return handleException(new RpcServerException(msg));\n        }\n        Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n        Message param \u003d prototype.newBuilderForType()\n            .mergeFrom(rpcRequest.getRequest()).build();\n        Message result;\n        try {\n          result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n        } catch (ServiceException e) {\n          Throwable cause \u003d e.getCause();\n          return handleException(cause !\u003d null ? cause : e);\n        } catch (Exception e) {\n          return handleException(e);\n        }\n  \n        HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n        return new RpcResponseWritable(response);\n      }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        }
      ]
    },
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7773. Add support for protocol buffer based RPC engine. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 2:55 PM",
      "commitName": "55d3dc50d16cd5b94f542f74e5329de4c30a8655",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,31 @@\n+    public Writable call(String protocol, Writable writableRequest,\n+        long receiveTime) throws IOException {\n+      RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n+      HadoopRpcRequestProto rpcRequest \u003d request.message;\n+      String methodName \u003d rpcRequest.getMethodName();\n+      if (verbose)\n+        LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n+      MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n+          .findMethodByName(methodName);\n+      if (methodDescriptor \u003d\u003d null) {\n+        String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n+            + \" protocol.\";\n+        LOG.warn(msg);\n+        return handleException(new RpcServerException(msg));\n+      }\n+      Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n+      Message param \u003d prototype.newBuilderForType()\n+          .mergeFrom(rpcRequest.getRequest()).build();\n+      Message result;\n+      try {\n+        result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n+      } catch (ServiceException e) {\n+        Throwable cause \u003d e.getCause();\n+        return handleException(cause !\u003d null ? cause : e);\n+      } catch (Exception e) {\n+        return handleException(e);\n+      }\n+\n+      HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n+      return new RpcResponseWritable(response);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Writable call(String protocol, Writable writableRequest,\n        long receiveTime) throws IOException {\n      RpcRequestWritable request \u003d (RpcRequestWritable) writableRequest;\n      HadoopRpcRequestProto rpcRequest \u003d request.message;\n      String methodName \u003d rpcRequest.getMethodName();\n      if (verbose)\n        LOG.info(\"Call: protocol\u003d\" + protocol + \", method\u003d\" + methodName);\n      MethodDescriptor methodDescriptor \u003d service.getDescriptorForType()\n          .findMethodByName(methodName);\n      if (methodDescriptor \u003d\u003d null) {\n        String msg \u003d \"Unknown method \" + methodName + \" called on \" + protocol\n            + \" protocol.\";\n        LOG.warn(msg);\n        return handleException(new RpcServerException(msg));\n      }\n      Message prototype \u003d service.getRequestPrototype(methodDescriptor);\n      Message param \u003d prototype.newBuilderForType()\n          .mergeFrom(rpcRequest.getRequest()).build();\n      Message result;\n      try {\n        result \u003d service.callBlockingMethod(methodDescriptor, null, param);\n      } catch (ServiceException e) {\n        Throwable cause \u003d e.getCause();\n        return handleException(cause !\u003d null ? cause : e);\n      } catch (Exception e) {\n        return handleException(e);\n      }\n\n      HadoopRpcResponseProto response \u003d constructProtoSpecificRpcSuccessResponse(result);\n      return new RpcResponseWritable(response);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java"
    }
  }
}