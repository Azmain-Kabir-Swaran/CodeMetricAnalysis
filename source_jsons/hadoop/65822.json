{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "put",
  "functionId": "put___meta-DirListingMetadata(modifiers-final)__unchangedEntries-List__Path__(modifiers-final)__operationState-BulkOperationState(annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 1456,
  "functionEndLine": 1495,
  "numCommitsSeen": 109,
  "timeTaken": 7391,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43",
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Ymultichange(Yparameterchange,Ybodychange)",
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ybodychange",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
          "commitDate": "25/01/20 10:35 AM",
          "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "23/01/20 5:21 AM",
          "commitNameOld": "6c1fa24ac02b82b5e267dc966e34fb7d4f9556db",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 2.22,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,40 @@\n   public void put(\n       final DirListingMetadata meta,\n+      final List\u003cPath\u003e unchangedEntries,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n         meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n         meta.getPath(),\n         tableName, region, meta);\n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n     // put all its ancestors if not present\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n     final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n         ancestorState);\n \n-    // next add all children of the directory\n-    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n+    // next add all changed children of the directory\n+    // ones that came from the previous listing are left as-is\n+    final Collection\u003cPathMetadata\u003e children \u003d meta.getListing()\n+        .stream()\n+        .filter(e -\u003e !unchangedEntries.contains(e.getFileStatus().getPath()))\n+        .collect(Collectors.toList());\n+\n+    metasToPut.addAll(pathMetaToDDBPathMeta(children));\n \n     // sort so highest-level entries are written to the store first.\n     // if a sequence fails, no orphan entries will have been written.\n     metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(ancestorState,\n         null,\n         pathMetadataToItem(metasToPut));\n     // and add the ancestors\n     synchronized (ancestorState) {\n       metasToPut.forEach(ancestorState::put);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      final List\u003cPath\u003e unchangedEntries,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n        meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n        meta.getPath(),\n        tableName, region, meta);\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all changed children of the directory\n    // ones that came from the previous listing are left as-is\n    final Collection\u003cPathMetadata\u003e children \u003d meta.getListing()\n        .stream()\n        .filter(e -\u003e !unchangedEntries.contains(e.getFileStatus().getPath()))\n        .collect(Collectors.toList());\n\n    metasToPut.addAll(pathMetaToDDBPathMeta(children));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(ancestorState,\n        null,\n        pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[meta-DirListingMetadata(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]",
            "newValue": "[meta-DirListingMetadata(modifiers-final), unchangedEntries-List\u003cPath\u003e(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
          "commitDate": "25/01/20 10:35 AM",
          "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "23/01/20 5:21 AM",
          "commitNameOld": "6c1fa24ac02b82b5e267dc966e34fb7d4f9556db",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 2.22,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,40 @@\n   public void put(\n       final DirListingMetadata meta,\n+      final List\u003cPath\u003e unchangedEntries,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n         meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n         meta.getPath(),\n         tableName, region, meta);\n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n     // put all its ancestors if not present\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n     final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n         ancestorState);\n \n-    // next add all children of the directory\n-    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n+    // next add all changed children of the directory\n+    // ones that came from the previous listing are left as-is\n+    final Collection\u003cPathMetadata\u003e children \u003d meta.getListing()\n+        .stream()\n+        .filter(e -\u003e !unchangedEntries.contains(e.getFileStatus().getPath()))\n+        .collect(Collectors.toList());\n+\n+    metasToPut.addAll(pathMetaToDDBPathMeta(children));\n \n     // sort so highest-level entries are written to the store first.\n     // if a sequence fails, no orphan entries will have been written.\n     metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(ancestorState,\n         null,\n         pathMetadataToItem(metasToPut));\n     // and add the ancestors\n     synchronized (ancestorState) {\n       metasToPut.forEach(ancestorState::put);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      final List\u003cPath\u003e unchangedEntries,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n        meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n        meta.getPath(),\n        tableName, region, meta);\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all changed children of the directory\n    // ones that came from the previous listing are left as-is\n    final Collection\u003cPathMetadata\u003e children \u003d meta.getListing()\n        .stream()\n        .filter(e -\u003e !unchangedEntries.contains(e.getFileStatus().getPath()))\n        .collect(Collectors.toList());\n\n    metasToPut.addAll(pathMetaToDDBPathMeta(children));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(ancestorState,\n        null,\n        pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/11/19 7:36 AM",
      "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 44.82,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n   public void put(\n       final DirListingMetadata meta,\n       @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n-        tableName,\n         meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n         meta.getPath(),\n         tableName, region, meta);\n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n     // put all its ancestors if not present\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n     final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n         ancestorState);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n     // sort so highest-level entries are written to the store first.\n     // if a sequence fails, no orphan entries will have been written.\n     metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(ancestorState,\n         null,\n         pathMetadataToItem(metasToPut));\n     // and add the ancestors\n     synchronized (ancestorState) {\n       metasToPut.forEach(ancestorState::put);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n        meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n        meta.getPath(),\n        tableName, region, meta);\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(ancestorState,\n        null,\n        pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "08/07/19 10:27 AM",
      "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,34 @@\n   public void put(\n       final DirListingMetadata meta,\n       @Nullable final BulkOperationState operationState) throws IOException {\n-    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n-\n+    LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n+        tableName,\n+        meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n+        meta.getPath(),\n+        tableName, region, meta);\n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n-    // put all its ancestors if not present; as an optimization we return at its\n-    // first existent ancestor\n+    // put all its ancestors if not present\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n     final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n         ancestorState);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n     // sort so highest-level entries are written to the store first.\n     // if a sequence fails, no orphan entries will have been written.\n     metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n-    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n+    processBatchWriteRequest(ancestorState,\n+        null,\n+        pathMetadataToItem(metasToPut));\n     // and add the ancestors\n     synchronized (ancestorState) {\n       metasToPut.forEach(ancestorState::put);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving {} dir meta for {} to table {} in region {}: {}\",\n        tableName,\n        meta.isAuthoritative() ? \"auth\" : \"nonauth\",\n        meta.getPath(),\n        tableName, region, meta);\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(ancestorState,\n        null,\n        pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,30 @@\n-  public void put(DirListingMetadata meta) throws IOException {\n+  public void put(\n+      final DirListingMetadata meta,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n-\n+    // put all its ancestors if not present; as an optimization we return at its\n+    // first existent ancestor\n+    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n-    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n+    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n+        ancestorState);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n+    // sort so highest-level entries are written to the store first.\n+    // if a sequence fails, no orphan entries will have been written.\n+    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n+    // and add the ancestors\n+    synchronized (ancestorState) {\n+      metasToPut.forEach(ancestorState::put);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present; as an optimization we return at its\n    // first existent ancestor\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[meta-DirListingMetadata]",
            "newValue": "[meta-DirListingMetadata(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,30 @@\n-  public void put(DirListingMetadata meta) throws IOException {\n+  public void put(\n+      final DirListingMetadata meta,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n-\n+    // put all its ancestors if not present; as an optimization we return at its\n+    // first existent ancestor\n+    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n-    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n+    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n+        ancestorState);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n+    // sort so highest-level entries are written to the store first.\n+    // if a sequence fails, no orphan entries will have been written.\n+    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n+    // and add the ancestors\n+    synchronized (ancestorState) {\n+      metasToPut.forEach(ancestorState::put);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present; as an optimization we return at its\n    // first existent ancestor\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,30 @@\n-  public void put(DirListingMetadata meta) throws IOException {\n+  public void put(\n+      final DirListingMetadata meta,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative(), meta.getLastUpdated());\n-\n+    // put all its ancestors if not present; as an optimization we return at its\n+    // first existent ancestor\n+    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Put);\n     // First add any missing ancestors...\n-    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n+    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n+        ancestorState);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n+    // sort so highest-level entries are written to the store first.\n+    // if a sequence fails, no orphan entries will have been written.\n+    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n+    // and add the ancestors\n+    synchronized (ancestorState) {\n+      metasToPut.forEach(ancestorState::put);\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void put(\n      final DirListingMetadata meta,\n      @Nullable final BulkOperationState operationState) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n    // put all its ancestors if not present; as an optimization we return at its\n    // first existent ancestor\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    // First add any missing ancestors...\n    final List\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta,\n        ancestorState);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    // sort so highest-level entries are written to the store first.\n    // if a sequence fails, no orphan entries will have been written.\n    metasToPut.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n    // and add the ancestors\n    synchronized (ancestorState) {\n      metasToPut.forEach(ancestorState::put);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[meta-DirListingMetadata]",
            "newValue": "[meta-DirListingMetadata(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
          }
        }
      ]
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "12/09/18 9:04 PM",
      "commitNameOld": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n   public void put(DirListingMetadata meta) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n-            false, meta.isAuthoritative());\n+            false, meta.isAuthoritative(), meta.getLastUpdated());\n \n     // First add any missing ancestors...\n     final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n     processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(DirListingMetadata meta) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative(), meta.getLastUpdated());\n\n    // First add any missing ancestors...\n    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15426 Make S3guard client resilient to DDB throttle events and network failures (Contributed by Steve Loughran)\n",
      "commitDate": "12/09/18 9:04 PM",
      "commitName": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/09/18 4:36 PM",
      "commitNameOld": "d32a8d5d582725eb724b78f27310ad1efd33ed2a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,17 @@\n   public void put(DirListingMetadata meta) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n     DDBPathMetadata ddbPathMeta \u003d\n         new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n             false, meta.isAuthoritative());\n \n     // First add any missing ancestors...\n-    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d invoker.retry(\n-        \"paths to put\", path.toString(), true,\n-        () -\u003e fullPathsToPut(ddbPathMeta));\n+    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n \n     // next add all children of the directory\n     metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n-    Invoker.once(\"put\", path.toString(),\n-        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(metasToPut)));\n+    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(DirListingMetadata meta) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative());\n\n    // First add any missing ancestors...\n    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d fullPathsToPut(ddbPathMeta);\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "08/08/18 10:57 PM",
      "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 8.47,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,20 @@\n   public void put(DirListingMetadata meta) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n     Path path \u003d meta.getPath();\n-    PathMetadata p \u003d new PathMetadata(makeDirStatus(path, username),\n-        meta.isEmpty(), false);\n+    DDBPathMetadata ddbPathMeta \u003d\n+        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n+            false, meta.isAuthoritative());\n \n     // First add any missing ancestors...\n-    final Collection\u003cPathMetadata\u003e metasToPut \u003d invoker.retry(\n+    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d invoker.retry(\n         \"paths to put\", path.toString(), true,\n-        () -\u003e fullPathsToPut(p));\n+        () -\u003e fullPathsToPut(ddbPathMeta));\n \n     // next add all children of the directory\n-    metasToPut.addAll(meta.getListing());\n+    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n \n     Invoker.once(\"put\", path.toString(),\n         () -\u003e processBatchWriteRequest(null, pathMetadataToItem(metasToPut)));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(DirListingMetadata meta) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    DDBPathMetadata ddbPathMeta \u003d\n        new DDBPathMetadata(makeDirStatus(path, username), meta.isEmpty(),\n            false, meta.isAuthoritative());\n\n    // First add any missing ancestors...\n    final Collection\u003cDDBPathMetadata\u003e metasToPut \u003d invoker.retry(\n        \"paths to put\", path.toString(), true,\n        () -\u003e fullPathsToPut(ddbPathMeta));\n\n    // next add all children of the directory\n    metasToPut.addAll(pathMetaToDDBPathMeta(meta.getListing()));\n\n    Invoker.once(\"put\", path.toString(),\n        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(metasToPut)));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   public void put(DirListingMetadata meta) throws IOException {\n     LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n \n     // directory path\n-    PathMetadata p \u003d new PathMetadata(makeDirStatus(meta.getPath(), username),\n+    Path path \u003d meta.getPath();\n+    PathMetadata p \u003d new PathMetadata(makeDirStatus(path, username),\n         meta.isEmpty(), false);\n \n     // First add any missing ancestors...\n-    final Collection\u003cPathMetadata\u003e metasToPut \u003d fullPathsToPut(p);\n+    final Collection\u003cPathMetadata\u003e metasToPut \u003d invoker.retry(\n+        \"paths to put\", path.toString(), true,\n+        () -\u003e fullPathsToPut(p));\n \n     // next add all children of the directory\n     metasToPut.addAll(meta.getListing());\n \n-    try {\n-      processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"put\", (String) null, e);\n-    }\n+    Invoker.once(\"put\", path.toString(),\n+        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(metasToPut)));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(DirListingMetadata meta) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    Path path \u003d meta.getPath();\n    PathMetadata p \u003d new PathMetadata(makeDirStatus(path, username),\n        meta.isEmpty(), false);\n\n    // First add any missing ancestors...\n    final Collection\u003cPathMetadata\u003e metasToPut \u003d invoker.retry(\n        \"paths to put\", path.toString(), true,\n        () -\u003e fullPathsToPut(p));\n\n    // next add all children of the directory\n    metasToPut.addAll(meta.getListing());\n\n    Invoker.once(\"put\", path.toString(),\n        () -\u003e processBatchWriteRequest(null, pathMetadataToItem(metasToPut)));\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,19 @@\n+  public void put(DirListingMetadata meta) throws IOException {\n+    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n+\n+    // directory path\n+    PathMetadata p \u003d new PathMetadata(makeDirStatus(meta.getPath(), username),\n+        meta.isEmpty(), false);\n+\n+    // First add any missing ancestors...\n+    final Collection\u003cPathMetadata\u003e metasToPut \u003d fullPathsToPut(p);\n+\n+    // next add all children of the directory\n+    metasToPut.addAll(meta.getListing());\n+\n+    try {\n+      processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"put\", (String) null, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void put(DirListingMetadata meta) throws IOException {\n    LOG.debug(\"Saving to table {} in region {}: {}\", tableName, region, meta);\n\n    // directory path\n    PathMetadata p \u003d new PathMetadata(makeDirStatus(meta.getPath(), username),\n        meta.isEmpty(), false);\n\n    // First add any missing ancestors...\n    final Collection\u003cPathMetadata\u003e metasToPut \u003d fullPathsToPut(p);\n\n    // next add all children of the directory\n    metasToPut.addAll(meta.getListing());\n\n    try {\n      processBatchWriteRequest(null, pathMetadataToItem(metasToPut));\n    } catch (AmazonClientException e) {\n      throw translateException(\"put\", (String) null, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}