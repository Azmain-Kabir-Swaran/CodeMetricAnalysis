{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SLSCapacityScheduler.java",
  "functionName": "handle",
  "functionId": "handle___schedulerEvent-SchedulerEvent",
  "sourceFilePath": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
  "functionStartLine": 162,
  "functionEndLine": 233,
  "numCommitsSeen": 21,
  "timeTaken": 1529,
  "changeHistory": [
    "6a5516c2381f107d96b8326939514de3c6e53d3d",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "e07f3c87cd3542760efcf713f909375b69eec00f"
  ],
  "changeHistoryShort": {
    "6a5516c2381f107d96b8326939514de3c6e53d3d": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ybodychange",
    "e07f3c87cd3542760efcf713f909375b69eec00f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6a5516c2381f107d96b8326939514de3c6e53d3d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5654. Not be able to run SLS with FairScheduler (yufeigu via rkanter)\n",
      "commitDate": "29/03/17 4:18 PM",
      "commitName": "6a5516c2381f107d96b8326939514de3c6e53d3d",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "21/03/17 3:21 PM",
      "commitNameOld": "cc938e99ec0904824c8072184eff75619fcaf040",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 8.04,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,72 @@\n   public void handle(SchedulerEvent schedulerEvent) {\n-\t    // metrics off\n-\t    if (! metricsON) {\n-\t      super.handle(schedulerEvent);\n-\t      return;\n-\t    }\n-\t    if(!running)    running \u003d true;\n+    if (!metricsON) {\n+      super.handle(schedulerEvent);\n+      return;\n+    }\n \n-\t    // metrics on\n-\t    Timer.Context handlerTimer \u003d null;\n-\t    Timer.Context operationTimer \u003d null;\n+    if (!schedulerMetrics.isRunning()) {\n+      schedulerMetrics.setRunning(true);\n+    }\n \n-\t    NodeUpdateSchedulerEventWrapper eventWrapper;\n-\t    try {\n-\t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n-\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n-\t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n-\t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n-\t                (NodeUpdateSchedulerEvent)schedulerEvent);\n-\t        schedulerEvent \u003d eventWrapper;\n-\t        updateQueueWithNodeUpdate(eventWrapper);\n-\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n-\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n-\t        // check if having AM Container, update resource usage information\n-\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n-\t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n-\t        ApplicationAttemptId appAttemptId \u003d\n-\t                appRemoveEvent.getApplicationAttemptID();\n-\t        String queue \u003d appQueueMap.get(appAttemptId);\n-\t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n-\t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n-\t          // should have one container which is AM container\n-\t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n-\t          updateQueueMetrics(queue,\n-\t                  rmc.getContainer().getResource().getMemorySize(),\n-\t                  rmc.getContainer().getResource().getVirtualCores());\n-\t        }\n-\t      }\n+    Timer.Context handlerTimer \u003d null;\n+    Timer.Context operationTimer \u003d null;\n \n-\t      handlerTimer \u003d schedulerHandleTimer.time();\n-\t      operationTimer \u003d schedulerHandleTimerMap\n-\t              .get(schedulerEvent.getType()).time();\n+    NodeUpdateSchedulerEventWrapper eventWrapper;\n+    try {\n+      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n+          \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n+        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n+            (NodeUpdateSchedulerEvent)schedulerEvent);\n+        schedulerEvent \u003d eventWrapper;\n+        updateQueueWithNodeUpdate(eventWrapper);\n+      } else if (schedulerEvent.getType() \u003d\u003d\n+          SchedulerEventType.APP_ATTEMPT_REMOVED\n+          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n+        // check if having AM Container, update resource usage information\n+        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n+            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n+        ApplicationAttemptId appAttemptId \u003d\n+            appRemoveEvent.getApplicationAttemptID();\n+        String queue \u003d appQueueMap.get(appAttemptId);\n+        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n+        if (!app.getLiveContainers().isEmpty()) {  // have 0 or 1\n+          // should have one container which is AM container\n+          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n+          schedulerMetrics.updateQueueMetricsByRelease(\n+              rmc.getContainer().getResource(), queue);\n+        }\n+      }\n \n-\t      super.handle(schedulerEvent);\n-\t    } finally {\n-\t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n-\t      if (operationTimer !\u003d null)   operationTimer.stop();\n-\t      schedulerHandleCounter.inc();\n-\t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n+      handlerTimer \u003d schedulerMetrics.getSchedulerHandleTimer().time();\n+      operationTimer \u003d schedulerMetrics.getSchedulerHandleTimer(\n+          schedulerEvent.getType()).time();\n \n-\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n-\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n-\t        SLSRunner.decreaseRemainingApps();\n-\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n-\t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n-\t        ApplicationAttemptId appAttemptId \u003d\n-\t                appRemoveEvent.getApplicationAttemptID();\n-\t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n-\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n-\t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n-          AppAttemptAddedSchedulerEvent appAddEvent \u003d\n-              (AppAttemptAddedSchedulerEvent) schedulerEvent;\n-          SchedulerApplication app \u003d\n-              applications.get(appAddEvent.getApplicationAttemptId()\n+      super.handle(schedulerEvent);\n+    } finally {\n+      if (handlerTimer !\u003d null) {\n+        handlerTimer.stop();\n+      }\n+      if (operationTimer !\u003d null) {\n+        operationTimer.stop();\n+      }\n+      schedulerMetrics.increaseSchedulerHandleCounter(schedulerEvent.getType());\n+\n+      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n+          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n+        SLSRunner.decreaseRemainingApps();\n+        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n+            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n+        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n+      } else if (schedulerEvent.getType() \u003d\u003d\n+          SchedulerEventType.APP_ATTEMPT_ADDED\n+          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n+        AppAttemptAddedSchedulerEvent appAddEvent \u003d\n+            (AppAttemptAddedSchedulerEvent) schedulerEvent;\n+        SchedulerApplication app \u003d\n+            applications.get(appAddEvent.getApplicationAttemptId()\n                 .getApplicationId());\n-          appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n-              .getQueueName());\n-\t      }\n-\t    }\n+        appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n+            .getQueueName());\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent schedulerEvent) {\n    if (!metricsON) {\n      super.handle(schedulerEvent);\n      return;\n    }\n\n    if (!schedulerMetrics.isRunning()) {\n      schedulerMetrics.setRunning(true);\n    }\n\n    Timer.Context handlerTimer \u003d null;\n    Timer.Context operationTimer \u003d null;\n\n    NodeUpdateSchedulerEventWrapper eventWrapper;\n    try {\n      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n          \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n            (NodeUpdateSchedulerEvent)schedulerEvent);\n        schedulerEvent \u003d eventWrapper;\n        updateQueueWithNodeUpdate(eventWrapper);\n      } else if (schedulerEvent.getType() \u003d\u003d\n          SchedulerEventType.APP_ATTEMPT_REMOVED\n          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n        // check if having AM Container, update resource usage information\n        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n        ApplicationAttemptId appAttemptId \u003d\n            appRemoveEvent.getApplicationAttemptID();\n        String queue \u003d appQueueMap.get(appAttemptId);\n        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n        if (!app.getLiveContainers().isEmpty()) {  // have 0 or 1\n          // should have one container which is AM container\n          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n          schedulerMetrics.updateQueueMetricsByRelease(\n              rmc.getContainer().getResource(), queue);\n        }\n      }\n\n      handlerTimer \u003d schedulerMetrics.getSchedulerHandleTimer().time();\n      operationTimer \u003d schedulerMetrics.getSchedulerHandleTimer(\n          schedulerEvent.getType()).time();\n\n      super.handle(schedulerEvent);\n    } finally {\n      if (handlerTimer !\u003d null) {\n        handlerTimer.stop();\n      }\n      if (operationTimer !\u003d null) {\n        operationTimer.stop();\n      }\n      schedulerMetrics.increaseSchedulerHandleCounter(schedulerEvent.getType());\n\n      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n        SLSRunner.decreaseRemainingApps();\n        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n      } else if (schedulerEvent.getType() \u003d\u003d\n          SchedulerEventType.APP_ATTEMPT_ADDED\n          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n        AppAttemptAddedSchedulerEvent appAddEvent \u003d\n            (AppAttemptAddedSchedulerEvent) schedulerEvent;\n        SchedulerApplication app \u003d\n            applications.get(appAddEvent.getApplicationAttemptId()\n                .getApplicationId());\n        appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n            .getQueueName());\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 248.81,
      "commitsBetweenForRepo": 1666,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void handle(SchedulerEvent schedulerEvent) {\n \t    // metrics off\n \t    if (! metricsON) {\n \t      super.handle(schedulerEvent);\n \t      return;\n \t    }\n \t    if(!running)    running \u003d true;\n \n \t    // metrics on\n \t    Timer.Context handlerTimer \u003d null;\n \t    Timer.Context operationTimer \u003d null;\n \n \t    NodeUpdateSchedulerEventWrapper eventWrapper;\n \t    try {\n \t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n \t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n \t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n \t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n \t                (NodeUpdateSchedulerEvent)schedulerEvent);\n \t        schedulerEvent \u003d eventWrapper;\n \t        updateQueueWithNodeUpdate(eventWrapper);\n \t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n \t        // check if having AM Container, update resource usage information\n \t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n \t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n \t        ApplicationAttemptId appAttemptId \u003d\n \t                appRemoveEvent.getApplicationAttemptID();\n \t        String queue \u003d appQueueMap.get(appAttemptId);\n \t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n \t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n \t          // should have one container which is AM container\n \t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n \t          updateQueueMetrics(queue,\n-\t                  rmc.getContainer().getResource().getMemory(),\n+\t                  rmc.getContainer().getResource().getMemorySize(),\n \t                  rmc.getContainer().getResource().getVirtualCores());\n \t        }\n \t      }\n \n \t      handlerTimer \u003d schedulerHandleTimer.time();\n \t      operationTimer \u003d schedulerHandleTimerMap\n \t              .get(schedulerEvent.getType()).time();\n \n \t      super.handle(schedulerEvent);\n \t    } finally {\n \t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n \t      if (operationTimer !\u003d null)   operationTimer.stop();\n \t      schedulerHandleCounter.inc();\n \t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n \n \t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n \t        SLSRunner.decreaseRemainingApps();\n \t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n \t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n \t        ApplicationAttemptId appAttemptId \u003d\n \t                appRemoveEvent.getApplicationAttemptID();\n \t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n \t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n           AppAttemptAddedSchedulerEvent appAddEvent \u003d\n               (AppAttemptAddedSchedulerEvent) schedulerEvent;\n           SchedulerApplication app \u003d\n               applications.get(appAddEvent.getApplicationAttemptId()\n                 .getApplicationId());\n           appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n               .getQueueName());\n \t      }\n \t    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent schedulerEvent) {\n\t    // metrics off\n\t    if (! metricsON) {\n\t      super.handle(schedulerEvent);\n\t      return;\n\t    }\n\t    if(!running)    running \u003d true;\n\n\t    // metrics on\n\t    Timer.Context handlerTimer \u003d null;\n\t    Timer.Context operationTimer \u003d null;\n\n\t    NodeUpdateSchedulerEventWrapper eventWrapper;\n\t    try {\n\t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n\t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n\t                (NodeUpdateSchedulerEvent)schedulerEvent);\n\t        schedulerEvent \u003d eventWrapper;\n\t        updateQueueWithNodeUpdate(eventWrapper);\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        // check if having AM Container, update resource usage information\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        String queue \u003d appQueueMap.get(appAttemptId);\n\t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n\t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n\t          // should have one container which is AM container\n\t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n\t          updateQueueMetrics(queue,\n\t                  rmc.getContainer().getResource().getMemorySize(),\n\t                  rmc.getContainer().getResource().getVirtualCores());\n\t        }\n\t      }\n\n\t      handlerTimer \u003d schedulerHandleTimer.time();\n\t      operationTimer \u003d schedulerHandleTimerMap\n\t              .get(schedulerEvent.getType()).time();\n\n\t      super.handle(schedulerEvent);\n\t    } finally {\n\t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n\t      if (operationTimer !\u003d null)   operationTimer.stop();\n\t      schedulerHandleCounter.inc();\n\t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        SLSRunner.decreaseRemainingApps();\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n          AppAttemptAddedSchedulerEvent appAddEvent \u003d\n              (AppAttemptAddedSchedulerEvent) schedulerEvent;\n          SchedulerApplication app \u003d\n              applications.get(appAddEvent.getApplicationAttemptId()\n                .getApplicationId());\n          appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n              .getQueueName());\n\t      }\n\t    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
      "extendedDetails": {}
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/12/13 4:07 PM",
      "commitNameOld": "e07f3c87cd3542760efcf713f909375b69eec00f",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 14.84,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,70 @@\n   public void handle(SchedulerEvent schedulerEvent) {\n \t    // metrics off\n \t    if (! metricsON) {\n \t      super.handle(schedulerEvent);\n \t      return;\n \t    }\n \t    if(!running)    running \u003d true;\n \n \t    // metrics on\n \t    Timer.Context handlerTimer \u003d null;\n \t    Timer.Context operationTimer \u003d null;\n \n \t    NodeUpdateSchedulerEventWrapper eventWrapper;\n \t    try {\n \t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n \t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n \t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n \t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n \t                (NodeUpdateSchedulerEvent)schedulerEvent);\n \t        schedulerEvent \u003d eventWrapper;\n \t        updateQueueWithNodeUpdate(eventWrapper);\n \t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n \t        // check if having AM Container, update resource usage information\n \t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n \t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n \t        ApplicationAttemptId appAttemptId \u003d\n \t                appRemoveEvent.getApplicationAttemptID();\n \t        String queue \u003d appQueueMap.get(appAttemptId);\n \t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n \t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n \t          // should have one container which is AM container\n \t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n \t          updateQueueMetrics(queue,\n \t                  rmc.getContainer().getResource().getMemory(),\n \t                  rmc.getContainer().getResource().getVirtualCores());\n \t        }\n \t      }\n \n \t      handlerTimer \u003d schedulerHandleTimer.time();\n \t      operationTimer \u003d schedulerHandleTimerMap\n \t              .get(schedulerEvent.getType()).time();\n \n \t      super.handle(schedulerEvent);\n \t    } finally {\n \t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n \t      if (operationTimer !\u003d null)   operationTimer.stop();\n \t      schedulerHandleCounter.inc();\n \t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n \n \t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n \t        SLSRunner.decreaseRemainingApps();\n \t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n \t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n \t        ApplicationAttemptId appAttemptId \u003d\n \t                appRemoveEvent.getApplicationAttemptID();\n \t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n \t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n \t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n-\t        AppAttemptAddedSchedulerEvent appAddEvent \u003d\n-\t                (AppAttemptAddedSchedulerEvent) schedulerEvent;\n-\t        String queueName \u003d appAddEvent.getQueue();\n-\t        appQueueMap.put(appAddEvent.getApplicationAttemptId(), queueName);\n+          AppAttemptAddedSchedulerEvent appAddEvent \u003d\n+              (AppAttemptAddedSchedulerEvent) schedulerEvent;\n+          SchedulerApplication app \u003d\n+              applications.get(appAddEvent.getApplicationAttemptId()\n+                .getApplicationId());\n+          appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n+              .getQueueName());\n \t      }\n \t    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent schedulerEvent) {\n\t    // metrics off\n\t    if (! metricsON) {\n\t      super.handle(schedulerEvent);\n\t      return;\n\t    }\n\t    if(!running)    running \u003d true;\n\n\t    // metrics on\n\t    Timer.Context handlerTimer \u003d null;\n\t    Timer.Context operationTimer \u003d null;\n\n\t    NodeUpdateSchedulerEventWrapper eventWrapper;\n\t    try {\n\t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n\t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n\t                (NodeUpdateSchedulerEvent)schedulerEvent);\n\t        schedulerEvent \u003d eventWrapper;\n\t        updateQueueWithNodeUpdate(eventWrapper);\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        // check if having AM Container, update resource usage information\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        String queue \u003d appQueueMap.get(appAttemptId);\n\t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n\t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n\t          // should have one container which is AM container\n\t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n\t          updateQueueMetrics(queue,\n\t                  rmc.getContainer().getResource().getMemory(),\n\t                  rmc.getContainer().getResource().getVirtualCores());\n\t        }\n\t      }\n\n\t      handlerTimer \u003d schedulerHandleTimer.time();\n\t      operationTimer \u003d schedulerHandleTimerMap\n\t              .get(schedulerEvent.getType()).time();\n\n\t      super.handle(schedulerEvent);\n\t    } finally {\n\t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n\t      if (operationTimer !\u003d null)   operationTimer.stop();\n\t      schedulerHandleCounter.inc();\n\t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        SLSRunner.decreaseRemainingApps();\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n          AppAttemptAddedSchedulerEvent appAddEvent \u003d\n              (AppAttemptAddedSchedulerEvent) schedulerEvent;\n          SchedulerApplication app \u003d\n              applications.get(appAddEvent.getApplicationAttemptId()\n                .getApplicationId());\n          appQueueMap.put(appAddEvent.getApplicationAttemptId(), app.getQueue()\n              .getQueueName());\n\t      }\n\t    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java",
      "extendedDetails": {}
    },
    "e07f3c87cd3542760efcf713f909375b69eec00f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1471. Preserve scheduler typeinfo in simulator to work with resource monitors.\nContributed by Carlo Curino.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552173 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/13 4:07 PM",
      "commitName": "e07f3c87cd3542760efcf713f909375b69eec00f",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,67 @@\n+  public void handle(SchedulerEvent schedulerEvent) {\n+\t    // metrics off\n+\t    if (! metricsON) {\n+\t      super.handle(schedulerEvent);\n+\t      return;\n+\t    }\n+\t    if(!running)    running \u003d true;\n+\n+\t    // metrics on\n+\t    Timer.Context handlerTimer \u003d null;\n+\t    Timer.Context operationTimer \u003d null;\n+\n+\t    NodeUpdateSchedulerEventWrapper eventWrapper;\n+\t    try {\n+\t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n+\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n+\t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n+\t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n+\t                (NodeUpdateSchedulerEvent)schedulerEvent);\n+\t        schedulerEvent \u003d eventWrapper;\n+\t        updateQueueWithNodeUpdate(eventWrapper);\n+\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n+\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n+\t        // check if having AM Container, update resource usage information\n+\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n+\t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n+\t        ApplicationAttemptId appAttemptId \u003d\n+\t                appRemoveEvent.getApplicationAttemptID();\n+\t        String queue \u003d appQueueMap.get(appAttemptId);\n+\t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n+\t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n+\t          // should have one container which is AM container\n+\t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n+\t          updateQueueMetrics(queue,\n+\t                  rmc.getContainer().getResource().getMemory(),\n+\t                  rmc.getContainer().getResource().getVirtualCores());\n+\t        }\n+\t      }\n+\n+\t      handlerTimer \u003d schedulerHandleTimer.time();\n+\t      operationTimer \u003d schedulerHandleTimerMap\n+\t              .get(schedulerEvent.getType()).time();\n+\n+\t      super.handle(schedulerEvent);\n+\t    } finally {\n+\t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n+\t      if (operationTimer !\u003d null)   operationTimer.stop();\n+\t      schedulerHandleCounter.inc();\n+\t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n+\n+\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n+\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n+\t        SLSRunner.decreaseRemainingApps();\n+\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n+\t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n+\t        ApplicationAttemptId appAttemptId \u003d\n+\t                appRemoveEvent.getApplicationAttemptID();\n+\t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n+\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n+\t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n+\t        AppAttemptAddedSchedulerEvent appAddEvent \u003d\n+\t                (AppAttemptAddedSchedulerEvent) schedulerEvent;\n+\t        String queueName \u003d appAddEvent.getQueue();\n+\t        appQueueMap.put(appAddEvent.getApplicationAttemptId(), queueName);\n+\t      }\n+\t    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(SchedulerEvent schedulerEvent) {\n\t    // metrics off\n\t    if (! metricsON) {\n\t      super.handle(schedulerEvent);\n\t      return;\n\t    }\n\t    if(!running)    running \u003d true;\n\n\t    // metrics on\n\t    Timer.Context handlerTimer \u003d null;\n\t    Timer.Context operationTimer \u003d null;\n\n\t    NodeUpdateSchedulerEventWrapper eventWrapper;\n\t    try {\n\t      //if (schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.NODE_UPDATE\n\t              \u0026\u0026 schedulerEvent instanceof NodeUpdateSchedulerEvent) {\n\t        eventWrapper \u003d new NodeUpdateSchedulerEventWrapper(\n\t                (NodeUpdateSchedulerEvent)schedulerEvent);\n\t        schedulerEvent \u003d eventWrapper;\n\t        updateQueueWithNodeUpdate(eventWrapper);\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        // check if having AM Container, update resource usage information\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t            (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        String queue \u003d appQueueMap.get(appAttemptId);\n\t        SchedulerAppReport app \u003d super.getSchedulerAppInfo(appAttemptId);\n\t        if (! app.getLiveContainers().isEmpty()) {  // have 0 or 1\n\t          // should have one container which is AM container\n\t          RMContainer rmc \u003d app.getLiveContainers().iterator().next();\n\t          updateQueueMetrics(queue,\n\t                  rmc.getContainer().getResource().getMemory(),\n\t                  rmc.getContainer().getResource().getVirtualCores());\n\t        }\n\t      }\n\n\t      handlerTimer \u003d schedulerHandleTimer.time();\n\t      operationTimer \u003d schedulerHandleTimerMap\n\t              .get(schedulerEvent.getType()).time();\n\n\t      super.handle(schedulerEvent);\n\t    } finally {\n\t      if (handlerTimer !\u003d null)     handlerTimer.stop();\n\t      if (operationTimer !\u003d null)   operationTimer.stop();\n\t      schedulerHandleCounter.inc();\n\t      schedulerHandleCounterMap.get(schedulerEvent.getType()).inc();\n\n\t      if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_REMOVED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptRemovedSchedulerEvent) {\n\t        SLSRunner.decreaseRemainingApps();\n\t        AppAttemptRemovedSchedulerEvent appRemoveEvent \u003d\n\t                (AppAttemptRemovedSchedulerEvent) schedulerEvent;\n\t        ApplicationAttemptId appAttemptId \u003d\n\t                appRemoveEvent.getApplicationAttemptID();\n\t        appQueueMap.remove(appRemoveEvent.getApplicationAttemptID());\n\t      } else if (schedulerEvent.getType() \u003d\u003d SchedulerEventType.APP_ATTEMPT_ADDED\n\t          \u0026\u0026 schedulerEvent instanceof AppAttemptAddedSchedulerEvent) {\n\t        AppAttemptAddedSchedulerEvent appAddEvent \u003d\n\t                (AppAttemptAddedSchedulerEvent) schedulerEvent;\n\t        String queueName \u003d appAddEvent.getQueue();\n\t        appQueueMap.put(appAddEvent.getApplicationAttemptId(), queueName);\n\t      }\n\t    }\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/scheduler/SLSCapacityScheduler.java"
    }
  }
}