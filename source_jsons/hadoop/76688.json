{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CodecRegistry.java",
  "functionName": "updateCoders",
  "functionId": "updateCoders___coderFactories-Iterable__RawErasureCoderFactory__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/erasurecode/CodecRegistry.java",
  "functionStartLine": 76,
  "functionEndLine": 125,
  "numCommitsSeen": 6,
  "timeTaken": 1172,
  "changeHistory": [
    "1b5451bf054c335188e4cd66f7b4a1d80013e86d",
    "bbf8cac14d8b1a0e919b57cb7f081edce45acd5b"
  ],
  "changeHistoryShort": {
    "1b5451bf054c335188e4cd66f7b4a1d80013e86d": "Ybodychange",
    "bbf8cac14d8b1a0e919b57cb7f081edce45acd5b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1b5451bf054c335188e4cd66f7b4a1d80013e86d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11794. Add ec sub command -listCodec to show currently supported ec codecs. Contributed by SammiChen.\n",
      "commitDate": "23/05/17 4:33 AM",
      "commitName": "1b5451bf054c335188e4cd66f7b4a1d80013e86d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "27/04/17 12:39 PM",
      "commitNameOld": "bbf8cac14d8b1a0e919b57cb7f081edce45acd5b",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 25.66,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,50 @@\n   void updateCoders(Iterable\u003cRawErasureCoderFactory\u003e coderFactories) {\n     for (RawErasureCoderFactory coderFactory : coderFactories) {\n       String codecName \u003d coderFactory.getCodecName();\n       List\u003cRawErasureCoderFactory\u003e coders \u003d coderMap.get(codecName);\n       if (coders \u003d\u003d null) {\n         coders \u003d new ArrayList\u003c\u003e();\n         coders.add(coderFactory);\n         coderMap.put(codecName, coders);\n         LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n             coderFactory.getCodecName(), coderFactory.getCoderName());\n       } else {\n         Boolean hasConflit \u003d false;\n         for (RawErasureCoderFactory coder : coders) {\n           if (coder.getCoderName().equals(coderFactory.getCoderName())) {\n             hasConflit \u003d true;\n             LOG.error(\"Coder {} cannot be registered because its coder name \" +\n                 \"{} has conflict with {}\", coderFactory.getClass().getName(),\n                 coderFactory.getCoderName(), coder.getClass().getName());\n             break;\n           }\n         }\n         if (!hasConflit) {\n           // set native coders as default if user does not\n           // specify a fallback order\n           if (coderFactory instanceof NativeRSRawErasureCoderFactory ||\n                   coderFactory instanceof NativeXORRawErasureCoderFactory) {\n             coders.add(0, coderFactory);\n           } else {\n             coders.add(coderFactory);\n           }\n           LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n               coderFactory.getCodecName(), coderFactory.getCoderName());\n         }\n       }\n     }\n \n     // update coderNameMap accordingly\n     coderNameMap.clear();\n     for (Map.Entry\u003cString, List\u003cRawErasureCoderFactory\u003e\u003e entry :\n         coderMap.entrySet()) {\n       String codecName \u003d entry.getKey();\n       List\u003cRawErasureCoderFactory\u003e coders \u003d entry.getValue();\n       coderNameMap.put(codecName, coders.stream().\n           map(RawErasureCoderFactory::getCoderName).\n           collect(Collectors.toList()).toArray(new String[0]));\n+      coderNameCompactMap.put(codecName, coders.stream().\n+          map(RawErasureCoderFactory::getCoderName)\n+          .collect(Collectors.joining(\", \")));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void updateCoders(Iterable\u003cRawErasureCoderFactory\u003e coderFactories) {\n    for (RawErasureCoderFactory coderFactory : coderFactories) {\n      String codecName \u003d coderFactory.getCodecName();\n      List\u003cRawErasureCoderFactory\u003e coders \u003d coderMap.get(codecName);\n      if (coders \u003d\u003d null) {\n        coders \u003d new ArrayList\u003c\u003e();\n        coders.add(coderFactory);\n        coderMap.put(codecName, coders);\n        LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n            coderFactory.getCodecName(), coderFactory.getCoderName());\n      } else {\n        Boolean hasConflit \u003d false;\n        for (RawErasureCoderFactory coder : coders) {\n          if (coder.getCoderName().equals(coderFactory.getCoderName())) {\n            hasConflit \u003d true;\n            LOG.error(\"Coder {} cannot be registered because its coder name \" +\n                \"{} has conflict with {}\", coderFactory.getClass().getName(),\n                coderFactory.getCoderName(), coder.getClass().getName());\n            break;\n          }\n        }\n        if (!hasConflit) {\n          // set native coders as default if user does not\n          // specify a fallback order\n          if (coderFactory instanceof NativeRSRawErasureCoderFactory ||\n                  coderFactory instanceof NativeXORRawErasureCoderFactory) {\n            coders.add(0, coderFactory);\n          } else {\n            coders.add(coderFactory);\n          }\n          LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n              coderFactory.getCodecName(), coderFactory.getCoderName());\n        }\n      }\n    }\n\n    // update coderNameMap accordingly\n    coderNameMap.clear();\n    for (Map.Entry\u003cString, List\u003cRawErasureCoderFactory\u003e\u003e entry :\n        coderMap.entrySet()) {\n      String codecName \u003d entry.getKey();\n      List\u003cRawErasureCoderFactory\u003e coders \u003d entry.getValue();\n      coderNameMap.put(codecName, coders.stream().\n          map(RawErasureCoderFactory::getCoderName).\n          collect(Collectors.toList()).toArray(new String[0]));\n      coderNameCompactMap.put(codecName, coders.stream().\n          map(RawErasureCoderFactory::getCoderName)\n          .collect(Collectors.joining(\", \")));\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/erasurecode/CodecRegistry.java",
      "extendedDetails": {}
    },
    "bbf8cac14d8b1a0e919b57cb7f081edce45acd5b": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13200. Implement customizable and configurable erasure coders. Contributed by Tim Yao.\n",
      "commitDate": "27/04/17 12:39 PM",
      "commitName": "bbf8cac14d8b1a0e919b57cb7f081edce45acd5b",
      "commitAuthor": "Wei-Chiu Chuang",
      "diff": "@@ -0,0 +1,47 @@\n+  void updateCoders(Iterable\u003cRawErasureCoderFactory\u003e coderFactories) {\n+    for (RawErasureCoderFactory coderFactory : coderFactories) {\n+      String codecName \u003d coderFactory.getCodecName();\n+      List\u003cRawErasureCoderFactory\u003e coders \u003d coderMap.get(codecName);\n+      if (coders \u003d\u003d null) {\n+        coders \u003d new ArrayList\u003c\u003e();\n+        coders.add(coderFactory);\n+        coderMap.put(codecName, coders);\n+        LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n+            coderFactory.getCodecName(), coderFactory.getCoderName());\n+      } else {\n+        Boolean hasConflit \u003d false;\n+        for (RawErasureCoderFactory coder : coders) {\n+          if (coder.getCoderName().equals(coderFactory.getCoderName())) {\n+            hasConflit \u003d true;\n+            LOG.error(\"Coder {} cannot be registered because its coder name \" +\n+                \"{} has conflict with {}\", coderFactory.getClass().getName(),\n+                coderFactory.getCoderName(), coder.getClass().getName());\n+            break;\n+          }\n+        }\n+        if (!hasConflit) {\n+          // set native coders as default if user does not\n+          // specify a fallback order\n+          if (coderFactory instanceof NativeRSRawErasureCoderFactory ||\n+                  coderFactory instanceof NativeXORRawErasureCoderFactory) {\n+            coders.add(0, coderFactory);\n+          } else {\n+            coders.add(coderFactory);\n+          }\n+          LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n+              coderFactory.getCodecName(), coderFactory.getCoderName());\n+        }\n+      }\n+    }\n+\n+    // update coderNameMap accordingly\n+    coderNameMap.clear();\n+    for (Map.Entry\u003cString, List\u003cRawErasureCoderFactory\u003e\u003e entry :\n+        coderMap.entrySet()) {\n+      String codecName \u003d entry.getKey();\n+      List\u003cRawErasureCoderFactory\u003e coders \u003d entry.getValue();\n+      coderNameMap.put(codecName, coders.stream().\n+          map(RawErasureCoderFactory::getCoderName).\n+          collect(Collectors.toList()).toArray(new String[0]));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void updateCoders(Iterable\u003cRawErasureCoderFactory\u003e coderFactories) {\n    for (RawErasureCoderFactory coderFactory : coderFactories) {\n      String codecName \u003d coderFactory.getCodecName();\n      List\u003cRawErasureCoderFactory\u003e coders \u003d coderMap.get(codecName);\n      if (coders \u003d\u003d null) {\n        coders \u003d new ArrayList\u003c\u003e();\n        coders.add(coderFactory);\n        coderMap.put(codecName, coders);\n        LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n            coderFactory.getCodecName(), coderFactory.getCoderName());\n      } else {\n        Boolean hasConflit \u003d false;\n        for (RawErasureCoderFactory coder : coders) {\n          if (coder.getCoderName().equals(coderFactory.getCoderName())) {\n            hasConflit \u003d true;\n            LOG.error(\"Coder {} cannot be registered because its coder name \" +\n                \"{} has conflict with {}\", coderFactory.getClass().getName(),\n                coderFactory.getCoderName(), coder.getClass().getName());\n            break;\n          }\n        }\n        if (!hasConflit) {\n          // set native coders as default if user does not\n          // specify a fallback order\n          if (coderFactory instanceof NativeRSRawErasureCoderFactory ||\n                  coderFactory instanceof NativeXORRawErasureCoderFactory) {\n            coders.add(0, coderFactory);\n          } else {\n            coders.add(coderFactory);\n          }\n          LOG.debug(\"Codec registered: codec \u003d {}, coder \u003d {}\",\n              coderFactory.getCodecName(), coderFactory.getCoderName());\n        }\n      }\n    }\n\n    // update coderNameMap accordingly\n    coderNameMap.clear();\n    for (Map.Entry\u003cString, List\u003cRawErasureCoderFactory\u003e\u003e entry :\n        coderMap.entrySet()) {\n      String codecName \u003d entry.getKey();\n      List\u003cRawErasureCoderFactory\u003e coders \u003d entry.getValue();\n      coderNameMap.put(codecName, coders.stream().\n          map(RawErasureCoderFactory::getCoderName).\n          collect(Collectors.toList()).toArray(new String[0]));\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/erasurecode/CodecRegistry.java"
    }
  }
}