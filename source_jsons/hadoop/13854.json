{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "reportDiffSorted",
  "functionId": "reportDiffSorted___storageInfo-DatanodeStorageInfo__newReport-Iterable__BlockReportReplica____toAdd-Collection__BlockInfoToAdd____toRemove-Collection__BlockInfo____toInvalidate-Collection__Block____toCorrupt-Collection__BlockToMarkCorrupt____toUC-Collection__StatefulBlockInfo__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 3054,
  "functionEndLine": 3128,
  "numCommitsSeen": 791,
  "timeTaken": 10747,
  "changeHistory": [
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "72dfb048a9a7be64b371b74478b90150bf300d35",
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a"
  ],
  "changeHistoryShort": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "72dfb048a9a7be64b371b74478b90150bf300d35": "Ybodychange",
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a": "Ymultichange(Yrename,Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,75 @@\n   private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n       Iterable\u003cBlockReportReplica\u003e newReport,\n       Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n       Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n       Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n       Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n       Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n \n     // The blocks must be sorted and the storagenodes blocks must be sorted\n     Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n     DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n     BlockInfo storageBlock \u003d null;\n \n     for (BlockReportReplica replica : newReport) {\n \n       long replicaID \u003d replica.getBlockId();\n       if (BlockIdManager.isStripedBlockID(replicaID)\n           \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n               !blocksMap.containsBlock(replica))) {\n         replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n       }\n \n       ReplicaState reportedState \u003d replica.getState();\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Reported block \" + replica\n-                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n-                  + \" replicaState \u003d \" + reportedState);\n-      }\n+      LOG.debug(\"Reported block {} on {} size {} replicaState \u003d {}\",\n+          replica, dn, replica.getNumBytes(), reportedState);\n \n       if (shouldPostponeBlocksFromFuture\n           \u0026\u0026 isGenStampInFuture(replica)) {\n         queueReportedBlock(storageInfo, replica, reportedState,\n                            QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n         storageBlock \u003d storageBlocksIterator.next();\n       }\n \n       do {\n         int cmp;\n         if (storageBlock \u003d\u003d null ||\n             (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n           // Check if block is available in NN but not yet on this storage\n           BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n           if (nnBlock !\u003d null) {\n             reportDiffSortedInner(storageInfo, replica, reportedState,\n                                   nnBlock, toAdd, toCorrupt, toUC);\n           } else {\n             // Replica not found anywhere so it should be invalidated\n             toInvalidate.add(new Block(replica));\n           }\n           break;\n         } else if (cmp \u003d\u003d 0) {\n           // Replica matched current storageblock\n           reportDiffSortedInner(storageInfo, replica, reportedState,\n                                 storageBlock, toAdd, toCorrupt, toUC);\n           storageBlock \u003d null;\n         } else {\n           // replica has higher ID than storedBlock\n           // Remove all stored blocks with IDs lower than replica\n           do {\n             toRemove.add(storageBlock);\n             storageBlock \u003d storageBlocksIterator.hasNext()\n                            ? storageBlocksIterator.next() : null;\n           } while (storageBlock !\u003d null \u0026\u0026\n                    Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n         }\n       } while (storageBlock !\u003d null);\n     }\n \n     // Iterate any remaining blocks that have not been reported and remove them\n     while (storageBlocksIterator.hasNext()) {\n       toRemove.add(storageBlocksIterator.next());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n      Iterable\u003cBlockReportReplica\u003e newReport,\n      Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n      Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n      Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n      Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n      Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n\n    // The blocks must be sorted and the storagenodes blocks must be sorted\n    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n    BlockInfo storageBlock \u003d null;\n\n    for (BlockReportReplica replica : newReport) {\n\n      long replicaID \u003d replica.getBlockId();\n      if (BlockIdManager.isStripedBlockID(replicaID)\n          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n              !blocksMap.containsBlock(replica))) {\n        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n      }\n\n      ReplicaState reportedState \u003d replica.getState();\n\n      LOG.debug(\"Reported block {} on {} size {} replicaState \u003d {}\",\n          replica, dn, replica.getNumBytes(), reportedState);\n\n      if (shouldPostponeBlocksFromFuture\n          \u0026\u0026 isGenStampInFuture(replica)) {\n        queueReportedBlock(storageInfo, replica, reportedState,\n                           QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n        storageBlock \u003d storageBlocksIterator.next();\n      }\n\n      do {\n        int cmp;\n        if (storageBlock \u003d\u003d null ||\n            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n          // Check if block is available in NN but not yet on this storage\n          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n          if (nnBlock !\u003d null) {\n            reportDiffSortedInner(storageInfo, replica, reportedState,\n                                  nnBlock, toAdd, toCorrupt, toUC);\n          } else {\n            // Replica not found anywhere so it should be invalidated\n            toInvalidate.add(new Block(replica));\n          }\n          break;\n        } else if (cmp \u003d\u003d 0) {\n          // Replica matched current storageblock\n          reportDiffSortedInner(storageInfo, replica, reportedState,\n                                storageBlock, toAdd, toCorrupt, toUC);\n          storageBlock \u003d null;\n        } else {\n          // replica has higher ID than storedBlock\n          // Remove all stored blocks with IDs lower than replica\n          do {\n            toRemove.add(storageBlock);\n            storageBlock \u003d storageBlocksIterator.hasNext()\n                           ? storageBlocksIterator.next() : null;\n          } while (storageBlock !\u003d null \u0026\u0026\n                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n        }\n      } while (storageBlock !\u003d null);\n    }\n\n    // Iterate any remaining blocks that have not been reported and remove them\n    while (storageBlocksIterator.hasNext()) {\n      toRemove.add(storageBlocksIterator.next());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "72dfb048a9a7be64b371b74478b90150bf300d35": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10858. FBR processing may generate incorrect reportedBlock-blockGroup mapping. Contributed by Jing Zhao.\n",
      "commitDate": "12/09/16 4:40 PM",
      "commitName": "72dfb048a9a7be64b371b74478b90150bf300d35",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/09/16 10:38 AM",
      "commitNameOld": "d37dc5d1b8e022a7085118a2e7066623483c293f",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n       Iterable\u003cBlockReportReplica\u003e newReport,\n       Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n       Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n       Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n       Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n       Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n \n     // The blocks must be sorted and the storagenodes blocks must be sorted\n     Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n     DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n     BlockInfo storageBlock \u003d null;\n \n     for (BlockReportReplica replica : newReport) {\n \n       long replicaID \u003d replica.getBlockId();\n       if (BlockIdManager.isStripedBlockID(replicaID)\n           \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n               !blocksMap.containsBlock(replica))) {\n         replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n       }\n \n       ReplicaState reportedState \u003d replica.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Reported block \" + replica\n                   + \" on \" + dn + \" size \" + replica.getNumBytes()\n                   + \" replicaState \u003d \" + reportedState);\n       }\n \n       if (shouldPostponeBlocksFromFuture\n           \u0026\u0026 isGenStampInFuture(replica)) {\n         queueReportedBlock(storageInfo, replica, reportedState,\n                            QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n         storageBlock \u003d storageBlocksIterator.next();\n       }\n \n       do {\n         int cmp;\n         if (storageBlock \u003d\u003d null ||\n             (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n           // Check if block is available in NN but not yet on this storage\n           BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n           if (nnBlock !\u003d null) {\n             reportDiffSortedInner(storageInfo, replica, reportedState,\n                                   nnBlock, toAdd, toCorrupt, toUC);\n           } else {\n             // Replica not found anywhere so it should be invalidated\n             toInvalidate.add(new Block(replica));\n           }\n           break;\n         } else if (cmp \u003d\u003d 0) {\n           // Replica matched current storageblock\n           reportDiffSortedInner(storageInfo, replica, reportedState,\n                                 storageBlock, toAdd, toCorrupt, toUC);\n           storageBlock \u003d null;\n         } else {\n           // replica has higher ID than storedBlock\n           // Remove all stored blocks with IDs lower than replica\n           do {\n             toRemove.add(storageBlock);\n             storageBlock \u003d storageBlocksIterator.hasNext()\n                            ? storageBlocksIterator.next() : null;\n           } while (storageBlock !\u003d null \u0026\u0026\n                    Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n         }\n       } while (storageBlock !\u003d null);\n     }\n \n-    // Iterate any remaing blocks that have not been reported and remove them\n+    // Iterate any remaining blocks that have not been reported and remove them\n     while (storageBlocksIterator.hasNext()) {\n       toRemove.add(storageBlocksIterator.next());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n      Iterable\u003cBlockReportReplica\u003e newReport,\n      Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n      Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n      Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n      Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n      Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n\n    // The blocks must be sorted and the storagenodes blocks must be sorted\n    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n    BlockInfo storageBlock \u003d null;\n\n    for (BlockReportReplica replica : newReport) {\n\n      long replicaID \u003d replica.getBlockId();\n      if (BlockIdManager.isStripedBlockID(replicaID)\n          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n              !blocksMap.containsBlock(replica))) {\n        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n      }\n\n      ReplicaState reportedState \u003d replica.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reported block \" + replica\n                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n                  + \" replicaState \u003d \" + reportedState);\n      }\n\n      if (shouldPostponeBlocksFromFuture\n          \u0026\u0026 isGenStampInFuture(replica)) {\n        queueReportedBlock(storageInfo, replica, reportedState,\n                           QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n        storageBlock \u003d storageBlocksIterator.next();\n      }\n\n      do {\n        int cmp;\n        if (storageBlock \u003d\u003d null ||\n            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n          // Check if block is available in NN but not yet on this storage\n          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n          if (nnBlock !\u003d null) {\n            reportDiffSortedInner(storageInfo, replica, reportedState,\n                                  nnBlock, toAdd, toCorrupt, toUC);\n          } else {\n            // Replica not found anywhere so it should be invalidated\n            toInvalidate.add(new Block(replica));\n          }\n          break;\n        } else if (cmp \u003d\u003d 0) {\n          // Replica matched current storageblock\n          reportDiffSortedInner(storageInfo, replica, reportedState,\n                                storageBlock, toAdd, toCorrupt, toUC);\n          storageBlock \u003d null;\n        } else {\n          // replica has higher ID than storedBlock\n          // Remove all stored blocks with IDs lower than replica\n          do {\n            toRemove.add(storageBlock);\n            storageBlock \u003d storageBlocksIterator.hasNext()\n                           ? storageBlocksIterator.next() : null;\n          } while (storageBlock !\u003d null \u0026\u0026\n                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n        }\n      } while (storageBlock !\u003d null);\n    }\n\n    // Iterate any remaining blocks that have not been reported and remove them\n    while (storageBlocksIterator.hasNext()) {\n      toRemove.add(storageBlocksIterator.next());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)\n",
      "commitDate": "02/02/16 11:23 AM",
      "commitName": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)\n",
          "commitDate": "02/02/16 11:23 AM",
          "commitName": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "31/01/16 11:54 PM",
          "commitNameOld": "e418bd1fb0568ce7ae22f588fea2dd9c95567383",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 1.48,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,78 @@\n-  private void reportDiff(DatanodeStorageInfo storageInfo, \n-      BlockListAsLongs newReport,\n+  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n+      Iterable\u003cBlockReportReplica\u003e newReport,\n       Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n       Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n       Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n       Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n       Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n \n-    // place a delimiter in the list which separates blocks \n-    // that have been reported from those that have not\n-    Block delimiterBlock \u003d new Block();\n-    BlockInfo delimiter \u003d new BlockInfoContiguous(delimiterBlock,\n-        (short) 1);\n-    AddBlockResult result \u003d storageInfo.addBlock(delimiter, delimiterBlock);\n-    assert result \u003d\u003d AddBlockResult.ADDED \n-        : \"Delimiting block cannot be present in the node\";\n-    int headIndex \u003d 0; //currently the delimiter is in the head of the list\n-    int curIndex;\n+    // The blocks must be sorted and the storagenodes blocks must be sorted\n+    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n+    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n+    BlockInfo storageBlock \u003d null;\n \n-    if (newReport \u003d\u003d null) {\n-      newReport \u003d BlockListAsLongs.EMPTY;\n-    }\n-    // scan the report and process newly reported blocks\n-    for (BlockReportReplica iblk : newReport) {\n-      ReplicaState iState \u003d iblk.getState();\n-      BlockInfo storedBlock \u003d processReportedBlock(storageInfo,\n-          iblk, iState, toAdd, toInvalidate, toCorrupt, toUC);\n+    for (BlockReportReplica replica : newReport) {\n \n-      // move block to the head of the list\n-      if (storedBlock !\u003d null \u0026\u0026\n-          (curIndex \u003d storedBlock.findStorageInfo(storageInfo)) \u003e\u003d 0) {\n-        headIndex \u003d storageInfo.moveBlockToHead(storedBlock, curIndex, headIndex);\n+      long replicaID \u003d replica.getBlockId();\n+      if (BlockIdManager.isStripedBlockID(replicaID)\n+          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n+              !blocksMap.containsBlock(replica))) {\n+        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n       }\n+\n+      ReplicaState reportedState \u003d replica.getState();\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Reported block \" + replica\n+                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n+                  + \" replicaState \u003d \" + reportedState);\n+      }\n+\n+      if (shouldPostponeBlocksFromFuture\n+          \u0026\u0026 isGenStampInFuture(replica)) {\n+        queueReportedBlock(storageInfo, replica, reportedState,\n+                           QUEUE_REASON_FUTURE_GENSTAMP);\n+        continue;\n+      }\n+\n+      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n+        storageBlock \u003d storageBlocksIterator.next();\n+      }\n+\n+      do {\n+        int cmp;\n+        if (storageBlock \u003d\u003d null ||\n+            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n+          // Check if block is available in NN but not yet on this storage\n+          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n+          if (nnBlock !\u003d null) {\n+            reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                  nnBlock, toAdd, toCorrupt, toUC);\n+          } else {\n+            // Replica not found anywhere so it should be invalidated\n+            toInvalidate.add(new Block(replica));\n+          }\n+          break;\n+        } else if (cmp \u003d\u003d 0) {\n+          // Replica matched current storageblock\n+          reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                storageBlock, toAdd, toCorrupt, toUC);\n+          storageBlock \u003d null;\n+        } else {\n+          // replica has higher ID than storedBlock\n+          // Remove all stored blocks with IDs lower than replica\n+          do {\n+            toRemove.add(storageBlock);\n+            storageBlock \u003d storageBlocksIterator.hasNext()\n+                           ? storageBlocksIterator.next() : null;\n+          } while (storageBlock !\u003d null \u0026\u0026\n+                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n+        }\n+      } while (storageBlock !\u003d null);\n     }\n \n-    // collect blocks that have not been reported\n-    // all of them are next to the delimiter\n-    Iterator\u003cBlockInfo\u003e it \u003d\n-        storageInfo.new BlockIterator(delimiter.getNext(0));\n-    while (it.hasNext()) {\n-      toRemove.add(it.next());\n+    // Iterate any remaing blocks that have not been reported and remove them\n+    while (storageBlocksIterator.hasNext()) {\n+      toRemove.add(storageBlocksIterator.next());\n     }\n-    storageInfo.removeBlock(delimiter);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n      Iterable\u003cBlockReportReplica\u003e newReport,\n      Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n      Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n      Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n      Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n      Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n\n    // The blocks must be sorted and the storagenodes blocks must be sorted\n    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n    BlockInfo storageBlock \u003d null;\n\n    for (BlockReportReplica replica : newReport) {\n\n      long replicaID \u003d replica.getBlockId();\n      if (BlockIdManager.isStripedBlockID(replicaID)\n          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n              !blocksMap.containsBlock(replica))) {\n        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n      }\n\n      ReplicaState reportedState \u003d replica.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reported block \" + replica\n                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n                  + \" replicaState \u003d \" + reportedState);\n      }\n\n      if (shouldPostponeBlocksFromFuture\n          \u0026\u0026 isGenStampInFuture(replica)) {\n        queueReportedBlock(storageInfo, replica, reportedState,\n                           QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n        storageBlock \u003d storageBlocksIterator.next();\n      }\n\n      do {\n        int cmp;\n        if (storageBlock \u003d\u003d null ||\n            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n          // Check if block is available in NN but not yet on this storage\n          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n          if (nnBlock !\u003d null) {\n            reportDiffSortedInner(storageInfo, replica, reportedState,\n                                  nnBlock, toAdd, toCorrupt, toUC);\n          } else {\n            // Replica not found anywhere so it should be invalidated\n            toInvalidate.add(new Block(replica));\n          }\n          break;\n        } else if (cmp \u003d\u003d 0) {\n          // Replica matched current storageblock\n          reportDiffSortedInner(storageInfo, replica, reportedState,\n                                storageBlock, toAdd, toCorrupt, toUC);\n          storageBlock \u003d null;\n        } else {\n          // replica has higher ID than storedBlock\n          // Remove all stored blocks with IDs lower than replica\n          do {\n            toRemove.add(storageBlock);\n            storageBlock \u003d storageBlocksIterator.hasNext()\n                           ? storageBlocksIterator.next() : null;\n          } while (storageBlock !\u003d null \u0026\u0026\n                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n        }\n      } while (storageBlock !\u003d null);\n    }\n\n    // Iterate any remaing blocks that have not been reported and remove them\n    while (storageBlocksIterator.hasNext()) {\n      toRemove.add(storageBlocksIterator.next());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "reportDiff",
            "newValue": "reportDiffSorted"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)\n",
          "commitDate": "02/02/16 11:23 AM",
          "commitName": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "31/01/16 11:54 PM",
          "commitNameOld": "e418bd1fb0568ce7ae22f588fea2dd9c95567383",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 1.48,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,78 @@\n-  private void reportDiff(DatanodeStorageInfo storageInfo, \n-      BlockListAsLongs newReport,\n+  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n+      Iterable\u003cBlockReportReplica\u003e newReport,\n       Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n       Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n       Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n       Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n       Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n \n-    // place a delimiter in the list which separates blocks \n-    // that have been reported from those that have not\n-    Block delimiterBlock \u003d new Block();\n-    BlockInfo delimiter \u003d new BlockInfoContiguous(delimiterBlock,\n-        (short) 1);\n-    AddBlockResult result \u003d storageInfo.addBlock(delimiter, delimiterBlock);\n-    assert result \u003d\u003d AddBlockResult.ADDED \n-        : \"Delimiting block cannot be present in the node\";\n-    int headIndex \u003d 0; //currently the delimiter is in the head of the list\n-    int curIndex;\n+    // The blocks must be sorted and the storagenodes blocks must be sorted\n+    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n+    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n+    BlockInfo storageBlock \u003d null;\n \n-    if (newReport \u003d\u003d null) {\n-      newReport \u003d BlockListAsLongs.EMPTY;\n-    }\n-    // scan the report and process newly reported blocks\n-    for (BlockReportReplica iblk : newReport) {\n-      ReplicaState iState \u003d iblk.getState();\n-      BlockInfo storedBlock \u003d processReportedBlock(storageInfo,\n-          iblk, iState, toAdd, toInvalidate, toCorrupt, toUC);\n+    for (BlockReportReplica replica : newReport) {\n \n-      // move block to the head of the list\n-      if (storedBlock !\u003d null \u0026\u0026\n-          (curIndex \u003d storedBlock.findStorageInfo(storageInfo)) \u003e\u003d 0) {\n-        headIndex \u003d storageInfo.moveBlockToHead(storedBlock, curIndex, headIndex);\n+      long replicaID \u003d replica.getBlockId();\n+      if (BlockIdManager.isStripedBlockID(replicaID)\n+          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n+              !blocksMap.containsBlock(replica))) {\n+        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n       }\n+\n+      ReplicaState reportedState \u003d replica.getState();\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Reported block \" + replica\n+                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n+                  + \" replicaState \u003d \" + reportedState);\n+      }\n+\n+      if (shouldPostponeBlocksFromFuture\n+          \u0026\u0026 isGenStampInFuture(replica)) {\n+        queueReportedBlock(storageInfo, replica, reportedState,\n+                           QUEUE_REASON_FUTURE_GENSTAMP);\n+        continue;\n+      }\n+\n+      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n+        storageBlock \u003d storageBlocksIterator.next();\n+      }\n+\n+      do {\n+        int cmp;\n+        if (storageBlock \u003d\u003d null ||\n+            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n+          // Check if block is available in NN but not yet on this storage\n+          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n+          if (nnBlock !\u003d null) {\n+            reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                  nnBlock, toAdd, toCorrupt, toUC);\n+          } else {\n+            // Replica not found anywhere so it should be invalidated\n+            toInvalidate.add(new Block(replica));\n+          }\n+          break;\n+        } else if (cmp \u003d\u003d 0) {\n+          // Replica matched current storageblock\n+          reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                storageBlock, toAdd, toCorrupt, toUC);\n+          storageBlock \u003d null;\n+        } else {\n+          // replica has higher ID than storedBlock\n+          // Remove all stored blocks with IDs lower than replica\n+          do {\n+            toRemove.add(storageBlock);\n+            storageBlock \u003d storageBlocksIterator.hasNext()\n+                           ? storageBlocksIterator.next() : null;\n+          } while (storageBlock !\u003d null \u0026\u0026\n+                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n+        }\n+      } while (storageBlock !\u003d null);\n     }\n \n-    // collect blocks that have not been reported\n-    // all of them are next to the delimiter\n-    Iterator\u003cBlockInfo\u003e it \u003d\n-        storageInfo.new BlockIterator(delimiter.getNext(0));\n-    while (it.hasNext()) {\n-      toRemove.add(it.next());\n+    // Iterate any remaing blocks that have not been reported and remove them\n+    while (storageBlocksIterator.hasNext()) {\n+      toRemove.add(storageBlocksIterator.next());\n     }\n-    storageInfo.removeBlock(delimiter);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n      Iterable\u003cBlockReportReplica\u003e newReport,\n      Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n      Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n      Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n      Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n      Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n\n    // The blocks must be sorted and the storagenodes blocks must be sorted\n    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n    BlockInfo storageBlock \u003d null;\n\n    for (BlockReportReplica replica : newReport) {\n\n      long replicaID \u003d replica.getBlockId();\n      if (BlockIdManager.isStripedBlockID(replicaID)\n          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n              !blocksMap.containsBlock(replica))) {\n        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n      }\n\n      ReplicaState reportedState \u003d replica.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reported block \" + replica\n                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n                  + \" replicaState \u003d \" + reportedState);\n      }\n\n      if (shouldPostponeBlocksFromFuture\n          \u0026\u0026 isGenStampInFuture(replica)) {\n        queueReportedBlock(storageInfo, replica, reportedState,\n                           QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n        storageBlock \u003d storageBlocksIterator.next();\n      }\n\n      do {\n        int cmp;\n        if (storageBlock \u003d\u003d null ||\n            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n          // Check if block is available in NN but not yet on this storage\n          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n          if (nnBlock !\u003d null) {\n            reportDiffSortedInner(storageInfo, replica, reportedState,\n                                  nnBlock, toAdd, toCorrupt, toUC);\n          } else {\n            // Replica not found anywhere so it should be invalidated\n            toInvalidate.add(new Block(replica));\n          }\n          break;\n        } else if (cmp \u003d\u003d 0) {\n          // Replica matched current storageblock\n          reportDiffSortedInner(storageInfo, replica, reportedState,\n                                storageBlock, toAdd, toCorrupt, toUC);\n          storageBlock \u003d null;\n        } else {\n          // replica has higher ID than storedBlock\n          // Remove all stored blocks with IDs lower than replica\n          do {\n            toRemove.add(storageBlock);\n            storageBlock \u003d storageBlocksIterator.hasNext()\n                           ? storageBlocksIterator.next() : null;\n          } while (storageBlock !\u003d null \u0026\u0026\n                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n        }\n      } while (storageBlock !\u003d null);\n    }\n\n    // Iterate any remaing blocks that have not been reported and remove them\n    while (storageBlocksIterator.hasNext()) {\n      toRemove.add(storageBlocksIterator.next());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[storageInfo-DatanodeStorageInfo, newReport-BlockListAsLongs, toAdd-Collection\u003cBlockInfoToAdd\u003e, toRemove-Collection\u003cBlockInfo\u003e, toInvalidate-Collection\u003cBlock\u003e, toCorrupt-Collection\u003cBlockToMarkCorrupt\u003e, toUC-Collection\u003cStatefulBlockInfo\u003e]",
            "newValue": "[storageInfo-DatanodeStorageInfo, newReport-Iterable\u003cBlockReportReplica\u003e, toAdd-Collection\u003cBlockInfoToAdd\u003e, toRemove-Collection\u003cBlockInfo\u003e, toInvalidate-Collection\u003cBlock\u003e, toCorrupt-Collection\u003cBlockToMarkCorrupt\u003e, toUC-Collection\u003cStatefulBlockInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9260. Improve the performance and GC friendliness of NameNode startup and full block reports (Staffan Friberg via cmccabe)\n",
          "commitDate": "02/02/16 11:23 AM",
          "commitName": "dd9ebf6eedfd4ff8b3486eae2a446de6b0c7fa8a",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "31/01/16 11:54 PM",
          "commitNameOld": "e418bd1fb0568ce7ae22f588fea2dd9c95567383",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 1.48,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,78 @@\n-  private void reportDiff(DatanodeStorageInfo storageInfo, \n-      BlockListAsLongs newReport,\n+  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n+      Iterable\u003cBlockReportReplica\u003e newReport,\n       Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n       Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n       Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n       Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n       Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n \n-    // place a delimiter in the list which separates blocks \n-    // that have been reported from those that have not\n-    Block delimiterBlock \u003d new Block();\n-    BlockInfo delimiter \u003d new BlockInfoContiguous(delimiterBlock,\n-        (short) 1);\n-    AddBlockResult result \u003d storageInfo.addBlock(delimiter, delimiterBlock);\n-    assert result \u003d\u003d AddBlockResult.ADDED \n-        : \"Delimiting block cannot be present in the node\";\n-    int headIndex \u003d 0; //currently the delimiter is in the head of the list\n-    int curIndex;\n+    // The blocks must be sorted and the storagenodes blocks must be sorted\n+    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n+    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n+    BlockInfo storageBlock \u003d null;\n \n-    if (newReport \u003d\u003d null) {\n-      newReport \u003d BlockListAsLongs.EMPTY;\n-    }\n-    // scan the report and process newly reported blocks\n-    for (BlockReportReplica iblk : newReport) {\n-      ReplicaState iState \u003d iblk.getState();\n-      BlockInfo storedBlock \u003d processReportedBlock(storageInfo,\n-          iblk, iState, toAdd, toInvalidate, toCorrupt, toUC);\n+    for (BlockReportReplica replica : newReport) {\n \n-      // move block to the head of the list\n-      if (storedBlock !\u003d null \u0026\u0026\n-          (curIndex \u003d storedBlock.findStorageInfo(storageInfo)) \u003e\u003d 0) {\n-        headIndex \u003d storageInfo.moveBlockToHead(storedBlock, curIndex, headIndex);\n+      long replicaID \u003d replica.getBlockId();\n+      if (BlockIdManager.isStripedBlockID(replicaID)\n+          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n+              !blocksMap.containsBlock(replica))) {\n+        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n       }\n+\n+      ReplicaState reportedState \u003d replica.getState();\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Reported block \" + replica\n+                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n+                  + \" replicaState \u003d \" + reportedState);\n+      }\n+\n+      if (shouldPostponeBlocksFromFuture\n+          \u0026\u0026 isGenStampInFuture(replica)) {\n+        queueReportedBlock(storageInfo, replica, reportedState,\n+                           QUEUE_REASON_FUTURE_GENSTAMP);\n+        continue;\n+      }\n+\n+      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n+        storageBlock \u003d storageBlocksIterator.next();\n+      }\n+\n+      do {\n+        int cmp;\n+        if (storageBlock \u003d\u003d null ||\n+            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n+          // Check if block is available in NN but not yet on this storage\n+          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n+          if (nnBlock !\u003d null) {\n+            reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                  nnBlock, toAdd, toCorrupt, toUC);\n+          } else {\n+            // Replica not found anywhere so it should be invalidated\n+            toInvalidate.add(new Block(replica));\n+          }\n+          break;\n+        } else if (cmp \u003d\u003d 0) {\n+          // Replica matched current storageblock\n+          reportDiffSortedInner(storageInfo, replica, reportedState,\n+                                storageBlock, toAdd, toCorrupt, toUC);\n+          storageBlock \u003d null;\n+        } else {\n+          // replica has higher ID than storedBlock\n+          // Remove all stored blocks with IDs lower than replica\n+          do {\n+            toRemove.add(storageBlock);\n+            storageBlock \u003d storageBlocksIterator.hasNext()\n+                           ? storageBlocksIterator.next() : null;\n+          } while (storageBlock !\u003d null \u0026\u0026\n+                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n+        }\n+      } while (storageBlock !\u003d null);\n     }\n \n-    // collect blocks that have not been reported\n-    // all of them are next to the delimiter\n-    Iterator\u003cBlockInfo\u003e it \u003d\n-        storageInfo.new BlockIterator(delimiter.getNext(0));\n-    while (it.hasNext()) {\n-      toRemove.add(it.next());\n+    // Iterate any remaing blocks that have not been reported and remove them\n+    while (storageBlocksIterator.hasNext()) {\n+      toRemove.add(storageBlocksIterator.next());\n     }\n-    storageInfo.removeBlock(delimiter);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void reportDiffSorted(DatanodeStorageInfo storageInfo,\n      Iterable\u003cBlockReportReplica\u003e newReport,\n      Collection\u003cBlockInfoToAdd\u003e toAdd,     // add to DatanodeDescriptor\n      Collection\u003cBlockInfo\u003e toRemove,       // remove from DatanodeDescriptor\n      Collection\u003cBlock\u003e toInvalidate,       // should be removed from DN\n      Collection\u003cBlockToMarkCorrupt\u003e toCorrupt, // add to corrupt replicas list\n      Collection\u003cStatefulBlockInfo\u003e toUC) { // add to under-construction list\n\n    // The blocks must be sorted and the storagenodes blocks must be sorted\n    Iterator\u003cBlockInfo\u003e storageBlocksIterator \u003d storageInfo.getBlockIterator();\n    DatanodeDescriptor dn \u003d storageInfo.getDatanodeDescriptor();\n    BlockInfo storageBlock \u003d null;\n\n    for (BlockReportReplica replica : newReport) {\n\n      long replicaID \u003d replica.getBlockId();\n      if (BlockIdManager.isStripedBlockID(replicaID)\n          \u0026\u0026 (!hasNonEcBlockUsingStripedID ||\n              !blocksMap.containsBlock(replica))) {\n        replicaID \u003d BlockIdManager.convertToStripedID(replicaID);\n      }\n\n      ReplicaState reportedState \u003d replica.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Reported block \" + replica\n                  + \" on \" + dn + \" size \" + replica.getNumBytes()\n                  + \" replicaState \u003d \" + reportedState);\n      }\n\n      if (shouldPostponeBlocksFromFuture\n          \u0026\u0026 isGenStampInFuture(replica)) {\n        queueReportedBlock(storageInfo, replica, reportedState,\n                           QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      if (storageBlock \u003d\u003d null \u0026\u0026 storageBlocksIterator.hasNext()) {\n        storageBlock \u003d storageBlocksIterator.next();\n      }\n\n      do {\n        int cmp;\n        if (storageBlock \u003d\u003d null ||\n            (cmp \u003d Long.compare(replicaID, storageBlock.getBlockId())) \u003c 0) {\n          // Check if block is available in NN but not yet on this storage\n          BlockInfo nnBlock \u003d blocksMap.getStoredBlock(new Block(replicaID));\n          if (nnBlock !\u003d null) {\n            reportDiffSortedInner(storageInfo, replica, reportedState,\n                                  nnBlock, toAdd, toCorrupt, toUC);\n          } else {\n            // Replica not found anywhere so it should be invalidated\n            toInvalidate.add(new Block(replica));\n          }\n          break;\n        } else if (cmp \u003d\u003d 0) {\n          // Replica matched current storageblock\n          reportDiffSortedInner(storageInfo, replica, reportedState,\n                                storageBlock, toAdd, toCorrupt, toUC);\n          storageBlock \u003d null;\n        } else {\n          // replica has higher ID than storedBlock\n          // Remove all stored blocks with IDs lower than replica\n          do {\n            toRemove.add(storageBlock);\n            storageBlock \u003d storageBlocksIterator.hasNext()\n                           ? storageBlocksIterator.next() : null;\n          } while (storageBlock !\u003d null \u0026\u0026\n                   Long.compare(replicaID, storageBlock.getBlockId()) \u003e 0);\n        }\n      } while (storageBlock !\u003d null);\n    }\n\n    // Iterate any remaing blocks that have not been reported and remove them\n    while (storageBlocksIterator.hasNext()) {\n      toRemove.add(storageBlocksIterator.next());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}