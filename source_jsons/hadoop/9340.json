{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "reencryptEncryptionZoneInt",
  "functionId": "reencryptEncryptionZoneInt___pc-FSPermissionChecker(modifiers-final)__zone-String(modifiers-final)__action-ReencryptAction(modifiers-final)__logRetryCache-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 7911,
  "functionEndLine": 7964,
  "numCommitsSeen": 1656,
  "timeTaken": 12787,
  "changeHistory": [
    "1824aee9da4056de0fb638906b2172e486bbebe7",
    "6020505943fbb6133f7c2747e6d85d79cde788ea",
    "84a1321f6aa0af6895564a7c47f8f264656f0294",
    "b3a4d7d2a01051e166c06ee78e8c6e8df1341948",
    "0ba8ff4b77db11fb68111f20fb077cffddd24f17",
    "1000a2af04b24c123a3b08168f36b4e90420cab7"
  ],
  "changeHistoryShort": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": "Ybodychange",
    "6020505943fbb6133f7c2747e6d85d79cde788ea": "Ybodychange",
    "84a1321f6aa0af6895564a7c47f8f264656f0294": "Ymultichange(Yparameterchange,Ybodychange)",
    "b3a4d7d2a01051e166c06ee78e8c6e8df1341948": "Ybodychange",
    "0ba8ff4b77db11fb68111f20fb077cffddd24f17": "Ybodychange",
    "1000a2af04b24c123a3b08168f36b4e90420cab7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
      "commitDate": "18/04/20 1:52 PM",
      "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
      "commitAuthor": "Toshihiro Suzuki",
      "commitDateOld": "25/03/20 10:28 AM",
      "commitNameOld": "a700803a18fb957d2799001a2ce1dcb70f75c080",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n       final String zone, final ReencryptAction action,\n       final boolean logRetryCache) throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n     String keyVersionName \u003d null;\n     if (action \u003d\u003d ReencryptAction.START) {\n       // get zone\u0027s latest key version name out of the lock.\n       keyVersionName \u003d\n           FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n       if (keyVersionName \u003d\u003d null) {\n         throw new IOException(\"Failed to get key version name for \" + zone);\n       }\n       LOG.info(\"Re-encryption using key version \" + keyVersionName\n           + \" for zone \" + zone);\n     }\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n           + \" re-encryption on zone \" + zone);\n       List\u003cXAttr\u003e xattrs;\n       dir.writeLock();\n       try {\n         final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n         if (iip.getLastINode() \u003d\u003d null) {\n           throw new FileNotFoundException(zone + \" does not exist.\");\n         }\n         switch (action) {\n         case START:\n           xattrs \u003d FSDirEncryptionZoneOp\n               .reencryptEncryptionZone(dir, iip, keyVersionName);\n           break;\n         case CANCEL:\n           xattrs \u003d\n               FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n           break;\n         default:\n           throw new IOException(\n               \"Re-encryption action \" + action + \" is not supported\");\n         }\n       } finally {\n         dir.writeUnlock();\n       }\n       if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n         getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n-      writeUnlock();\n+      writeUnlock(action + \"reencryption\", getLockReportInfoSupplier(zone));\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n      final String zone, final ReencryptAction action,\n      final boolean logRetryCache) throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d\n          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n      LOG.info(\"Re-encryption using key version \" + keyVersionName\n          + \" for zone \" + zone);\n    }\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock(action + \"reencryption\", getLockReportInfoSupplier(zone));\n    }\n    getEditLog().logSync();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "6020505943fbb6133f7c2747e6d85d79cde788ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14915. Move Superuser Check Before Taking Lock For Encryption API. Contributed by Ayush Saxena.\n",
      "commitDate": "22/10/19 6:14 AM",
      "commitName": "6020505943fbb6133f7c2747e6d85d79cde788ea",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "21/10/19 5:31 PM",
      "commitNameOld": "72003b19bf4c652b53625984d109542abd0cf20e",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n   private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n       final String zone, final ReencryptAction action,\n       final boolean logRetryCache) throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n     String keyVersionName \u003d null;\n     if (action \u003d\u003d ReencryptAction.START) {\n       // get zone\u0027s latest key version name out of the lock.\n       keyVersionName \u003d\n           FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n       if (keyVersionName \u003d\u003d null) {\n         throw new IOException(\"Failed to get key version name for \" + zone);\n       }\n       LOG.info(\"Re-encryption using key version \" + keyVersionName\n           + \" for zone \" + zone);\n     }\n     writeLock();\n     try {\n-      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n           + \" re-encryption on zone \" + zone);\n       List\u003cXAttr\u003e xattrs;\n       dir.writeLock();\n       try {\n         final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n         if (iip.getLastINode() \u003d\u003d null) {\n           throw new FileNotFoundException(zone + \" does not exist.\");\n         }\n         switch (action) {\n         case START:\n           xattrs \u003d FSDirEncryptionZoneOp\n               .reencryptEncryptionZone(dir, iip, keyVersionName);\n           break;\n         case CANCEL:\n           xattrs \u003d\n               FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n           break;\n         default:\n           throw new IOException(\n               \"Re-encryption action \" + action + \" is not supported\");\n         }\n       } finally {\n         dir.writeUnlock();\n       }\n       if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n         getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n       writeUnlock();\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n      final String zone, final ReencryptAction action,\n      final boolean logRetryCache) throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d\n          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n      LOG.info(\"Re-encryption using key version \" + keyVersionName\n          + \" for zone \" + zone);\n    }\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "84a1321f6aa0af6895564a7c47f8f264656f0294": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13136. Avoid taking FSN lock while doing group member lookup for FSD permission check. Contributed by Xiaoyu Yao.\n",
      "commitDate": "22/02/18 11:32 AM",
      "commitName": "84a1321f6aa0af6895564a7c47f8f264656f0294",
      "commitAuthor": "Xiaoyu Yao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13136. Avoid taking FSN lock while doing group member lookup for FSD permission check. Contributed by Xiaoyu Yao.\n",
          "commitDate": "22/02/18 11:32 AM",
          "commitName": "84a1321f6aa0af6895564a7c47f8f264656f0294",
          "commitAuthor": "Xiaoyu Yao",
          "commitDateOld": "15/02/18 1:32 PM",
          "commitNameOld": "47473952e56b0380147d42f4110ad03c2276c961",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 6.92,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,55 @@\n-  private void reencryptEncryptionZoneInt(final String zone,\n-      final ReencryptAction action, final boolean logRetryCache)\n-      throws IOException {\n+  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n+      final String zone, final ReencryptAction action,\n+      final boolean logRetryCache) throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n     String keyVersionName \u003d null;\n     if (action \u003d\u003d ReencryptAction.START) {\n       // get zone\u0027s latest key version name out of the lock.\n-      keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n+      keyVersionName \u003d\n+          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n       if (keyVersionName \u003d\u003d null) {\n         throw new IOException(\"Failed to get key version name for \" + zone);\n       }\n       LOG.info(\"Re-encryption using key version \" + keyVersionName\n           + \" for zone \" + zone);\n     }\n     writeLock();\n     try {\n-      checkSuperuserPrivilege();\n+      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n           + \" re-encryption on zone \" + zone);\n-      final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n       List\u003cXAttr\u003e xattrs;\n       dir.writeLock();\n       try {\n         final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n         if (iip.getLastINode() \u003d\u003d null) {\n           throw new FileNotFoundException(zone + \" does not exist.\");\n         }\n         switch (action) {\n         case START:\n           xattrs \u003d FSDirEncryptionZoneOp\n               .reencryptEncryptionZone(dir, iip, keyVersionName);\n           break;\n         case CANCEL:\n           xattrs \u003d\n               FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n           break;\n         default:\n           throw new IOException(\n               \"Re-encryption action \" + action + \" is not supported\");\n         }\n       } finally {\n         dir.writeUnlock();\n       }\n       if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n         getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n       writeUnlock();\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n      final String zone, final ReencryptAction action,\n      final boolean logRetryCache) throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d\n          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n      LOG.info(\"Re-encryption using key version \" + keyVersionName\n          + \" for zone \" + zone);\n    }\n    writeLock();\n    try {\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[zone-String(modifiers-final), action-ReencryptAction(modifiers-final), logRetryCache-boolean(modifiers-final)]",
            "newValue": "[pc-FSPermissionChecker(modifiers-final), zone-String(modifiers-final), action-ReencryptAction(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13136. Avoid taking FSN lock while doing group member lookup for FSD permission check. Contributed by Xiaoyu Yao.\n",
          "commitDate": "22/02/18 11:32 AM",
          "commitName": "84a1321f6aa0af6895564a7c47f8f264656f0294",
          "commitAuthor": "Xiaoyu Yao",
          "commitDateOld": "15/02/18 1:32 PM",
          "commitNameOld": "47473952e56b0380147d42f4110ad03c2276c961",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 6.92,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,55 @@\n-  private void reencryptEncryptionZoneInt(final String zone,\n-      final ReencryptAction action, final boolean logRetryCache)\n-      throws IOException {\n+  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n+      final String zone, final ReencryptAction action,\n+      final boolean logRetryCache) throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n     String keyVersionName \u003d null;\n     if (action \u003d\u003d ReencryptAction.START) {\n       // get zone\u0027s latest key version name out of the lock.\n-      keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n+      keyVersionName \u003d\n+          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n       if (keyVersionName \u003d\u003d null) {\n         throw new IOException(\"Failed to get key version name for \" + zone);\n       }\n       LOG.info(\"Re-encryption using key version \" + keyVersionName\n           + \" for zone \" + zone);\n     }\n     writeLock();\n     try {\n-      checkSuperuserPrivilege();\n+      checkSuperuserPrivilege(pc);\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n           + \" re-encryption on zone \" + zone);\n-      final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n       List\u003cXAttr\u003e xattrs;\n       dir.writeLock();\n       try {\n         final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n         if (iip.getLastINode() \u003d\u003d null) {\n           throw new FileNotFoundException(zone + \" does not exist.\");\n         }\n         switch (action) {\n         case START:\n           xattrs \u003d FSDirEncryptionZoneOp\n               .reencryptEncryptionZone(dir, iip, keyVersionName);\n           break;\n         case CANCEL:\n           xattrs \u003d\n               FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n           break;\n         default:\n           throw new IOException(\n               \"Re-encryption action \" + action + \" is not supported\");\n         }\n       } finally {\n         dir.writeUnlock();\n       }\n       if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n         getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n       writeUnlock();\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void reencryptEncryptionZoneInt(final FSPermissionChecker pc,\n      final String zone, final ReencryptAction action,\n      final boolean logRetryCache) throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d\n          FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, pc, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n      LOG.info(\"Re-encryption using key version \" + keyVersionName\n          + \" for zone \" + zone);\n    }\n    writeLock();\n    try {\n      checkSuperuserPrivilege(pc);\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "b3a4d7d2a01051e166c06ee78e8c6e8df1341948": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12400. Provide a way for NN to drain the local key cache before re-encryption.\n",
      "commitDate": "07/09/17 8:51 PM",
      "commitName": "b3a4d7d2a01051e166c06ee78e8c6e8df1341948",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "07/09/17 4:57 PM",
      "commitNameOld": "4e50dc976a92a9560630c87cfc4e4513916e5735",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   private void reencryptEncryptionZoneInt(final String zone,\n       final ReencryptAction action, final boolean logRetryCache)\n       throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n     String keyVersionName \u003d null;\n     if (action \u003d\u003d ReencryptAction.START) {\n       // get zone\u0027s latest key version name out of the lock.\n       keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n       if (keyVersionName \u003d\u003d null) {\n         throw new IOException(\"Failed to get key version name for \" + zone);\n       }\n+      LOG.info(\"Re-encryption using key version \" + keyVersionName\n+          + \" for zone \" + zone);\n     }\n     writeLock();\n     try {\n       checkSuperuserPrivilege();\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n           + \" re-encryption on zone \" + zone);\n       final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n       List\u003cXAttr\u003e xattrs;\n       dir.writeLock();\n       try {\n         final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n         if (iip.getLastINode() \u003d\u003d null) {\n           throw new FileNotFoundException(zone + \" does not exist.\");\n         }\n         switch (action) {\n         case START:\n           xattrs \u003d FSDirEncryptionZoneOp\n               .reencryptEncryptionZone(dir, iip, keyVersionName);\n           break;\n         case CANCEL:\n           xattrs \u003d\n               FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n           break;\n         default:\n           throw new IOException(\n               \"Re-encryption action \" + action + \" is not supported\");\n         }\n       } finally {\n         dir.writeUnlock();\n       }\n       if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n         getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n       writeUnlock();\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reencryptEncryptionZoneInt(final String zone,\n      final ReencryptAction action, final boolean logRetryCache)\n      throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n      LOG.info(\"Re-encryption using key version \" + keyVersionName\n          + \" for zone \" + zone);\n    }\n    writeLock();\n    try {\n      checkSuperuserPrivilege();\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "0ba8ff4b77db11fb68111f20fb077cffddd24f17": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12359. Re-encryption should operate with minimum KMS ACL requirements.\n",
      "commitDate": "05/09/17 10:08 AM",
      "commitName": "0ba8ff4b77db11fb68111f20fb077cffddd24f17",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "31/08/17 11:20 PM",
      "commitNameOld": "1b3b9938cf663c71d2e5d9032fdfb1460bae0d3f",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 4.45,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,53 @@\n   private void reencryptEncryptionZoneInt(final String zone,\n       final ReencryptAction action, final boolean logRetryCache)\n       throws IOException {\n     if (getProvider() \u003d\u003d null) {\n       throw new IOException(\"No key provider configured, re-encryption \"\n           + \"operation is rejected\");\n     }\n-    FSPermissionChecker pc \u003d getPermissionChecker();\n-    // get keyVersionName out of the lock. This keyVersionName will be used\n-    // as the target keyVersion for the entire re-encryption.\n-    // This means all edek\u0027s keyVersion will be compared with this one, and\n-    // kms is only contacted if the edek\u0027s keyVersion is different.\n-    final KeyVersion kv \u003d\n-        FSDirEncryptionZoneOp.getLatestKeyVersion(dir, zone, pc);\n-    provider.invalidateCache(kv.getName());\n+    String keyVersionName \u003d null;\n+    if (action \u003d\u003d ReencryptAction.START) {\n+      // get zone\u0027s latest key version name out of the lock.\n+      keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n+      if (keyVersionName \u003d\u003d null) {\n+        throw new IOException(\"Failed to get key version name for \" + zone);\n+      }\n+    }\n     writeLock();\n     try {\n       checkSuperuserPrivilege();\n       checkOperation(OperationCategory.WRITE);\n-      checkNameNodeSafeMode(\n-          \"NameNode in safemode, cannot \" + action + \" re-encryption on zone \"\n-              + zone);\n-      switch (action) {\n-      case START:\n-        FSDirEncryptionZoneOp\n-            .reencryptEncryptionZone(dir, zone, kv.getVersionName(),\n-                logRetryCache);\n-        break;\n-      case CANCEL:\n-        FSDirEncryptionZoneOp\n-            .cancelReencryptEncryptionZone(dir, zone, logRetryCache);\n-        break;\n-      default:\n-        throw new IOException(\n-            \"Re-encryption action \" + action + \" is not supported\");\n+      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n+          + \" re-encryption on zone \" + zone);\n+      final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n+      List\u003cXAttr\u003e xattrs;\n+      dir.writeLock();\n+      try {\n+        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n+        if (iip.getLastINode() \u003d\u003d null) {\n+          throw new FileNotFoundException(zone + \" does not exist.\");\n+        }\n+        switch (action) {\n+        case START:\n+          xattrs \u003d FSDirEncryptionZoneOp\n+              .reencryptEncryptionZone(dir, iip, keyVersionName);\n+          break;\n+        case CANCEL:\n+          xattrs \u003d\n+              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n+          break;\n+        default:\n+          throw new IOException(\n+              \"Re-encryption action \" + action + \" is not supported\");\n+        }\n+      } finally {\n+        dir.writeUnlock();\n+      }\n+      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n+        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n       }\n     } finally {\n       writeUnlock();\n     }\n     getEditLog().logSync();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void reencryptEncryptionZoneInt(final String zone,\n      final ReencryptAction action, final boolean logRetryCache)\n      throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    String keyVersionName \u003d null;\n    if (action \u003d\u003d ReencryptAction.START) {\n      // get zone\u0027s latest key version name out of the lock.\n      keyVersionName \u003d FSDirEncryptionZoneOp.getCurrentKeyVersion(dir, zone);\n      if (keyVersionName \u003d\u003d null) {\n        throw new IOException(\"Failed to get key version name for \" + zone);\n      }\n    }\n    writeLock();\n    try {\n      checkSuperuserPrivilege();\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"NameNode in safemode, cannot \" + action\n          + \" re-encryption on zone \" + zone);\n      final FSPermissionChecker pc \u003d dir.getPermissionChecker();\n      List\u003cXAttr\u003e xattrs;\n      dir.writeLock();\n      try {\n        final INodesInPath iip \u003d dir.resolvePath(pc, zone, DirOp.WRITE);\n        if (iip.getLastINode() \u003d\u003d null) {\n          throw new FileNotFoundException(zone + \" does not exist.\");\n        }\n        switch (action) {\n        case START:\n          xattrs \u003d FSDirEncryptionZoneOp\n              .reencryptEncryptionZone(dir, iip, keyVersionName);\n          break;\n        case CANCEL:\n          xattrs \u003d\n              FSDirEncryptionZoneOp.cancelReencryptEncryptionZone(dir, iip);\n          break;\n        default:\n          throw new IOException(\n              \"Re-encryption action \" + action + \" is not supported\");\n        }\n      } finally {\n        dir.writeUnlock();\n      }\n      if (xattrs !\u003d null \u0026\u0026 !xattrs.isEmpty()) {\n        getEditLog().logSetXAttrs(zone, xattrs, logRetryCache);\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1000a2af04b24c123a3b08168f36b4e90420cab7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10899. Add functionality to re-encrypt EDEKs.\n",
      "commitDate": "23/08/17 5:06 PM",
      "commitName": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,41 @@\n+  private void reencryptEncryptionZoneInt(final String zone,\n+      final ReencryptAction action, final boolean logRetryCache)\n+      throws IOException {\n+    if (getProvider() \u003d\u003d null) {\n+      throw new IOException(\"No key provider configured, re-encryption \"\n+          + \"operation is rejected\");\n+    }\n+    FSPermissionChecker pc \u003d getPermissionChecker();\n+    // get keyVersionName out of the lock. This keyVersionName will be used\n+    // as the target keyVersion for the entire re-encryption.\n+    // This means all edek\u0027s keyVersion will be compared with this one, and\n+    // kms is only contacted if the edek\u0027s keyVersion is different.\n+    final KeyVersion kv \u003d\n+        FSDirEncryptionZoneOp.getLatestKeyVersion(dir, zone, pc);\n+    provider.invalidateCache(kv.getName());\n+    writeLock();\n+    try {\n+      checkSuperuserPrivilege();\n+      checkOperation(OperationCategory.WRITE);\n+      checkNameNodeSafeMode(\n+          \"NameNode in safemode, cannot \" + action + \" re-encryption on zone \"\n+              + zone);\n+      switch (action) {\n+      case START:\n+        FSDirEncryptionZoneOp\n+            .reencryptEncryptionZone(dir, zone, kv.getVersionName(),\n+                logRetryCache);\n+        break;\n+      case CANCEL:\n+        FSDirEncryptionZoneOp\n+            .cancelReencryptEncryptionZone(dir, zone, logRetryCache);\n+        break;\n+      default:\n+        throw new IOException(\n+            \"Re-encryption action \" + action + \" is not supported\");\n+      }\n+    } finally {\n+      writeUnlock();\n+    }\n+    getEditLog().logSync();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void reencryptEncryptionZoneInt(final String zone,\n      final ReencryptAction action, final boolean logRetryCache)\n      throws IOException {\n    if (getProvider() \u003d\u003d null) {\n      throw new IOException(\"No key provider configured, re-encryption \"\n          + \"operation is rejected\");\n    }\n    FSPermissionChecker pc \u003d getPermissionChecker();\n    // get keyVersionName out of the lock. This keyVersionName will be used\n    // as the target keyVersion for the entire re-encryption.\n    // This means all edek\u0027s keyVersion will be compared with this one, and\n    // kms is only contacted if the edek\u0027s keyVersion is different.\n    final KeyVersion kv \u003d\n        FSDirEncryptionZoneOp.getLatestKeyVersion(dir, zone, pc);\n    provider.invalidateCache(kv.getName());\n    writeLock();\n    try {\n      checkSuperuserPrivilege();\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\n          \"NameNode in safemode, cannot \" + action + \" re-encryption on zone \"\n              + zone);\n      switch (action) {\n      case START:\n        FSDirEncryptionZoneOp\n            .reencryptEncryptionZone(dir, zone, kv.getVersionName(),\n                logRetryCache);\n        break;\n      case CANCEL:\n        FSDirEncryptionZoneOp\n            .cancelReencryptEncryptionZone(dir, zone, logRetryCache);\n        break;\n      default:\n        throw new IOException(\n            \"Re-encryption action \" + action + \" is not supported\");\n      }\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}