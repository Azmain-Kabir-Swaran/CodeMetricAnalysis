{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "computeUserLimitAndSetHeadroom",
  "functionId": "computeUserLimitAndSetHeadroom___application-FiCaSchedulerApp__clusterResource-Resource__nodePartition-String__schedulingMode-SchedulingMode__userLimit-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 1430,
  "functionEndLine": 1469,
  "numCommitsSeen": 648,
  "timeTaken": 17921,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
    "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8",
    "e9c2aa1bc383cb08784846534415bf17667d6e41",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "ec06957941367930c855b5e05e6a84ba676fd46a",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
    "189a63a719c63b67a1783a280bfc2f72dcb55277",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15",
    "14dd647c556016d351f425ee956ccf800ccb9ce2",
    "86358221fc85a7743052a0b4c1647353508bf308",
    "c53420f58364b11fbda1dace7679d45534533382",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
    "8437df8ba943e348b6a5d6370b4e0a74ff350a90",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1",
    "ef1a619a4df3a612eb293a6e8e1e952eaef18eba",
    "21c9116309d8482e7e28522cd7386e65415b15e9",
    "b8f0836f9420e71652404c41471653bb15f62a48",
    "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": "Ybodychange",
    "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8": "Ymultichange(Yparameterchange,Ybodychange)",
    "e9c2aa1bc383cb08784846534415bf17667d6e41": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "ec06957941367930c855b5e05e6a84ba676fd46a": "Ybodychange",
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": "Ymultichange(Yparameterchange,Ybodychange)",
    "189a63a719c63b67a1783a280bfc2f72dcb55277": "Ybodychange",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": "Ybodychange",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Ybodychange",
    "86358221fc85a7743052a0b4c1647353508bf308": "Ybodychange",
    "c53420f58364b11fbda1dace7679d45534533382": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3": "Ymultichange(Ymodifierchange,Ybodychange)",
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8": "Ybodychange",
    "8437df8ba943e348b6a5d6370b4e0a74ff350a90": "Ybodychange",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Yparameterchange",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": "Ybodychange",
    "ef1a619a4df3a612eb293a6e8e1e952eaef18eba": "Ymultichange(Yrename,Ybodychange)",
    "21c9116309d8482e7e28522cd7386e65415b15e9": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "b8f0836f9420e71652404c41471653bb15f62a48": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,40 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode, Resource userLimit) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n     if (queueUser \u003d\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"User \" + user + \" has been removed!\");\n-      }\n+      LOG.debug(\"User {} has been removed!\", user);\n       return Resources.none();\n     }\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     if (userLimit \u003d\u003d null) {\n       userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n           clusterResource, nodePartition, schedulingMode);\n     }\n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n         metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n           + userLimit + \" queueMaxAvailRes\u003d\"\n           + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n           + queueUser.getUsed() + \" partition\u003d\"\n           + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode, Resource userLimit) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n    if (queueUser \u003d\u003d null) {\n      LOG.debug(\"User {} has been removed!\", user);\n      return Resources.none();\n    }\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    if (userLimit \u003d\u003d null) {\n      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n          clusterResource, nodePartition, schedulingMode);\n    }\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7591. NPE in async-scheduling mode of CapacityScheduler. (Tao Yang via wangda)\n\nChange-Id: I46689e530550ee0a6ac7a29786aab2cc1bdf314f\n",
      "commitDate": "08/12/17 3:17 PM",
      "commitName": "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,42 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode, Resource userLimit) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n+    if (queueUser \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"User \" + user + \" has been removed!\");\n+      }\n+      return Resources.none();\n+    }\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     if (userLimit \u003d\u003d null) {\n       userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n           clusterResource, nodePartition, schedulingMode);\n     }\n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n         metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n           + userLimit + \" queueMaxAvailRes\u003d\"\n           + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n           + queueUser.getUsed() + \" partition\u003d\"\n           + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode, Resource userLimit) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n    if (queueUser \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"User \" + user + \" has been removed!\");\n      }\n      return Resources.none();\n    }\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    if (userLimit \u003d\u003d null) {\n      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n          clusterResource, nodePartition, schedulingMode);\n    }\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6775. CapacityScheduler: Improvements to assignContainers, avoid unnecessary canAssignToUser/Queue calls. (Nathan Roberts via wangda)\n\nChange-Id: I84ccd54200ccbaae23018ef320028e42b4c3509a\n",
      "commitDate": "13/07/17 10:30 AM",
      "commitName": "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6775. CapacityScheduler: Improvements to assignContainers, avoid unnecessary canAssignToUser/Queue calls. (Nathan Roberts via wangda)\n\nChange-Id: I84ccd54200ccbaae23018ef320028e42b4c3509a\n",
          "commitDate": "13/07/17 10:30 AM",
          "commitName": "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "22/06/17 11:50 PM",
          "commitNameOld": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 20.44,
          "commitsBetweenForRepo": 89,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n-      SchedulingMode schedulingMode) {\n+      SchedulingMode schedulingMode, Resource userLimit) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n-    Resource userLimit \u003d\n-        getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n-            nodePartition, schedulingMode);\n-\n+    if (userLimit \u003d\u003d null) {\n+      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n+          clusterResource, nodePartition, schedulingMode);\n+    }\n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n+        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n           + userLimit + \" queueMaxAvailRes\u003d\"\n           + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n-          + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n+          + queueUser.getUsed() + \" partition\u003d\"\n           + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode, Resource userLimit) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    if (userLimit \u003d\u003d null) {\n      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n          clusterResource, nodePartition, schedulingMode);\n    }\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, nodePartition-String, schedulingMode-SchedulingMode]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, nodePartition-String, schedulingMode-SchedulingMode, userLimit-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6775. CapacityScheduler: Improvements to assignContainers, avoid unnecessary canAssignToUser/Queue calls. (Nathan Roberts via wangda)\n\nChange-Id: I84ccd54200ccbaae23018ef320028e42b4c3509a\n",
          "commitDate": "13/07/17 10:30 AM",
          "commitName": "945c0958bb8df3dd9d5f1467f1216d2e6b0ee3d8",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "22/06/17 11:50 PM",
          "commitNameOld": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 20.44,
          "commitsBetweenForRepo": 89,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,36 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n-      SchedulingMode schedulingMode) {\n+      SchedulingMode schedulingMode, Resource userLimit) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n-    Resource userLimit \u003d\n-        getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n-            nodePartition, schedulingMode);\n-\n+    if (userLimit \u003d\u003d null) {\n+      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n+          clusterResource, nodePartition, schedulingMode);\n+    }\n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n+        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n           + userLimit + \" queueMaxAvailRes\u003d\"\n           + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n-          + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n+          + queueUser.getUsed() + \" partition\u003d\"\n           + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode, Resource userLimit) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    if (userLimit \u003d\u003d null) {\n      userLimit \u003d getResourceLimitForActiveUsers(application.getUser(),\n          clusterResource, nodePartition, schedulingMode);\n    }\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        metrics.getUserMetrics(user) \u003d\u003d null ? Resources.none() :\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "e9c2aa1bc383cb08784846534415bf17667d6e41": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6467. CSQueueMetrics needs to update the current metrics for default partition only. Contributed by Manikandan R.\n",
      "commitDate": "19/06/17 9:01 AM",
      "commitName": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n             nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n           + userLimit + \" queueMaxAvailRes\u003d\"\n           + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n           + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n           + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n-    metrics.setAvailableResourcesToUser(user, headroom);\n+    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(nodePartition, user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/01/17 10:52 AM",
      "commitNameOld": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.98,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n-        computeUserLimit(application.getUser(), clusterResource, queueUser,\n+        getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n             nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n-          \" userLimit\u003d\" + userLimit + \n-          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n-          \" consumed\u003d\" + queueUser.getUsed() + \n-          \" headroom\u003d\" + headroom);\n+      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n+          + userLimit + \" queueMaxAvailRes\u003d\"\n+          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n+          + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n+          + nodePartition);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        getResourceLimitForActiveUsers(application.getUser(), clusterResource,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \" userLimit\u003d\"\n          + userLimit + \" queueMaxAvailRes\u003d\"\n          + cachedResourceLimitsForHeadroom.getLimit() + \" consumed\u003d\"\n          + queueUser.getUsed() + \" headroom\u003d\" + headroom + \" partition\u003d\"\n          + nodePartition);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/10/16 1:17 AM",
      "commitNameOld": "1c8ab41e8b3477a93cbdf0b553a87b131eb60e1f",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n-        computeUserLimit(application, clusterResource, queueUser,\n+        computeUserLimit(application.getUser(), clusterResource, queueUser,\n             nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n \n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application.getUser(), clusterResource, queueUser,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ec06957941367930c855b5e05e6a84ba676fd46a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3215. Respect labels in CapacityScheduler when computing headroom. (Naganarasimha G R via wangda)\n",
      "commitDate": "08/04/16 3:33 PM",
      "commitName": "ec06957941367930c855b5e05e6a84ba676fd46a",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/03/16 5:07 PM",
      "commitNameOld": "fc055a3cbe9545cf1c59421641c7b296aa33f953",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.93,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, queueUser,\n             nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n-    \n+\n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n-            clusterResource, userLimit);\n+            clusterResource, userLimit, nodePartition);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, queueUser,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n\n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit, nodePartition);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "83fe34ac0896cee0918bbfad7bd51231e4aec39b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "24/07/15 2:00 PM",
      "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "24/07/15 2:00 PM",
          "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
          "commitAuthor": "Jian He",
          "commitDateOld": "22/07/15 11:54 AM",
          "commitNameOld": "76ec26de8099dc48ce3812c595b7ab857a600442",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, String nodePartition,\n+      Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n-        computeUserLimit(application, clusterResource, required,\n-            queueUser, nodePartition, schedulingMode);\n+        computeUserLimit(application, clusterResource, queueUser,\n+            nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n-      queueUser, this, application, required, queueResourceLimitsInfo);\n+      queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, queueUser,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, nodePartition-String, schedulingMode-SchedulingMode]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, nodePartition-String, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3026. Move application-specific container allocation logic from LeafQueue to FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "24/07/15 2:00 PM",
          "commitName": "83fe34ac0896cee0918bbfad7bd51231e4aec39b",
          "commitAuthor": "Jian He",
          "commitDateOld": "22/07/15 11:54 AM",
          "commitNameOld": "76ec26de8099dc48ce3812c595b7ab857a600442",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 2.09,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, String nodePartition,\n+      Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n-        computeUserLimit(application, clusterResource, required,\n-            queueUser, nodePartition, schedulingMode);\n+        computeUserLimit(application, clusterResource, queueUser,\n+            nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n-      queueUser, this, application, required, queueResourceLimitsInfo);\n+      queueUser, this, application, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, queueUser,\n            nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "189a63a719c63b67a1783a280bfc2f72dcb55277": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3434. Interaction between reservations and userlimit can result in significant ULF violation\n",
      "commitDate": "23/04/15 7:39 AM",
      "commitName": "189a63a719c63b67a1783a280bfc2f72dcb55277",
      "commitAuthor": "tgraves",
      "commitDateOld": "21/04/15 8:06 PM",
      "commitNameOld": "bdd90110e6904b59746812d9a093924a65e72280",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.48,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, String nodePartition,\n       SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n             queueUser, nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n-        getHeadroom(queueUser, currentResourceLimits.getLimit(),\n+        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n             clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n-          \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n+          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, cachedResourceLimitsForHeadroom.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + cachedResourceLimitsForHeadroom.getLimit() +\n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
      "commitDate": "14/04/15 11:45 AM",
      "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n+      Resource clusterResource, Resource required, String nodePartition,\n+      SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n-            queueUser, requestedLabels);\n+            queueUser, nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, currentResourceLimits.getLimit(),\n             clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, currentResourceLimits.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, requestedLabels-Set\u003cString\u003e]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, nodePartition-String, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/04/15 11:38 PM",
          "commitNameOld": "afa5d4715a3aea2a6e93380b014c7bb8f0880383",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 4.51,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n-      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n+      Resource clusterResource, Resource required, String nodePartition,\n+      SchedulingMode schedulingMode) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n-            queueUser, requestedLabels);\n+            queueUser, nodePartition, schedulingMode);\n \n     setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, currentResourceLimits.getLimit(),\n             clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, String nodePartition,\n      SchedulingMode schedulingMode) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, nodePartition, schedulingMode);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, currentResourceLimits.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/15 10:24 AM",
      "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/03/15 11:49 AM",
      "commitNameOld": "e17e5ba9d7e2bd45ba6884f59f8045817594b284",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.9,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n             queueUser, requestedLabels);\n \n-    Resource currentResourceLimit \u003d\n-        computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n+    setQueueResourceLimitsInfo(clusterResource);\n     \n     Resource headroom \u003d\n-        getHeadroom(queueUser, currentResourceLimit, clusterResource, userLimit);\n+        getHeadroom(queueUser, currentResourceLimits.getLimit(),\n+            clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n-          \" queueMaxAvailRes\u003d\" + currentResourceLimit + \n+          \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    setQueueResourceLimitsInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, currentResourceLimits.getLimit(),\n            clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + currentResourceLimits.getLimit() + \n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/02/15 2:58 PM",
      "commitNameOld": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 18.12,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,34 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n             queueUser, requestedLabels);\n \n-    //Max avail capacity needs to take into account usage by ancestor-siblings\n-    //which are greater than their base capacity, so we are interested in \"max avail\"\n-    //capacity\n-    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n-      resourceCalculator, clusterResource, this);\n-    \n-    Resource queueMaxCap \u003d \n-      updateHeadroomInfo(clusterResource, absoluteMaxAvailCapacity);\n+    Resource currentResourceLimit \u003d\n+        computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n     \n     Resource headroom \u003d\n-        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n+        getHeadroom(queueUser, currentResourceLimit, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n-          \" queueMaxCap\u003d\" + queueMaxCap + \n+          \" queueMaxAvailRes\u003d\" + currentResourceLimit + \n           \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n-      queueUser, this, application, required, queueHeadroomInfo);\n+      queueUser, this, application, required, queueResourceLimitsInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    Resource currentResourceLimit \u003d\n        computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, currentResourceLimit, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxAvailRes\u003d\" + currentResourceLimit + \n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueResourceLimitsInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "86358221fc85a7743052a0b4c1647353508bf308": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3099. Capacity Scheduler LeafQueue/ParentQueue should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "30/01/15 3:15 PM",
      "commitName": "86358221fc85a7743052a0b4c1647353508bf308",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n             queueUser, requestedLabels);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n     \n     Resource queueMaxCap \u003d \n       updateHeadroomInfo(clusterResource, absoluteMaxAvailCapacity);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n-          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n+          \" consumed\u003d\" + queueUser.getUsed() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n    \n    Resource queueMaxCap \u003d \n      updateHeadroomInfo(clusterResource, absoluteMaxAvailCapacity);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getUsed() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c53420f58364b11fbda1dace7679d45534533382": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2637. Fixed max-am-resource-percent calculation in CapacityScheduler when activating applications. Contributed by Craig Welch\n",
      "commitDate": "13/01/15 5:32 PM",
      "commitName": "c53420f58364b11fbda1dace7679d45534533382",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/01/15 2:15 PM",
      "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.14,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,40 @@\n   Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n       Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n     User queueUser \u003d getUser(user);\n \n     // Compute user limit respect requested labels,\n     // TODO, need consider headroom respect labels also\n     Resource userLimit \u003d\n         computeUserLimit(application, clusterResource, required,\n             queueUser, requestedLabels);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n-\n-    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n-        Resources.multiplyAndNormalizeDown(\n-            resourceCalculator, \n-            clusterResource, \n-            absoluteMaxAvailCapacity,\n-            minimumAllocation);\n-\t\n-    synchronized (queueHeadroomInfo) {\n-      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n-      queueHeadroomInfo.setClusterResource(clusterResource);\n-    }\n+    \n+    Resource queueMaxCap \u003d \n+      updateHeadroomInfo(clusterResource, absoluteMaxAvailCapacity);\n     \n     Resource headroom \u003d\n         getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n    \n    Resource queueMaxCap \u003d \n      updateHeadroomInfo(clusterResource, absoluteMaxAvailCapacity);\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,49 @@\n-  Resource computeUserLimitAndSetHeadroom(\n-      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n-    \n+  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n+      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n-    \n     User queueUser \u003d getUser(user);\n \n-    Resource userLimit \u003d                          // User limit\n-        computeUserLimit(application, clusterResource, required, queueUser);\n+    // Compute user limit respect requested labels,\n+    // TODO, need consider headroom respect labels also\n+    Resource userLimit \u003d\n+        computeUserLimit(application, clusterResource, required,\n+            queueUser, requestedLabels);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n             absoluteMaxAvailCapacity,\n             minimumAllocation);\n \t\n     synchronized (queueHeadroomInfo) {\n       queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n       queueHeadroomInfo.setClusterResource(clusterResource);\n     }\n     \n-    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n+    Resource headroom \u003d\n+        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n-          \" consumed\u003d\" + queueUser.getConsumedResources() + \n+          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n\t\n    synchronized (queueHeadroomInfo) {\n      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n      queueHeadroomInfo.setClusterResource(clusterResource);\n    }\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource]",
            "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource, requestedLabels-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,47 +1,49 @@\n-  Resource computeUserLimitAndSetHeadroom(\n-      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n-    \n+  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n+      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n     String user \u003d application.getUser();\n-    \n     User queueUser \u003d getUser(user);\n \n-    Resource userLimit \u003d                          // User limit\n-        computeUserLimit(application, clusterResource, required, queueUser);\n+    // Compute user limit respect requested labels,\n+    // TODO, need consider headroom respect labels also\n+    Resource userLimit \u003d\n+        computeUserLimit(application, clusterResource, required,\n+            queueUser, requestedLabels);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n             absoluteMaxAvailCapacity,\n             minimumAllocation);\n \t\n     synchronized (queueHeadroomInfo) {\n       queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n       queueHeadroomInfo.setClusterResource(clusterResource);\n     }\n     \n-    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n+    Resource headroom \u003d\n+        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n-          \" consumed\u003d\" + queueUser.getConsumedResources() + \n+          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(FiCaSchedulerApp application,\n      Resource clusterResource, Resource required, Set\u003cString\u003e requestedLabels) {\n    String user \u003d application.getUser();\n    User queueUser \u003d getUser(user);\n\n    // Compute user limit respect requested labels,\n    // TODO, need consider headroom respect labels also\n    Resource userLimit \u003d\n        computeUserLimit(application, clusterResource, required,\n            queueUser, requestedLabels);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n\t\n    synchronized (queueHeadroomInfo) {\n      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n      queueHeadroomInfo.setClusterResource(clusterResource);\n    }\n    \n    Resource headroom \u003d\n        getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getTotalConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-1857. CapacityScheduler headroom doesn\u0027t account for other AM\u0027s running. Contributed by Chen He and Craig Welch\n",
      "commitDate": "07/10/14 1:45 PM",
      "commitName": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1857. CapacityScheduler headroom doesn\u0027t account for other AM\u0027s running. Contributed by Chen He and Craig Welch\n",
          "commitDate": "07/10/14 1:45 PM",
          "commitName": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/10/14 3:48 PM",
          "commitNameOld": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,47 @@\n-  private Resource computeUserLimitAndSetHeadroom(\n+  Resource computeUserLimitAndSetHeadroom(\n       FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     User queueUser \u003d getUser(user);\n-    \n-    /** \n-     * Headroom is min((userLimit, queue-max-cap) - consumed)\n-     */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required, queueUser);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n             absoluteMaxAvailCapacity,\n             minimumAllocation);\n \t\n     synchronized (queueHeadroomInfo) {\n       queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n       queueHeadroomInfo.setClusterResource(clusterResource);\n     }\n     \n     Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + queueUser.getConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    User queueUser \u003d getUser(user);\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required, queueUser);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n\t\n    synchronized (queueHeadroomInfo) {\n      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n      queueHeadroomInfo.setClusterResource(clusterResource);\n    }\n    \n    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1857. CapacityScheduler headroom doesn\u0027t account for other AM\u0027s running. Contributed by Chen He and Craig Welch\n",
          "commitDate": "07/10/14 1:45 PM",
          "commitName": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/10/14 3:48 PM",
          "commitNameOld": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,47 @@\n-  private Resource computeUserLimitAndSetHeadroom(\n+  Resource computeUserLimitAndSetHeadroom(\n       FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     User queueUser \u003d getUser(user);\n-    \n-    /** \n-     * Headroom is min((userLimit, queue-max-cap) - consumed)\n-     */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required, queueUser);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n             absoluteMaxAvailCapacity,\n             minimumAllocation);\n \t\n     synchronized (queueHeadroomInfo) {\n       queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n       queueHeadroomInfo.setClusterResource(clusterResource);\n     }\n     \n     Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + queueUser.getConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n       queueUser, this, application, required, queueHeadroomInfo);\n     \n     application.setHeadroomProvider(headroomProvider);\n \n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    User queueUser \u003d getUser(user);\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required, queueUser);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n\t\n    synchronized (queueHeadroomInfo) {\n      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n      queueHeadroomInfo.setClusterResource(clusterResource);\n    }\n    \n    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "519e5a7dd2bd540105434ec3c8939b68f6c024f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2644. Fixed CapacityScheduler to return up-to-date headroom when AM allocates. Contributed by Craig Welch\n",
      "commitDate": "06/10/14 3:48 PM",
      "commitName": "519e5a7dd2bd540105434ec3c8939b68f6c024f8",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/10/14 5:09 PM",
      "commitNameOld": "c8212bacb1b2a7e6ee83cc56f72297465ce99390",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 2.94,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n   private Resource computeUserLimitAndSetHeadroom(\n       FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n+    User queueUser \u003d getUser(user);\n+    \n     /** \n      * Headroom is min((userLimit, queue-max-cap) - consumed)\n      */\n \n     Resource userLimit \u003d                          // User limit\n-        computeUserLimit(application, clusterResource, required);\n+        computeUserLimit(application, clusterResource, required, queueUser);\n \n     //Max avail capacity needs to take into account usage by ancestor-siblings\n     //which are greater than their base capacity, so we are interested in \"max avail\"\n     //capacity\n     float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n       resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n             absoluteMaxAvailCapacity,\n             minimumAllocation);\n+\t\n+    synchronized (queueHeadroomInfo) {\n+      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n+      queueHeadroomInfo.setClusterResource(clusterResource);\n+    }\n     \n-    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n-    Resource headroom \u003d \n-        Resources.subtract(\n-            Resources.min(resourceCalculator, clusterResource, \n-                userLimit, queueMaxCap), \n-            userConsumed);\n+    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n-          \" consumed\u003d\" + userConsumed + \n+          \" consumed\u003d\" + queueUser.getConsumedResources() + \n           \" headroom\u003d\" + headroom);\n     }\n     \n-    application.setHeadroom(headroom);\n+    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n+      queueUser, this, application, required, queueHeadroomInfo);\n+    \n+    application.setHeadroomProvider(headroomProvider);\n+\n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    User queueUser \u003d getUser(user);\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required, queueUser);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n\t\n    synchronized (queueHeadroomInfo) {\n      queueHeadroomInfo.setQueueMaxCap(queueMaxCap);\n      queueHeadroomInfo.setClusterResource(clusterResource);\n    }\n    \n    Resource headroom \u003d getHeadroom(queueUser, queueMaxCap, clusterResource, userLimit);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + queueUser.getConsumedResources() + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    CapacityHeadroomProvider headroomProvider \u003d new CapacityHeadroomProvider(\n      queueUser, this, application, required, queueHeadroomInfo);\n    \n    application.setHeadroomProvider(headroomProvider);\n\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "8437df8ba943e348b6a5d6370b4e0a74ff350a90": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2008. Fixed CapacityScheduler to calculate headroom based on max available capacity instead of configured max capacity. Contributed by Craig Welch\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616580 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 1:00 PM",
      "commitName": "8437df8ba943e348b6a5d6370b4e0a74ff350a90",
      "commitAuthor": "Jian He",
      "commitDateOld": "08/06/14 8:09 PM",
      "commitNameOld": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 59.7,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,45 @@\n   private Resource computeUserLimitAndSetHeadroom(\n       FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     /** \n      * Headroom is min((userLimit, queue-max-cap) - consumed)\n      */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required);\n-    \n+\n+    //Max avail capacity needs to take into account usage by ancestor-siblings\n+    //which are greater than their base capacity, so we are interested in \"max avail\"\n+    //capacity\n+    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n+      resourceCalculator, clusterResource, this);\n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.multiplyAndNormalizeDown(\n             resourceCalculator, \n             clusterResource, \n-            absoluteMaxCapacity, \n+            absoluteMaxAvailCapacity,\n             minimumAllocation);\n     \n     Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n         Resources.subtract(\n             Resources.min(resourceCalculator, clusterResource, \n                 userLimit, queueMaxCap), \n             userConsumed);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + userConsumed + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n\n    //Max avail capacity needs to take into account usage by ancestor-siblings\n    //which are greater than their base capacity, so we are interested in \"max avail\"\n    //capacity\n    float absoluteMaxAvailCapacity \u003d CSQueueUtils.getAbsoluteMaxAvailCapacity(\n      resourceCalculator, clusterResource, this);\n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxAvailCapacity,\n            minimumAllocation);\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(\n            Resources.min(resourceCalculator, clusterResource, \n                userLimit, queueMaxCap), \n            userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/11/12 1:56 PM",
      "commitNameOld": "fb5b96dfc324f999e8b3698288c110a1c3b71c30",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 62.3,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,40 @@\n   private Resource computeUserLimitAndSetHeadroom(\n       FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     /** \n      * Headroom is min((userLimit, queue-max-cap) - consumed)\n      */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required);\n     \n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n-        Resources.createResource(\n-            CSQueueUtils.roundDown(minimumAllocation, \n-                (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n-            );\n+        Resources.multiplyAndNormalizeDown(\n+            resourceCalculator, \n+            clusterResource, \n+            absoluteMaxCapacity, \n+            minimumAllocation);\n     \n     Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n-        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n+        Resources.subtract(\n+            Resources.min(resourceCalculator, clusterResource, \n+                userLimit, queueMaxCap), \n+            userConsumed);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + userConsumed + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.multiplyAndNormalizeDown(\n            resourceCalculator, \n            clusterResource, \n            absoluteMaxCapacity, \n            minimumAllocation);\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(\n            Resources.min(resourceCalculator, clusterResource, \n                userLimit, queueMaxCap), \n            userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.createResource(\n            CSQueueUtils.roundDown(minimumAllocation, \n                (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n            );\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Yparameterchange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "10/07/12 2:26 PM",
      "commitNameOld": "3bfb26ad3b5ac46f992a632541c97ca2bc897638",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.18,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private Resource computeUserLimitAndSetHeadroom(\n-      SchedulerApp application, Resource clusterResource, Resource required) {\n+      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     /** \n      * Headroom is min((userLimit, queue-max-cap) - consumed)\n      */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required);\n     \n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.createResource(\n             CSQueueUtils.roundDown(minimumAllocation, \n                 (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n             );\n     \n     Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n         Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + userConsumed + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      FiCaSchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.createResource(\n            CSQueueUtils.roundDown(minimumAllocation, \n                (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n            );\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldValue": "[application-SchedulerApp, clusterResource-Resource, required-Resource]",
        "newValue": "[application-FiCaSchedulerApp, clusterResource-Resource, required-Resource]"
      }
    },
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/12 7:38 PM",
      "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "02/02/12 5:16 PM",
      "commitNameOld": "a5c46c91655acebccd1367706b05946eff90f744",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,36 @@\n   private Resource computeUserLimitAndSetHeadroom(\n       SchedulerApp application, Resource clusterResource, Resource required) {\n     \n     String user \u003d application.getUser();\n     \n     /** \n      * Headroom is min((userLimit, queue-max-cap) - consumed)\n      */\n \n     Resource userLimit \u003d                          // User limit\n         computeUserLimit(application, clusterResource, required);\n     \n \n     Resource queueMaxCap \u003d                        // Queue Max-Capacity\n         Resources.createResource(\n-            roundDown((int)(absoluteMaxCapacity * clusterResource.getMemory()))\n+            CSQueueUtils.roundDown(minimumAllocation, \n+                (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n             );\n     \n     Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n         Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n     \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n           \" userLimit\u003d\" + userLimit + \n           \" queueMaxCap\u003d\" + queueMaxCap + \n           \" consumed\u003d\" + userConsumed + \n           \" headroom\u003d\" + headroom);\n     }\n     \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n     \n     return userLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      SchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.createResource(\n            CSQueueUtils.roundDown(minimumAllocation, \n                (int)(absoluteMaxCapacity * clusterResource.getMemory()))\n            );\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ef1a619a4df3a612eb293a6e8e1e952eaef18eba": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "MAPREDUCE-3752. Modified application limits to include queue max-capacities besides the usual user limits. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239422 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/02/12 4:41 PM",
      "commitName": "ef1a619a4df3a612eb293a6e8e1e952eaef18eba",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE-3752. Modified application limits to include queue max-capacities besides the usual user limits. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239422 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/02/12 4:41 PM",
          "commitName": "ef1a619a4df3a612eb293a6e8e1e952eaef18eba",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "27/01/12 5:32 PM",
          "commitNameOld": "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.96,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,10 +1,35 @@\n-  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n-      Resource clusterResource, Resource required) {\n+  private Resource computeUserLimitAndSetHeadroom(\n+      SchedulerApp application, Resource clusterResource, Resource required) {\n+    \n     String user \u003d application.getUser();\n-    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n+    \n+    /** \n+     * Headroom is min((userLimit, queue-max-cap) - consumed)\n+     */\n+\n+    Resource userLimit \u003d                          // User limit\n+        computeUserLimit(application, clusterResource, required);\n+    \n+\n+    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n+        Resources.createResource(\n+            roundDown((int)(absoluteMaxCapacity * clusterResource.getMemory()))\n+            );\n+    \n+    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n-        Resources.subtract(limit, getUser(user).getConsumedResources());\n+        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n+    \n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n+          \" userLimit\u003d\" + userLimit + \n+          \" queueMaxCap\u003d\" + queueMaxCap + \n+          \" consumed\u003d\" + userConsumed + \n+          \" headroom\u003d\" + headroom);\n+    }\n+    \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n-    return limit;\n+    \n+    return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      SchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.createResource(\n            roundDown((int)(absoluteMaxCapacity * clusterResource.getMemory()))\n            );\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "computeAndSetUserResourceLimit",
            "newValue": "computeUserLimitAndSetHeadroom"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3752. Modified application limits to include queue max-capacities besides the usual user limits. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239422 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/02/12 4:41 PM",
          "commitName": "ef1a619a4df3a612eb293a6e8e1e952eaef18eba",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "27/01/12 5:32 PM",
          "commitNameOld": "5262b7ba4d018562d4e7d60772af4ddc3d770a23",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 4.96,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,10 +1,35 @@\n-  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n-      Resource clusterResource, Resource required) {\n+  private Resource computeUserLimitAndSetHeadroom(\n+      SchedulerApp application, Resource clusterResource, Resource required) {\n+    \n     String user \u003d application.getUser();\n-    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n+    \n+    /** \n+     * Headroom is min((userLimit, queue-max-cap) - consumed)\n+     */\n+\n+    Resource userLimit \u003d                          // User limit\n+        computeUserLimit(application, clusterResource, required);\n+    \n+\n+    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n+        Resources.createResource(\n+            roundDown((int)(absoluteMaxCapacity * clusterResource.getMemory()))\n+            );\n+    \n+    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n     Resource headroom \u003d \n-        Resources.subtract(limit, getUser(user).getConsumedResources());\n+        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n+    \n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n+          \" userLimit\u003d\" + userLimit + \n+          \" queueMaxCap\u003d\" + queueMaxCap + \n+          \" consumed\u003d\" + userConsumed + \n+          \" headroom\u003d\" + headroom);\n+    }\n+    \n     application.setHeadroom(headroom);\n     metrics.setAvailableResourcesToUser(user, headroom);\n-    return limit;\n+    \n+    return userLimit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeUserLimitAndSetHeadroom(\n      SchedulerApp application, Resource clusterResource, Resource required) {\n    \n    String user \u003d application.getUser();\n    \n    /** \n     * Headroom is min((userLimit, queue-max-cap) - consumed)\n     */\n\n    Resource userLimit \u003d                          // User limit\n        computeUserLimit(application, clusterResource, required);\n    \n\n    Resource queueMaxCap \u003d                        // Queue Max-Capacity\n        Resources.createResource(\n            roundDown((int)(absoluteMaxCapacity * clusterResource.getMemory()))\n            );\n    \n    Resource userConsumed \u003d getUser(user).getConsumedResources(); \n    Resource headroom \u003d \n        Resources.subtract(Resources.min(userLimit, queueMaxCap), userConsumed);\n    \n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Headroom calculation for user \" + user + \": \" + \n          \" userLimit\u003d\" + userLimit + \n          \" queueMaxCap\u003d\" + queueMaxCap + \n          \" consumed\u003d\" + userConsumed + \n          \" headroom\u003d\" + headroom);\n    }\n    \n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    \n    return userLimit;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "21c9116309d8482e7e28522cd7386e65415b15e9": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3713. Fixed the way head-room is allocated to applications by CapacityScheduler so that it deducts current-usage per user and not per-application. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235989 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 3:31 PM",
      "commitName": "21c9116309d8482e7e28522cd7386e65415b15e9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3713. Fixed the way head-room is allocated to applications by CapacityScheduler so that it deducts current-usage per user and not per-application. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235989 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/12 3:31 PM",
          "commitName": "21c9116309d8482e7e28522cd7386e65415b15e9",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "25/01/12 10:17 AM",
          "commitNameOld": "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,8 +1,10 @@\n-  private void computeAndSetUserResourceLimit(SchedulerApp application, \n-      Resource clusterResource) {\n-    Resource userLimit \u003d \n-        computeUserLimit(application, clusterResource, Resources.none());\n-    application.setAvailableResourceLimit(userLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), \n-        application.getHeadroom());\n+  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource, Resource required) {\n+    String user \u003d application.getUser();\n+    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n+    Resource headroom \u003d \n+        Resources.subtract(limit, getUser(user).getConsumedResources());\n+    application.setHeadroom(headroom);\n+    metrics.setAvailableResourcesToUser(user, headroom);\n+    return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    String user \u003d application.getUser();\n    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n    Resource headroom \u003d \n        Resources.subtract(limit, getUser(user).getConsumedResources());\n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    return limit;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-SchedulerApp, clusterResource-Resource]",
            "newValue": "[application-SchedulerApp, clusterResource-Resource, required-Resource]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-3713. Fixed the way head-room is allocated to applications by CapacityScheduler so that it deducts current-usage per user and not per-application. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235989 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/12 3:31 PM",
          "commitName": "21c9116309d8482e7e28522cd7386e65415b15e9",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "25/01/12 10:17 AM",
          "commitNameOld": "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,8 +1,10 @@\n-  private void computeAndSetUserResourceLimit(SchedulerApp application, \n-      Resource clusterResource) {\n-    Resource userLimit \u003d \n-        computeUserLimit(application, clusterResource, Resources.none());\n-    application.setAvailableResourceLimit(userLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), \n-        application.getHeadroom());\n+  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource, Resource required) {\n+    String user \u003d application.getUser();\n+    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n+    Resource headroom \u003d \n+        Resources.subtract(limit, getUser(user).getConsumedResources());\n+    application.setHeadroom(headroom);\n+    metrics.setAvailableResourcesToUser(user, headroom);\n+    return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    String user \u003d application.getUser();\n    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n    Resource headroom \u003d \n        Resources.subtract(limit, getUser(user).getConsumedResources());\n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    return limit;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Resource"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3713. Fixed the way head-room is allocated to applications by CapacityScheduler so that it deducts current-usage per user and not per-application. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235989 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/12 3:31 PM",
          "commitName": "21c9116309d8482e7e28522cd7386e65415b15e9",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "25/01/12 10:17 AM",
          "commitNameOld": "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 0.22,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,8 +1,10 @@\n-  private void computeAndSetUserResourceLimit(SchedulerApp application, \n-      Resource clusterResource) {\n-    Resource userLimit \u003d \n-        computeUserLimit(application, clusterResource, Resources.none());\n-    application.setAvailableResourceLimit(userLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), \n-        application.getHeadroom());\n+  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource, Resource required) {\n+    String user \u003d application.getUser();\n+    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n+    Resource headroom \u003d \n+        Resources.subtract(limit, getUser(user).getConsumedResources());\n+    application.setHeadroom(headroom);\n+    metrics.setAvailableResourcesToUser(user, headroom);\n+    return limit;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource, Resource required) {\n    String user \u003d application.getUser();\n    Resource limit \u003d computeUserLimit(application, clusterResource, required);\n    Resource headroom \u003d \n        Resources.subtract(limit, getUser(user).getConsumedResources());\n    application.setHeadroom(headroom);\n    metrics.setAvailableResourcesToUser(user, headroom);\n    return limit;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "b8f0836f9420e71652404c41471653bb15f62a48": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3126. Fixed a corner case in CapacityScheduler where headroom wasn\u0027t updated on changes to cluster size.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182000 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/10/11 11:24 AM",
      "commitName": "b8f0836f9420e71652404c41471653bb15f62a48",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE-3126. Fixed a corner case in CapacityScheduler where headroom wasn\u0027t updated on changes to cluster size.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182000 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/10/11 11:24 AM",
          "commitName": "b8f0836f9420e71652404c41471653bb15f62a48",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/10/11 10:27 PM",
          "commitNameOld": "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 4.54,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,8 @@\n-  private void setUserResourceLimit(SchedulerApp application, \n-      Resource resourceLimit) {\n-    application.setAvailableResourceLimit(resourceLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), application.getHeadroom());\n+  private void computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource) {\n+    Resource userLimit \u003d \n+        computeUserLimit(application, clusterResource, Resources.none());\n+    application.setAvailableResourceLimit(userLimit);\n+    metrics.setAvailableResourcesToUser(application.getUser(), \n+        application.getHeadroom());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource) {\n    Resource userLimit \u003d \n        computeUserLimit(application, clusterResource, Resources.none());\n    application.setAvailableResourceLimit(userLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), \n        application.getHeadroom());\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "setUserResourceLimit",
            "newValue": "computeAndSetUserResourceLimit"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3126. Fixed a corner case in CapacityScheduler where headroom wasn\u0027t updated on changes to cluster size.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182000 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/10/11 11:24 AM",
          "commitName": "b8f0836f9420e71652404c41471653bb15f62a48",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/10/11 10:27 PM",
          "commitNameOld": "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 4.54,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,8 @@\n-  private void setUserResourceLimit(SchedulerApp application, \n-      Resource resourceLimit) {\n-    application.setAvailableResourceLimit(resourceLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), application.getHeadroom());\n+  private void computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource) {\n+    Resource userLimit \u003d \n+        computeUserLimit(application, clusterResource, Resources.none());\n+    application.setAvailableResourceLimit(userLimit);\n+    metrics.setAvailableResourcesToUser(application.getUser(), \n+        application.getHeadroom());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource) {\n    Resource userLimit \u003d \n        computeUserLimit(application, clusterResource, Resources.none());\n    application.setAvailableResourceLimit(userLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), \n        application.getHeadroom());\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[application-SchedulerApp, resourceLimit-Resource]",
            "newValue": "[application-SchedulerApp, clusterResource-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3126. Fixed a corner case in CapacityScheduler where headroom wasn\u0027t updated on changes to cluster size.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1182000 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/10/11 11:24 AM",
          "commitName": "b8f0836f9420e71652404c41471653bb15f62a48",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "06/10/11 10:27 PM",
          "commitNameOld": "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 4.54,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,8 @@\n-  private void setUserResourceLimit(SchedulerApp application, \n-      Resource resourceLimit) {\n-    application.setAvailableResourceLimit(resourceLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), application.getHeadroom());\n+  private void computeAndSetUserResourceLimit(SchedulerApp application, \n+      Resource clusterResource) {\n+    Resource userLimit \u003d \n+        computeUserLimit(application, clusterResource, Resources.none());\n+    application.setAvailableResourceLimit(userLimit);\n+    metrics.setAvailableResourcesToUser(application.getUser(), \n+        application.getHeadroom());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void computeAndSetUserResourceLimit(SchedulerApp application, \n      Resource clusterResource) {\n    Resource userLimit \u003d \n        computeUserLimit(application, clusterResource, Resources.none());\n    application.setAvailableResourceLimit(userLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), \n        application.getHeadroom());\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2794. [MR-279] Incorrect metrics value for AvailableGB per queue per user. (John George via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179936 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/10/11 10:27 PM",
      "commitName": "b8102dbdf8b4dc2e99bc7c58f4085a7313830a2d",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "05/10/11 4:56 AM",
      "commitNameOld": "f24dcb3449c77da665058427bc7fa480cad507fc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,5 +1,5 @@\n   private void setUserResourceLimit(SchedulerApp application, \n       Resource resourceLimit) {\n     application.setAvailableResourceLimit(resourceLimit);\n-    metrics.setAvailableResourcesToUser(application.getUser(), resourceLimit);\n+    metrics.setAvailableResourcesToUser(application.getUser(), application.getHeadroom());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setUserResourceLimit(SchedulerApp application, \n      Resource resourceLimit) {\n    application.setAvailableResourceLimit(resourceLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), application.getHeadroom());\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void setUserResourceLimit(SchedulerApp application, \n      Resource resourceLimit) {\n    application.setAvailableResourceLimit(resourceLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), resourceLimit);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,5 @@\n+  private void setUserResourceLimit(SchedulerApp application, \n+      Resource resourceLimit) {\n+    application.setAvailableResourceLimit(resourceLimit);\n+    metrics.setAvailableResourcesToUser(application.getUser(), resourceLimit);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void setUserResourceLimit(SchedulerApp application, \n      Resource resourceLimit) {\n    application.setAvailableResourceLimit(resourceLimit);\n    metrics.setAvailableResourcesToUser(application.getUser(), resourceLimit);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}