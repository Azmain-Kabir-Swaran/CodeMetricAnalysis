{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirStatAndListingOp.java",
  "functionName": "createFileStatus",
  "functionId": "createFileStatus___fsd-FSDirectory__iip-INodesInPath__child-INode__storagePolicy-byte__needLocation-boolean__needBlockToken-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
  "functionStartLine": 397,
  "functionEndLine": 477,
  "numCommitsSeen": 700,
  "timeTaken": 17728,
  "changeHistory": [
    "98d249dcdabb664ca82083a323afb1a8ed13c062",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
    "107c177782a24a16c66113841f2fc5144f56207b",
    "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
    "52b00600df921763725396ed92194d3338167655",
    "3085a604300ed76d06a0011bd5555e419897b6cd",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "744208431f7365bf054e6b773b86af2583001e1d",
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f",
    "9f4bf3bdf9e74800643477cfb18361e01cf6859c",
    "71a81b6257c0000475ad62eb69292a20d45d269c",
    "f62237bc2f02afe11ce185e13aa51a60b5960037",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
    "98d340745be682fb251677bb4830aca76119868f",
    "9a18598e2da8e699ed852ffa30fd7f503902190c",
    "91c81fdc24709b3caf1f6281c8879ffee08db956",
    "9da927540f0ea6698388a4e79ef32c4dc51495ea",
    "c55d609053fe24b3a50fbe17dc1b47717b453ed6",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
    "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
    "bb84f1fccb18c6c7373851e05d2451d55e908242",
    "1737950d0fc83c68f386881b843c41b0b1e342de"
  ],
  "changeHistoryShort": {
    "98d249dcdabb664ca82083a323afb1a8ed13c062": "Ybodychange",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": "Ymultichange(Yparameterchange,Ybodychange)",
    "107c177782a24a16c66113841f2fc5144f56207b": "Ybodychange",
    "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2": "Ybodychange",
    "52b00600df921763725396ed92194d3338167655": "Ybodychange",
    "3085a604300ed76d06a0011bd5555e419897b6cd": "Ybodychange",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ybodychange",
    "744208431f7365bf054e6b773b86af2583001e1d": "Ybodychange",
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": "Ymultichange(Yparameterchange,Ybodychange)",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": "Ymultichange(Yparameterchange,Ybodychange)",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": "Ymultichange(Yparameterchange,Ybodychange)",
    "9f4bf3bdf9e74800643477cfb18361e01cf6859c": "Ymultichange(Yparameterchange,Ybodychange)",
    "71a81b6257c0000475ad62eb69292a20d45d269c": "Ybodychange",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ybodychange",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": "Ybodychange",
    "98d340745be682fb251677bb4830aca76119868f": "Ybodychange",
    "9a18598e2da8e699ed852ffa30fd7f503902190c": "Ybodychange",
    "91c81fdc24709b3caf1f6281c8879ffee08db956": "Ybodychange",
    "9da927540f0ea6698388a4e79ef32c4dc51495ea": "Ybodychange",
    "c55d609053fe24b3a50fbe17dc1b47717b453ed6": "Ymultichange(Yparameterchange,Ybodychange)",
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": "Ymultichange(Yparameterchange,Ybodychange)",
    "0af44ea8462437f8e7a8271b15a19677fd7f05a1": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ybodychange",
    "1737950d0fc83c68f386881b843c41b0b1e342de": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "98d249dcdabb664ca82083a323afb1a8ed13c062": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14996. RBF: GetFileStatus fails for directory with EC policy set in case of multiple destinations. Contributed by Ayush Saxena.\n",
      "commitDate": "20/11/19 10:38 PM",
      "commitName": "98d249dcdabb664ca82083a323afb1a8ed13c062",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "23/10/19 11:44 PM",
      "commitNameOld": "ee699dc26c7b660a5222a30782f3bf5cb1e55085",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 28.0,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,81 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation, boolean needBlockToken) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n     final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n     boolean isSnapShottable \u003d false;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n             needBlockToken, inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     } else if (node.isDirectory()) {\n       isSnapShottable \u003d node.asDirectory().isSnapshottable();\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n-        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n-    if (hasAcl) {\n-      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n-    }\n-    if (isEncrypted) {\n-      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n-    }\n-    if (isErasureCoded) {\n-      flags.add(HdfsFileStatus.Flags.HAS_EC);\n-    }\n-    if(isSnapShottable){\n-      flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n-    }\n+\n+    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n+        DFSUtil.getFlags(isEncrypted, isErasureCoded, isSnapShottable, hasAcl);\n+\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         nodeAttrs.getFsPermission(),\n         flags,\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation, boolean needBlockToken) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    boolean isSnapShottable \u003d false;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n            needBlockToken, inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else if (node.isDirectory()) {\n      isSnapShottable \u003d node.asDirectory().isSnapshottable();\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        DFSUtil.getFlags(isEncrypted, isErasureCoded, isSnapShottable, hasAcl);\n\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        nodeAttrs.getFsPermission(),\n        flags,\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
      "commitDate": "11/12/17 8:14 PM",
      "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
          "commitDate": "11/12/17 8:14 PM",
          "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "29/11/17 8:28 PM",
          "commitNameOld": "0e560f3b8d194c10dce06443979df4074e14b0db",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 11.99,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,91 +1,91 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n-      boolean needLocation) throws IOException {\n+      boolean needLocation, boolean needBlockToken) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n     final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n     boolean isSnapShottable \u003d false;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n-            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n-            inSnapshot, feInfo, ecPolicy);\n+            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n+            needBlockToken, inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     } else if (node.isDirectory()) {\n       isSnapShottable \u003d node.asDirectory().isSnapshottable();\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n         EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n     if (hasAcl) {\n       flags.add(HdfsFileStatus.Flags.HAS_ACL);\n     }\n     if (isEncrypted) {\n       flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n     }\n     if (isErasureCoded) {\n       flags.add(HdfsFileStatus.Flags.HAS_EC);\n     }\n     if(isSnapShottable){\n       flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n     }\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         nodeAttrs.getFsPermission(),\n         flags,\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation, boolean needBlockToken) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    boolean isSnapShottable \u003d false;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n            needBlockToken, inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else if (node.isDirectory()) {\n      isSnapShottable \u003d node.asDirectory().isSnapshottable();\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n    if (hasAcl) {\n      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n    }\n    if (isEncrypted) {\n      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n    }\n    if (isErasureCoded) {\n      flags.add(HdfsFileStatus.Flags.HAS_EC);\n    }\n    if(isSnapShottable){\n      flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n    }\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        nodeAttrs.getFsPermission(),\n        flags,\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, iip-INodesInPath, child-INode, storagePolicy-byte, needLocation-boolean]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, child-INode, storagePolicy-byte, needLocation-boolean, needBlockToken-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
          "commitDate": "11/12/17 8:14 PM",
          "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "29/11/17 8:28 PM",
          "commitNameOld": "0e560f3b8d194c10dce06443979df4074e14b0db",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 11.99,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,91 +1,91 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n-      boolean needLocation) throws IOException {\n+      boolean needLocation, boolean needBlockToken) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n     final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n     boolean isSnapShottable \u003d false;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n-            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n-            inSnapshot, feInfo, ecPolicy);\n+            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n+            needBlockToken, inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     } else if (node.isDirectory()) {\n       isSnapShottable \u003d node.asDirectory().isSnapshottable();\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n         EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n     if (hasAcl) {\n       flags.add(HdfsFileStatus.Flags.HAS_ACL);\n     }\n     if (isEncrypted) {\n       flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n     }\n     if (isErasureCoded) {\n       flags.add(HdfsFileStatus.Flags.HAS_EC);\n     }\n     if(isSnapShottable){\n       flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n     }\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         nodeAttrs.getFsPermission(),\n         flags,\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation, boolean needBlockToken) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    boolean isSnapShottable \u003d false;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size,\n            needBlockToken, inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else if (node.isDirectory()) {\n      isSnapShottable \u003d node.asDirectory().isSnapshottable();\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n    if (hasAcl) {\n      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n    }\n    if (isEncrypted) {\n      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n    }\n    if (isErasureCoded) {\n      flags.add(HdfsFileStatus.Flags.HAS_EC);\n    }\n    if(isSnapShottable){\n      flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n    }\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        nodeAttrs.getFsPermission(),\n        flags,\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "107c177782a24a16c66113841f2fc5144f56207b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12455. WebHDFS - Adding \"snapshot enabled\" status to ListStatus query result. Contributed by Ajay Kumar.\n",
      "commitDate": "03/10/17 1:02 PM",
      "commitName": "107c177782a24a16c66113841f2fc5144f56207b",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "02/08/17 12:12 PM",
      "commitNameOld": "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 62.03,
      "commitsBetweenForRepo": 524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,91 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n     final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n+    boolean isSnapShottable \u003d false;\n+\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n+    } else if (node.isDirectory()) {\n+      isSnapShottable \u003d node.asDirectory().isSnapshottable();\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n         EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n     if (hasAcl) {\n       flags.add(HdfsFileStatus.Flags.HAS_ACL);\n     }\n     if (isEncrypted) {\n       flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n     }\n     if (isErasureCoded) {\n       flags.add(HdfsFileStatus.Flags.HAS_EC);\n     }\n+    if(isSnapShottable){\n+      flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n+    }\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         nodeAttrs.getFsPermission(),\n         flags,\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    boolean isSnapShottable \u003d false;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else if (node.isDirectory()) {\n      isSnapShottable \u003d node.asDirectory().isSnapshottable();\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n    if (hasAcl) {\n      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n    }\n    if (isEncrypted) {\n      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n    }\n    if (isErasureCoded) {\n      flags.add(HdfsFileStatus.Flags.HAS_EC);\n    }\n    if(isSnapShottable){\n      flags.add(HdfsFileStatus.Flags.SNAPSHOT_ENABLED);\n    }\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        nodeAttrs.getFsPermission(),\n        flags,\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6984. Serialize FileStatus via protobuf.\n",
      "commitDate": "02/08/17 12:12 PM",
      "commitName": "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "14/07/17 2:35 PM",
      "commitNameOld": "f413ee33df301659c4ca9024380c2354983dcc84",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 18.9,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,84 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n     final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n+    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n+        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n+    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n+    if (hasAcl) {\n+      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n+    }\n+    if (isEncrypted) {\n+      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n+    }\n+    if (isErasureCoded) {\n+      flags.add(HdfsFileStatus.Flags.HAS_EC);\n+    }\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n-        getPermissionForFileStatus(nodeAttrs, isEncrypted, isErasureCoded),\n+        nodeAttrs.getFsPermission(),\n+        flags,\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    boolean hasAcl \u003d nodeAttrs.getAclFeature() !\u003d null;\n    if (hasAcl) {\n      flags.add(HdfsFileStatus.Flags.HAS_ACL);\n    }\n    if (isEncrypted) {\n      flags.add(HdfsFileStatus.Flags.HAS_CRYPT);\n    }\n    if (isErasureCoded) {\n      flags.add(HdfsFileStatus.Flags.HAS_EC);\n    }\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        nodeAttrs.getFsPermission(),\n        flags,\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "52b00600df921763725396ed92194d3338167655": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13715. Add isErasureCoded() API to FileStatus class. Contributed by Manoj Govindassamy.\n",
      "commitDate": "24/03/17 11:44 AM",
      "commitName": "52b00600df921763725396ed92194d3338167655",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/03/17 1:00 PM",
      "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 20.91,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n+    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n-        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n+        getPermissionForFileStatus(nodeAttrs, isEncrypted, isErasureCoded),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n    final boolean isErasureCoded \u003d (ecPolicy !\u003d null);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted, isErasureCoded),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "3085a604300ed76d06a0011bd5555e419897b6cd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8112. Relax permission checking for EC related operations.\n",
      "commitDate": "03/03/17 1:00 PM",
      "commitName": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 129.95,
      "commitsBetweenForRepo": 799,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     LocatedBlocks loc \u003d null;\n \n     final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n-        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n+        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       if (isEncrypted) {\n         feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n       }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .unprotectedGetErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/10/16 9:27 AM",
      "commitNameOld": "744208431f7365bf054e6b773b86af2583001e1d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 3.16,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,70 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n-    final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n-    final boolean isRawPath \u003d iip.isRaw();\n     LocatedBlocks loc \u003d null;\n \n-    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n-        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n+    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n+    FileEncryptionInfo feInfo \u003d null;\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n-      isEncrypted \u003d (feInfo !\u003d null)\n-          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n+      if (isEncrypted) {\n+        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n+      }\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n-    } else {\n-      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n     return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    LocatedBlocks loc \u003d null;\n\n    final boolean isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    FileEncryptionInfo feInfo \u003d null;\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      if (isEncrypted) {\n        feInfo \u003d FSDirEncryptionZoneOp.getFileEncryptionInfo(fsd, iip);\n      }\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "744208431f7365bf054e6b773b86af2583001e1d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10940. Reduce performance penalty of block caching when not used. Contributed by Daryn Sharp.\n",
      "commitDate": "03/10/16 9:27 AM",
      "commitName": "744208431f7365bf054e6b773b86af2583001e1d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "30/09/16 11:03 AM",
      "commitNameOld": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.93,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,73 @@\n   private static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n       boolean needLocation) throws IOException {\n     assert fsd.hasReadLock();\n     // only directory listing sets the status name.\n     byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n     if (child !\u003d null) {\n       name \u003d child.getLocalNameBytes();\n       // have to do this for EC and EZ lookups...\n       iip \u003d INodesInPath.append(iip, child, name);\n     }\n \n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     final boolean isRawPath \u003d iip.isRaw();\n     LocatedBlocks loc \u003d null;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n       if (needLocation) {\n         final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n         final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n         final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n             ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n         loc \u003d fsd.getBlockManager().createLocatedBlocks(\n             fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n             inSnapshot, feInfo, ecPolicy);\n         if (loc \u003d\u003d null) {\n           loc \u003d new LocatedBlocks();\n         }\n       }\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n-    HdfsFileStatus status \u003d createFileStatus(\n+    return createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy,\n         loc);\n-    // Set caching information for the located blocks.\n-    if (loc !\u003d null) {\n-      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n-      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n-        cacheManager.setCachedLocations(lb);\n-      }\n-    }\n-    return status;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n    LocatedBlocks loc \u003d null;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    return createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "a0730aa5ced7666a8c92f9fb830b615f5f9f477a": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-10851. FSDirStatAndListingOp: stop passing path as string. Contributed by Daryn Sharp.\n",
      "commitDate": "30/09/16 11:03 AM",
      "commitName": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10851. FSDirStatAndListingOp: stop passing path as string. Contributed by Daryn Sharp.\n",
          "commitDate": "30/09/16 11:03 AM",
          "commitName": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "24/08/16 1:21 PM",
          "commitNameOld": "a1f3293762dddb0ca953d1145f5b53d9086b25b8",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 36.9,
          "commitsBetweenForRepo": 208,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,81 @@\n-  static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n-      byte storagePolicy, INodesInPath iip) throws IOException {\n+  private static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n+      boolean needLocation) throws IOException {\n+    assert fsd.hasReadLock();\n+    // only directory listing sets the status name.\n+    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n+    if (child !\u003d null) {\n+      name \u003d child.getLocalNameBytes();\n+      // have to do this for EC and EZ lookups...\n+      iip \u003d INodesInPath.append(iip, child, name);\n+    }\n+\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     final boolean isRawPath \u003d iip.isRaw();\n+    LocatedBlocks loc \u003d null;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n+      if (needLocation) {\n+        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n+        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n+        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n+            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n+        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n+            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n+            inSnapshot, feInfo, ecPolicy);\n+        if (loc \u003d\u003d null) {\n+          loc \u003d new LocatedBlocks();\n+        }\n+      }\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-    return new HdfsFileStatus(\n+    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n+    HdfsFileStatus status \u003d createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n-        path,\n+        name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n-        ecPolicy);\n+        ecPolicy,\n+        loc);\n+    // Set caching information for the located blocks.\n+    if (loc !\u003d null) {\n+      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n+      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n+        cacheManager.setCachedLocations(lb);\n+      }\n+    }\n+    return status;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n    LocatedBlocks loc \u003d null;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    HdfsFileStatus status \u003d createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n    // Set caching information for the located blocks.\n    if (loc !\u003d null) {\n      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n        cacheManager.setCachedLocations(lb);\n      }\n    }\n    return status;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, iip-INodesInPath, child-INode, storagePolicy-byte, needLocation-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-10851. FSDirStatAndListingOp: stop passing path as string. Contributed by Daryn Sharp.\n",
          "commitDate": "30/09/16 11:03 AM",
          "commitName": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "24/08/16 1:21 PM",
          "commitNameOld": "a1f3293762dddb0ca953d1145f5b53d9086b25b8",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 36.9,
          "commitsBetweenForRepo": 208,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,81 @@\n-  static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n-      byte storagePolicy, INodesInPath iip) throws IOException {\n+  private static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n+      boolean needLocation) throws IOException {\n+    assert fsd.hasReadLock();\n+    // only directory listing sets the status name.\n+    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n+    if (child !\u003d null) {\n+      name \u003d child.getLocalNameBytes();\n+      // have to do this for EC and EZ lookups...\n+      iip \u003d INodesInPath.append(iip, child, name);\n+    }\n+\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     final boolean isRawPath \u003d iip.isRaw();\n+    LocatedBlocks loc \u003d null;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n+      if (needLocation) {\n+        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n+        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n+        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n+            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n+        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n+            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n+            inSnapshot, feInfo, ecPolicy);\n+        if (loc \u003d\u003d null) {\n+          loc \u003d new LocatedBlocks();\n+        }\n+      }\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-    return new HdfsFileStatus(\n+    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n+    HdfsFileStatus status \u003d createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n-        path,\n+        name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n-        ecPolicy);\n+        ecPolicy,\n+        loc);\n+    // Set caching information for the located blocks.\n+    if (loc !\u003d null) {\n+      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n+      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n+        cacheManager.setCachedLocations(lb);\n+      }\n+    }\n+    return status;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n    LocatedBlocks loc \u003d null;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    HdfsFileStatus status \u003d createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n    // Set caching information for the located blocks.\n    if (loc !\u003d null) {\n      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n        cacheManager.setCachedLocations(lb);\n      }\n    }\n    return status;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[static]",
            "newValue": "[private, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10851. FSDirStatAndListingOp: stop passing path as string. Contributed by Daryn Sharp.\n",
          "commitDate": "30/09/16 11:03 AM",
          "commitName": "a0730aa5ced7666a8c92f9fb830b615f5f9f477a",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "24/08/16 1:21 PM",
          "commitNameOld": "a1f3293762dddb0ca953d1145f5b53d9086b25b8",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 36.9,
          "commitsBetweenForRepo": 208,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,81 @@\n-  static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n-      byte storagePolicy, INodesInPath iip) throws IOException {\n+  private static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n+      boolean needLocation) throws IOException {\n+    assert fsd.hasReadLock();\n+    // only directory listing sets the status name.\n+    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n+    if (child !\u003d null) {\n+      name \u003d child.getLocalNameBytes();\n+      // have to do this for EC and EZ lookups...\n+      iip \u003d INodesInPath.append(iip, child, name);\n+    }\n+\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n     final int snapshot \u003d iip.getPathSnapshotId();\n     final boolean isRawPath \u003d iip.isRaw();\n+    LocatedBlocks loc \u003d null;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n+      if (needLocation) {\n+        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n+        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n+        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n+            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n+        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n+            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n+            inSnapshot, feInfo, ecPolicy);\n+        if (loc \u003d\u003d null) {\n+          loc \u003d new LocatedBlocks();\n+        }\n+      }\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-    return new HdfsFileStatus(\n+    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n+    HdfsFileStatus status \u003d createFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n-        path,\n+        name,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n-        ecPolicy);\n+        ecPolicy,\n+        loc);\n+    // Set caching information for the located blocks.\n+    if (loc !\u003d null) {\n+      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n+      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n+        cacheManager.setCachedLocations(lb);\n+      }\n+    }\n+    return status;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, INodesInPath iip, INode child, byte storagePolicy,\n      boolean needLocation) throws IOException {\n    assert fsd.hasReadLock();\n    // only directory listing sets the status name.\n    byte[] name \u003d HdfsFileStatus.EMPTY_NAME;\n    if (child !\u003d null) {\n      name \u003d child.getLocalNameBytes();\n      // have to do this for EC and EZ lookups...\n      iip \u003d INodesInPath.append(iip, child, name);\n    }\n\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n    LocatedBlocks loc \u003d null;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n      if (needLocation) {\n        final boolean inSnapshot \u003d snapshot !\u003d Snapshot.CURRENT_STATE_ID;\n        final boolean isUc \u003d !inSnapshot \u0026\u0026 fileNode.isUnderConstruction();\n        final long fileSize \u003d !inSnapshot \u0026\u0026 isUc\n            ? fileNode.computeFileSizeNotIncludingLastUcBlock() : size;\n        loc \u003d fsd.getBlockManager().createLocatedBlocks(\n            fileNode.getBlocks(snapshot), fileSize, isUc, 0L, size, false,\n            inSnapshot, feInfo, ecPolicy);\n        if (loc \u003d\u003d null) {\n          loc \u003d new LocatedBlocks();\n        }\n      }\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    INodeAttributes nodeAttrs \u003d fsd.getAttributes(iip);\n    HdfsFileStatus status \u003d createFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        name,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy,\n        loc);\n    // Set caching information for the located blocks.\n    if (loc !\u003d null) {\n      CacheManager cacheManager \u003d fsd.getFSNamesystem().getCacheManager();\n      for (LocatedBlock lb: loc.getLocatedBlocks()) {\n        cacheManager.setCachedLocations(lb);\n      }\n    }\n    return status;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
      "commitDate": "24/08/16 6:46 AM",
      "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
          "commitDate": "24/08/16 6:46 AM",
          "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "22/08/16 2:57 PM",
          "commitNameOld": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path,\n-      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n-      boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n+      byte storagePolicy, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n+    final int snapshot \u003d iip.getPathSnapshotId();\n+    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n      byte storagePolicy, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
          "commitDate": "24/08/16 6:46 AM",
          "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "22/08/16 2:57 PM",
          "commitNameOld": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 1.66,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path,\n-      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n-      boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n+      byte storagePolicy, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n+    final int snapshot \u003d iip.getPathSnapshotId();\n+    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n      byte storagePolicy, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
      "commitDate": "22/08/16 2:57 PM",
      "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
          "commitDate": "22/08/16 2:57 PM",
          "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 1:37 PM",
          "commitNameOld": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,48 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n-      byte storagePolicy, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path,\n+      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n+      boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n-    final int snapshot \u003d iip.getPathSnapshotId();\n-    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
          "commitDate": "22/08/16 2:57 PM",
          "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "22/08/16 1:37 PM",
          "commitNameOld": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,48 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n-      byte storagePolicy, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path,\n+      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n+      boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n-    final int snapshot \u003d iip.getPathSnapshotId();\n-    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
      "commitDate": "22/08/16 1:37 PM",
      "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
          "commitDate": "22/08/16 1:37 PM",
          "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "17/08/16 1:53 PM",
          "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 4.99,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path,\n-      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n-      boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n+      byte storagePolicy, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n+    final int snapshot \u003d iip.getPathSnapshotId();\n+    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n      byte storagePolicy, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
          "commitDate": "22/08/16 1:37 PM",
          "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "17/08/16 1:53 PM",
          "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 4.99,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,48 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path,\n-      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n-      boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n+      byte storagePolicy, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n     final INode node \u003d iip.getLastINode();\n+    final int snapshot \u003d iip.getPathSnapshotId();\n+    final boolean isRawPath \u003d iip.isRaw();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n         .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n           || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n       isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INodeAttributes nodeAttrs,\n      byte storagePolicy, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n    final int snapshot \u003d iip.getPathSnapshotId();\n    final boolean isRawPath \u003d iip.isRaw();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "9f4bf3bdf9e74800643477cfb18361e01cf6859c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9621. getListing wrongly associates Erasure Coding policy to pre-existing replicated files under an EC directory. Contributed by Jing Zhao.\n",
      "commitDate": "11/01/16 11:31 AM",
      "commitName": "9f4bf3bdf9e74800643477cfb18361e01cf6859c",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9621. getListing wrongly associates Erasure Coding policy to pre-existing replicated files under an EC directory. Contributed by Jing Zhao.\n",
          "commitDate": "11/01/16 11:31 AM",
          "commitName": "9f4bf3bdf9e74800643477cfb18361e01cf6859c",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/11/15 1:14 PM",
          "commitNameOld": "977e0b3c4ce76746a3d8590d2d790fdc96c86ca5",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 47.93,
          "commitsBetweenForRepo": 246,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,48 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INode node,\n+      FSDirectory fsd, byte[] path,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n+    final INode node \u003d iip.getLastINode();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n-    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n-        fsd.getFSNamesystem(), iip);\n+    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n+        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n-          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd,\n-              INodesInPath.fromINode(node)));\n+          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n-      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd,\n-          INodesInPath.fromINode(node));\n+      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], node-INode, nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9621. getListing wrongly associates Erasure Coding policy to pre-existing replicated files under an EC directory. Contributed by Jing Zhao.\n",
          "commitDate": "11/01/16 11:31 AM",
          "commitName": "9f4bf3bdf9e74800643477cfb18361e01cf6859c",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "24/11/15 1:14 PM",
          "commitNameOld": "977e0b3c4ce76746a3d8590d2d790fdc96c86ca5",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 47.93,
          "commitsBetweenForRepo": 246,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,48 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INode node,\n+      FSDirectory fsd, byte[] path,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n+    final INode node \u003d iip.getLastINode();\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n         .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n-    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n-        fsd.getFSNamesystem(), iip);\n+    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n+        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null)\n-          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd,\n-              INodesInPath.fromINode(node)));\n+          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n     } else {\n-      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd,\n-          INodesInPath.fromINode(node));\n+      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n    final INode node \u003d iip.getLastINode();\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp\n        .getErasureCodingPolicy(fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd, iip));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd, iip);\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "71a81b6257c0000475ad62eb69292a20d45d269c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7529. Consolidate encryption zone related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "24/09/15 8:34 AM",
      "commitName": "71a81b6257c0000475ad62eb69292a20d45d269c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "18/09/15 9:26 AM",
      "commitNameOld": "3f4275310203de4ccfb15337f3c503e25408a265",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.96,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,45 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n-    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-        fsd.getFileEncryptionInfo(node, snapshot, iip);\n+    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n+        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n-      isEncrypted \u003d (feInfo !\u003d null) ||\n-          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n+      isEncrypted \u003d (feInfo !\u003d null)\n+          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd,\n+              INodesInPath.fromINode(node)));\n     } else {\n-      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n+      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd,\n+          INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null : FSDirEncryptionZoneOp\n        .getFileEncryptionInfo(fsd, node, snapshot, iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null)\n          || (isRawPath \u0026\u0026 FSDirEncryptionZoneOp.isInAnEZ(fsd,\n              INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d FSDirEncryptionZoneOp.isInAnEZ(fsd,\n          INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 16.42,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,47 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n-    final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n+    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n         fsd.getFSNamesystem(), iip);\n-    final ErasureCodingPolicy ecPolicy \u003d\n-        ecZone !\u003d null ? ecZone.getErasureCodingPolicy() : null;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         ecPolicy);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    final ErasureCodingPolicy ecPolicy \u003d FSDirErasureCodingOp.getErasureCodingPolicy(\n        fsd.getFSNamesystem(), iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8854. Erasure coding: add ECPolicy to replace schema+cellSize in hadoop-hdfs. Contributed by Walter Su.\n",
      "commitDate": "13/08/15 10:04 AM",
      "commitName": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "29/06/15 10:32 PM",
      "commitNameOld": "0b7af27b9a369d6abdb1fb6c216f50692267f3f4",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 44.48,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n     final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n         fsd.getFSNamesystem(), iip);\n-    final ECSchema schema \u003d ecZone !\u003d null ? ecZone.getSchema() : null;\n-    final int cellSize \u003d ecZone !\u003d null ? ecZone.getCellSize() : 0;\n+    final ErasureCodingPolicy ecPolicy \u003d\n+        ecZone !\u003d null ? ecZone.getErasureCodingPolicy() : null;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n-        schema,\n-        cellSize);\n+        ecPolicy);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n        fsd.getFSNamesystem(), iip);\n    final ErasureCodingPolicy ecPolicy \u003d\n        ecZone !\u003d null ? ecZone.getErasureCodingPolicy() : null;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        ecPolicy);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "98d340745be682fb251677bb4830aca76119868f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8450. Erasure Coding: Consolidate erasure coding zone related implementation into a single class (Contributed by Rakesh R)\n",
      "commitDate": "10/06/15 10:18 PM",
      "commitName": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "26/05/15 12:07 PM",
      "commitNameOld": "9a18598e2da8e699ed852ffa30fd7f503902190c",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 15.42,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n-    \n-    final ErasureCodingZone ecZone \u003d fsd.getECZone(iip);\n+\n+    final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n+        fsd.getFSNamesystem(), iip);\n     final ECSchema schema \u003d ecZone !\u003d null ? ecZone.getSchema() : null;\n     final int cellSize \u003d ecZone !\u003d null ? ecZone.getCellSize() : 0;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         schema,\n         cellSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    final ErasureCodingZone ecZone \u003d FSDirErasureCodingOp.getErasureCodingZone(\n        fsd.getFSNamesystem(), iip);\n    final ECSchema schema \u003d ecZone !\u003d null ? ecZone.getSchema() : null;\n    final int cellSize \u003d ecZone !\u003d null ? ecZone.getCellSize() : 0;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        schema,\n        cellSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "9a18598e2da8e699ed852ffa30fd7f503902190c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8408. Revisit and refactor ErasureCodingInfo (Contributed by Vinayakumar B)\n",
      "commitDate": "26/05/15 12:07 PM",
      "commitName": "9a18598e2da8e699ed852ffa30fd7f503902190c",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "91c81fdc24709b3caf1f6281c8879ffee08db956",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n     \n-    final ErasureCodingZoneInfo ecZoneInfo \u003d fsd.getECZoneInfo(iip);\n-    final ECSchema schema \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getSchema() : null;\n-    final int cellSize \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getCellSize() : 0;\n+    final ErasureCodingZone ecZone \u003d fsd.getECZone(iip);\n+    final ECSchema schema \u003d ecZone !\u003d null ? ecZone.getSchema() : null;\n+    final int cellSize \u003d ecZone !\u003d null ? ecZone.getCellSize() : 0;\n \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n         schema,\n         cellSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n    \n    final ErasureCodingZone ecZone \u003d fsd.getECZone(iip);\n    final ECSchema schema \u003d ecZone !\u003d null ? ecZone.getSchema() : null;\n    final int cellSize \u003d ecZone !\u003d null ? ecZone.getCellSize() : 0;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        schema,\n        cellSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "91c81fdc24709b3caf1f6281c8879ffee08db956": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8375. Add cellSize as an XAttr to ECZone. Contributed by Vinayakumar B.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "91c81fdc24709b3caf1f6281c8879ffee08db956",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 12:01 PM",
      "commitNameOld": "9da927540f0ea6698388a4e79ef32c4dc51495ea",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,49 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n     \n-    final ECSchema schema \u003d fsd.getECSchema(iip);\n-    \n+    final ErasureCodingZoneInfo ecZoneInfo \u003d fsd.getECZoneInfo(iip);\n+    final ECSchema schema \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getSchema() : null;\n+    final int cellSize \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getCellSize() : 0;\n+\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy,\n-        schema);\n+        schema,\n+        cellSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n    \n    final ErasureCodingZoneInfo ecZoneInfo \u003d fsd.getECZoneInfo(iip);\n    final ECSchema schema \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getSchema() : null;\n    final int cellSize \u003d ecZoneInfo !\u003d null ? ecZoneInfo.getCellSize() : 0;\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        schema,\n        cellSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "9da927540f0ea6698388a4e79ef32c4dc51495ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8289. Erasure Coding: add ECSchema to HdfsFileStatus. Contributed by Yong Zhang.\n",
      "commitDate": "26/05/15 12:01 PM",
      "commitName": "9da927540f0ea6698388a4e79ef32c4dc51495ea",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 24.08,
      "commitsBetweenForRepo": 367,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   static HdfsFileStatus createFileStatus(\n       FSDirectory fsd, byte[] path, INode node,\n       INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n       boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n \n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n-\n+    \n+    final ECSchema schema \u003d fsd.getECSchema(iip);\n+    \n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n \n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n \n     return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n-        storagePolicy);\n+        storagePolicy,\n+        schema);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n    \n    final ECSchema schema \u003d fsd.getECSchema(iip);\n    \n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy,\n        schema);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
      "extendedDetails": {}
    },
    "c55d609053fe24b3a50fbe17dc1b47717b453ed6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8200. Refactor FSDirStatAndListingOp. Contributed by Haohui Mai.\n",
      "commitDate": "30/04/15 1:41 PM",
      "commitName": "c55d609053fe24b3a50fbe17dc1b47717b453ed6",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8200. Refactor FSDirStatAndListingOp. Contributed by Haohui Mai.\n",
          "commitDate": "30/04/15 1:41 PM",
          "commitName": "c55d609053fe24b3a50fbe17dc1b47717b453ed6",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "20/04/15 12:36 AM",
          "commitNameOld": "5c97db07fb306842f49d73a67a90cecec19a7833",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 10.55,
          "commitsBetweenForRepo": 106,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,43 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, String fullPath, byte[] path, INode node,\n-      byte storagePolicy, int snapshot, boolean isRawPath,\n-      INodesInPath iip) throws IOException {\n-     long size \u003d 0;     // length is zero for directories\n-     short replication \u003d 0;\n-     long blocksize \u003d 0;\n-     final boolean isEncrypted;\n+      FSDirectory fsd, byte[] path, INode node,\n+      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n+      boolean isRawPath, INodesInPath iip) throws IOException {\n+    long size \u003d 0;     // length is zero for directories\n+    short replication \u003d 0;\n+    long blocksize \u003d 0;\n+    final boolean isEncrypted;\n \n-     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         fsd.getFileEncryptionInfo(node, snapshot, iip);\n+    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n+        fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n-     if (node.isFile()) {\n-       final INodeFile fileNode \u003d node.asFile();\n-       size \u003d fileNode.computeFileSize(snapshot);\n-       replication \u003d fileNode.getFileReplication(snapshot);\n-       blocksize \u003d fileNode.getPreferredBlockSize();\n-       isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n-     } else {\n-       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n-     }\n+    if (node.isFile()) {\n+      final INodeFile fileNode \u003d node.asFile();\n+      size \u003d fileNode.computeFileSize(snapshot);\n+      replication \u003d fileNode.getFileReplication(snapshot);\n+      blocksize \u003d fileNode.getPreferredBlockSize();\n+      isEncrypted \u003d (feInfo !\u003d null) ||\n+          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n+    } else {\n+      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n+    }\n \n-     int childrenNum \u003d node.isDirectory() ?\n-         node.asDirectory().getChildrenNum(snapshot) : 0;\n+    int childrenNum \u003d node.isDirectory() ?\n+        node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-     INodeAttributes nodeAttrs \u003d\n-         fsd.getAttributes(fullPath, path, node, snapshot);\n-     return new HdfsFileStatus(\n+    return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, fullPath-String, path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], node-INode, nodeAttrs-INodeAttributes, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8200. Refactor FSDirStatAndListingOp. Contributed by Haohui Mai.\n",
          "commitDate": "30/04/15 1:41 PM",
          "commitName": "c55d609053fe24b3a50fbe17dc1b47717b453ed6",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "20/04/15 12:36 AM",
          "commitNameOld": "5c97db07fb306842f49d73a67a90cecec19a7833",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 10.55,
          "commitsBetweenForRepo": 106,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,43 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, String fullPath, byte[] path, INode node,\n-      byte storagePolicy, int snapshot, boolean isRawPath,\n-      INodesInPath iip) throws IOException {\n-     long size \u003d 0;     // length is zero for directories\n-     short replication \u003d 0;\n-     long blocksize \u003d 0;\n-     final boolean isEncrypted;\n+      FSDirectory fsd, byte[] path, INode node,\n+      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n+      boolean isRawPath, INodesInPath iip) throws IOException {\n+    long size \u003d 0;     // length is zero for directories\n+    short replication \u003d 0;\n+    long blocksize \u003d 0;\n+    final boolean isEncrypted;\n \n-     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         fsd.getFileEncryptionInfo(node, snapshot, iip);\n+    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n+        fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n-     if (node.isFile()) {\n-       final INodeFile fileNode \u003d node.asFile();\n-       size \u003d fileNode.computeFileSize(snapshot);\n-       replication \u003d fileNode.getFileReplication(snapshot);\n-       blocksize \u003d fileNode.getPreferredBlockSize();\n-       isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n-     } else {\n-       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n-     }\n+    if (node.isFile()) {\n+      final INodeFile fileNode \u003d node.asFile();\n+      size \u003d fileNode.computeFileSize(snapshot);\n+      replication \u003d fileNode.getFileReplication(snapshot);\n+      blocksize \u003d fileNode.getPreferredBlockSize();\n+      isEncrypted \u003d (feInfo !\u003d null) ||\n+          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n+    } else {\n+      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n+    }\n \n-     int childrenNum \u003d node.isDirectory() ?\n-         node.asDirectory().getChildrenNum(snapshot) : 0;\n+    int childrenNum \u003d node.isDirectory() ?\n+        node.asDirectory().getChildrenNum(snapshot) : 0;\n \n-     INodeAttributes nodeAttrs \u003d\n-         fsd.getAttributes(fullPath, path, node, snapshot);\n-     return new HdfsFileStatus(\n+    return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(nodeAttrs, isEncrypted),\n         nodeAttrs.getUserName(),\n         nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node,\n      INodeAttributes nodeAttrs, byte storagePolicy, int snapshot,\n      boolean isRawPath, INodesInPath iip) throws IOException {\n    long size \u003d 0;     // length is zero for directories\n    short replication \u003d 0;\n    long blocksize \u003d 0;\n    final boolean isEncrypted;\n\n    final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n        fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n    if (node.isFile()) {\n      final INodeFile fileNode \u003d node.asFile();\n      size \u003d fileNode.computeFileSize(snapshot);\n      replication \u003d fileNode.getFileReplication(snapshot);\n      blocksize \u003d fileNode.getPreferredBlockSize();\n      isEncrypted \u003d (feInfo !\u003d null) ||\n          (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n    } else {\n      isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n    }\n\n    int childrenNum \u003d node.isDirectory() ?\n        node.asDirectory().getChildrenNum(snapshot) : 0;\n\n    return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "53a28afe293e5bf185c8d4f2c7aea212e66015c2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
      "commitDate": "24/03/15 4:02 PM",
      "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "13/01/15 12:24 AM",
          "commitNameOld": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 70.61,
          "commitsBetweenForRepo": 649,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,45 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n-      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, String fullPath, byte[] path, INode node,\n+      byte storagePolicy, int snapshot, boolean isRawPath,\n+      INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n          fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n            (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n        isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n      int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n+     INodeAttributes nodeAttrs \u003d\n+         fsd.getAttributes(fullPath, path, node, snapshot);\n      return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n-        getPermissionForFileStatus(node, snapshot, isEncrypted),\n-        node.getUserName(snapshot),\n-        node.getGroupName(snapshot),\n+        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n+        nodeAttrs.getUserName(),\n+        nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, String fullPath, byte[] path, INode node,\n      byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     INodeAttributes nodeAttrs \u003d\n         fsd.getAttributes(fullPath, path, node, snapshot);\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[fsd-FSDirectory, path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, fullPath-String, path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6826. Plugin interface to enable delegation of HDFS authorization assertions. Contributed by Arun Suresh.\n",
          "commitDate": "24/03/15 4:02 PM",
          "commitName": "53a28afe293e5bf185c8d4f2c7aea212e66015c2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "13/01/15 12:24 AM",
          "commitNameOld": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 70.61,
          "commitsBetweenForRepo": 649,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,45 @@\n   static HdfsFileStatus createFileStatus(\n-      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n-      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n+      FSDirectory fsd, String fullPath, byte[] path, INode node,\n+      byte storagePolicy, int snapshot, boolean isRawPath,\n+      INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n          fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n            (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n        isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n      int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n+     INodeAttributes nodeAttrs \u003d\n+         fsd.getAttributes(fullPath, path, node, snapshot);\n      return new HdfsFileStatus(\n         size,\n         node.isDirectory(),\n         replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n-        getPermissionForFileStatus(node, snapshot, isEncrypted),\n-        node.getUserName(snapshot),\n-        node.getGroupName(snapshot),\n+        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n+        nodeAttrs.getUserName(),\n+        nodeAttrs.getGroupName(),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, String fullPath, byte[] path, INode node,\n      byte storagePolicy, int snapshot, boolean isRawPath,\n      INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     INodeAttributes nodeAttrs \u003d\n         fsd.getAttributes(fullPath, path, node, snapshot);\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(nodeAttrs, isEncrypted),\n        nodeAttrs.getUserName(),\n        nodeAttrs.getGroupName(),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "0af44ea8462437f8e7a8271b15a19677fd7f05a1": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7450. Consolidate the implementation of GetFileInfo(), GetListings() and GetContentSummary() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "01/12/14 9:36 PM",
      "commitName": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7450. Consolidate the implementation of GetFileInfo(), GetListings() and GetContentSummary() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:36 PM",
          "commitName": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:21 PM",
          "commitNameOld": "9fa29902575ac3774bf3728e7bcde7f3eefb1d4c",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,42 @@\n-  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n+  static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n       int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot, iip);\n+         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n+           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n-       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n+       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n-     int childrenNum \u003d node.isDirectory() ? \n+     int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n-        size, \n-        node.isDirectory(), \n-        replication, \n+        size,\n+        node.isDirectory(),\n+        replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
            "oldMethodName": "createFileStatus",
            "newMethodName": "createFileStatus"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7450. Consolidate the implementation of GetFileInfo(), GetListings() and GetContentSummary() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:36 PM",
          "commitName": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:21 PM",
          "commitNameOld": "9fa29902575ac3774bf3728e7bcde7f3eefb1d4c",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,42 @@\n-  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n+  static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n       int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot, iip);\n+         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n+           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n-       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n+       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n-     int childrenNum \u003d node.isDirectory() ? \n+     int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n-        size, \n-        node.isDirectory(), \n-        replication, \n+        size,\n+        node.isDirectory(),\n+        replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7450. Consolidate the implementation of GetFileInfo(), GetListings() and GetContentSummary() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:36 PM",
          "commitName": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:21 PM",
          "commitNameOld": "9fa29902575ac3774bf3728e7bcde7f3eefb1d4c",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,42 @@\n-  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n+  static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n       int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot, iip);\n+         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n+           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n-       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n+       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n-     int childrenNum \u003d node.isDirectory() ? \n+     int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n-        size, \n-        node.isDirectory(), \n-        replication, \n+        size,\n+        node.isDirectory(),\n+        replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7450. Consolidate the implementation of GetFileInfo(), GetListings() and GetContentSummary() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:36 PM",
          "commitName": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:21 PM",
          "commitNameOld": "9fa29902575ac3774bf3728e7bcde7f3eefb1d4c",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,42 @@\n-  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n+  static HdfsFileStatus createFileStatus(\n+      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n       int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot, iip);\n+         fsd.getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n-           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n+           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n-       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n+       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n-     int childrenNum \u003d node.isDirectory() ? \n+     int childrenNum \u003d node.isDirectory() ?\n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n-        size, \n-        node.isDirectory(), \n-        replication, \n+        size,\n+        node.isDirectory(),\n+        replication,\n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createFileStatus(\n      FSDirectory fsd, byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         fsd.getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 fsd.isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d fsd.isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ?\n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size,\n        node.isDirectory(),\n        replication,\n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirStatAndListingOp.java",
          "extendedDetails": {
            "oldValue": "[path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]",
            "newValue": "[fsd-FSDirectory, path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        }
      ]
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "commitDateOld": "29/09/14 4:29 PM",
      "commitNameOld": "7f0422be763b7ab6a60a0e90670e12661683f835",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,41 @@\n   HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n       int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n-     boolean isLazyPersist \u003d false;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n          getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n-       isLazyPersist \u003d fileNode.getLazyPersistFlag();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n            (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n        isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n      int childrenNum \u003d node.isDirectory() ? \n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n         size, \n         node.isDirectory(), \n         replication, \n         blocksize,\n-        isLazyPersist,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ? \n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size, \n        node.isDirectory(), \n        replication, \n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1737950d0fc83c68f386881b843c41b0b1e342de": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6987. Move CipherSuite xattr information up to the encryption zone root. Contributed by Zhe Zhang.\n",
      "commitDate": "21/09/14 9:29 PM",
      "commitName": "1737950d0fc83c68f386881b843c41b0b1e342de",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6987. Move CipherSuite xattr information up to the encryption zone root. Contributed by Zhe Zhang.\n",
          "commitDate": "21/09/14 9:29 PM",
          "commitName": "1737950d0fc83c68f386881b843c41b0b1e342de",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "17/09/14 10:00 PM",
          "commitNameOld": "2d2b0009e662db75cf22e2ce8d618ed0a8e61c2f",
          "commitAuthorOld": "",
          "daysBetweenCommits": 3.98,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n   HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n-      int snapshot, boolean isRawPath) throws IOException {\n+      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot);\n+         getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n            (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n        isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n      int childrenNum \u003d node.isDirectory() ? \n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n         size, \n         node.isDirectory(), \n         replication, \n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ? \n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size, \n        node.isDirectory(), \n        replication, \n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean]",
            "newValue": "[path-byte[], node-INode, storagePolicy-byte, snapshot-int, isRawPath-boolean, iip-INodesInPath]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6987. Move CipherSuite xattr information up to the encryption zone root. Contributed by Zhe Zhang.\n",
          "commitDate": "21/09/14 9:29 PM",
          "commitName": "1737950d0fc83c68f386881b843c41b0b1e342de",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "17/09/14 10:00 PM",
          "commitNameOld": "2d2b0009e662db75cf22e2ce8d618ed0a8e61c2f",
          "commitAuthorOld": "",
          "daysBetweenCommits": 3.98,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,41 @@\n   HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n-      int snapshot, boolean isRawPath) throws IOException {\n+      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n      long size \u003d 0;     // length is zero for directories\n      short replication \u003d 0;\n      long blocksize \u003d 0;\n      final boolean isEncrypted;\n \n      final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n-         getFileEncryptionInfo(node, snapshot);\n+         getFileEncryptionInfo(node, snapshot, iip);\n \n      if (node.isFile()) {\n        final INodeFile fileNode \u003d node.asFile();\n        size \u003d fileNode.computeFileSize(snapshot);\n        replication \u003d fileNode.getFileReplication(snapshot);\n        blocksize \u003d fileNode.getPreferredBlockSize();\n        isEncrypted \u003d (feInfo !\u003d null) ||\n            (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n      } else {\n        isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n      }\n \n      int childrenNum \u003d node.isDirectory() ? \n          node.asDirectory().getChildrenNum(snapshot) : 0;\n \n      return new HdfsFileStatus(\n         size, \n         node.isDirectory(), \n         replication, \n         blocksize,\n         node.getModificationTime(snapshot),\n         node.getAccessTime(snapshot),\n         getPermissionForFileStatus(node, snapshot, isEncrypted),\n         node.getUserName(snapshot),\n         node.getGroupName(snapshot),\n         node.isSymlink() ? node.asSymlink().getSymlink() : null,\n         path,\n         node.getId(),\n         childrenNum,\n         feInfo,\n         storagePolicy);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  HdfsFileStatus createFileStatus(byte[] path, INode node, byte storagePolicy,\n      int snapshot, boolean isRawPath, INodesInPath iip) throws IOException {\n     long size \u003d 0;     // length is zero for directories\n     short replication \u003d 0;\n     long blocksize \u003d 0;\n     final boolean isEncrypted;\n\n     final FileEncryptionInfo feInfo \u003d isRawPath ? null :\n         getFileEncryptionInfo(node, snapshot, iip);\n\n     if (node.isFile()) {\n       final INodeFile fileNode \u003d node.asFile();\n       size \u003d fileNode.computeFileSize(snapshot);\n       replication \u003d fileNode.getFileReplication(snapshot);\n       blocksize \u003d fileNode.getPreferredBlockSize();\n       isEncrypted \u003d (feInfo !\u003d null) ||\n           (isRawPath \u0026\u0026 isInAnEZ(INodesInPath.fromINode(node)));\n     } else {\n       isEncrypted \u003d isInAnEZ(INodesInPath.fromINode(node));\n     }\n\n     int childrenNum \u003d node.isDirectory() ? \n         node.asDirectory().getChildrenNum(snapshot) : 0;\n\n     return new HdfsFileStatus(\n        size, \n        node.isDirectory(), \n        replication, \n        blocksize,\n        node.getModificationTime(snapshot),\n        node.getAccessTime(snapshot),\n        getPermissionForFileStatus(node, snapshot, isEncrypted),\n        node.getUserName(snapshot),\n        node.getGroupName(snapshot),\n        node.isSymlink() ? node.asSymlink().getSymlink() : null,\n        path,\n        node.getId(),\n        childrenNum,\n        feInfo,\n        storagePolicy);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}