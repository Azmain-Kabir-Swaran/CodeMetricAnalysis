{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReceiver.java",
  "functionName": "manageWriterOsCache",
  "functionId": "manageWriterOsCache___offsetInBlock-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
  "functionStartLine": 890,
  "functionEndLine": 943,
  "numCommitsSeen": 106,
  "timeTaken": 6207,
  "changeHistory": [
    "462e25a3b264e1148d0cbca00db7f10d43a0555f",
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf",
    "dcedb72af468128458e597f08d22f5c34b744ae5",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
    "21d10ccc6e463cf250414264c78acb4a6e7c83e3",
    "f15ff5e4f4eae0540939b2a5c65d2e91833d6e7a",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
    "efea68dc3538de9aafae206d64903506e41fc9e1",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24"
  ],
  "changeHistoryShort": {
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": "Ybodychange",
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc": "Ybodychange",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": "Ybodychange",
    "dcedb72af468128458e597f08d22f5c34b744ae5": "Ybodychange",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": "Ybodychange",
    "21d10ccc6e463cf250414264c78acb4a6e7c83e3": "Ybodychange",
    "f15ff5e4f4eae0540939b2a5c65d2e91833d6e7a": "Ybodychange",
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": "Ybodychange",
    "efea68dc3538de9aafae206d64903506e41fc9e1": "Ybodychange",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": "Yintroduced"
  },
  "changeHistoryDetails": {
    "462e25a3b264e1148d0cbca00db7f10d43a0555f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12814. Add blockId when warning slow mirror/disk in BlockReceiver. Contributed by Jiandan Yang.\n",
      "commitDate": "16/11/17 12:19 AM",
      "commitName": "462e25a3b264e1148d0cbca00db7f10d43a0555f",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/08/17 3:49 PM",
      "commitNameOld": "a1e3f84afe6c02cc642699634052d2fb60b30179",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 79.4,
      "commitsBetweenForRepo": 781,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (streams.getOutFd() !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                 block, streams, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           } else {\n             streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n           streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n               POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs\n-              + \"ms), volume\u003d\" + getVolumeBaseUri());\n+              + \"ms), volume\u003d\" + getVolumeBaseUri()\n+              + \", blockId\u003d\" + replicaInfo.getBlockId());\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (streams.getOutFd() !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, streams, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n              POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs\n              + \"ms), volume\u003d\" + getVolumeBaseUri()\n              + \", blockId\u003d\" + replicaInfo.getBlockId());\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "5485d93bda3329a7c80767c3723cc6e1a9233dbc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11603. Improve slow mirror/disk warnings in BlockReceiver.\n",
      "commitDate": "31/03/17 12:10 PM",
      "commitName": "5485d93bda3329a7c80767c3723cc6e1a9233dbc",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/03/17 7:02 PM",
      "commitNameOld": "ffa160ddb824cbcb8ab6b10ee1414507686e3c63",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 13.71,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (streams.getOutFd() !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                 block, streams, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           } else {\n             streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n           streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n               POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n-        if (duration \u003e datanodeSlowLogThresholdMs) {\n+        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n-              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs\n+              + \"ms), volume\u003d\" + getVolumeBaseUri());\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (streams.getOutFd() !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, streams, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n              POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs \u0026\u0026 LOG.isWarnEnabled()) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs\n              + \"ms), volume\u003d\" + getVolumeBaseUri());\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "06/12/16 11:05 AM",
      "commitName": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "05/12/16 12:44 PM",
      "commitNameOld": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n-      if (outFd !\u003d null \u0026\u0026\n+      if (streams.getOutFd() !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n-                block, outFd, lastCacheManagementOffset,\n+                block, streams, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           } else {\n-            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n-                lastCacheManagementOffset,\n+            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n-          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n-              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n+          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n+              POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (streams.getOutFd() !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, streams, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n              POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "dcedb72af468128458e597f08d22f5c34b744ae5": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\"\n\nThis reverts commit aeecfa24f4fb6af289920cbf8830c394e66bd78e.\n",
      "commitDate": "05/12/16 12:44 PM",
      "commitName": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "29/11/16 8:52 PM",
      "commitNameOld": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n-      if (streams.getOutFd() !\u003d null \u0026\u0026\n+      if (outFd !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n-                block, streams, lastCacheManagementOffset,\n+                block, outFd, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           } else {\n-            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n+            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n+                lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n-          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n-              POSIX_FADV_DONTNEED);\n+          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n+              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, outFd, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n                lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "29/11/16 8:52 PM",
      "commitName": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "13/09/16 12:54 PM",
      "commitNameOld": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 77.37,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,52 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n-      if (outFd !\u003d null \u0026\u0026\n+      if (streams.getOutFd() !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n-                block, outFd, lastCacheManagementOffset,\n+                block, streams, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           } else {\n-            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n-                lastCacheManagementOffset,\n+            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n                 SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n-          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n-              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n+          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n+              POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (streams.getOutFd() !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, streams, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            streams.syncFileRangeIfPossible(lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          streams.dropCacheBehindWrites(block.getBlockName(), 0, dropPos,\n              POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "21d10ccc6e463cf250414264c78acb4a6e7c83e3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7824. NativeIO.java flags and identifiers must be set correctly for each platform, not hardcoded to their Linux values (Martin Walsh via Colin P. McCabe)\n",
      "commitDate": "31/07/15 3:01 PM",
      "commitName": "21d10ccc6e463cf250414264c78acb4a6e7c83e3",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "14/07/15 12:04 PM",
      "commitNameOld": "59388a801514d6af64ef27fbf246d8054f1dcc74",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 17.12,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,53 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (outFd !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           if (syncBehindWritesInBackground) {\n             this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                 block, outFd, lastCacheManagementOffset,\n                 offsetInBlock - lastCacheManagementOffset,\n-                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+                SYNC_FILE_RANGE_WRITE);\n           } else {\n             NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n-                lastCacheManagementOffset, offsetInBlock\n-                    - lastCacheManagementOffset,\n-                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+                lastCacheManagementOffset,\n+                offsetInBlock - lastCacheManagementOffset,\n+                SYNC_FILE_RANGE_WRITE);\n           }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n           NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n-              block.getBlockName(), outFd, 0, dropPos,\n-              NativeIO.POSIX.POSIX_FADV_DONTNEED);\n+              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, outFd, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          } else {\n            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n                lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n              block.getBlockName(), outFd, 0, dropPos, POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "f15ff5e4f4eae0540939b2a5c65d2e91833d6e7a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6109 let sync_file_range() system call run in background (Liang Xie via stack)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599347 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/06/14 1:27 PM",
      "commitName": "f15ff5e4f4eae0540939b2a5c65d2e91833d6e7a",
      "commitAuthor": "Michael Stack",
      "commitDateOld": "26/05/14 12:38 PM",
      "commitNameOld": "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
      "commitAuthorOld": "Michael Stack",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,54 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (outFd !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n-          NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n-              lastCacheManagementOffset,\n-              offsetInBlock - lastCacheManagementOffset,\n-              NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+          if (syncBehindWritesInBackground) {\n+            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n+                block, outFd, lastCacheManagementOffset,\n+                offsetInBlock - lastCacheManagementOffset,\n+                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+          } else {\n+            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n+                lastCacheManagementOffset, offsetInBlock\n+                    - lastCacheManagementOffset,\n+                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+          }\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n           NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n               block.getBlockName(), outFd, 0, dropPos,\n               NativeIO.POSIX.POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n         long duration \u003d Time.monotonicNow() - begin;\n         if (duration \u003e datanodeSlowLogThresholdMs) {\n           LOG.warn(\"Slow manageWriterOsCache took \" + duration\n               + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n         }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          if (syncBehindWritesInBackground) {\n            this.datanode.getFSDataset().submitBackgroundSyncFileRangeRequest(\n                block, outFd, lastCacheManagementOffset,\n                offsetInBlock - lastCacheManagementOffset,\n                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n          } else {\n            NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n                lastCacheManagementOffset, offsetInBlock\n                    - lastCacheManagementOffset,\n                NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n          }\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n              block.getBlockName(), outFd, 0, dropPos,\n              NativeIO.POSIX.POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae": {
      "type": "Ybodychange",
      "commitMessage": "HBASE-6110 adding more slow action log in critical write path (Liang Xie via stack)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/14 12:38 PM",
      "commitName": "1228f8f6fb16de4f0283dd1c7939e6fc3dfb7aae",
      "commitAuthor": "Michael Stack",
      "commitDateOld": "12/05/14 12:08 PM",
      "commitNameOld": "e9459baec5a46651c156fbae5f8f3c9cc8325ef0",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,47 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (outFd !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n+        long begin \u003d Time.monotonicNow();\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n               lastCacheManagementOffset,\n               offsetInBlock - lastCacheManagementOffset,\n               NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n           NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n               block.getBlockName(), outFd, 0, dropPos,\n               NativeIO.POSIX.POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n+        long duration \u003d Time.monotonicNow() - begin;\n+        if (duration \u003e datanodeSlowLogThresholdMs) {\n+          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n+              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n+        }\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        long begin \u003d Time.monotonicNow();\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n              lastCacheManagementOffset,\n              offsetInBlock - lastCacheManagementOffset,\n              NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n              block.getBlockName(), outFd, 0, dropPos,\n              NativeIO.POSIX.POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n        long duration \u003d Time.monotonicNow() - begin;\n        if (duration \u003e datanodeSlowLogThresholdMs) {\n          LOG.warn(\"Slow manageWriterOsCache took \" + duration\n              + \"ms (threshold\u003d\" + datanodeSlowLogThresholdMs + \"ms)\");\n        }\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "efea68dc3538de9aafae206d64903506e41fc9e1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5511. improve CacheManipulator interface to allow better unit testing (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543676 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/13 4:48 PM",
      "commitName": "efea68dc3538de9aafae206d64903506e41fc9e1",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "25/07/13 9:42 PM",
      "commitNameOld": "7723b139d55fc2c3954939559cb4914046a0f81c",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 116.84,
      "commitsBetweenForRepo": 738,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   private void manageWriterOsCache(long offsetInBlock) {\n     try {\n       if (outFd !\u003d null \u0026\u0026\n           offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n         //\n         // For SYNC_FILE_RANGE_WRITE, we want to sync from\n         // lastCacheManagementOffset to a position \"two windows ago\"\n         //\n         //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n         // +-----------------------O--------------------------X\n         // start                  last                      curPos\n         // of file                 \n         //\n         if (syncBehindWrites) {\n           NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n               lastCacheManagementOffset,\n               offsetInBlock - lastCacheManagementOffset,\n               NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n         }\n         //\n         // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n         // of the file to a position prior to the current position.\n         //\n         // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n         //                 \u003c---W---\u003e\n         // +--------------+--------O--------------------------X\n         // start        dropPos   last                      curPos\n         // of file             \n         //                     \n         long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n         if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n-          NativeIO.POSIX.posixFadviseIfPossible(block.getBlockName(),\n-              outFd, 0, dropPos, NativeIO.POSIX.POSIX_FADV_DONTNEED);\n+          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n+              block.getBlockName(), outFd, 0, dropPos,\n+              NativeIO.POSIX.POSIX_FADV_DONTNEED);\n         }\n         lastCacheManagementOffset \u003d offsetInBlock;\n       }\n     } catch (Throwable t) {\n       LOG.warn(\"Error managing cache for writer of block \" + block, t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n              lastCacheManagementOffset,\n              offsetInBlock - lastCacheManagementOffset,\n              NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.getCacheManipulator().posixFadviseIfPossible(\n              block.getBlockName(), outFd, 0, dropPos,\n              NativeIO.POSIX.POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java",
      "extendedDetails": {}
    },
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4817.  Make HDFS advisory caching configurable on a per-file basis.  (Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 11:15 AM",
      "commitName": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,40 @@\n+  private void manageWriterOsCache(long offsetInBlock) {\n+    try {\n+      if (outFd !\u003d null \u0026\u0026\n+          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n+        //\n+        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n+        // lastCacheManagementOffset to a position \"two windows ago\"\n+        //\n+        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n+        // +-----------------------O--------------------------X\n+        // start                  last                      curPos\n+        // of file                 \n+        //\n+        if (syncBehindWrites) {\n+          NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n+              lastCacheManagementOffset,\n+              offsetInBlock - lastCacheManagementOffset,\n+              NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n+        }\n+        //\n+        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n+        // of the file to a position prior to the current position.\n+        //\n+        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n+        //                 \u003c---W---\u003e\n+        // +--------------+--------O--------------------------X\n+        // start        dropPos   last                      curPos\n+        // of file             \n+        //                     \n+        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n+        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n+          NativeIO.POSIX.posixFadviseIfPossible(block.getBlockName(),\n+              outFd, 0, dropPos, NativeIO.POSIX.POSIX_FADV_DONTNEED);\n+        }\n+        lastCacheManagementOffset \u003d offsetInBlock;\n+      }\n+    } catch (Throwable t) {\n+      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void manageWriterOsCache(long offsetInBlock) {\n    try {\n      if (outFd !\u003d null \u0026\u0026\n          offsetInBlock \u003e lastCacheManagementOffset + CACHE_DROP_LAG_BYTES) {\n        //\n        // For SYNC_FILE_RANGE_WRITE, we want to sync from\n        // lastCacheManagementOffset to a position \"two windows ago\"\n        //\n        //                         \u003c\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d sync \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003e\n        // +-----------------------O--------------------------X\n        // start                  last                      curPos\n        // of file                 \n        //\n        if (syncBehindWrites) {\n          NativeIO.POSIX.syncFileRangeIfPossible(outFd,\n              lastCacheManagementOffset,\n              offsetInBlock - lastCacheManagementOffset,\n              NativeIO.POSIX.SYNC_FILE_RANGE_WRITE);\n        }\n        //\n        // For POSIX_FADV_DONTNEED, we want to drop from the beginning \n        // of the file to a position prior to the current position.\n        //\n        // \u003c\u003d\u003d\u003d drop \u003d\u003d\u003d\u003d\u003d\u003e \n        //                 \u003c---W---\u003e\n        // +--------------+--------O--------------------------X\n        // start        dropPos   last                      curPos\n        // of file             \n        //                     \n        long dropPos \u003d lastCacheManagementOffset - CACHE_DROP_LAG_BYTES;\n        if (dropPos \u003e 0 \u0026\u0026 dropCacheBehindWrites) {\n          NativeIO.POSIX.posixFadviseIfPossible(block.getBlockName(),\n              outFd, 0, dropPos, NativeIO.POSIX.POSIX_FADV_DONTNEED);\n        }\n        lastCacheManagementOffset \u003d offsetInBlock;\n      }\n    } catch (Throwable t) {\n      LOG.warn(\"Error managing cache for writer of block \" + block, t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockReceiver.java"
    }
  }
}